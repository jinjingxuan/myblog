# 北大肖臻老师《区块链技术与应用》公开课学习 6
* 学习地址：[https://www.bilibili.com/video/BV1Vt411X7JF](https://www.bilibili.com/video/BV1Vt411X7JF)
* 参考文章：[北京大学肖臻老师《区块链技术与应用》公开课笔记20——ETH中GHOST协议篇](https://blog.nowcoder.net/n/6d1f8b54058347d4a217b961e5b965f1)

## Ghost 协议
`BTC` 系统中出块时间为 `10min`，而以太坊中出块时间被降低到 `15s`左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。在 `BTC` 系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。
对此，以太坊设计了新的共识协议—— `GHOST协议` (该协议并非原创，而是对原本就有的Ghost协议进行了改进)。

![](./imgs/ghost.png)

> 如图，假定以太坊系统存在以下情况，`A、B、C、D` 在四个分支上，最后，随着时间推移 `B` 所在链成为最长合法链，因此 `A、C、D` 区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些 `补偿`，并称其为 `Uncle Block`（叔父区块）。
> 规定 `E` 区块在发布时可以将 `A、C、D` 叔父区块包含进来，`A、C、D` 叔父区块可以得到出块奖励的 `7/8`，而为了激励 `E` 包含叔父区块，规定 `E` 每包含一个叔父区块可以额外得到 `1/32` 的出块奖励。为了防止 `E` 大量包含叔父区块，规定一个区块只能最多包含 `2` 个叔父区块，因此 `E` 在 `A、C、D` 中最多只能包含 `2` 个区块作为自己的出块奖励。
> `E` 把 `A` 作为叔父区块的前提是：在挖 `E` 这个区块的时候就知道 `A` 的存在了，把 `A` 写在自己的块头里修改后继续挖，因为挖矿是无记忆性的所以这并不影响什么。

问题：
1. 因为叔父区块最多只能包含 2 个，如果出现 3 个怎么办？
2. 矿工自私，故意不包含叔父区块，导致叔父区块 7/8 出块奖励没了，而自己仅仅损失 1/32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。

![](./imgs/ghost2.png)

> 如图1为对上面例子的补充，`F` 为 `E` 后面一个新的区块。因为规定 `E` 最多只能包含 `2` 个叔父区块，所以假定 `E` 包含了 `C` 和 `D`。此时，`F` 也可以将 `A` 认为自己的的叔父区块(实际上并非叔父辈的，而是爷爷辈的)。如果继续往下挖，`F` 后的新区块仍然可以包含 `B` 同辈的区块。这样，就有效地解决了上面的问题。
> 就算自己挖的区块成为了叔父区块，自己也可以在最长合法链上挖，然后把自己包含进去。

问题：`叔父` 最多可以隔多少代？

![](./imgs/ghost3.png)

> 以太坊中规定，如果 `M` 包含 `F` 区块，则 `F` 获得 `7/8` 出块奖励；如果 `M` 包含 `E` 区块，则 `F` 获得 `6/8` 出块奖励，以此类推向前。直到包含 `A` 区块，A获得 `2/8` 出块奖励，再往前的叔父区块，对于 `M` 来说就不再认可其为 `M` 的叔父了(合法的叔父只有 6 辈)。对于 `M` 来说，无论包含哪个辈分的叔父，得到的出块奖励都是 `1/32` 出块奖励。
> 这样，就方便了全节点进行记录（有效叔父区块不会无限增加），此外，也从协议上鼓励一旦出现分叉马上进行合并。

以上这些都是为了解决临时性分叉的问题，那么为什么比特币和以太坊要设计最长合法链呢，是为了防止数据被篡改。

* BTC 奖励：block reward（静态奖励）+ tx fee（动态奖励）
* ETH 奖励：block reward（静态奖励）+ gas fee（动态奖励，叔父区块是得不到的）
* BTC 中为了人为制造稀缺性，比特币每隔一段时间出块奖励会降低，最终当出块奖励趋于 0 后会主要依赖于交易费运作。而以太坊中并没有人为规定每隔一段时间降低出块奖励。

> 如果区块里包含智能合约，执行智能合约的时候会获得汽油费。但是所占的比例很小，跟比特币类似交易费占比很小。

把叔父区块包含进来的时候，叔父区块里的交易要不要执行？

> 不应该，叔父区块和同辈的主链上区块有可能包含有冲突的交易。执行完父区块的交易再去执行叔父区块的交易可能就变成非法的了。因此，一个节点在收到一个叔父区块的时候，只检查区块合法性而不检查其中交易的合法性。

分叉后的区块后面还跟着其他区块怎么处理？
![](./imgs/ghost4.png)

> `A->F` 该链并非一个最长合法链，所以 `B->F` 这些区块怎么办？可不可以规定将下面整条链作为一个整体，给予出块奖励？
> 不行，这一定程度上鼓励了分叉攻击(如果 A 转给 B 一大笔钱，B 等了很多区块后觉得没什么问题了，此时 A 发动分叉攻击将钱转给 A'，这需要挖出更多的区块代价是很大的，但是，后面的区块都给奖励，这就降低了分叉攻击的成本，因为即使攻击失败也有奖励)。因此，`ETH` 系统中规定，只认可 `A` 区块为叔父区块，给予其补偿，而其后的区块全部作废。

### 具体例子
[https://etherscan.io/](https://etherscan.io/)

![](./imgs/ghost5.jpg)

* Block Height 为当前区块的序号，UncleNumber 为叔父区块的序号
* 如果相差为 1，说明是刚刚相差一辈，获得 `7/8` 的奖励，以此类推

![](./imgs/ghost6.png)

* Block Reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（1个, 0.09375 = 3 * 1 / 32）
* Uncles Reward: 叔父区块获得的奖励，通过计算可知隔两代，2.25 = 3 * 6 / 8

![](./imgs/ghost7.png)

* Block Reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（2个, 0.1875 = 3 * 2 * 1 / 32）
* Uncles Reward: 叔父区块获得的奖励，通过计算可知分别隔两代和隔一代，4.875 = 2.25 (3 * 6 / 8) + 2.625 (3 * 7 / 8)

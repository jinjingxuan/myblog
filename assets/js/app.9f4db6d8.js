(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,s,i=e[0],l=e[1],c=e[2],d=0,p=[];d<i.length;d++)s=i[d],Object.prototype.hasOwnProperty.call(o,s)&&o[s]&&p.push(o[s][0]),o[s]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,i=1;i<t.length;i++){var l=t[i];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=s(s.s=t[0]))}return n}var r={},o={8:0},a=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,i=document.createElement("script");i.charset="utf-8",i.timeout=120,s.nc&&i.setAttribute("nonce",s.nc),i.src=function(n){return s.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"a370845a",2:"08803d47",3:"dcb80023",4:"90bd5023",5:"aac70c1c",6:"cb4a535e",7:"16f464c2",9:"9ef1a0ca",10:"564253ef",11:"141e02ca",12:"c43cf55f",13:"1dee1651",14:"2970adac",15:"47e79098",16:"7f32b066",17:"39279ba9",18:"5420b8ce",19:"c0bf9dd5",20:"cdc096d5",21:"c15da32c",22:"2bbe2c16",23:"eeb36d86",24:"41feb9df",25:"930d64a8",26:"5307a77c",27:"4a948b1f",28:"bbc3bf81",29:"b7a67a8a",30:"330bc25e",31:"25f35abb",32:"a7c33843",33:"d13de414",34:"126d6be8",35:"e963fb93",36:"7cb8c866",37:"b3474fca",38:"eecfa05c",39:"6a80f40a",40:"b0beb471",41:"530597a8",42:"785f9606",43:"e9c9f9f4",44:"be01cfaa",45:"a18f09d2",46:"7458026c",47:"95b924b1",48:"0f18d045",49:"c6955b79",50:"3353848b",51:"afa43e50",52:"7d2ab80d",53:"4374eb9c",54:"600b5fc3",55:"8d7c9286",56:"a2b7aaec",57:"762096ae",58:"617a72f5",59:"945d9369",60:"c72295ad",61:"973e7b17",62:"319a300f",63:"f08654c5",64:"68d2cc61",65:"b1b2a254",66:"531fba3e",67:"c3f68f3a",68:"ffd2b4d9",69:"12142fca",70:"375b5e76",71:"dd79fc2d",72:"d6376070",73:"d40bfbcf",74:"ae8198d7",75:"6c535169",76:"4342f65a",77:"d384c6ce",78:"456c5622",79:"f351ce94",80:"d8f1fdfc",81:"189da1dd",82:"288dce1a",83:"2b313f1f",84:"c0f2d51f",85:"f4395185",86:"51058c54",87:"de8e8b37",88:"18284846",89:"9e892ed0",90:"98585e36",91:"0e7d737f",92:"ef614598",93:"c06259bc",94:"414ae13c",95:"25b3964d",96:"472fa650",97:"6b5c5419",98:"c5925425",99:"b4635e29",100:"c35b9817",101:"c6a8c814",102:"88236ccf",103:"67c936e1",104:"8fc3204b",105:"58194991",106:"40f7a133",107:"8e7a3cbd",108:"85a56101",109:"e8350503",110:"c44ed8f7",111:"1b5062ea",112:"61191925",113:"0a3dc942",114:"bda2b561",115:"adace76f",116:"8b2a6290",117:"c0e5e0cf",118:"6b430d21",119:"5eaa5de1",120:"17910a89",121:"fb6ccf62",122:"a57b91f6",123:"37dd985e",124:"0fddbe5d",125:"65d7027f",126:"c5a821cb",127:"3b3ef1fc",128:"d78bc2aa",129:"51a1a88e",130:"729b0572",131:"ac6f9726",132:"b13e1261",133:"4759f2f2",134:"4ca33894",135:"eee995e6",136:"0dec144e",137:"4f794e1a",138:"287f26dc",139:"9f0c6e77",140:"1c5bf392",141:"18013a51",142:"ad961356",143:"e6d314ef",144:"2c0d38d4",145:"ef4a83a0",146:"629f8b70",147:"b46d65fb",148:"524bf7db",149:"164af466",150:"cc678031",151:"eb336eb5",152:"f0bed21e",153:"37c5472f",154:"028e1db1",155:"d5fd774f",156:"d1d9a355",157:"f9f4ede3",158:"2a231f1b",159:"0d569bfc",160:"89d06450",161:"1918e7a6",162:"d272494d",163:"4fe631fe",164:"40a5d0a3",165:"1a34a9e4",166:"7c784998",167:"8a3d563d",168:"94bc381d",169:"b9cc0fe2",170:"b2cd295c",171:"d59f35fa",172:"5db5ca48",173:"df8bb8d9",174:"67bfb9a4",175:"20444ba4",176:"218dea39",177:"1c8a3d47",178:"4aa5e430",179:"0d2c3f09",180:"cb18eea2",181:"da6e1f74",182:"140f2683",183:"ed45cd62",184:"2c972959",185:"6f4edb76",186:"0907fa31"}[n]+".js"}(n);var l=new Error;a=function(e){i.onerror=i.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:i})}),12e4);i.onerror=i.onload=a,document.head.appendChild(i)}return Promise.all(e)},s.m=n,s.c=r,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)s.d(t,r,function(e){return n[e]}.bind(null,r));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/myblog/",s.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var c=0;c<i.length;c++)e(i[c]);var u=l;a.push([99,0]),t()}([function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var r=t(24),o=Function.prototype,a=o.call,s=r&&o.bind.bind(a,a);n.exports=r?s:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r=t(3);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(65),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){"use strict";var r=t(2),o=t(29),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(158),o=t(161);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(13),o=t(143),a=t(144),s=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?o(n):a(n)}},function(n,e,t){"use strict";var r=t(4),o=t(15),a=t(32);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(7).Symbol;n.exports=r},function(n,e,t){"use strict";function r(n,e,t,r,o,a,s,i){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):o&&(l=i?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(4),o=t(60),a=t(96),s=t(45),i=t(51),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(s(n),e=i(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=i(e),s(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){"use strict";var r=t(2),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e,t){var r=t(148),o=t(149),a=t(150),s=t(151),i=t(152);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(67);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(9)(Object,"create");n.exports=r},function(n,e,t){var r=t(170);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(43);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,s((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),i(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,d)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,s=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return i(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&p(o),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n,e,t){"use strict";var r=t(0),o=t(49).f,a=t(12),s=t(90),i=t(35),l=t(61),c=t(118);n.exports=function(n,e){var t,u,d,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[h]||i(h,{}):r[h]&&r[h].prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(m=o(t,u))&&m.value:t[u],!c(f?u:h+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),s(t,u,p,n)}}},function(n,e,t){"use strict";var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var r=t(46),o=t(33);n.exports=function(n){return r(o(n))}},function(n,e,t){"use strict";var r=t(0),o=t(1),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(1),o=t(105),a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(o(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(0),o=t(57),a=t(8),s=t(59),i=t(55),l=t(54),c=r.Symbol,u=o("wks"),d=l?c.for||c:c&&c.withoutSetter||s;n.exports=function(n){return a(u,n)||(u[n]=i&&a(c,n)?c[n]:d("Symbol."+n)),u[n]}},function(n,e,t){"use strict";var r=t(33),o=Object;n.exports=function(n){return o(r(n))}},function(n,e,t){"use strict";var r=t(116);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(24),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(50),o=TypeError;n.exports=function(n){if(r(n))throw new o("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(58),o=t(0),a=t(35),s=n.exports=o["__core-js_shared__"]||a("__core-js_shared__",{});(s.versions||(s.versions=[])).push({version:"3.37.1",mode:r?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(0),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(142),o=t(10),a=Object.prototype,s=a.hasOwnProperty,i=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&s.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(9)(t(7),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(162),o=t(169),a=t(171),s=t(172),i=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),o=t(43),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(s.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(11),o=t(10);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(6),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(o(n)+" is not an object")}},function(n,e,t){"use strict";var r=t(2),o=t(3),a=t(16),s=Object,i=r("".split);n.exports=o((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"===a(n)?i(n,""):s(n)}:s},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var r=t(4),o=t(31),a=t(101),s=t(32),i=t(25),l=t(51),c=t(8),u=t(60),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=i(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return s(!o(a.f,n,e),n[e])}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(102),o=t(52);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e,t){"use strict";var r=t(26),o=t(1),a=t(53),s=t(54),i=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&a(e.prototype,i(n))}},function(n,e,t){"use strict";var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(55);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(56),o=t(3),a=t(0).String;n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol("symbol detection");return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,o,a=t(0),s=t(103),i=a.process,l=a.Deno,c=i&&i.versions||l&&l.version,u=c&&c.v8;u&&(o=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&s&&(!(r=s.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=s.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){"use strict";var r=t(34);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(2),o=0,a=Math.random(),s=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++o+a,36)}},function(n,e,t){"use strict";var r=t(4),o=t(3),a=t(95);n.exports=!r&&!o((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(8),o=t(111),a=t(49),s=t(15);n.exports=function(n,e,t){for(var i=o(e),l=s.f,c=a.f,u=0;u<i.length;u++){var d=i[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var r=t(115);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(125),o=t(6),a=t(33),s=t(126);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),s(r),o(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(17),o=t(153),a=t(154),s=t(155),i=t(156),l=t(157);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=s,c.prototype.has=i,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(11),o=t(38);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(174),o=t(10);n.exports=function n(e,t,a,s,i){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,s,n,i))}},function(n,e,t){var r=t(72),o=t(177),a=t(73);n.exports=function(n,e,t,s,i,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var v=n[h],b=e[h];if(s)var y=c?s(b,v,h,e,n,l):s(v,b,h,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!o(e,(function(n,e){if(!a(g,e)&&(v===n||i(v,n,t,s,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!i(v,b,t,s,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(39),o=t(175),a=t(176);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=o,s.prototype.has=a,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(187),o=t(193),a=t(78);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(7),o=t(189),a=e&&!e.nodeType&&e,s=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=s&&s.exports===a?r.Buffer:void 0,l=(i?i.isBuffer:void 0)||o;n.exports=l}).call(this,t(48)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(190),o=t(191),a=t(192),s=a&&a.isTypedArray,i=s?o(s):r;n.exports=i},function(n,e,t){var r=t(68),o=t(41);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(9)(t(7),"Set");n.exports=r},function(n,e,t){var r=t(38);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(83),o=t(21);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(5),o=t(42),a=t(204),s=t(207);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(140),o=t(145),a=t(216),s=t(224),i=t(233),l=t(92),c=a((function(n){var e=l(n);return i(e)&&(e=void 0),s(r(n,1,i,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var a="",s=0,i=0;for(s=o.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}i!==s&&(a+=t.substring(i,s)),i=s+1,a+=e}return i!==s?a+t.substring(i,s):a}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,s=parseInt,i="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=i||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var i=o.test(n);return i||a.test(n)?s(n.slice(2),i?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,s,i,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=o;return r=o=void 0,c=e,s=n.apply(a,t)}function y(n){return c=n,i=setTimeout(w,e),u?b(n):s}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(x(n))return k(n);i=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function k(n){return i=void 0,v&&r?b(n):(r=o=void 0,s)}function j(){var n=m(),t=x(n);if(r=arguments,o=this,l=n,t){if(void 0===i)return y(l);if(g)return i=setTimeout(w,e),b(l)}return void 0===i&&(i=setTimeout(w,e)),s}return e=f(e)||0,h(t)&&(u=!!t.leading,a=(g="maxWait"in t)?d(f(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),j.cancel=function(){void 0!==i&&clearTimeout(i),c=0,r=l=o=i=void 0},j.flush=function(){return void 0===i?s:k(m())},j}},function(n,e,t){"use strict";var r=t(23),o=t(29),a=t(30),s=t(137),i=t(139);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=o(this),t=a(e),r=arguments.length;i(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){"use strict";var r=t(1),o=t(15),a=t(93),s=t(35);n.exports=function(n,e,t,i){i||(i={});var l=i.enumerable,c=void 0!==i.name?i.name:e;if(r(t)&&a(t,c,i),i.global)l?n[e]=t:s(e,t);else{try{i.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!i.nonConfigurable,writable:!i.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(131),o=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(2),o=t(3),a=t(1),s=t(8),i=t(4),l=t(107).CONFIGURABLE,c=t(108),u=t(109),d=u.enforce,p=u.get,m=String,h=Object.defineProperty,f=r("".slice),g=r("".replace),v=r([].join),b=i&&!o((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||l&&n.name!==e)&&(i?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&s(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?i&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return s(r,"source")||(r.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r=t(0),o=t(6),a=r.document,s=o(a)&&o(a.createElement);n.exports=function(n){return s?a.createElement(n):{}}},function(n,e,t){"use strict";var r=t(4),o=t(3);n.exports=r&&o((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(57),o=t(59),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){"use strict";var r=t(2),o=t(8),a=t(25),s=t(113).indexOf,i=t(47),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,u=[];for(t in r)!o(i,t)&&o(r,t)&&l(u,t);for(;e.length>c;)o(r,t=e[c++])&&(~s(u,t)||l(u,t));return u}},function(n,e,t){n.exports=t(238)},function(n,e,t){"use strict";var r=t(23),o=t(119).left,a=t(120),s=t(56);r({target:"Array",proto:!0,forced:!t(121)&&s>79&&s<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(31),o=t(6),a=t(52),s=t(104),i=t(106),l=t(28),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!o(n)||a(n))return n;var t,l=s(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!o(t)||a(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var r=t(27),o=t(50);n.exports=function(n,e){var t=n[e];return o(t)?void 0:r(t)}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(31),o=t(1),a=t(6),s=TypeError;n.exports=function(n,e){var t,i;if("string"===e&&o(t=n.toString)&&!a(i=r(t,n)))return i;if(o(t=n.valueOf)&&!a(i=r(t,n)))return i;if("string"!==e&&o(t=n.toString)&&!a(i=r(t,n)))return i;throw new s("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(4),o=t(8),a=Function.prototype,s=r&&Object.getOwnPropertyDescriptor,i=o(a,"name"),l=i&&"something"===function(){}.name,c=i&&(!r||r&&s(a,"name").configurable);n.exports={EXISTS:i,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var r=t(2),o=t(1),a=t(34),s=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return s(n)}),n.exports=a.inspectSource},function(n,e,t){"use strict";var r,o,a,s=t(110),i=t(0),l=t(6),c=t(12),u=t(8),d=t(34),p=t(97),m=t(47),h=i.TypeError,f=i.WeakMap;if(s||d.state){var g=d.state||(d.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},o=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=p("state");m[v]=!0,r=function(n,e){if(u(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},o=function(n){return u(n,v)?n[v]:{}},a=function(n){return u(n,v)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=o(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(0),o=t(1),a=r.WeakMap;n.exports=o(a)&&/native code/.test(String(a))},function(n,e,t){"use strict";var r=t(26),o=t(2),a=t(112),s=t(117),i=t(45),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(i(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(98),o=t(94).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){"use strict";var r=t(25),o=t(114),a=t(30),s=function(n){return function(e,t,s){var i=r(e),l=a(i);if(0===l)return!n&&-1;var c,u=o(s,l);if(n&&t!=t){for(;l>u;)if((c=i[u++])!=c)return!0}else for(;l>u;u++)if((n||u in i)&&i[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){"use strict";var r=t(62),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:r)(e)}},function(n,e,t){"use strict";var r=t(62),o=Math.min;n.exports=function(n){var e=r(n);return e>0?o(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(3),o=t(1),a=/#|\.prototype\./,s=function(n,e){var t=l[i(n)];return t===u||t!==c&&(o(e)?r(e):!!e)},i=s.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",u=s.POLYFILL="P";n.exports=s},function(n,e,t){"use strict";var r=t(27),o=t(29),a=t(46),s=t(30),i=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,u){var d=o(e),p=a(d),m=s(d);if(r(t),0===m&&c<2)throw new i(l);var h=n?m-1:0,f=n?-1:1;if(c<2)for(;;){if(h in p){u=p[h],h+=f;break}if(h+=f,n?h<0:m<=h)throw new i(l)}for(;n?h>=0:m>h;h+=f)h in p&&(u=t(u,p[h],h,d));return u}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(0),o=t(16);n.exports="process"===o(r.process)},function(n,e,t){"use strict";var r=t(23),o=t(0),a=t(123),s=t(124),i=o.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(i&&i[n]){var t={};t[n]=s("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(24),o=Function.prototype,a=o.apply,s=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?s.bind(a):function(){return s.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(26),o=t(8),a=t(12),s=t(53),i=t(63),l=t(61),c=t(128),u=t(129),d=t(130),p=t(133),m=t(134),h=t(4),f=t(58);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),y=b[b.length-1],x=r.apply(null,b);if(x){var w=x.prototype;if(!f&&o(w,"cause")&&delete w.cause,!t)return x;var k=r("Error"),j=e((function(n,e){var t=d(g?e:n,void 0),r=g?new x(n):new x;return void 0!==t&&a(r,"message",t),m(r,j,r.stack,2),this&&s(w,this)&&u(r,this,j),arguments.length>v&&p(r,arguments[v]),r}));if(j.prototype=w,"Error"!==y?i?i(j,k):l(j,k,{name:!0}):h&&"stackTraceLimit"in x&&(c(j,x,"stackTraceLimit"),c(j,x,"prepareStackTrace")),l(j,x),!f)try{w.name!==y&&a(w,"name",y),w.constructor=j}catch(n){}return j}}},function(n,e,t){"use strict";var r=t(2),o=t(27);n.exports=function(n,e,t){try{return r(o(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(127),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a("Can't set "+o(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(6);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(15).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),o=t(6),a=t(63);n.exports=function(n,e,t){var s,i;return a&&r(s=e.constructor)&&s!==t&&o(i=s.prototype)&&i!==t.prototype&&a(n,i),n}},function(n,e,t){"use strict";var r=t(91);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(132),o=t(1),a=t(16),s=t(28)("toStringTag"),i=Object,l="Arguments"===a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=i(n),s))?t:l?a(e):"Object"===(r=a(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r={};r[t(28)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(6),o=t(12);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(12),o=t(135),a=t(136),s=Error.captureStackTrace;n.exports=function(n,e,t,i){a&&(s?s(n,e):r(n,"stack",o(t,i)))}},function(n,e,t){"use strict";var r=t(2),o=Error,a=r("".replace),s=String(new o("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,l=i.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=a(n,i,"");return n}},function(n,e,t){"use strict";var r=t(3),o=t(32);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(4),o=t(138),a=TypeError,s=Object.getOwnPropertyDescriptor,i=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=i?function(n,e){if(o(n)&&!s(n,"length").writable)throw new a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(16);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(64),o=t(141);n.exports=function n(e,t,a,s,i){var l=-1,c=e.length;for(a||(a=o),i||(i=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,s,i):r(i,u):s||(i[i.length]=u)}return i}},function(n,e,t){var r=t(13),o=t(36),a=t(5),s=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(s&&n&&n[s])}},function(n,e,t){var r=t(11),o=t(10);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(13),o=Object.prototype,a=o.hasOwnProperty,s=o.toString,i=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,i),t=n[i];try{n[i]=void 0;var r=!0}catch(n){}var o=s.call(n);return r&&(e?n[i]=t:delete n[i]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(146),o=t(202),a=t(44),s=t(5),i=t(213);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?s(n)?o(n[0],n[1]):r(n):i(n)}},function(n,e,t){var r=t(147),o=t(201),a=t(81);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(66),o=t(70);n.exports=function(n,e,t,a){var s=t.length,i=s,l=!a;if(null==n)return!i;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<i;){var u=(c=t[s])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new r;if(a)var h=a(d,p,u,n,e,m);if(!(void 0===h?o(p,d,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(18),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(18);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(18);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(18);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(17);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(17),o=t(37),a=t(39);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var s=t.__data__;if(!o||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(68),o=t(159),a=t(38),s=t(69),i=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?p:i).test(s(n))}},function(n,e,t){var r,o=t(160),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(7)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(163),o=t(17),a=t(37);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(164),o=t(165),a=t(166),s=t(167),i=t(168);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(19),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(19),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(20);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(66),o=t(71),a=t(178),s=t(181),i=t(197),l=t(5),c=t(75),u=t(77),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),b=g?"[object Array]":i(n),y=v?"[object Array]":i(e),x=(b="[object Arguments]"==b?d:b)==d,w=(y="[object Arguments]"==y?d:y)==d,k=b==y;if(k&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(k&&!x)return f||(f=new r),g||u(n)?o(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var j=x&&p.call(n,"__wrapped__"),T=w&&p.call(e,"__wrapped__");if(j||T){var S=j?n.value():n,_=T?e.value():e;return f||(f=new r),h(S,_,t,m,f)}}return!!k&&(f||(f=new r),s(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(13),o=t(179),a=t(67),s=t(71),i=t(180),l=t(40),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=i;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;r|=2,p.set(n,e);var g=s(m(n),m(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(7).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(182),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,s,i){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:o.call(e,p)))return!1}var m=i.get(n),h=i.get(e);if(m&&h)return m==e&&h==n;var f=!0;i.set(n,e),i.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],b=e[p];if(a)var y=l?a(b,v,p,e,n,i):a(v,b,p,n,e,i);if(!(void 0===y?v===b||s(v,b,t,a,i):y)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(f=!1)}return i.delete(n),i.delete(e),f}},function(n,e,t){var r=t(183),o=t(184),a=t(74);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(64),o=t(5);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(185),o=t(186),a=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,i=s?function(n){return null==n?[]:(n=Object(n),r(s(n),(function(e){return a.call(n,e)})))}:o;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var s=n[t];e(s,t,n)&&(a[o++]=s)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(188),o=t(36),a=t(5),s=t(75),i=t(76),l=t(77),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),d=!t&&!u&&s(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,h=m?r(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||i(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(11),o=t(41),a=t(10),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!s[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(65),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o&&r.process,i=function(){try{var n=a&&a.require&&a.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=i}).call(this,t(48)(n))},function(n,e,t){var r=t(194),o=t(195),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(196)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(198),o=t(37),a=t(199),s=t(79),i=t(200),l=t(11),c=t(69),u=c(r),d=c(o),p=c(a),m=c(s),h=c(i),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=f(new o)||a&&"[object Promise]"!=f(a.resolve())||s&&"[object Set]"!=f(new s)||i&&"[object WeakMap]"!=f(new i))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(9)(t(7),"DataView");n.exports=r},function(n,e,t){var r=t(9)(t(7),"Promise");n.exports=r},function(n,e,t){var r=t(9)(t(7),"WeakMap");n.exports=r},function(n,e,t){var r=t(80),o=t(74);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],s=n[a];e[t]=[a,s,r(s)]}return e}},function(n,e,t){var r=t(70),o=t(203),a=t(210),s=t(42),i=t(80),l=t(81),c=t(21);n.exports=function(n,e){return s(n)&&i(e)?l(c(n),e):function(t){var s=o(t,n);return void 0===s&&s===e?a(t,n):r(e,s,3)}}},function(n,e,t){var r=t(82);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(205),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,s=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var r=t(206);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(39);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var s=n.apply(this,r);return t.cache=a.set(o,s)||a,s};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(208);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(13),o=t(209),a=t(5),s=t(43),i=r?r.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(211),o=t(212);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(83),o=t(36),a=t(5),s=t(76),i=t(41),l=t(21);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&i(u)&&s(p,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(214),o=t(215),a=t(42),s=t(21);n.exports=function(n){return a(n)?r(s(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(82);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(44),o=t(217),a=t(219);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(218),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,s=-1,i=o(a.length-e,0),l=Array(i);++s<i;)l[s]=a[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=a[s];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(220),o=t(223)(r);n.exports=o},function(n,e,t){var r=t(221),o=t(222),a=t(44),s=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(9),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(72),o=t(225),a=t(230),s=t(73),i=t(231),l=t(40);n.exports=function(n,e,t){var c=-1,u=o,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=a;else if(d>=200){var f=e?null:i(n);if(f)return l(f);p=!1,u=s,h=new r}else h=e?[]:m;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else u(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var r=t(226);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(227),o=t(228),a=t(229);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(79),o=t(232),a=t(40),s=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(78),o=t(10);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(84)},function(n,e,t){"use strict";t(85)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function a(n){return null==n}function s(n){return null!=n}function i(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,v,2):String(n)}function v(n,e){return e&&e.__v_isRef?e.value:e}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var x=y("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var k=Object.prototype.hasOwnProperty;function j(n,e){return k.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,_=T((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),I=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),P=/\B([A-Z])/g,z=T((function(n){return n.replace(P,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function E(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function A(n,e){for(var t in e)n[t]=e[t];return n}function M(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function O(n,e,t){}var R=function(n,e,t){return!1},D=function(n){return n};function q(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return q(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var s=Object.keys(n),i=Object.keys(e);return s.length===i.length&&s.every((function(t){return q(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(q(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function B(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var $=["component","directive","filter"],V=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:R,isReservedAttr:R,isUnknownElement:R,getTagNamespace:O,parsePlatformTagName:D,mustUseProp:R,async:!0,_lifecycleHooks:V},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function J(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(U.source,".$_\\d]"));var W="__proto__"in{},X="undefined"!=typeof window,K=X&&window.navigator.userAgent.toLowerCase(),Z=K&&/msie|trident/.test(K),Y=K&&K.indexOf("msie 9.0")>0,Q=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var nn=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var en,tn=K&&K.match(/firefox\/(\d+)/),rn={}.watch,on=!1;if(X)try{var an={};Object.defineProperty(an,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===en&&(en=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);un="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function mn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,o,a,s,i){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function gn(n){return new hn(void 0,void 0,void 0,String(n))}function vn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var bn=0,yn=[],xn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var wn=[];function kn(n){wn.push(n),xn.target=n}function jn(){wn.pop(),xn.target=wn[wn.length-1]}var Tn=Array.prototype,Sn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];J(Sn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,a=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&s.observeArray(o),s.dep.notify(),a}))}));var _n=Object.getOwnPropertyNames(Sn),In={},Pn=!0;function zn(n){Pn=n}var Cn={notify:O,depend:O,addSub:O,removeSub:O},En=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new xn,this.vmCount=0,J(n,"__ob__",this),o(n)){if(!t)if(W)n.__proto__=Sn;else for(var r=0,a=_n.length;r<a;r++){J(n,i=_n[r],Sn[i])}e||this.observeArray(n)}else{var s=Object.keys(n);for(r=0;r<s.length;r++){var i;Mn(n,i=s[r],In,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)An(n[e],!1,this.mock)},n}();function An(n,e,t){return n&&j(n,"__ob__")&&n.__ob__ instanceof En?n.__ob__:!Pn||!t&&sn()||!o(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Bn(n)||n instanceof hn?void 0:new En(n,e,t)}function Mn(n,e,t,r,a,s,i){void 0===i&&(i=!1);var l=new xn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var u=c&&c.get,d=c&&c.set;u&&!d||t!==In&&2!==arguments.length||(t=n[e]);var p=a?t&&t.__ob__:An(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=u?u.call(n):t;return xn.target&&(l.depend(),p&&(p.dep.depend(),o(e)&&Dn(e))),Bn(e)&&!a?e.value:e},set:function(e){var r=u?u.call(n):t;if(B(r,e)){if(d)d.call(n,e);else{if(u)return;if(!a&&Bn(r)&&!Bn(e))return void(r.value=e);t=e}p=a?e&&e.__ob__:An(e,!1,s),l.notify()}}}),l}}function On(n,e,t){if(!Nn(n)){var r=n.__ob__;return o(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&An(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Mn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Rn(n,e){if(o(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||j(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&Dn(e)}function qn(n){return Ln(n,!0),J(n,"__v_isShallow",!0),n}function Ln(n,e){if(!Nn(n)){An(n,e,sn());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function Bn(n){return!(!n||!0!==n.__v_isRef)}function $n(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Bn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Bn(r)&&!Bn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Vn;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Vn,!n&&Vn&&(this.index=(Vn.scopes||(Vn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Vn;try{return Vn=this,n()}finally{Vn=e}}else 0},n.prototype.on=function(){Vn=this},n.prototype.off=function(){Vn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Jn(n,e){function t(){var n=t.fns;if(!o(n))return Pe(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Pe(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,r,o,s){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Hn(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=Jn(c,s)),i(d.once)&&(c=n[l]=o(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((d=Hn(l)).name,e[l],d.capture)}function Wn(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}a(o)?r=Jn([l]):s(o.fns)&&i(o.merged)?(r=o).fns.push(l):r=Jn([o,l]),r.merged=!0,n[e]=r}function Xn(n,e,t,r,o){if(s(e)){if(j(e,t))return n[t]=e[t],o||delete e[t],!0;if(j(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Kn(n){return l(n)?[gn(n)]:o(n)?function n(e,t){var r,c,u,d,p=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(u=p.length-1,d=p[u],o(c)?c.length>0&&(Zn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Zn(d)&&(p[u]=gn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Zn(d)?p[u]=gn(d.text+c):""!==c&&p.push(gn(c)):Zn(c)&&Zn(d)?p[u]=gn(d.text+c.text):(i(e._isVList)&&s(c.tag)&&a(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Zn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Yn(n,e){var t,r,a,i,l=null;if(o(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)i=a[t],l[t]=e(n[i],i,t);return s(l)||(l=[]),l._isVList=!0,l}function Qn(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=A(A({},r),t)),o=a(t)||(c(e)?e():e)):o=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},o):o}function ne(n){return Et(this.$options,"filters",n,!0)||D}function ee(n,e){return o(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,o){var a=F.keyCodes[e]||t;return o&&r&&!F.keyCodes[e]?ee(o,r):a?ee(a,n):r?z(r)!==e:void 0===n}function re(n,e,t,r,a){if(t)if(u(t)){o(t)&&(t=M(t));var s=void 0,i=function(o){if("class"===o||"style"===o||x(o))s=n;else{var i=n.attrs&&n.attrs.type;s=r||F.mustUseProp(e,i,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=_(o),c=z(o);l in s||c in s||(s[o]=t[o],a&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var l in t)i(l)}else;return n}function oe(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||se(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return se(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function se(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ie(n[r],"".concat(e,"_").concat(r),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?A({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var s=n[a];o(s)?ce(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return r&&(e.$key=r),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=ae,n._n=b,n._s=g,n._l=Yn,n._t=Qn,n._q=q,n._i=L,n._m=oe,n._f=ne,n._k=te,n._b=re,n._v=gn,n._e=fn,n._u=ce,n._g=le,n._d=ue,n._p=de}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],s=a.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,a.context!==e&&a.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(a);else{var i=s.slot,l=t[i]||(t[i]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function fe(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,o){var a,s=Object.keys(t).length>0,i=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(i&&o&&o!==r&&l===o.$key&&!s&&!o.$hasNormal)return o;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ve(n,t,c,e[c]))}else a={};for(var u in t)u in a||(a[u]=be(t,u));return e&&Object.isExtensible(e)&&(e._normalized=a),J(a,"$stable",i),J(a,"$key",l),J(a,"$hasNormal",s),a}function ve(n,e,t,r){var a=function(){var e=pn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!o(t)?[t]:Kn(t))&&t[0];return mn(e),t&&(!a||1===t.length&&a.isComment&&!fe(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function be(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};J(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return $n(n,e,t)}))}}}function xe(n,e,t,r,o){var a=!1;for(var s in e)s in n?e[s]!==t[s]&&(a=!0):(a=!0,we(n,s,r,o));for(var s in n)s in e||(a=!0,delete n[s]);return a}function we(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var je=null;function Te(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Se(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||fe(t)))return t}}function _e(n,e,t,r,d,p){return(o(t)||l(t))&&(d=r,r=t,t=void 0),i(p)&&(d=2),function(n,e,t,r,l){if(s(t)&&s(t.__ob__))return fn();s(t)&&s(t.is)&&(e=t.is);if(!e)return fn();0;o(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Kn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),d=F.isReservedTag(e)?new hn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!s(m=Et(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):wt(m,t,n,r,e)}else d=wt(e,t,n,r);return o(d)?d:s(d)?(s(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(s(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];s(c.tag)&&(a(c.ns)||i(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,p),s(t)&&function(n){u(n.style)&&Fe(n.style);u(n.class)&&Fe(n.class)}(t),d):fn()}(n,e,t,r,d)}function Ie(n,e,t){kn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){ze(n,r,"errorCaptured hook")}}ze(n,e,t)}finally{jn()}}function Pe(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Ie(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){Ie(n,r,o)}return a}function ze(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Ee,Ae=!1,Me=[],Oe=!1;function Re(){Oe=!1;var n=Me.slice(0);Me.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var De=Promise.resolve();Ee=function(){De.then(Re),nn&&setTimeout(O)},Ae=!0}else if(Z||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ee="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Re)}:function(){setTimeout(Re,0)};else{var qe=1,Le=new MutationObserver(Re),Ne=document.createTextNode(String(qe));Le.observe(Ne,{characterData:!0}),Ee=function(){qe=(qe+1)%2,Ne.data=String(qe)},Ae=!0}function Be(n,e){var t;if(Me.push((function(){if(n)try{n.call(e)}catch(n){Ie(n,e,"nextTick")}else t&&t(e)})),Oe||(Oe=!0,Ee()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function $e(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=It(r[e],t)}(t,n,e)}}$e("beforeMount"),$e("mounted"),$e("beforeUpdate"),$e("updated"),$e("beforeDestroy"),$e("destroyed"),$e("activated"),$e("deactivated"),$e("serverPrefetch"),$e("renderTracked"),$e("renderTriggered"),$e("errorCaptured");var Ve=new un;function Fe(n){return function n(e,t){var r,a,s=o(e);if(!s&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(s)for(r=e.length;r--;)n(e[r],t);else if(Bn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Ve),Ve.clear(),n}var Ue,He=0,Je=function(){function n(n,e,t,r,o){var a,s;a=this,void 0===(s=Vn&&!Vn._vm?Vn:n?n._scope:void 0)&&(s=Vn),s&&s.active&&s.effects.push(a),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ie(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),jn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Pe(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){Ue.$on(n,e)}function We(n,e){Ue.$off(n,e)}function Xe(n,e){var t=Ue;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ke(n,e,t){Ue=n,Gn(e,t||{},Ge,We,Xe,n),Ue=void 0}var Ze=null;function Ye(n){var e=Ze;return Ze=n,function(){Ze=e}}function Qe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Qe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),kn();var o=pn,a=Vn;r&&mn(n);var s=n.$options[e],i="".concat(e," hook");if(s)for(var l=0,c=s.length;l<c;l++)Pe(s[l],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&(mn(o),a&&a.on()),jn()}var tt=[],rt=[],ot={},at=!1,st=!1,it=0;var lt=0,ct=Date.now;if(X&&!Z){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ct(),st=!0,tt.sort(dt),it=0;it<tt.length;it++)(n=tt[it]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=rt.slice(),r=tt.slice();it=tt.length=rt.length=0,ot={},at=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),ln&&F.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==ot[e]&&(n!==xn.target||!n.noRecurse)){if(ot[e]=!0,st){for(var t=tt.length-1;t>it&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,Be(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){var s=n[a].from;if(s in e._provided)t[a]=e._provided[s];else if("default"in n[a]){var i=n[a].default;t[a]=c(i)?i.call(e):i}else 0}}return t}}function ft(n,e,t,a,s){var l,c=this,u=s.options;j(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=i(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=ht(u.inject,a),this.slots=function(){return c.$slots||ge(a,n.scopedSlots,c.$slots=me(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var s=_e(l,n,e,t,r,p);return s&&!o(s)&&(s.fnScopeId=u._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,r){return _e(l,n,e,t,r,p)}}function gt(n,e,t,r,o){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function vt(n,e){for(var t in e)n[_(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}pe(ft.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;s(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){var s=o.data.scopedSlots,i=n.$scopedSlots,l=!!(s&&!s.$stable||i!==r&&!i.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o),n.$options._renderChildren=a;var d=o.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,d,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){zn(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],v=n.$options.props;m[g]=At(g,v,e,n)}zn(!0),n.$options.propsData=e}c&&(n.$slots=me(a,o.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Qe(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(yt);function wt(n,e,t,l,c){if(!a(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=je;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),i(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var r=n.owners=[t],o=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=N((function(t){n.resolved=Te(t,e),o?r.length=0:d(!0)})),m=N((function(e){s(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,m);return u(h)&&(f(h)?a(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=Te(h.error,e)),s(h.loading)&&(n.loadingComp=Te(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),s(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,r,o){var a=fn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(p,e,t,l,c);e=e||{},Jt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),i=a[r],l=e.model.callback;s(i)?(o(i)?-1===i.indexOf(l):i!==l)&&(a[r]=[l].concat(i)):a[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},i=n.attrs,l=n.props;if(s(i)||s(l))for(var c in r){var u=z(c);Xn(o,l,c,u,!0)||Xn(o,i,c,u,!1)}return o}}(e,n);if(i(n.options.functional))return function(n,e,t,a,i){var l=n.options,c={},u=l.props;if(s(u))for(var d in u)c[d]=At(d,u,e||r);else s(t.attrs)&&vt(c,t.attrs),s(t.props)&&vt(c,t.props);var p=new ft(t,c,i,a,n),m=l.render.call(null,p._c,p);if(m instanceof hn)return gt(m,t,p.parent,l,p);if(o(m)){for(var h=Kn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=gt(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],o=e[r],a=yt[r];o===a||o&&o._merged||(e[r]=o?kt(a,o):a)}}(e);var v=bt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var jt=O,Tt=F.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,o,a,s=dn?Reflect.ownKeys(e):Object.keys(e),i=0;i<s.length;i++)"__ob__"!==(r=s[i])&&(o=n[r],a=e[r],t&&j(n,r)?o!==a&&p(o)&&p(a)&&St(o,a):On(n,r,a));return n}function _t(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,o=c(n)?n.call(t,t):n;return r?St(r,o):o}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function It(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pt(n,e,t,r){var o=Object.create(n||null);return e?A(o,e):o}Tt.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},V.forEach((function(n){Tt[n]=It})),$.forEach((function(n){Tt[n+"s"]=Pt})),Tt.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var s in A(a,n),e){var i=a[s],l=e[s];i&&!o(i)&&(i=[i]),a[s]=i?i.concat(l):o(l)?l:[l]}return a},Tt.props=Tt.methods=Tt.inject=Tt.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return A(o,n),e&&A(o,e),o},Tt.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var zt=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,s={};if(o(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(s[_(a)]={type:null});else if(p(t))for(var i in t)a=t[i],s[_(i)]=p(a)?a:{type:a};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var s in t){var i=t[s];r[s]=p(i)?A({from:s},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Ct(n,e.mixins[r],t);var s,i={};for(s in n)l(s);for(s in e)j(n,s)||l(s);function l(r){var o=Tt[r]||zt;i[r]=o(n[r],e[r],t,r)}return i}function Et(n,e,t,r){if("string"==typeof t){var o=n[e];if(j(o,t))return o[t];var a=_(t);if(j(o,a))return o[a];var s=I(a);return j(o,s)?o[s]:o[t]||o[a]||o[s]}}function At(n,e,t,r){var o=e[n],a=!j(t,n),s=t[n],i=Dt(Boolean,o.type);if(i>-1)if(a&&!j(o,"default"))s=!1;else if(""===s||s===z(n)){var l=Dt(String,o.type);(l<0||i<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!j(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Ot(e.type)?r.call(n):r}(r,o,n);var u=Pn;zn(!0),An(s),zn(u)}return s}var Mt=/^\s*function (\w+)/;function Ot(n){var e=n&&n.toString().match(Mt);return e?e[1]:""}function Rt(n,e){return Ot(n)===Ot(e)}function Dt(n,e){if(!o(e))return Rt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Rt(e[t],n))return t;return-1}var qt={enumerable:!0,configurable:!0,get:O,set:O};function Lt(n,e,t){qt.get=function(){return this[e][t]},qt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,qt)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=qn({}),o=n.$options._propKeys=[];n.$parent&&zn(!1);var a=function(a){o.push(a);var s=At(a,e,t,n);Mn(r,a,s,void 0,!0),a in n||Lt(n,"_props",a)};for(var s in e)a(s);zn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ye(n);mn(n),kn();var o=Pe(t,null,[n._props||qn({}),r],n,"setup");if(jn(),mn(),c(o))e.render=o;else if(u(o))if(n._setupState=o,o.__sfc){var a=n._setupProxy={};for(var s in o)"__sfc"!==s&&$n(a,o,s)}else for(var s in o)H(s)||$n(n,o,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?O:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Ie(n,e,"data()"),{}}finally{jn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&j(r,a)||H(a)||Lt(n,"_data",a)}var s=An(e);s&&s.vmCount++}(n);else{var t=An(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var o in e){var a=e[o],s=c(a)?a:a.get;0,r||(t[o]=new Je(n,s||O,O,Bt)),o in n||$t(n,o,a)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var a=0;a<r.length;a++)Ut(n,t,r[a]);else Ut(n,t,r)}}(n,e.watch)}var Bt={lazy:!0};function $t(n,e,t){var r=!sn();c(t)?(qt.get=r?Vt(e):Ft(t),qt.set=O):(qt.get=t.get?r&&!1!==t.cache?Vt(e):Ft(t.get):O,qt.set=t.set||O),Object.defineProperty(n,e,qt)}function Vt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function Ut(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ht=0;function Jt(n){var e=n.options;if(n.super){var t=Jt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&A(n.extendOptions,r),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=bt(n)||bt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=Ct(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Lt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)$t(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,$.forEach((function(n){s[n]=t[n]})),a&&(s.options.components[a]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=A({},s.options),o[r]=s,s}}function Xt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Kt(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Zt(n,e){var t=n.cache,r=n.keys,o=n._vnode,a=n.$vnode;for(var s in t){var i=t[s];if(i){var l=i.name;l&&!e(l)&&Yt(t,s,r,o)}}a.componentOptions.children=void 0}function Yt(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,w(t,e)}Gt.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(Jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=me(e._renderChildren,o),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,o){return _e(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return _e(n,e,t,r,o,!0)};var a=t&&t.data;Mn(n,"$attrs",a&&a.attrs||r,null,!0),Mn(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(zn(!1),Object.keys(e).forEach((function(t){Mn(n,t,e[t])})),zn(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Un(n),o=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++){var s=o[a];Object.defineProperty(r,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=Rn,n.prototype.$watch=function(n,e,t){if(p(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var r=new Je(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');kn(),Pe(e,this,[r.value],this,o),jn()}return function(){r.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var a=0,s=n.length;a<s;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var s,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var l=i.length;l--;)if((s=i[l])===e||s.fn===e){i.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?E(t):t;for(var r=E(arguments,1),o='event handler for "'.concat(n,'"'),a=0,s=t.length;a<s;a++)Pe(t[a],e,r,e,o)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Ye(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Be(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=ge(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ke(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var a,s=pn,i=je;try{mn(n),je=n,a=t.call(n._renderProxy,n.$createElement)}catch(e){Ie(e,n,"render"),a=n._vnode}finally{je=i,mn(s)}return o(a)&&1===a.length&&(a=a[0]),a instanceof hn||(a=fn()),a.parent=r,a}}(Gt);var Qt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Qt,exclude:Qt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,s=t.componentOptions;n[r]={name:Xt(s),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Zt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Zt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Xt(t),o=this.include,a=this.exclude;if(o&&(!r||!Kt(o,r))||a&&r&&Kt(a,r))return e;var s=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,w(i,l),i.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:jt,extend:A,mergeOptions:Ct,defineReactive:Mn},n.set=On,n.delete=Rn,n.nextTick=Be,n.observable=function(n){return An(n),n},n.options=Object.create(null),$.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=E(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Wt(n),function(n){$.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:sn}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:ft}),Gt.version="2.7.16";var er=y("style,class"),tr=y("input,textarea,option,select,progress"),rr=y("contenteditable,draggable,spellcheck"),or=y("events,caret,typing,plaintext-only"),ar=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),sr="http://www.w3.org/1999/xlink",ir=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return ir(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function ur(n){for(var e=n.data,t=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;s(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(s(n)||s(e))return pr(n,mr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:pr(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function pr(n,e){return n?e?n+" "+e:n:e||""}function mr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)s(e=mr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},fr=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return fr(n)||gr(n)};var br=Object.create(null);var yr=y("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wr={create:function(n,e){kr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(kr(n,!0),kr(e))},destroy:function(n){kr(n,!0)}};function kr(n,e){var t=n.data.ref;if(s(t)){var r=n.context,a=n.componentInstance||n.elm,i=e?null:a,l=e?void 0:a;if(c(t))Pe(t,r,[i],r,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Bn(t),m=r.$refs;if(d||p)if(u){var h=d?m[t]:t.value;e?o(h)&&w(h,a):o(h)?h.includes(a)||h.push(a):d?(m[t]=[a],jr(r,t,m[t])):t.value=[a]}else if(d){if(e&&m[t]!==a)return;m[t]=l,jr(r,t,i)}else if(p){if(e&&t.value!==a)return;t.value=i}else 0}}}function jr(n,e,t){var r=n._setupState;r&&j(r,e)&&(Bn(r[e])?r[e].value=t:r[e]=t)}var Tr=new hn("",{},[]),Sr=["create","activate","update","remove","destroy"];function _r(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=s(t=n.data)&&s(t=t.attrs)&&t.type,o=s(t=e.data)&&s(t=t.attrs)&&t.type;return r===o||yr(r)&&yr(o)}(n,e)||i(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Ir(n,e,t){var r,o,a={};for(r=e;r<=t;++r)s(o=n[r].key)&&(a[o]=r);return a}var Pr={create:zr,update:zr,destroy:function(n){zr(n,Tr)}};function zr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===Tr,s=e===Tr,i=Er(n.data.directives,n.context),l=Er(e.data.directives,e.context),c=[],u=[];for(t in l)r=i[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,Mr(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(Mr(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Mr(c[t],"inserted",e,n)};a?Wn(e,"insert",d):d()}u.length&&Wn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Mr(u[t],"componentUpdated",e,n)}));if(!a)for(t in i)l[t]||Mr(i[t],"unbind",n,n,s)}(n,e)}var Cr=Object.create(null);function Er(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Cr),o[Ar(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||Et(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||Et(e.$options,"directives",r.name)}return o}function Ar(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Mr(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){Ie(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Or=[wr,Pr];function Rr(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(s(u.__ob__)||i(u._v_attr_proxy))&&(u=e.data.attrs=A({},u)),u)o=u[r],c[r]!==o&&Dr(l,r,o,e.data.pre);for(r in(Z||Q)&&u.value!==c.value&&Dr(l,"value",u.value),c)a(u[r])&&(ir(r)?l.removeAttributeNS(sr,lr(r)):rr(r)||l.removeAttribute(r))}}function Dr(n,e,t,r){r||n.tagName.indexOf("-")>-1?qr(n,e,t):ar(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&or(e)?e:"true"}(e,t)):ir(e)?cr(t)?n.removeAttributeNS(sr,lr(e)):n.setAttributeNS(sr,e,t):qr(n,e,t)}function qr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(Z&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Lr={create:Rr,update:Rr};function Nr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var i=ur(e),l=t._transitionClasses;s(l)&&(i=pr(i,mr(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var Br,$r={create:Nr,update:Nr};function Vr(n,e,t){var r=Br;return function o(){var a=e.apply(null,arguments);null!==a&&Hr(n,o,t,r)}}var Fr=Ae&&!(tn&&Number(tn[1])<=53);function Ur(n,e,t,r){if(Fr){var o=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Br.addEventListener(n,e,on?{capture:t,passive:r}:t)}function Hr(n,e,t,r){(r||Br).removeEventListener(n,e._wrapper||e,t)}function Jr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Br=e.elm||n.elm,function(n){if(s(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,r,Ur,Hr,Vr,e.context),Br=void 0}}var Gr,Wr={create:Jr,update:Jr,destroy:function(n){return Jr(n,Tr)}};function Xr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||i(c._v_attr_proxy))&&(c=e.data.domProps=A({},c)),l)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var u=a(r)?"":String(r);Kr(o,u)&&(o.value=u)}else if("innerHTML"===t&&gr(o.tagName)&&a(o.innerHTML)){(Gr=Gr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Gr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;d.firstChild;)o.appendChild(d.firstChild)}else if(r!==l[t])try{o[t]=r}catch(n){}}}}function Kr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(s(r)){if(r.number)return b(t)!==b(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Zr={create:Xr,update:Xr},Yr=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Qr(n){var e=no(n.style);return n.staticStyle?A(n.staticStyle,e):e}function no(n){return Array.isArray(n)?M(n):"string"==typeof n?Yr(n):n}var eo,to=/^--/,ro=/\s*!important$/,oo=function(n,e,t){if(to.test(e))n.style.setProperty(e,t);else if(ro.test(t))n.style.setProperty(z(e),t.replace(ro,""),"important");else{var r=so(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},ao=["Webkit","Moz","ms"],so=T((function(n){if(eo=eo||document.createElement("div").style,"filter"!==(n=_(n))&&n in eo)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ao.length;t++){var r=ao[t]+e;if(r in eo)return r}}));function io(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,i,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=no(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?A({},p):p;var m=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Qr(o.data))&&A(r,t);(t=Qr(n.data))&&A(r,t);for(var a=n;a=a.parent;)a.data&&(t=Qr(a.data))&&A(r,t);return r}(e,!0);for(i in d)a(m[i])&&oo(l,i,"");for(i in m)o=m[i],oo(l,i,null==o?"":o)}}var lo={create:io,update:io},co=/\s+/;function uo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(co).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function po(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(co).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function mo(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,ho(n.name||"v")),A(e,n),e}return"string"==typeof n?ho(n):void 0}}var ho=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),fo=X&&!Y,go="transition",vo="transitionend",bo="animation",yo="animationend";fo&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(go="WebkitTransition",vo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(bo="WebkitAnimation",yo="webkitAnimationEnd"));var xo=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function wo(n){xo((function(){xo(n)}))}function ko(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),uo(n,e))}function jo(n,e){n._transitionClasses&&w(n._transitionClasses,e),po(n,e)}function To(n,e,t){var r=_o(n,e),o=r.type,a=r.timeout,s=r.propCount;if(!o)return t();var i="transition"===o?vo:yo,l=0,c=function(){n.removeEventListener(i,u),t()},u=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),a+1),n.addEventListener(i,u)}var So=/\b(transform|all)(,|$)/;function _o(n,e){var t,r=window.getComputedStyle(n),o=(r[go+"Delay"]||"").split(", "),a=(r[go+"Duration"]||"").split(", "),s=Io(o,a),i=(r[bo+"Delay"]||"").split(", "),l=(r[bo+"Duration"]||"").split(", "),c=Io(i,l),u=0,d=0;return"transition"===e?s>0&&(t="transition",u=s,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&So.test(r[go+"Property"])}}function Io(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Po(e)+Po(n[t])})))}function Po(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function zo(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=mo(n.data.transition);if(!a(r)&&!s(t._enterCb)&&1===t.nodeType){for(var o=r.css,i=r.type,l=r.enterClass,d=r.enterToClass,p=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,f=r.appearActiveClass,g=r.beforeEnter,v=r.enter,y=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,k=r.appear,j=r.afterAppear,T=r.appearCancelled,S=r.duration,_=Ze,I=Ze.$vnode;I&&I.parent;)_=I.context,I=I.parent;var P=!_._isMounted||!n.isRootInsert;if(!P||k||""===k){var z=P&&m?m:l,C=P&&f?f:p,E=P&&h?h:d,A=P&&w||g,M=P&&c(k)?k:v,O=P&&j||y,R=P&&T||x,D=b(u(S)?S.enter:S);0;var q=!1!==o&&!Y,L=Ao(M),B=t._enterCb=N((function(){q&&(jo(t,E),jo(t,C)),B.cancelled?(q&&jo(t,z),R&&R(t)):O&&O(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),M&&M(t,B)})),A&&A(t),q&&(ko(t,z),ko(t,C),wo((function(){jo(t,z),B.cancelled||(ko(t,E),L||(Eo(D)?setTimeout(B,D):To(t,i,B)))}))),n.data.show&&(e&&e(),M&&M(t,B)),q||L||B()}}}function Co(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=mo(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var o=r.css,i=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,v=r.duration,y=!1!==o&&!Y,x=Ao(m),w=b(u(v)?v.leave:v);0;var k=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(jo(t,c),jo(t,d)),k.cancelled?(y&&jo(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(j):j()}function j(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(ko(t,l),ko(t,d),wo((function(){jo(t,l),k.cancelled||(ko(t,c),x||(Eo(w)?setTimeout(k,w):To(t,i,k)))}))),m&&m(t,k),y||x||k())}}function Eo(n){return"number"==typeof n&&!isNaN(n)}function Ao(n){if(a(n))return!1;var e=n.fns;return s(e)?Ao(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Mo(n,e){!0!==e.data.show&&zo(e)}var Oo=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<Sr.length;++e)for(r[Sr[e]]=[],t=0;t<c.length;++t)s(c[t][Sr[e]])&&r[Sr[e]].push(c[t][Sr[e]]);function d(n){var e=u.parentNode(n);s(e)&&u.removeChild(e,n)}function p(n,e,t,o,a,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=vn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(s(a)){var l=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,o),i(l)&&function(n,e,t,o){var a,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,s(a=i.data)&&s(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Tr,i);e.push(i);break}h(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,p=n.children,g=n.tag;s(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),f(n,p,e),s(d)&&v(n,e),h(t,n.elm,o)):i(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,o)):(n.elm=u.createTextNode(n.text),h(t,n.elm,o))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),b(n)):(kr(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function f(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,t){for(var o=0;o<r.create.length;++o)r.create[o](Tr,n);s(e=n.data.hook)&&(s(e.create)&&e.create(Tr,n),s(e.insert)&&t.push(n))}function b(n){var e;if(s(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;s(e=Ze)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,o,a){for(;r<=o;++r)p(t[r],a,n,e,!1,t,r)}function w(n){var e,t,o=n.data;if(s(o))for(s(e=o.hook)&&s(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];s(r)&&(s(r.tag)?(j(r),w(r)):d(r.elm))}}function j(n,e){if(s(e)||s(n.data)){var t,o=r.remove.length+1;for(s(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,o),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&j(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else d(n.elm)}function T(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(s(a)&&_r(n,a))return o}}function S(n,e,t,o,l,c){if(n!==e){s(e.elm)&&s(o)&&(e=o[l]=vn(e));var d=e.elm=n.elm;if(i(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(s(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}a(e.text)?s(f)&&s(v)?f!==v&&function(n,e,t,r,o){var i,l,c,d=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],y=t[v],w=!o;for(0;d<=h&&m<=v;)a(f)?f=e[++d]:a(g)?g=e[--h]:_r(f,b)?(S(f,b,r,t,m),f=e[++d],b=t[++m]):_r(g,y)?(S(g,y,r,t,v),g=e[--h],y=t[--v]):_r(f,y)?(S(f,y,r,t,v),w&&u.insertBefore(n,f.elm,u.nextSibling(g.elm)),f=e[++d],y=t[--v]):_r(g,b)?(S(g,b,r,t,m),w&&u.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(a(i)&&(i=Ir(e,d,h)),a(l=s(b.key)?i[b.key]:T(b,e,d,h))?p(b,r,n,f.elm,!1,t,m):_r(c=e[l],b)?(S(c,b,r,t,m),e[l]=void 0,w&&u.insertBefore(n,c.elm,f.elm)):p(b,r,n,f.elm,!1,t,m),b=t[++m]);d>h?x(n,a(t[v+1])?null:t[v+1].elm,t,m,v,r):m>v&&k(e,d,h)}(d,f,v,t,c):s(v)?(s(n.text)&&u.setTextContent(d,""),x(d,null,v,0,v.length-1,t)):s(f)?k(f,0,f.length-1):s(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function _(n,e,t){if(i(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var I=y("attrs,class,staticClass,staticStyle,key");function P(n,e,t,r){var o,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,i(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(o=l.hook)&&s(o=o.init)&&o(e,!0),s(o=e.componentInstance)))return m(e,t),!0;if(s(a)){if(s(c))if(n.hasChildNodes())if(s(o=l)&&s(o=o.domProps)&&s(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!P(d,c[p],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else f(e,c,t);if(s(l)){var h=!1;for(var g in l)if(!I(g)){h=!0,v(e,t);break}!h&&l.class&&Fe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var l,c=!1,d=[];if(a(n))c=!0,p(e,d);else{var m=s(n.nodeType);if(!m&&_r(n,e))S(n,e,d,null,null,o);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&P(n,e,d))return _(e,d,!0),n;l=n,n=new hn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=u.parentNode(h);if(p(e,d,h._leaveCb?null:f,u.nextSibling(h)),s(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<r.create.length;++x)r.create[x](Tr,v);var j=v.data.hook.insert;if(j.merged)for(var T=j.fns.slice(1),I=0;I<T.length;I++)T[I]()}else kr(v);v=v.parent}s(f)?k([n],0,0):s(n.tag)&&w(n)}}return _(e,d,c),e.elm}s(n)&&w(n)}}({nodeOps:xr,modules:[Lr,$r,Wr,Zr,lo,X?{create:Mo,activate:Mo,remove:function(n,e){!0!==n.data.show?Co(n,e):e()}}:{}].concat(Or)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Vo(n,"input")}));var Ro={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Wn(t,"postpatch",(function(){Ro.componentUpdated(n,e,t)})):Do(n,e,t.context),n._vOptions=[].map.call(n.options,No)):("textarea"===t.tag||yr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Bo),n.addEventListener("compositionend",$o),n.addEventListener("change",$o),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Do(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,No);if(o.some((function(n,e){return!q(n,r[e])})))(n.multiple?e.value.some((function(n){return Lo(n,o)})):e.value!==e.oldValue&&Lo(e.value,o))&&Vo(n,"change")}}};function Do(n,e,t){qo(n,e,t),(Z||Q)&&setTimeout((function(){qo(n,e,t)}),0)}function qo(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,s,i=0,l=n.options.length;i<l;i++)if(s=n.options[i],o)a=L(r,No(s))>-1,s.selected!==a&&(s.selected=a);else if(q(No(s),r))return void(n.selectedIndex!==i&&(n.selectedIndex=i));o||(n.selectedIndex=-1)}}function Lo(n,e){return e.every((function(e){return!q(e,n)}))}function No(n){return"_value"in n?n._value:n.value}function Bo(n){n.target.composing=!0}function $o(n){n.target.composing&&(n.target.composing=!1,Vo(n.target,"input"))}function Vo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fo(n){return!n.componentInstance||n.data&&n.data.transition?n:Fo(n.componentInstance._vnode)}var Uo={model:Ro,show:{bind:function(n,e,t){var r=e.value,o=(t=Fo(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,zo(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fo(t)).data&&t.data.transition?(t.data.show=!0,r?zo(t,(function(){n.style.display=n.__vOriginalDisplay})):Co(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Ho={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Jo(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Jo(Se(e.children)):n}function Go(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[_(r)]=o[r];return e}function Wo(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Xo=function(n){return n.tag||fe(n)},Ko=function(n){return"show"===n.name},Zo={name:"transition",props:Ho,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Xo)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=Jo(o);if(!a)return o;if(this._leaving)return Wo(n,o);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:l(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var i=(a.data||(a.data={})).transition=Go(this),c=this._vnode,u=Jo(c);if(a.data.directives&&a.data.directives.some(Ko)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!fe(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=A({},i);if("out-in"===r)return this._leaving=!0,Wn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wo(n,o);if("in-out"===r){if(fe(a))return c;var p,m=function(){p()};Wn(i,"afterEnter",m),Wn(i,"enterCancelled",m),Wn(d,"delayLeave",(function(n){p=n}))}}return o}}},Yo=A({tag:String,moveClass:String},Ho);function Qo(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function na(n){n.data.newPos=n.elm.getBoundingClientRect()}function ea(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),a.transitionDuration="0s"}}delete Yo.mode;var ta={Transition:Zo,TransitionGroup:{props:Yo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],s=Go(this),i=0;i<o.length;i++){if((u=o[i]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))a.push(u),t[u.key]=u,(u.data||(u.data={})).transition=s;else;}if(r){var l=[],c=[];for(i=0;i<r.length;i++){var u;(u=r[i]).data.transition=s,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qo),n.forEach(na),n.forEach(ea),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ko(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(vo,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(vo,n),t._moveCb=null,jo(t,e))})}})))},methods:{hasMove:function(n,e){if(!fo)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){po(t,n)})),uo(t,e),t.style.display="none",this.$el.appendChild(t);var r=_o(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ra(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=vr,Gt.config.isReservedAttr=er,Gt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!X)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=br[n])return br[n];var e=document.createElement(n);return n.indexOf("-")>-1?br[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:br[n]=/HTMLUnknownElement/.test(e.toString())},A(Gt.options.directives,Uo),A(Gt.options.components,ta),Gt.prototype.__patch__=X?Oo:O,Gt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Je(n,r,O,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var a=0;a<o.length;a++)o[a].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){F.devtools&&ln&&ln.emit("init",Gt)}),0);var oa=/[!'()*]/g,aa=function(n){return"%"+n.charCodeAt(0).toString(16)},sa=/%2C/g,ia=function(n){return encodeURIComponent(n).replace(oa,aa).replace(sa,",")};function la(n){try{return decodeURIComponent(n)}catch(n){0}return n}var ca=function(n){return null==n||"object"==typeof n?n:String(n)};function ua(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=la(t.shift()),o=t.length>0?la(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function da(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ia(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(ia(e)):r.push(ia(e)+"="+ia(n)))})),r.join("&")}return ia(e)+"="+ia(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pa=/\/?$/;function ma(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=ha(a)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:va(e,o),matched:n?ga(n):[]};return t&&(s.redirectedFrom=va(t,o)),Object.freeze(s)}function ha(n){if(Array.isArray(n))return n.map(ha);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ha(n[t]);return e}return n}var fa=ma(null,{path:"/"});function ga(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function va(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||da)(r)+o}function ba(n,e,t){return e===fa?n===e:!!e&&(n.path&&e.path?n.path.replace(pa,"")===e.path.replace(pa,"")&&(t||n.hash===e.hash&&ya(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ya(n.query,e.query)&&ya(n.params,e.params))))}function ya(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var s=e[t];return null==a||null==s?a===s:"object"==typeof a&&"object"==typeof s?ya(a,s):String(a)===String(s)}))}function xa(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var s=0;s<a.length;s++)o._isBeingDestroyed||a[s](o)}}}}var wa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var s=o.$createElement,i=t.name,l=o.$route,c=o._routerViewCache||(o._routerViewCache={}),u=0,d=!1;o&&o._routerRoot!==o;){var p=o.$vnode?o.$vnode.data:{};p.routerView&&u++,p.keepAlive&&o._directInactive&&o._inactive&&(d=!0),o=o.$parent}if(a.routerViewDepth=u,d){var m=c[i],h=m&&m.component;return h?(m.configProps&&ka(h,a,m.route,m.configProps),s(h,a,r)):s()}var f=l.matched[u],g=f&&f.components[i];if(!f||!g)return c[i]=null,s();c[i]={component:g},a.registerRouteInstance=function(n,e){var t=f.instances[i];(e&&t!==n||!e&&t===n)&&(f.instances[i]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){f.instances[i]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[i]&&(f.instances[i]=n.componentInstance),xa(l)};var v=f.props&&f.props[i];return v&&(ra(c[i],{route:l,configProps:v}),ka(g,a,l,v)),s(g,a,r)}};function ka(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=ra({},o);var a=e.attrs=e.attrs||{};for(var s in o)n.props&&s in n.props||(a[s]=o[s],delete o[s])}}function ja(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),s=0;s<a.length;s++){var i=a[s];".."===i?o.pop():"."!==i&&o.push(i)}return""!==o[0]&&o.unshift(""),o.join("/")}function Ta(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Sa=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_a=Ba,Ia=Aa,Pa=function(n,e){return Oa(Aa(n,e),e)},za=Oa,Ca=Na,Ea=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Aa(n,e){for(var t,r=[],o=0,a=0,s="",i=e&&e.delimiter||"/";null!=(t=Ea.exec(n));){var l=t[0],c=t[1],u=t.index;if(s+=n.slice(a,u),a=u+l.length,c)s+=c[1];else{var d=n[a],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];s&&(r.push(s),s="");var b=null!=p&&null!=d&&d!==p,y="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||i,k=h||f;r.push({name:m||o++,prefix:p||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:k?Da(k):v?".*":"[^"+Ra(w)+"]+?"})}}return a<n.length&&(s+=n.substr(a)),s&&r.push(s),r}function Ma(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Oa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",La(e)));return function(e,r){for(var o="",a=e||{},s=(r||{}).pretty?Ma:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Sa(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=s(u[d]),!t[i].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(u),!t[i].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function Ra(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Da(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function qa(n,e){return n.keys=e,n}function La(n){return n&&n.sensitive?"":"i"}function Na(n,e,t){Sa(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",s=0;s<n.length;s++){var i=n[s];if("string"==typeof i)a+=Ra(i);else{var l=Ra(i.prefix),c="(?:"+i.pattern+")";e.push(i),i.repeat&&(c+="(?:"+l+c+")*"),a+=c=i.optional?i.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Ra(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+u+"|$)",qa(new RegExp("^"+a,La(t)),e)}function Ba(n,e,t){return Sa(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return qa(n,e)}(n,e):Sa(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(Ba(n[o],e,t).source);return qa(new RegExp("(?:"+r.join("|")+")",La(t)),e)}(n,e,t):function(n,e,t){return Na(Aa(n,t),e,t)}(n,e,t)}_a.parse=Ia,_a.compile=Pa,_a.tokensToFunction=za,_a.tokensToRegExp=Ca;var $a=Object.create(null);function Va(n,e,t){e=e||{};try{var r=$a[n]||($a[n]=_a.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fa(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=ra({},n)).params;return a&&"object"==typeof a&&(o.params=ra({},a)),o}if(!o.path&&o.params&&e){(o=ra({},o))._normalized=!0;var s=ra(ra({},e.params),o.params);if(e.name)o.name=e.name,o.params=s;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;o.path=Va(i,s,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),c=e&&e.path||"/",u=l.path?ja(l.path,c,t||o.append):c,d=function(n,e,t){void 0===e&&(e={});var r,o=t||ua;try{r=o(n||"")}catch(n){r={}}for(var a in e){var s=e[a];r[a]=Array.isArray(s)?s.map(ca):ca(s)}return r}(l.query,o.query,r&&r.options.parseQuery),p=o.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var Ua,Ha=function(){},Ja={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,s=o.route,i=o.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=s.redirectedFrom?ma(null,Fa(s.redirectedFrom),null,t):s;l[h]=ba(r,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(pa,"/").indexOf(e.path.replace(pa,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Ga(n)&&(e.replace?t.replace(a,Ha):t.push(a,Ha))},b={click:Ga};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:s,navigate:v,isActive:l[m],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:i,"aria-current":g};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=ra({},w.data);for(var j in k.on=k.on||{},k.on){var T=k.on[j];j in b&&(k.on[j]=Array.isArray(T)?T:[T])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=v;var _=w.data.attrs=ra({},w.data.attrs);_.href=i,_["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ga(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wa="undefined"!=typeof window;function Xa(n,e,t,r,o){var a=e||[],s=t||Object.create(null),i=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,s){var i=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ta(e.path+"/"+n)}(i,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var d={path:u,regex:Ka(u,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:s,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=s?Ta(s+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var p=Array.isArray(o.alias)?o.alias:[o.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:o.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,s,i,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:s,nameMap:i}}function Ka(n,e){return _a(n,[],e)}function Za(n,e){var t=Xa(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function s(n,t,s){var i=Fa(n,t,!1,e),c=i.name;if(c){var u=a[c];if(!u)return l(null,i);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in i.params)&&d.indexOf(p)>-1&&(i.params[p]=t.params[p]);return i.path=Va(u.path,i.params),l(u,i,s)}if(i.path){i.params={};for(var m=0;m<r.length;m++){var h=r[m],f=o[h];if(Ya(f.regex,i.path,i.params))return l(f,i,s)}}return l(null,i)}function i(n,t){var r=n.redirect,o="function"==typeof r?r(ma(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var i=o,c=i.name,u=i.path,d=t.query,p=t.hash,m=t.params;if(d=i.hasOwnProperty("query")?i.query:d,p=i.hasOwnProperty("hash")?i.hash:p,m=i.hasOwnProperty("params")?i.params:m,c){a[c];return s({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var h=function(n,e){return ja(n,e.parent?e.parent.path:"/",!0)}(u,n);return s({_normalized:!0,path:Va(h,m),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?i(n,r||t):n&&n.matchAs?function(n,e,t){var r=s({_normalized:!0,path:Va(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):ma(n,t,r,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Xa([e||n],r,o,a,t),t&&t.alias.length&&Xa(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Xa(n,r,o,a)}}}function Ya(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var s=n.keys[o-1];s&&(t[s.name||"pathMatch"]="string"==typeof r[o]?la(r[o]):r[o])}return!0}var Qa=Wa&&window.performance&&window.performance.now?window.performance:Date;function ns(){return Qa.now().toFixed(3)}var es=ns();function ts(){return es}function rs(n){return es=n}var os=Object.create(null);function as(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ra({},window.history.state);return t.key=ts(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ls),function(){window.removeEventListener("popstate",ls)}}function ss(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=ts();if(n)return os[n]}(),s=o.call(n,e,t,r?a:null);s&&("function"==typeof s.then?s.then((function(n){ms(n,a)})).catch((function(n){0})):ms(s,a))}))}}function is(){var n=ts();n&&(os[n]={x:window.pageXOffset,y:window.pageYOffset})}function ls(n){is(),n.state&&n.state.key&&rs(n.state.key)}function cs(n){return ds(n.x)||ds(n.y)}function us(n){return{x:ds(n.x)?n.x:window.pageXOffset,y:ds(n.y)?n.y:window.pageYOffset}}function ds(n){return"number"==typeof n}var ps=/^#\d/;function ms(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=ps.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:ds((t=a).x)?t.x:0,y:ds(t.y)?t.y:0})}else cs(n)&&(e=us(n))}else r&&cs(n)&&(e=us(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var hs,fs=Wa&&((-1===(hs=window.navigator.userAgent).indexOf("Android 2.")&&-1===hs.indexOf("Android 4.0")||-1===hs.indexOf("Mobile Safari")||-1!==hs.indexOf("Chrome")||-1!==hs.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gs(n,e){is();var t=window.history;try{if(e){var r=ra({},t.state);r.key=ts(),t.replaceState(r,"",n)}else t.pushState({key:rs(ns())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vs(n){gs(n,!0)}var bs={redirected:2,aborted:4,cancelled:8,duplicated:16};function ys(n,e){return ws(n,e,bs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ks.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xs(n,e){return ws(n,e,bs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ws(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var ks=["params","query","hash"];function js(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Ts(n,e){return js(n)&&n._isRouter&&(null==e||n.type===e)}function Ss(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}function _s(n){return function(e,t,r){var o=!1,a=0,s=null;Is(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=Cs((function(e){var o;((o=e).__esModule||zs&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ua.extend(e),t.components[i]=e,--a<=0&&r()})),u=Cs((function(n){var e="Failed to resolve async component "+i+": "+n;s||(s=js(n)?n:new Error(e),r(s))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),o||r()}}function Is(n,e){return Ps(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ps(n){return Array.prototype.concat.apply([],n)}var zs="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Cs(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Es=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=fa,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function As(n,e,t,r){var o=Is(n,(function(n,r,o,a){var s=function(n,e){"function"!=typeof n&&(n=Ua.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,r,o,a)})):t(s,r,o,a)}));return Ps(r?o.reverse():o)}function Ms(n,e){if(e)return function(){return n.apply(e,arguments)}}Es.prototype.listen=function(n){this.cb=n},Es.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Es.prototype.onError=function(n){this.errorCbs.push(n)},Es.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(Ts(n,bs.redirected)&&a===fa||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Es.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,s,i=function(n){!Ts(n)&&js(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(ba(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&ss(this.router,o,n,!1),i(((s=ws(a=o,n,bs.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",s));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,h=[].concat(function(n){return As(n,"beforeRouteLeave",Ms,!0)}(p),this.router.beforeHooks,function(n){return As(n,"beforeRouteUpdate",Ms)}(d),m.map((function(n){return n.beforeEnter})),_s(m)),f=function(e,t){if(r.pending!==n)return i(xs(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),i(function(n,e){return ws(n,e,bs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):js(e)?(r.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(ys(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){i(n)}};Ss(h,f,(function(){Ss(function(n){return As(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return i(xs(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){xa(n)}))}))}))},Es.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Es.prototype.setupListeners=function(){},Es.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=fa,this.pending=null};var Os=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Rs(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=fs&&t;r&&this.listeners.push(as());var o=function(){var t=n.current,o=Rs(n.base);n.current===fa&&o===n._startLocation||n.transitionTo(o,(function(n){r&&ss(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){gs(Ta(r.base+n.fullPath)),ss(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){vs(Ta(r.base+n.fullPath)),ss(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Rs(this.base)!==this.current.fullPath){var e=Ta(this.base+this.current.fullPath);n?gs(e):vs(e)}},e.prototype.getCurrentLocation=function(){return Rs(this.base)},e}(Es);function Rs(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ds=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Rs(n);if(!/^\/#/.test(e))return window.location.replace(Ta(n+"/#"+e)),!0}(this.base)||qs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=fs&&e;t&&this.listeners.push(as());var r=function(){var e=n.current;qs()&&n.transitionTo(Ls(),(function(r){t&&ss(n.router,r,e,!0),fs||$s(r.fullPath)}))},o=fs?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Bs(n.fullPath),ss(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){$s(n.fullPath),ss(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ls()!==e&&(n?Bs(e):$s(e))},e.prototype.getCurrentLocation=function(){return Ls()},e}(Es);function qs(){var n=Ls();return"/"===n.charAt(0)||($s("/"+n),!1)}function Ls(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ns(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bs(n){fs?gs(Ns(n)):window.location.hash=n}function $s(n){fs?vs(Ns(n)):window.location.replace(Ns(n))}var Vs=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Ts(n,bs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Es),Fs=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Za(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!fs&&!1!==n.fallback,this.fallback&&(e="hash"),Wa||(e="abstract"),this.mode=e,e){case"history":this.history=new Os(this,n.base);break;case"hash":this.history=new Ds(this,n.base,this.fallback);break;case"abstract":this.history=new Vs(this,n.base);break;default:0}},Us={currentRoute:{configurable:!0}};Fs.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Us.currentRoute.get=function(){return this.history&&this.history.current},Fs.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Os||t instanceof Ds){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;fs&&o&&"fullPath"in n&&ss(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fs.prototype.beforeEach=function(n){return Js(this.beforeHooks,n)},Fs.prototype.beforeResolve=function(n){return Js(this.resolveHooks,n)},Fs.prototype.afterEach=function(n){return Js(this.afterHooks,n)},Fs.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fs.prototype.onError=function(n){this.history.onError(n)},Fs.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Fs.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fs.prototype.go=function(n){this.history.go(n)},Fs.prototype.back=function(){this.go(-1)},Fs.prototype.forward=function(){this.go(1)},Fs.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fs.prototype.resolve=function(n,e,t){var r=Fa(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},Fs.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fs.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==fa&&this.history.transitionTo(this.history.getCurrentLocation())},Fs.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==fa&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fs.prototype,Us);var Hs=Fs;function Js(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fs.install=function n(e){if(!n.installed||Ua!==e){n.installed=!0,Ua=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",wa),e.component("RouterLink",Ja);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},Fs.version="3.6.5",Fs.isNavigationFailure=Ts,Fs.NavigationFailureType=bs,Fs.START_LOCATION=fa,Wa&&window.Vue&&window.Vue.use(Fs);t(100);t(122),t(89);var Gs={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(23)]).then(t.bind(null,535)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,254)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(44)]).then(t.bind(null,242)),"components/Home":()=>Promise.all([t.e(0),t.e(37)]).then(t.bind(null,286)),"components/NavLink":()=>t.e(52).then(t.bind(null,241)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,266)),"components/Navbar":()=>Promise.all([t.e(0),t.e(1)]).then(t.bind(null,532)),"components/Page":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,287)),"components/PageEdit":()=>Promise.all([t.e(0),t.e(38)]).then(t.bind(null,268)),"components/PageNav":()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,269)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,288)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(45)]).then(t.bind(null,289)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,267)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(41)]).then(t.bind(null,255)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,253)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,540)),"global-components/CodeBlock":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,536)),"global-components/CodeGroup":()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,537)),"layouts/404":()=>t.e(7).then(t.bind(null,538)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(1),t.e(2)]).then(t.bind(null,539)),NotFound:()=>t.e(7).then(t.bind(null,538)),Layout:()=>Promise.all([t.e(0),t.e(1),t.e(2)]).then(t.bind(null,539))},Ws={"v-c1dabb48":()=>t.e(63).then(t.bind(null,541)),"v-1d3fcc5f":()=>t.e(64).then(t.bind(null,542)),"v-a184f442":()=>t.e(66).then(t.bind(null,543)),"v-75ce495f":()=>t.e(65).then(t.bind(null,544)),"v-8bc9b32a":()=>t.e(67).then(t.bind(null,545)),"v-8eba8a22":()=>t.e(68).then(t.bind(null,546)),"v-a9b7d16e":()=>t.e(72).then(t.bind(null,547)),"v-efe7e982":()=>t.e(69).then(t.bind(null,548)),"v-da398842":()=>t.e(73).then(t.bind(null,549)),"v-1901b0ef":()=>t.e(70).then(t.bind(null,550)),"v-7e657abf":()=>t.e(75).then(t.bind(null,551)),"v-b1fb6c42":()=>t.e(77).then(t.bind(null,552)),"v-06da033f":()=>t.e(76).then(t.bind(null,553)),"v-ba589682":()=>t.e(71).then(t.bind(null,554)),"v-401c9622":()=>t.e(74).then(t.bind(null,555)),"v-4d369e5f":()=>t.e(78).then(t.bind(null,556)),"v-97a9a082":()=>t.e(79).then(t.bind(null,557)),"v-0aa58e3f":()=>t.e(20).then(t.bind(null,558)),"v-88916b42":()=>t.e(32).then(t.bind(null,559)),"v-45ab779f":()=>t.e(27).then(t.bind(null,560)),"v-12859882":()=>t.e(21).then(t.bind(null,561)),"v-fe9d3e02":()=>t.e(19).then(t.bind(null,562)),"v-b0622042":()=>t.e(53).then(t.bind(null,563)),"v-723ecb02":()=>t.e(80).then(t.bind(null,564)),"v-31c31d1f":()=>t.e(14).then(t.bind(null,565)),"v-6cc9067f":()=>t.e(25).then(t.bind(null,566)),"v-9a739656":()=>t.e(81).then(t.bind(null,567)),"v-0ea86735":()=>t.e(28).then(t.bind(null,568)),"v-aee874c2":()=>t.e(82).then(t.bind(null,569)),"v-0ba510df":()=>t.e(42).then(t.bind(null,570)),"v-93f09142":()=>t.e(83).then(t.bind(null,571)),"v-73b79b9f":()=>t.e(84).then(t.bind(null,572)),"v-55613da1":()=>t.e(54).then(t.bind(null,573)),"v-0a42a91f":()=>t.e(87).then(t.bind(null,574)),"v-69aa6042":()=>t.e(29).then(t.bind(null,575)),"v-f33b1342":()=>t.e(88).then(t.bind(null,576)),"v-02e836bf":()=>t.e(90).then(t.bind(null,577)),"v-37be6dff":()=>t.e(86).then(t.bind(null,578)),"v-0a94c1c2":()=>t.e(85).then(t.bind(null,579)),"v-69e9675f":()=>t.e(92).then(t.bind(null,580)),"v-5946fd9f":()=>t.e(89).then(t.bind(null,581)),"v-2c5dd41f":()=>t.e(91).then(t.bind(null,582)),"v-627741de":()=>t.e(93).then(t.bind(null,583)),"v-a28862e2":()=>t.e(95).then(t.bind(null,584)),"v-1c0f0a82":()=>t.e(94).then(t.bind(null,585)),"v-5907ba7a":()=>t.e(96).then(t.bind(null,586)),"v-5446e962":()=>t.e(97).then(t.bind(null,587)),"v-1a6af8df":()=>t.e(98).then(t.bind(null,588)),"v-614479ff":()=>t.e(102).then(t.bind(null,589)),"v-4f8373df":()=>t.e(99).then(t.bind(null,590)),"v-9f6e0502":()=>t.e(103).then(t.bind(null,591)),"v-374d8d79":()=>t.e(105).then(t.bind(null,592)),"v-2e1355ed":()=>t.e(100).then(t.bind(null,593)),"v-7d9ab412":()=>t.e(106).then(t.bind(null,594)),"v-31a181ab":()=>t.e(101).then(t.bind(null,595)),"v-6650d0ff":()=>t.e(109).then(t.bind(null,596)),"v-2277ee5f":()=>t.e(104).then(t.bind(null,597)),"v-39158f3f":()=>t.e(107).then(t.bind(null,598)),"v-d8e7da82":()=>t.e(111).then(t.bind(null,599)),"v-7cee71df":()=>t.e(110).then(t.bind(null,600)),"v-abac98c2":()=>t.e(112).then(t.bind(null,601)),"v-51361542":()=>t.e(114).then(t.bind(null,602)),"v-4fb3301f":()=>t.e(108).then(t.bind(null,603)),"v-1ef1807f":()=>t.e(116).then(t.bind(null,604)),"v-7e715702":()=>t.e(113).then(t.bind(null,605)),"v-4cc5601f":()=>t.e(115).then(t.bind(null,606)),"v-389f887d":()=>t.e(117).then(t.bind(null,607)),"v-2e49301f":()=>t.e(118).then(t.bind(null,608)),"v-276555bf":()=>t.e(123).then(t.bind(null,609)),"v-42ba8bff":()=>t.e(119).then(t.bind(null,610)),"v-6611c3b5":()=>t.e(120).then(t.bind(null,611)),"v-18136627":()=>t.e(124).then(t.bind(null,612)),"v-6c3f9039":()=>t.e(121).then(t.bind(null,613)),"v-4444465f":()=>t.e(125).then(t.bind(null,614)),"v-90ff3d02":()=>t.e(122).then(t.bind(null,615)),"v-38e6942a":()=>t.e(127).then(t.bind(null,616)),"v-30a98ff2":()=>t.e(128).then(t.bind(null,617)),"v-f887684e":()=>t.e(129).then(t.bind(null,618)),"v-ce167802":()=>t.e(33).then(t.bind(null,619)),"v-4e92cd47":()=>t.e(126).then(t.bind(null,620)),"v-4d2d4882":()=>t.e(130).then(t.bind(null,621)),"v-3cac1b41":()=>t.e(12).then(t.bind(null,622)),"v-59f34d9f":()=>t.e(22).then(t.bind(null,623)),"v-54d03685":()=>t.e(26).then(t.bind(null,624)),"v-7b5aca02":()=>t.e(46).then(t.bind(null,625)),"v-4a5cdbb2":()=>t.e(133).then(t.bind(null,626)),"v-332a845f":()=>t.e(134).then(t.bind(null,627)),"v-7df093d7":()=>t.e(135).then(t.bind(null,628)),"v-e6f13c42":()=>t.e(131).then(t.bind(null,629)),"v-2fabc2e5":()=>t.e(136).then(t.bind(null,630)),"v-92095dc2":()=>t.e(137).then(t.bind(null,631)),"v-58d22542":()=>t.e(139).then(t.bind(null,632)),"v-6770af3f":()=>t.e(132).then(t.bind(null,633)),"v-756dc182":()=>t.e(138).then(t.bind(null,634)),"v-3c368902":()=>t.e(140).then(t.bind(null,635)),"v-1f9aecc2":()=>t.e(141).then(t.bind(null,636)),"v-2253c17f":()=>t.e(39).then(t.bind(null,637)),"v-02ff5082":()=>t.e(142).then(t.bind(null,638)),"v-394e602d":()=>t.e(143).then(t.bind(null,639)),"v-59238a45":()=>t.e(47).then(t.bind(null,640)),"v-fbf0dec2":()=>t.e(48).then(t.bind(null,641)),"v-36417e3f":()=>t.e(55).then(t.bind(null,642)),"v-1ab45bbf":()=>t.e(49).then(t.bind(null,643)),"v-cae08c22":()=>t.e(50).then(t.bind(null,644)),"v-12faf143":()=>t.e(144).then(t.bind(null,645)),"v-96cebf82":()=>t.e(34).then(t.bind(null,646)),"v-1a9ac042":()=>t.e(146).then(t.bind(null,647)),"v-207c297e":()=>t.e(145).then(t.bind(null,648)),"v-488d7642":()=>t.e(149).then(t.bind(null,649)),"v-ec255d82":()=>t.e(56).then(t.bind(null,650)),"v-8f73d49e":()=>t.e(148).then(t.bind(null,651)),"v-fdfdbb42":()=>t.e(150).then(t.bind(null,652)),"v-fa561802":()=>t.e(147).then(t.bind(null,653)),"v-140d9f9f":()=>t.e(153).then(t.bind(null,654)),"v-b9f651c2":()=>t.e(151).then(t.bind(null,655)),"v-c4186e42":()=>t.e(43).then(t.bind(null,656)),"v-28afe8df":()=>t.e(152).then(t.bind(null,657)),"v-4e5f06df":()=>t.e(154).then(t.bind(null,658)),"v-f77072e6":()=>t.e(155).then(t.bind(null,659)),"v-4dfcdb42":()=>t.e(156).then(t.bind(null,660)),"v-57f44261":()=>t.e(13).then(t.bind(null,661)),"v-d382ca42":()=>t.e(157).then(t.bind(null,662)),"v-0913acae":()=>t.e(158).then(t.bind(null,663)),"v-3fa254c2":()=>t.e(15).then(t.bind(null,664)),"v-608ca1ba":()=>t.e(11).then(t.bind(null,665)),"v-36664eb2":()=>t.e(159).then(t.bind(null,666)),"v-3cf55a6b":()=>t.e(160).then(t.bind(null,667)),"v-686968dd":()=>t.e(35).then(t.bind(null,668)),"v-31f17df6":()=>t.e(162).then(t.bind(null,669)),"v-4871443f":()=>t.e(36).then(t.bind(null,670)),"v-56cbc582":()=>t.e(16).then(t.bind(null,671)),"v-b22ada6e":()=>t.e(57).then(t.bind(null,672)),"v-52235c03":()=>t.e(163).then(t.bind(null,673)),"v-979acdda":()=>t.e(58).then(t.bind(null,674)),"v-5e39087f":()=>t.e(59).then(t.bind(null,675)),"v-12ea54df":()=>t.e(161).then(t.bind(null,676)),"v-66d04f5f":()=>t.e(60).then(t.bind(null,677)),"v-1397f439":()=>t.e(164).then(t.bind(null,678)),"v-70043cdf":()=>t.e(30).then(t.bind(null,679)),"v-d9099882":()=>t.e(165).then(t.bind(null,680)),"v-5f89be0a":()=>t.e(62).then(t.bind(null,681)),"v-1d8b151f":()=>t.e(166).then(t.bind(null,682)),"v-545d6c55":()=>t.e(61).then(t.bind(null,683)),"v-be252d12":()=>t.e(168).then(t.bind(null,684)),"v-eb77cf16":()=>t.e(169).then(t.bind(null,685)),"v-739ac773":()=>t.e(170).then(t.bind(null,686)),"v-9d022a42":()=>t.e(167).then(t.bind(null,687)),"v-2df2cd1f":()=>t.e(171).then(t.bind(null,688)),"v-d2732a66":()=>t.e(51).then(t.bind(null,689)),"v-3b654611":()=>t.e(173).then(t.bind(null,690)),"v-7a32bc31":()=>t.e(172).then(t.bind(null,691)),"v-6ee223b1":()=>t.e(176).then(t.bind(null,692)),"v-11c69222":()=>t.e(177).then(t.bind(null,693)),"v-3cfb1de5":()=>t.e(40).then(t.bind(null,694)),"v-f35fd416":()=>t.e(178).then(t.bind(null,695)),"v-1213428e":()=>t.e(174).then(t.bind(null,696)),"v-32b0df1a":()=>t.e(175).then(t.bind(null,697)),"v-81716842":()=>t.e(182).then(t.bind(null,698)),"v-73ff258f":()=>t.e(179).then(t.bind(null,699)),"v-652b741f":()=>t.e(181).then(t.bind(null,700)),"v-5f833423":()=>t.e(180).then(t.bind(null,701)),"v-7338b94a":()=>t.e(184).then(t.bind(null,702)),"v-7a5510c6":()=>t.e(183).then(t.bind(null,703)),"v-6c1c61ce":()=>t.e(185).then(t.bind(null,704)),"v-65000a52":()=>t.e(186).then(t.bind(null,705))};function Xs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ks=/-(\w)/g,Zs=Xs(n=>n.replace(Ks,(n,e)=>e?e.toUpperCase():"")),Ys=/\B([A-Z])/g,Qs=Xs(n=>n.replace(Ys,"-$1").toLowerCase()),ni=Xs(n=>n.charAt(0).toUpperCase()+n.slice(1));function ei(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ni(Zs(e))):n(ni(e))||n(Qs(e))}const ti=Object.assign({},Gs,Ws),ri=n=>ti[n],oi=n=>Ws[n],ai=n=>Gs[n],si=n=>Gt.component(n);function ii(n){return ei(oi,n)}function li(n){return ei(ai,n)}function ci(n){return ei(ri,n)}function ui(n){return ei(si,n)}function di(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ui(n)&&ci(n)){const e=await ci(n)();Gt.component(n,e.default)}}))}function pi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var mi=t(86),hi=t.n(mi),fi=t(87),gi=t.n(fi),vi={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gi()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=yi(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xi(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hi()([{name:"description",content:this.$description}],n,this.siteMeta,wi)},updateCanonicalLink(){bi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",yi(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xi(null,this.currentMetaTags),bi()}};function bi(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function yi(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xi(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function wi(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ki=t(88),ji={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ki)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],s=e[n+1],i=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(i&&l!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ti=t(22),Si=t.n(Ti),_i=[vi,ji,{mounted(){Si.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||Si.a.start(),t()}),this.$router.afterEach(()=>{Si.a.done(),this.isSidebarOpen=!1})}}],Ii={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return pi("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Pi=t(14),zi=Object(Pi.a)(Ii,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(zi,"mixins",_i);const Ci=[{name:"v-c1dabb48",path:"/",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-c1dabb48").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-1d3fcc5f",path:"/algorithm/array.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1d3fcc5f").then(t)}},{name:"v-a184f442",path:"/algorithm/dynamic.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-a184f442").then(t)}},{name:"v-75ce495f",path:"/algorithm/dfs-bfs.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-75ce495f").then(t)}},{name:"v-8bc9b32a",path:"/algorithm/greedy.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-8bc9b32a").then(t)}},{name:"v-8eba8a22",path:"/algorithm/list.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-8eba8a22").then(t)}},{name:"v-a9b7d16e",path:"/algorithm/string.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-a9b7d16e").then(t)}},{name:"v-efe7e982",path:"/algorithm/scene.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-efe7e982").then(t)}},{name:"v-da398842",path:"/algorithm/trace.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-da398842").then(t)}},{name:"v-1901b0ef",path:"/algorithm/sort.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1901b0ef").then(t)}},{name:"v-7e657abf",path:"/algorithm/two-pointer.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7e657abf").then(t)}},{name:"v-b1fb6c42",path:"/blockchain/ethersjs.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-b1fb6c42").then(t)}},{name:"v-06da033f",path:"/blockchain/base.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-06da033f").then(t)}},{name:"v-ba589682",path:"/algorithm/stack.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-ba589682").then(t)}},{name:"v-401c9622",path:"/algorithm/tree.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-401c9622").then(t)}},{name:"v-4d369e5f",path:"/blockchain/info.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4d369e5f").then(t)}},{name:"v-97a9a082",path:"/blockchain/js.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-97a9a082").then(t)}},{name:"v-0aa58e3f",path:"/blockchain/learn1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0aa58e3f").then(t)}},{name:"v-88916b42",path:"/blockchain/learn4.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-88916b42").then(t)}},{name:"v-45ab779f",path:"/blockchain/learn2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-45ab779f").then(t)}},{name:"v-12859882",path:"/blockchain/learn5.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-12859882").then(t)}},{name:"v-fe9d3e02",path:"/blockchain/learn3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-fe9d3e02").then(t)}},{name:"v-b0622042",path:"/blockchain/learn8.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-b0622042").then(t)}},{name:"v-723ecb02",path:"/book/http.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-723ecb02").then(t)}},{name:"v-31c31d1f",path:"/blockchain/learn6.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-31c31d1f").then(t)}},{name:"v-6cc9067f",path:"/blockchain/learn7.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6cc9067f").then(t)}},{name:"v-9a739656",path:"/chrome/cross.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-9a739656").then(t)}},{name:"v-0ea86735",path:"/chrome/performance.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0ea86735").then(t)}},{name:"v-aee874c2",path:"/chrome/gc.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-aee874c2").then(t)}},{name:"v-0ba510df",path:"/chrome/render.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0ba510df").then(t)}},{name:"v-93f09142",path:"/code-style/code-style.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-93f09142").then(t)}},{name:"v-73b79b9f",path:"/css/bfc.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-73b79b9f").then(t)}},{name:"v-55613da1",path:"/css/flex.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-55613da1").then(t)}},{name:"v-0a42a91f",path:"/css/problem.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0a42a91f").then(t)}},{name:"v-69aa6042",path:"/computer/computer.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-69aa6042").then(t)}},{name:"v-f33b1342",path:"/design-pattern/design-pattern.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-f33b1342").then(t)}},{name:"v-02e836bf",path:"/engineering/commander.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-02e836bf").then(t)}},{name:"v-37be6dff",path:"/css/layout.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-37be6dff").then(t)}},{name:"v-0a94c1c2",path:"/css/box.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0a94c1c2").then(t)}},{name:"v-69e9675f",path:"/engineering/env.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-69e9675f").then(t)}},{name:"v-5946fd9f",path:"/design-pattern/object.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5946fd9f").then(t)}},{name:"v-2c5dd41f",path:"/engineering/engineering.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2c5dd41f").then(t)}},{name:"v-627741de",path:"/engineering/eslint.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-627741de").then(t)}},{name:"v-a28862e2",path:"/engineering/gulp.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-a28862e2").then(t)}},{name:"v-1c0f0a82",path:"/engineering/grunt.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1c0f0a82").then(t)}},{name:"v-5907ba7a",path:"/engineering/rollup.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5907ba7a").then(t)}},{name:"v-5446e962",path:"/engineering/test.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5446e962").then(t)}},{name:"v-1a6af8df",path:"/git/git.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1a6af8df").then(t)}},{name:"v-614479ff",path:"/interview/english.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-614479ff").then(t)}},{name:"v-4f8373df",path:"/interview/algorithm.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4f8373df").then(t)}},{name:"v-9f6e0502",path:"/interview/foreign-company.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-9f6e0502").then(t)}},{name:"v-374d8d79",path:"/interview/interview-10.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-374d8d79").then(t)}},{name:"v-2e1355ed",path:"/interview/code-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2e1355ed").then(t)}},{name:"v-7d9ab412",path:"/interview/interview-11.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7d9ab412").then(t)}},{name:"v-31a181ab",path:"/interview/code-2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-31a181ab").then(t)}},{name:"v-6650d0ff",path:"/interview/interview-4.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6650d0ff").then(t)}},{name:"v-2277ee5f",path:"/interview/interview-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2277ee5f").then(t)}},{name:"v-39158f3f",path:"/interview/interview-2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-39158f3f").then(t)}},{name:"v-d8e7da82",path:"/interview/interview-6.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-d8e7da82").then(t)}},{name:"v-7cee71df",path:"/interview/interview-5.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7cee71df").then(t)}},{name:"v-abac98c2",path:"/interview/interview-7.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-abac98c2").then(t)}},{name:"v-51361542",path:"/interview/interview-9.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-51361542").then(t)}},{name:"v-4fb3301f",path:"/interview/interview-3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4fb3301f").then(t)}},{name:"v-1ef1807f",path:"/interview/iq.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1ef1807f").then(t)}},{name:"v-7e715702",path:"/interview/interview-8.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7e715702").then(t)}},{name:"v-4cc5601f",path:"/interview/interview.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4cc5601f").then(t)}},{name:"v-389f887d",path:"/javascript/ES2017-2022.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-389f887d").then(t)}},{name:"v-2e49301f",path:"/javascript/ES6.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2e49301f").then(t)}},{name:"v-276555bf",path:"/javascript/date.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-276555bf").then(t)}},{name:"v-42ba8bff",path:"/javascript/asynchronous.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-42ba8bff").then(t)}},{name:"v-6611c3b5",path:"/javascript/clone.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6611c3b5").then(t)}},{name:"v-18136627",path:"/javascript/log.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-18136627").then(t)}},{name:"v-6c3f9039",path:"/javascript/closure.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6c3f9039").then(t)}},{name:"v-4444465f",path:"/javascript/number.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4444465f").then(t)}},{name:"v-90ff3d02",path:"/javascript/datatype.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-90ff3d02").then(t)}},{name:"v-38e6942a",path:"/javascript/prototype.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-38e6942a").then(t)}},{name:"v-30a98ff2",path:"/javascript/scope.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-30a98ff2").then(t)}},{name:"v-f887684e",path:"/javascript/stringify.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-f887684e").then(t)}},{name:"v-ce167802",path:"/javascript/function.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-ce167802").then(t)}},{name:"v-4e92cd47",path:"/javascript/parse-order.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4e92cd47").then(t)}},{name:"v-4d2d4882",path:"/javascript/this.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4d2d4882").then(t)}},{name:"v-3cac1b41",path:"/mobile/gc-3d.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3cac1b41").then(t)}},{name:"v-59f34d9f",path:"/mobile/galacean.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-59f34d9f").then(t)}},{name:"v-54d03685",path:"/mobile/cross.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-54d03685").then(t)}},{name:"v-7b5aca02",path:"/mobile/h5.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7b5aca02").then(t)}},{name:"v-4a5cdbb2",path:"/mobile/long-list.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4a5cdbb2").then(t)}},{name:"v-332a845f",path:"/module/module.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-332a845f").then(t)}},{name:"v-7df093d7",path:"/module/webpack.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7df093d7").then(t)}},{name:"v-e6f13c42",path:"/micro/micro.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-e6f13c42").then(t)}},{name:"v-2fabc2e5",path:"/node/express.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2fabc2e5").then(t)}},{name:"v-92095dc2",path:"/node/node-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-92095dc2").then(t)}},{name:"v-58d22542",path:"/node/node-3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-58d22542").then(t)}},{name:"v-6770af3f",path:"/mobile/adaptation.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6770af3f").then(t)}},{name:"v-756dc182",path:"/node/node-2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-756dc182").then(t)}},{name:"v-3c368902",path:"/node/node-4.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3c368902").then(t)}},{name:"v-1f9aecc2",path:"/node/node-5.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1f9aecc2").then(t)}},{name:"v-2253c17f",path:"/node/book.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2253c17f").then(t)}},{name:"v-02ff5082",path:"/node/node-6.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-02ff5082").then(t)}},{name:"v-394e602d",path:"/re/development.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-394e602d").then(t)}},{name:"v-59238a45",path:"/product/abtest.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-59238a45").then(t)}},{name:"v-fbf0dec2",path:"/re/devops.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-fbf0dec2").then(t)}},{name:"v-36417e3f",path:"/re/mongodb.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-36417e3f").then(t)}},{name:"v-1ab45bbf",path:"/re/docker.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1ab45bbf").then(t)}},{name:"v-cae08c22",path:"/re/nginx.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-cae08c22").then(t)}},{name:"v-12faf143",path:"/re/shell.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-12faf143").then(t)}},{name:"v-96cebf82",path:"/react/fiber.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-96cebf82").then(t)}},{name:"v-1a9ac042",path:"/react/react-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1a9ac042").then(t)}},{name:"v-207c297e",path:"/react/diff.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-207c297e").then(t)}},{name:"v-488d7642",path:"/read/read.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-488d7642").then(t)}},{name:"v-ec255d82",path:"/react/redux.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-ec255d82").then(t)}},{name:"v-8f73d49e",path:"/react/time.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-8f73d49e").then(t)}},{name:"v-fdfdbb42",path:"/regular/regular.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-fdfdbb42").then(t)}},{name:"v-fa561802",path:"/react/react-hooks.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-fa561802").then(t)}},{name:"v-140d9f9f",path:"/san/composition.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-140d9f9f").then(t)}},{name:"v-b9f651c2",path:"/route/route.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-b9f651c2").then(t)}},{name:"v-c4186e42",path:"/ssr/ssr.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-c4186e42").then(t)}},{name:"v-28afe8df",path:"/safe/safe.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-28afe8df").then(t)}},{name:"v-4e5f06df",path:"/san/eslint-plugin-san.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4e5f06df").then(t)}},{name:"v-f77072e6",path:"/san/san-loader.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-f77072e6").then(t)}},{name:"v-4dfcdb42",path:"/san/san.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4dfcdb42").then(t)}},{name:"v-57f44261",path:"/three/three2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-57f44261").then(t)}},{name:"v-d382ca42",path:"/time/2021.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-d382ca42").then(t)}},{name:"v-0913acae",path:"/time/2022a.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-0913acae").then(t)}},{name:"v-3fa254c2",path:"/three/three3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3fa254c2").then(t)}},{name:"v-608ca1ba",path:"/three/three1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-608ca1ba").then(t)}},{name:"v-36664eb2",path:"/time/2022b.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-36664eb2").then(t)}},{name:"v-3cf55a6b",path:"/time/2023a.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3cf55a6b").then(t)}},{name:"v-686968dd",path:"/three/three4.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-686968dd").then(t)}},{name:"v-31f17df6",path:"/tool/babel.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-31f17df6").then(t)}},{name:"v-4871443f",path:"/tool/camera.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-4871443f").then(t)}},{name:"v-56cbc582",path:"/tool/debugger.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-56cbc582").then(t)}},{name:"v-b22ada6e",path:"/tool/htmlparser2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-b22ada6e").then(t)}},{name:"v-52235c03",path:"/tool/npm.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-52235c03").then(t)}},{name:"v-979acdda",path:"/tool/postcss.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-979acdda").then(t)}},{name:"v-5e39087f",path:"/tool/yaml.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5e39087f").then(t)}},{name:"v-12ea54df",path:"/time/code.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-12ea54df").then(t)}},{name:"v-66d04f5f",path:"/ts/book.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-66d04f5f").then(t)}},{name:"v-1397f439",path:"/tool/performance.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1397f439").then(t)}},{name:"v-70043cdf",path:"/tool/tool.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-70043cdf").then(t)}},{name:"v-d9099882",path:"/ts/ts-advance.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-d9099882").then(t)}},{name:"v-5f89be0a",path:"/ts/ts-type.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5f89be0a").then(t)}},{name:"v-1d8b151f",path:"/virtual-dom/example.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1d8b151f").then(t)}},{name:"v-545d6c55",path:"/ts/decorator.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-545d6c55").then(t)}},{name:"v-be252d12",path:"/vue/code-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-be252d12").then(t)}},{name:"v-eb77cf16",path:"/vue/code-2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-eb77cf16").then(t)}},{name:"v-739ac773",path:"/vue/code-3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-739ac773").then(t)}},{name:"v-9d022a42",path:"/virtual-dom/virtualdom.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-9d022a42").then(t)}},{name:"v-2df2cd1f",path:"/vue/communication.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-2df2cd1f").then(t)}},{name:"v-d2732a66",path:"/ts/ts-base.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-d2732a66").then(t)}},{name:"v-3b654611",path:"/vue/vite.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3b654611").then(t)}},{name:"v-7a32bc31",path:"/vue/responsive.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7a32bc31").then(t)}},{name:"v-6ee223b1",path:"/vue/vue3.0-2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6ee223b1").then(t)}},{name:"v-11c69222",path:"/vue/vue3.0-3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-11c69222").then(t)}},{name:"v-3cfb1de5",path:"/vue/template.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-3cfb1de5").then(t)}},{name:"v-f35fd416",path:"/vue/vuex.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-f35fd416").then(t)}},{name:"v-1213428e",path:"/vue/vue-router.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-1213428e").then(t)}},{name:"v-32b0df1a",path:"/vue/vue3.0-1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-32b0df1a").then(t)}},{name:"v-81716842",path:"/webpack/webpack1.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-81716842").then(t)}},{name:"v-73ff258f",path:"/webgl/canvas.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-73ff258f").then(t)}},{name:"v-652b741f",path:"/webpack/hmr.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-652b741f").then(t)}},{name:"v-5f833423",path:"/webpack/config.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-5f833423").then(t)}},{name:"v-7338b94a",path:"/webpack/webpack3.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7338b94a").then(t)}},{name:"v-7a5510c6",path:"/webpack/webpack2.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-7a5510c6").then(t)}},{name:"v-6c1c61ce",path:"/webpack/webpack4.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-6c1c61ce").then(t)}},{name:"v-65000a52",path:"/webpack/webpack5.html",component:zi,beforeEnter:(n,e,t)=>{di("Layout","v-65000a52").then(t)}},{path:"*",component:zi}],Ei={title:"Breeze blog",description:"",base:"/myblog/",headTags:[],pages:[{title:"个人简介",frontmatter:{},regularPath:"/",relativePath:"README.md",key:"v-c1dabb48",path:"/",headers:[{level:2,title:"个人简介",slug:"个人简介",normalizedTitle:"个人简介",charIndex:2},{level:2,title:"更新日志",slug:"更新日志",normalizedTitle:"更新日志",charIndex:56}],lastUpdated:"5/23/2025, 5:16:31 PM",lastUpdatedTimestamp:1747991791e3,headersStr:"个人简介 更新日志",content:"# 个人简介\n\n☀️ Breeze\n\n✨ 年龄：27\n\n🔍 毕业院校：BIT\n\n📝 前端开发工程师\n\n\n# 更新日志\n\n * 区块链公开课学习\n\n * 面试准备\n\n * 英语学习",normalizedContent:"# 个人简介\n\n☀️ breeze\n\n✨ 年龄：27\n\n🔍 毕业院校：bit\n\n📝 前端开发工程师\n\n\n# 更新日志\n\n * 区块链公开课学习\n\n * 面试准备\n\n * 英语学习",charsets:{cjk:!0}},{title:"数组操作",frontmatter:{},regularPath:"/algorithm/array.html",relativePath:"algorithm/array.md",key:"v-1d3fcc5f",path:"/algorithm/array.html",headers:[{level:2,title:"合并两个有序数组",slug:"合并两个有序数组",normalizedTitle:"合并两个有序数组",charIndex:11},{level:2,title:"合并区间",slug:"合并区间",normalizedTitle:"合并区间",charIndex:23},{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:31},{level:2,title:"只出现一次的数字",slug:"只出现一次的数字",normalizedTitle:"只出现一次的数字",charIndex:39},{level:2,title:"找到所有数组中消失的数字",slug:"找到所有数组中消失的数字",normalizedTitle:"找到所有数组中消失的数字",charIndex:51},{level:2,title:"两数之和",slug:"两数之和",normalizedTitle:"两数之和",charIndex:67},{level:2,title:"三数之和",slug:"三数之和",normalizedTitle:"三数之和",charIndex:75},{level:2,title:"数字数组去重排序",slug:"数字数组去重排序",normalizedTitle:"数字数组去重排序",charIndex:83},{level:2,title:"删除排序数组中的重复项",slug:"删除排序数组中的重复项",normalizedTitle:"删除排序数组中的重复项",charIndex:95},{level:2,title:"旋转矩阵",slug:"旋转矩阵",normalizedTitle:"旋转矩阵",charIndex:110},{level:2,title:"非递减数列",slug:"非递减数列",normalizedTitle:"非递减数列",charIndex:118},{level:2,title:"顺时针打印矩阵",slug:"顺时针打印矩阵",normalizedTitle:"顺时针打印矩阵",charIndex:127},{level:2,title:"最长湍流子数组",slug:"最长湍流子数组",normalizedTitle:"最长湍流子数组",charIndex:138},{level:2,title:"长度最小子数组(滑动窗口)",slug:"长度最小子数组-滑动窗口",normalizedTitle:"长度最小子数组(滑动窗口)",charIndex:8498},{level:2,title:"寻找两个正序数组的中位数",slug:"寻找两个正序数组的中位数",normalizedTitle:"寻找两个正序数组的中位数",charIndex:160},{level:2,title:"从两个数组中找出共有的元素",slug:"从两个数组中找出共有的元素",normalizedTitle:"从两个数组中找出共有的元素",charIndex:176},{level:2,title:"二分查找（有重复元素）",slug:"二分查找-有重复元素",normalizedTitle:"二分查找（有重复元素）",charIndex:193},{level:2,title:"和为k的子数组",slug:"和为k的子数组",normalizedTitle:"和为k的子数组",charIndex:208}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"合并两个有序数组 合并区间 二分查找 只出现一次的数字 找到所有数组中消失的数字 两数之和 三数之和 数字数组去重排序 删除排序数组中的重复项 旋转矩阵 非递减数列 顺时针打印矩阵 最长湍流子数组 长度最小子数组(滑动窗口) 寻找两个正序数组的中位数 从两个数组中找出共有的元素 二分查找（有重复元素） 和为k的子数组",content:"# 数组操作\n\n * 合并两个有序数组\n * 合并区间\n * 二分查找\n * 只出现一次的数字\n * 找到所有数组中消失的数字\n * 两数之和\n * 三数之和\n * 数字数组去重排序\n * 删除排序数组中的重复项\n * 旋转矩阵\n * 非递减数列\n * 顺时针打印矩阵\n * 最长湍流子数组\n * 长度最小子数组\n * 寻找两个正序数组的中位数\n * 从两个数组中找出共有的元素\n * 二分查找（有重复元素）\n * 和为k的子数组\n\n\n# 合并两个有序数组\n\n * leetcode88\n * 要求：时间复杂度O(m + n)，不需要额外空间\n * 图示\n\nvar merge = function(nums1, m, nums2, n) {\n    let i = m - 1;\n    let j = n - 1;\n    let len = i + j + 1;\n    while (j >= 0) {\n        nums1[len--] = nums1[i] >= nums2[j] ? nums1[i--] : nums2[j--];\n    }\n};\n\n// 参数如果只给了两个普通的数组\nconst merge = (nums1, nums2) => {\n    let i = nums1.length - 1;\n    let j = nums2.length - 1;\n    let len = i + j + 1;\n    nums1 = nums1.concat(new Array(nums2.length).fill(0));\n    while (j >= 0) {\n        nums1[len--] = nums1[i] >= nums2[j] ? nums1[i--] : nums2[j--];\n    }\n    return nums1;\n}\n\n\n\n\n# 合并区间\n\n题目来源：leetcode56\n\n示例 1:\n\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n示例 2:\n输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n\n * 思路\n\n// 1. 先按照 intervals[i][0] 从小到大排序\n// 2. intervals[i][1] >= intervals[i+1][1] 直接取 intervals[i][1] : [1,4] [2,3] 直接取 [1,4]\n// 3. intervals[i][1] >= intervals[i+1][0] 时 intervals[i][1] = intervals[i+1][1] ：[1,4] [3,5] 取 [1,5]  \n// 4. 设置一个 flag，如果此轮合并过，继续合并下一轮  \n\n\n * 个人解法\n\nvar merge = function(intervals) {\n    let flag = true;\n    intervals.sort((a,b) => a[0] - b[0]);\n    while (flag) {\n        flag = false;\n        for (let i = 0; i < intervals.length - 1; i++) {\n            if (intervals[i][1] >= intervals[i + 1][1]) {\n                intervals.splice(i + 1, 1);\n                flag = true;\n            }\n            else if (intervals[i][1] >= intervals[i + 1][0]) {\n                intervals[i][1] = intervals[i + 1][1];\n                intervals.splice(i + 1,1);\n                flag = true;\n            }     \n        }\n    }\n    return intervals;\n};\n\n\n\n# 二分查找\n\n * leetcode704\n\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right) {\n        let mid = Math.floor((left + right)/2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        }\n        else if (nums[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -1;\n};\n\n\n\n# 只出现一次的数字\n\n * leetcode136\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n * 任何数和 0 做异或运算，结果仍然是原来的数，\n * 任何数和其自身做异或运算，结果是 0\n * 异或运算满足交换律和结合律\n\nvar singleNumber = function(nums) {\n    return nums.reduce((pre, item) => pre ^ item, 0)\n};\n\n\n\n# 找到所有数组中消失的数字\n\n * leetcode448\n\n给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例:\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n * 值表示索引\n\nvar findDisappearedNumbers = function(nums) {\n    let arr = [], res = []\n    for (let i = 0; i < nums.length; i++) {\n        arr[nums[i]-1] = 1\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (arr[i] !== 1) {\n            res.push(i+1)\n        } \n    }\n    return res\n};\n\n\n\n# 两数之和\n\n * leetcode1\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\nvar twoSum = function(nums, target) {\n    let map = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target - nums[i])) return [map.get(target - nums[i]), i]\n        map.set(nums[i], i)\n    }\n};\n\n\n\n# 三数之和\n\n * leetcode15\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例：\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n * 双指针讲思路，注意去重\n * 题解\n\nvar threeSum = function(nums) {\n    nums.sort((a, b) => a - b)\n    const res = []\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (nums[i] > 0) break\n        let l = i + 1, r = nums.length - 1\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            while (l < r) {\n                if (nums[i] + nums[l] + nums[r] > 0) r--\n                else if (nums[i] + nums[l] + nums[r] < 0) l++\n                else {\n                    res.push([nums[i], nums[l], nums[r]])\n                    while (l < r && nums[l] == nums[l + 1]) l++\n                    while (l < r && nums[r] == nums[r - 1]) r--\n                    l++, r--\n                }\n            }\n        }\n    }\n    return res\n};\n\n\n\n# 数字数组去重排序\n\n * 用下标表示数字，空间复杂度较高，一般不建议使用\n\nconst arr = [5, 1, 1, 3, 2, 0]\n\nconst foo = (arr) => {\n  const res = []\n  const ans = []\n  for (let i in arr) {\n      res[arr[i]] = 1\n  }\n  for (let i in res) {\n      ans.push(i)\n  }\n  return ans\n}\n\n\n\n# 删除排序数组中的重复项\n\n> 示例 1:\n> \n> 给定数组 nums = [1,1,2],\n> \n> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 (注意只需修改，不需删除)\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n> \n> 示例 2:\n> \n> 给定 nums = [0,0,1,1,1,2,2,3,3,4],\n> \n> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n\n * 遍历一次，不重复的放在数组前几位，时间复杂度O（n)\n\nvar removeDuplicates = function(nums) {\n    let len = 1\n    for(let i = 1; i < nums.length; i++){\n        if(nums[i]!==nums[i-1]) nums[len++] = nums[i]\n    }\n    return len\n};\n\n\n> 给定 nums = [3,2,2,3], val = 3,\n> \n> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n> \n> 给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n> \n> 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n> \n> 注意这五个元素可为任意顺序。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n\nvar removeElement = function(nums, val) {\n    let len = 0\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] !== val) nums[len++] = nums[i]\n    }\n    return len\n};\n\n\n\n# 旋转矩阵\n\n * leetcode48\n\n> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n> \n> 示例 1:\n> \n> 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ],\n> \n> 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ]\n\nvar rotate = function(matrix) { \n    const len = matrix.length;\n    for(let i = 0; i < len; i++){\n        for(let j = 0; j < len; j++){\n            let curr = matrix[i].pop()\n            matrix[len - j - 1].unshift(curr)\n        }\n    }\n};\n\n\n * 具体过程如下：\n\n[ [ 1, 2 ], [ 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 5, 2, 4 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 4, 1 ], [ 5, 2 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 4, 1 ], [ 5, 2 ], [ 9, 6, 3, 7, 8 ] ]\n\n[ [ 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3, 7 ] ]\n\n[ [ 7, 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3 ] ]\n\n\n\n# 非递减数列\n\n * leetcode665\n\n * 题解\n\nvar checkPossibility = function(nums) {\n    let count = 0\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < nums[i-1]) {\n            if (i === 1 || nums[i] >= nums[i-2]) {\n                nums[i-1] = nums[i]\n            } else {\n                nums[i] = nums[i-1]\n            }\n            count ++\n        }\n    }\n    return count <= 1\n};\n\n\n\n# 顺时针打印矩阵\n\n * leetcode54\n * 【手绘图解】两种遍历的策略，看你喜欢哪种\n\n示例 1：\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n示例 2：\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\nvar spiralOrder = function(matrix) {\n    if (!matrix.length) return [];\n    let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1;\n    const res = [];\n    while (right > left && bottom > top) {\n        for (let i = left; i < right; i++) res.push(matrix[top][i]); // 上层\n        for (let i = top; i < bottom; i++) res.push(matrix[i][right]); // 右层\n        for (let i = right; i > left; i--) res.push(matrix[bottom][i]); // 下层\n        for (let i = bottom; i > top; i--) res.push(matrix[i][left]); // 左层\n        // 四个边界同时收缩，进入内层\n        left++;\n        right--;\n        top++;\n        bottom--;\n    }\n    // 剩下一列，从上到下依次添加\n    if (left === right) {\n        for (let i = top; i <= bottom; i++) res.push(matrix[i][left]);\n    }\n    // 剩下一行，从左到右依次添加\n    else if (top === bottom) {\n        for (let i = left; i <= right; i++) res.push(matrix[top][i]);\n    }\n    return res;\n}\n\n\n\n# 最长湍流子数组\n\n * leetcode978\n\n * 题解\n\nvar maxTurbulenceSize = function(arr) {\n    let n = arr.length,\n        maxNum = Number.MIN_SAFE_INTEGER,\n        cur = 1\n    if(n === 1) return 1\n    for(let i = 1; i < n; i++) {\n        if(arr[i] === arr[i-1]) {\n            cur = 1\n        }else if(arr[i] > arr[i-1] && arr[i-2] >= arr[i-1]) {\n            cur++\n        } else if(arr[i] < arr[i-1] && arr[i-2] <= arr[i-1]) {\n            cur++\n        } else {\n            cur = 2\n        }\n        maxNum = Math.max(maxNum, cur)\n    }\n    return maxNum;\n};\n\n\n\n# 长度最小子数组(滑动窗口)\n\n * leetcode209\n * 题解\n\nvar minSubArrayLen = function(s, nums) {\n    const int_max = Number.MAX_SAFE_INTEGER\n    var i = 0, sum = 0, ans = int_max\n    for (var j = 0; j < nums.length; j++) {\n        sum += nums[j]\n        while (sum >= s) {\n            ans = Math.min(ans, j - i + 1)\n            sum -= nums[i++]\n        }\n    }\n    return ans === int_max ? 0 : ans\n};\n\n\n\n# 寻找两个正序数组的中位数\n\n * leetcode4\n\nvar findMedianSortedArrays = function(nums1, nums2) {\n    let i = nums1.length - 1, j = nums2.length - 1\n    nums1 = nums1.concat(new Array(j + 1).fill(0))\n    let k = nums1.length - 1\n    while (j >= 0) {\n        nums1[i] > nums2[j] ? nums1[k--] = nums1[i--] : nums1[k--] = nums2[j--]\n    }\n    if (nums1.length % 2 === 0) {\n        return (nums1[nums1.length / 2] + nums1[nums1.length / 2 - 1]) / 2\n    } else {\n        return nums1[~~(nums1.length / 2)]\n    }\n};\n\n\n\n# 从两个数组中找出共有的元素\n\n// 从两个数组中找出共有的元素。\n// 示例： arr1 = [1,2,3,4]; arr2=[3,4,5,6]\n// intersection(arr1, arr2);\n// output [3,4]\n\nfunction intersection(arr1, arr2) {\n    return arr1.filter(item => arr2.includes(item))\n}\n\nfunction intersection(arr1, arr2) {\n    const map = new Map()\n    const res = []\n    for (const item of arr1) {\n        if (!map.get(item)) {\n            map.set(item, 1)\n        }\n    }\n    for (const item of arr2) {\n        if (map.get(item)) {\n            res.push(item)\n        }\n    }\n    return res\n}\n\n\n\n# 二分查找（有重复元素）\n\n> 一个有序可重复数组，指定target，返回该target在数组中的位置。\n> \n> [1,2,2,3,4,5]\n> \n> 1 => [0]\n> \n> 2 = >[1,2]\n> \n> 10 = > [-1]\n\nfunction search(arr, target) {\n    const res = []\n    let left = 0, right = arr.length - 1\n    while (left <= right) {\n        let mid = (left + right) >> 1\n        if (arr[mid] === target) {\n            res.push(mid)\n            let index1 = index2 = mid\n            while (arr[index1 + 1] === arr[index1]) {\n                res.push(index1 + 1)\n                index1++\n            }\n            while (arr[index2 - 1] === arr[index2]) {\n                res.push(index2 - 1)\n                index2--\n            }\n            break\n        } else if (arr[mid] > target) {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res.length ? res : [-1]\n}\n\n\n\n# 和为k的子数组\n\n * leetcode560\n * 前缀和 + 哈希表\n\n// k = 7\n// 数组：    3, 4, 2,  3,  2\n// 前缀和    3, 7, 9, 12, 14\n// map\n// key   0, 3, 7, 9, 12, 14\n// value 1, 1, 1, 1,  1,  1\n\n// 为什么有个初值{0, 1}，因为第一次要记录[3, 4]的结果，sum - key = 7 - 7 = 0,\n// 而表中是没有0对应的次数的，所以要设置一个初值，用于记录第一个值。\n// 第二次要记录 [2, 3, 2]的结果，sum - key = 14 - 7 = 7\n\nfunction subarraySum(nums, k) {\n  const map = new Map();\n  map.set(0, 1);\n  let count = 0;\n  let currentSum = 0;\n  for (const num of nums) {\n    currentSum += num;\n    if (map.get(currentSum - k)) {\n      count += map.get(currentSum - k);\n    }\n    map.set(currentSum, (map.get(currentSum) || 0) + 1);\n  }\n  return count;\n}\n",normalizedContent:"# 数组操作\n\n * 合并两个有序数组\n * 合并区间\n * 二分查找\n * 只出现一次的数字\n * 找到所有数组中消失的数字\n * 两数之和\n * 三数之和\n * 数字数组去重排序\n * 删除排序数组中的重复项\n * 旋转矩阵\n * 非递减数列\n * 顺时针打印矩阵\n * 最长湍流子数组\n * 长度最小子数组\n * 寻找两个正序数组的中位数\n * 从两个数组中找出共有的元素\n * 二分查找（有重复元素）\n * 和为k的子数组\n\n\n# 合并两个有序数组\n\n * leetcode88\n * 要求：时间复杂度o(m + n)，不需要额外空间\n * 图示\n\nvar merge = function(nums1, m, nums2, n) {\n    let i = m - 1;\n    let j = n - 1;\n    let len = i + j + 1;\n    while (j >= 0) {\n        nums1[len--] = nums1[i] >= nums2[j] ? nums1[i--] : nums2[j--];\n    }\n};\n\n// 参数如果只给了两个普通的数组\nconst merge = (nums1, nums2) => {\n    let i = nums1.length - 1;\n    let j = nums2.length - 1;\n    let len = i + j + 1;\n    nums1 = nums1.concat(new array(nums2.length).fill(0));\n    while (j >= 0) {\n        nums1[len--] = nums1[i] >= nums2[j] ? nums1[i--] : nums2[j--];\n    }\n    return nums1;\n}\n\n\n\n\n# 合并区间\n\n题目来源：leetcode56\n\n示例 1:\n\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n示例 2:\n输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n\n * 思路\n\n// 1. 先按照 intervals[i][0] 从小到大排序\n// 2. intervals[i][1] >= intervals[i+1][1] 直接取 intervals[i][1] : [1,4] [2,3] 直接取 [1,4]\n// 3. intervals[i][1] >= intervals[i+1][0] 时 intervals[i][1] = intervals[i+1][1] ：[1,4] [3,5] 取 [1,5]  \n// 4. 设置一个 flag，如果此轮合并过，继续合并下一轮  \n\n\n * 个人解法\n\nvar merge = function(intervals) {\n    let flag = true;\n    intervals.sort((a,b) => a[0] - b[0]);\n    while (flag) {\n        flag = false;\n        for (let i = 0; i < intervals.length - 1; i++) {\n            if (intervals[i][1] >= intervals[i + 1][1]) {\n                intervals.splice(i + 1, 1);\n                flag = true;\n            }\n            else if (intervals[i][1] >= intervals[i + 1][0]) {\n                intervals[i][1] = intervals[i + 1][1];\n                intervals.splice(i + 1,1);\n                flag = true;\n            }     \n        }\n    }\n    return intervals;\n};\n\n\n\n# 二分查找\n\n * leetcode704\n\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right) {\n        let mid = math.floor((left + right)/2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        }\n        else if (nums[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -1;\n};\n\n\n\n# 只出现一次的数字\n\n * leetcode136\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n\n * 任何数和 0 做异或运算，结果仍然是原来的数，\n * 任何数和其自身做异或运算，结果是 0\n * 异或运算满足交换律和结合律\n\nvar singlenumber = function(nums) {\n    return nums.reduce((pre, item) => pre ^ item, 0)\n};\n\n\n\n# 找到所有数组中消失的数字\n\n * leetcode448\n\n给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为o(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例:\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n * 值表示索引\n\nvar finddisappearednumbers = function(nums) {\n    let arr = [], res = []\n    for (let i = 0; i < nums.length; i++) {\n        arr[nums[i]-1] = 1\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (arr[i] !== 1) {\n            res.push(i+1)\n        } \n    }\n    return res\n};\n\n\n\n# 两数之和\n\n * leetcode1\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\nvar twosum = function(nums, target) {\n    let map = new map()\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target - nums[i])) return [map.get(target - nums[i]), i]\n        map.set(nums[i], i)\n    }\n};\n\n\n\n# 三数之和\n\n * leetcode15\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例：\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n * 双指针讲思路，注意去重\n * 题解\n\nvar threesum = function(nums) {\n    nums.sort((a, b) => a - b)\n    const res = []\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (nums[i] > 0) break\n        let l = i + 1, r = nums.length - 1\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            while (l < r) {\n                if (nums[i] + nums[l] + nums[r] > 0) r--\n                else if (nums[i] + nums[l] + nums[r] < 0) l++\n                else {\n                    res.push([nums[i], nums[l], nums[r]])\n                    while (l < r && nums[l] == nums[l + 1]) l++\n                    while (l < r && nums[r] == nums[r - 1]) r--\n                    l++, r--\n                }\n            }\n        }\n    }\n    return res\n};\n\n\n\n# 数字数组去重排序\n\n * 用下标表示数字，空间复杂度较高，一般不建议使用\n\nconst arr = [5, 1, 1, 3, 2, 0]\n\nconst foo = (arr) => {\n  const res = []\n  const ans = []\n  for (let i in arr) {\n      res[arr[i]] = 1\n  }\n  for (let i in res) {\n      ans.push(i)\n  }\n  return ans\n}\n\n\n\n# 删除排序数组中的重复项\n\n> 示例 1:\n> \n> 给定数组 nums = [1,1,2],\n> \n> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 (注意只需修改，不需删除)\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n> \n> 示例 2:\n> \n> 给定 nums = [0,0,1,1,1,2,2,3,3,4],\n> \n> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n\n * 遍历一次，不重复的放在数组前几位，时间复杂度o（n)\n\nvar removeduplicates = function(nums) {\n    let len = 1\n    for(let i = 1; i < nums.length; i++){\n        if(nums[i]!==nums[i-1]) nums[len++] = nums[i]\n    }\n    return len\n};\n\n\n> 给定 nums = [3,2,2,3], val = 3,\n> \n> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n> \n> 给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n> \n> 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n> \n> 注意这五个元素可为任意顺序。\n> \n> 你不需要考虑数组中超出新长度后面的元素。\n\nvar removeelement = function(nums, val) {\n    let len = 0\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] !== val) nums[len++] = nums[i]\n    }\n    return len\n};\n\n\n\n# 旋转矩阵\n\n * leetcode48\n\n> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n> \n> 示例 1:\n> \n> 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ],\n> \n> 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ]\n\nvar rotate = function(matrix) { \n    const len = matrix.length;\n    for(let i = 0; i < len; i++){\n        for(let j = 0; j < len; j++){\n            let curr = matrix[i].pop()\n            matrix[len - j - 1].unshift(curr)\n        }\n    }\n};\n\n\n * 具体过程如下：\n\n[ [ 1, 2 ], [ 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 2, 4, 5 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 1 ], [ 5, 2, 4 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 4, 1 ], [ 5, 2 ], [ 6, 3, 7, 8, 9 ] ]\n\n[ [ 4, 1 ], [ 5, 2 ], [ 9, 6, 3, 7, 8 ] ]\n\n[ [ 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3, 7 ] ]\n\n[ [ 7, 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3 ] ]\n\n\n\n# 非递减数列\n\n * leetcode665\n\n * 题解\n\nvar checkpossibility = function(nums) {\n    let count = 0\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < nums[i-1]) {\n            if (i === 1 || nums[i] >= nums[i-2]) {\n                nums[i-1] = nums[i]\n            } else {\n                nums[i] = nums[i-1]\n            }\n            count ++\n        }\n    }\n    return count <= 1\n};\n\n\n\n# 顺时针打印矩阵\n\n * leetcode54\n * 【手绘图解】两种遍历的策略，看你喜欢哪种\n\n示例 1：\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n\n示例 2：\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n\nvar spiralorder = function(matrix) {\n    if (!matrix.length) return [];\n    let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1;\n    const res = [];\n    while (right > left && bottom > top) {\n        for (let i = left; i < right; i++) res.push(matrix[top][i]); // 上层\n        for (let i = top; i < bottom; i++) res.push(matrix[i][right]); // 右层\n        for (let i = right; i > left; i--) res.push(matrix[bottom][i]); // 下层\n        for (let i = bottom; i > top; i--) res.push(matrix[i][left]); // 左层\n        // 四个边界同时收缩，进入内层\n        left++;\n        right--;\n        top++;\n        bottom--;\n    }\n    // 剩下一列，从上到下依次添加\n    if (left === right) {\n        for (let i = top; i <= bottom; i++) res.push(matrix[i][left]);\n    }\n    // 剩下一行，从左到右依次添加\n    else if (top === bottom) {\n        for (let i = left; i <= right; i++) res.push(matrix[top][i]);\n    }\n    return res;\n}\n\n\n\n# 最长湍流子数组\n\n * leetcode978\n\n * 题解\n\nvar maxturbulencesize = function(arr) {\n    let n = arr.length,\n        maxnum = number.min_safe_integer,\n        cur = 1\n    if(n === 1) return 1\n    for(let i = 1; i < n; i++) {\n        if(arr[i] === arr[i-1]) {\n            cur = 1\n        }else if(arr[i] > arr[i-1] && arr[i-2] >= arr[i-1]) {\n            cur++\n        } else if(arr[i] < arr[i-1] && arr[i-2] <= arr[i-1]) {\n            cur++\n        } else {\n            cur = 2\n        }\n        maxnum = math.max(maxnum, cur)\n    }\n    return maxnum;\n};\n\n\n\n# 长度最小子数组(滑动窗口)\n\n * leetcode209\n * 题解\n\nvar minsubarraylen = function(s, nums) {\n    const int_max = number.max_safe_integer\n    var i = 0, sum = 0, ans = int_max\n    for (var j = 0; j < nums.length; j++) {\n        sum += nums[j]\n        while (sum >= s) {\n            ans = math.min(ans, j - i + 1)\n            sum -= nums[i++]\n        }\n    }\n    return ans === int_max ? 0 : ans\n};\n\n\n\n# 寻找两个正序数组的中位数\n\n * leetcode4\n\nvar findmediansortedarrays = function(nums1, nums2) {\n    let i = nums1.length - 1, j = nums2.length - 1\n    nums1 = nums1.concat(new array(j + 1).fill(0))\n    let k = nums1.length - 1\n    while (j >= 0) {\n        nums1[i] > nums2[j] ? nums1[k--] = nums1[i--] : nums1[k--] = nums2[j--]\n    }\n    if (nums1.length % 2 === 0) {\n        return (nums1[nums1.length / 2] + nums1[nums1.length / 2 - 1]) / 2\n    } else {\n        return nums1[~~(nums1.length / 2)]\n    }\n};\n\n\n\n# 从两个数组中找出共有的元素\n\n// 从两个数组中找出共有的元素。\n// 示例： arr1 = [1,2,3,4]; arr2=[3,4,5,6]\n// intersection(arr1, arr2);\n// output [3,4]\n\nfunction intersection(arr1, arr2) {\n    return arr1.filter(item => arr2.includes(item))\n}\n\nfunction intersection(arr1, arr2) {\n    const map = new map()\n    const res = []\n    for (const item of arr1) {\n        if (!map.get(item)) {\n            map.set(item, 1)\n        }\n    }\n    for (const item of arr2) {\n        if (map.get(item)) {\n            res.push(item)\n        }\n    }\n    return res\n}\n\n\n\n# 二分查找（有重复元素）\n\n> 一个有序可重复数组，指定target，返回该target在数组中的位置。\n> \n> [1,2,2,3,4,5]\n> \n> 1 => [0]\n> \n> 2 = >[1,2]\n> \n> 10 = > [-1]\n\nfunction search(arr, target) {\n    const res = []\n    let left = 0, right = arr.length - 1\n    while (left <= right) {\n        let mid = (left + right) >> 1\n        if (arr[mid] === target) {\n            res.push(mid)\n            let index1 = index2 = mid\n            while (arr[index1 + 1] === arr[index1]) {\n                res.push(index1 + 1)\n                index1++\n            }\n            while (arr[index2 - 1] === arr[index2]) {\n                res.push(index2 - 1)\n                index2--\n            }\n            break\n        } else if (arr[mid] > target) {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res.length ? res : [-1]\n}\n\n\n\n# 和为k的子数组\n\n * leetcode560\n * 前缀和 + 哈希表\n\n// k = 7\n// 数组：    3, 4, 2,  3,  2\n// 前缀和    3, 7, 9, 12, 14\n// map\n// key   0, 3, 7, 9, 12, 14\n// value 1, 1, 1, 1,  1,  1\n\n// 为什么有个初值{0, 1}，因为第一次要记录[3, 4]的结果，sum - key = 7 - 7 = 0,\n// 而表中是没有0对应的次数的，所以要设置一个初值，用于记录第一个值。\n// 第二次要记录 [2, 3, 2]的结果，sum - key = 14 - 7 = 7\n\nfunction subarraysum(nums, k) {\n  const map = new map();\n  map.set(0, 1);\n  let count = 0;\n  let currentsum = 0;\n  for (const num of nums) {\n    currentsum += num;\n    if (map.get(currentsum - k)) {\n      count += map.get(currentsum - k);\n    }\n    map.set(currentsum, (map.get(currentsum) || 0) + 1);\n  }\n  return count;\n}\n",charsets:{cjk:!0}},{title:"动态规划",frontmatter:{title:"动态规划",date:"2020-11-16T16:01:54.000Z",categories:"算法"},regularPath:"/algorithm/dynamic.html",relativePath:"algorithm/dynamic.md",key:"v-a184f442",path:"/algorithm/dynamic.html",headers:[{level:2,title:"动态规划与贪心的区别",slug:"动态规划与贪心的区别",normalizedTitle:"动态规划与贪心的区别",charIndex:208},{level:2,title:"爬楼梯",slug:"爬楼梯",normalizedTitle:"爬楼梯",charIndex:11},{level:2,title:"零钱兑换",slug:"零钱兑换",normalizedTitle:"零钱兑换",charIndex:18},{level:2,title:"最大子序列和（连续）",slug:"最大子序列和-连续",normalizedTitle:"最大子序列和（连续）",charIndex:1950},{level:2,title:"打家劫舍（非连续）",slug:"打家劫舍-非连续",normalizedTitle:"打家劫舍（非连续）",charIndex:3626},{level:2,title:"最长非重复子串",slug:"最长非重复子串",normalizedTitle:"最长非重复子串",charIndex:36},{level:2,title:"最长重复子数组",slug:"最长重复子数组",normalizedTitle:"最长重复子数组",charIndex:47},{level:2,title:"最长递增子序列",slug:"最长递增子序列",normalizedTitle:"最长递增子序列",charIndex:58},{level:2,title:"最长公共子序列(LCS)",slug:"最长公共子序列-lcs",normalizedTitle:"最长公共子序列(lcs)",charIndex:6717},{level:2,title:"编辑距离(SES)",slug:"编辑距离-ses",normalizedTitle:"编辑距离(ses)",charIndex:7900},{level:2,title:"LCS和SES的关系",slug:"lcs和ses的关系",normalizedTitle:"lcs和ses的关系",charIndex:9349},{level:2,title:"最长回文子串",slug:"最长回文子串",normalizedTitle:"最长回文子串",charIndex:88},{level:2,title:"不同路径",slug:"不同路径",normalizedTitle:"不同路径",charIndex:98},{level:2,title:"最小路径和",slug:"最小路径和",normalizedTitle:"最小路径和",charIndex:106},{level:2,title:"正则表达式匹配",slug:"正则表达式匹配",normalizedTitle:"正则表达式匹配",charIndex:115},{level:2,title:"分割等和子集",slug:"分割等和子集",normalizedTitle:"分割等和子集",charIndex:126},{level:2,title:"三角形的最小路径和",slug:"三角形的最小路径和",normalizedTitle:"三角形的最小路径和",charIndex:136},{level:2,title:"买卖股票的最佳时机",slug:"买卖股票的最佳时机",normalizedTitle:"买卖股票的最佳时机",charIndex:149},{level:2,title:"买卖股票的最佳时机ii（多次交易）",slug:"买卖股票的最佳时机ii-多次交易",normalizedTitle:"买卖股票的最佳时机ii（多次交易）",charIndex:15753},{level:2,title:"买卖股票的最佳时机iii（含冷冻期）",slug:"买卖股票的最佳时机iii-含冷冻期",normalizedTitle:"买卖股票的最佳时机iii（含冷冻期）",charIndex:16432}],lastUpdated:"4/6/2023, 7:10:18 PM",lastUpdatedTimestamp:1680779418e3,headersStr:"动态规划与贪心的区别 爬楼梯 零钱兑换 最大子序列和（连续） 打家劫舍（非连续） 最长非重复子串 最长重复子数组 最长递增子序列 最长公共子序列(LCS) 编辑距离(SES) LCS和SES的关系 最长回文子串 不同路径 最小路径和 正则表达式匹配 分割等和子集 三角形的最小路径和 买卖股票的最佳时机 买卖股票的最佳时机ii（多次交易） 买卖股票的最佳时机iii（含冷冻期）",content:'# 动态规划\n\n * 爬楼梯\n * 零钱兑换\n * 最大子序列和\n * 最长非重复子串\n * 最长重复子数组\n * 最长递增子序列\n * 最长公共子序列\n * 编辑距离\n * 最长回文子串\n * 不同路径\n * 最小路径和\n * 正则表达式匹配\n * 分割等和子集\n * 三角形的最小路径和\n * 买卖股票的最佳时机i/ii/iii\n * 打家劫舍\n\n> 动态规划的三个概念：最优子结构，边界，状态转移方程\n\n\n# 动态规划与贪心的区别\n\n> 贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。 贪心是求局部最优，以得到全局最优（不一定是正确的，需要证明）\n> \n> 比如某国的钱币分为1元3元4元，如果要拿6元钱怎么拿？贪心的话先拿4再拿两个1，一共3张钱，而实际最优其实是两张3元（类似于背包问题，需要考虑物品个数）\n> \n> 动态规划算法中，全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解\n\n动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。 区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。\n\n\n# 爬楼梯\n\n * leetcode70\n\n有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。\n\n\n * 思考：如果只差最后一步就走到第 10 级，此时分为两种：从第 9 级到 10 级，从第 8 级到 10 级\n * 0 到 9 级的走法有 x，0 到 8 级的走法有 y 种，那么 0 到 10 级的走法一共有 x+y\n * F(10) = F(9) + F(8)，F(8) = F(8) + F(7)\n * F(9) 和 F(8) 是 F(10) 的最优子结构\n * 边界是 F(1) 和 F(2)\n * 状态转移方程是 F(n) = F(n-1) + F(n-2)\n\nvar climbStairs = function(n) {\n    let dp = new Array(n + 1).fill(0)\n    dp[1] = 1\n    dp[2] = 2\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n};\n\n\n\n# 零钱兑换\n\n * leetcode322\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n你可以认为每种硬币的数量是无限的。\n\n示例 1：\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n\n示例 2：\n输入：coins = [2], amount = 3\n输出：-1\n\n\n * 设dp[i] 表示总金额为 i 的时候最优解法的硬币数\n * 若面值有1，2，5要凑够120元，此时可以拿一枚面值为1的，最优个数为 dp[119] + 1，拿一枚面试为2的，最优个数为dp[118] + 1，拿一枚面值为5的，最优个数为dp[115] + 1，取三种的最小值即可\n * 状态转移方程：dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)\n * 边界：dp[0] = 0\n\nconst coinChange = (coins, amount) => {\n  \tlet dp = new Array( amount + 1 ).fill( Infinity );\n    dp[0] = 0;\n    for (let i = 1; i <= amount; i++) {\n        for (let coin of coins) {\n            if (i - coin >= 0) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n\n\n# 最大子序列和（连续）\n\n * leetcode53\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n * 分析：答案肯定是在以下组合中：\n * 第一个子组合是以第一个数字结尾的连续序列，也就是[-2]，最大值-2\n * 第二个子组合是以第二个数字结尾的连续序列，也就是[-2,1], [1]，最大值1\n * 第三个子组合是以第三个数字结尾的连续序列，也就是[-2,1,-3], [1,-3], [-3]，最大值-2\n * 第四个子组合是以第四个数字结尾的连续序列，也就是[-2,1,-3,4],[1.-3,4],[-3,4],[4]，最大值4\n * 第n个子组合......\n\n----------------------------------------\n\n * 最优子结构：组合 n 只是在组合 n-1 的基础上每一个数组后面添加 1 个数字 num，然后增加一个只有第 n 个数字的数组[num]，只需要比较前一个组合的最大值 + num 和 num\n * 边界：dp[0] = nums[0]\n * 状态转移方程：dp[i] = max(dp[i-1] + nums[i], nums[i]) 或者 dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i]\n\n// 组合3只是在组合2的基础上每一个数组后面添加第3个数字，也就是3，然后增加一个只有第三个数字的数组[3]\n// 只需要比较前一个组合的最大值+num和num\n// 计算出九个组合的最大值，再取最大的即可\n\nvar maxSubArray = function(nums) {\n    const dp = new Array(nums.length).fill(0);\n    dp[0] = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);\n    }\n    return Math.max(...dp);\n};\n\n\n怎么求对应的数组呢？相比于上题，应该存储起始和结束的索引。\n\nvar maxSubArray = function(nums) {\n    const len = nums.length\n    const dp = new Array(len).fill(0)\n    let start = end = 0\n    let finalStart = finalEnd = 0\n    let max = dp[0] = nums[0]\n    for (let i = 1; i < len; i++) {\n        if (dp[i - 1] > 0) {\n            dp[i] = dp[i - 1] + nums[i]\n            end = i\n        } else {\n            dp[i] = nums[i]\n            start = end = i\n        }\n        if (dp[i] > max) {\n            max = dp[i]\n            finalStart = start\n            finalEnd = end\n        }\n    }\n    return nums.slice(finalStart, finalEnd + 1)\n};\n\nconsole.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))\n// [4,-1,2,1]\n\n\n\n# 打家劫舍（非连续）\n\n * leetcode198\n * 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值\n * 状态转移方程：dp[n] = max( dp[n-1], dp[n-2] + num )\n * 举例来说：[3,4,2]，1 号房间可盗窃最大值为 3， 即为 dp[1]=3，2 号房间可盗窃最大值为 4， 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = 5，3 号房间可盗窃最大值为 5\n * 时间复杂度：O(n)\n\nvar rob = function(nums) {\n    const dp = new Array(nums.length).fill(0);\n  \n  \t// 初始化好前两个状态\n    dp[0] = nums[0];\n    dp[1] = nums[1] > nums[0] ? nums[1] : nums[0];\n\n    for (let i = 2; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n    }\n\n    return dp[nums.length - 1]\n};\n\n\n\n# 最长非重复子串\n\n * 剑指offer48\n\n示例 1:\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n示例 2:\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n示例 3:\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n * dp[i]代表以s[i]结尾的最长非重复字串\n * 若dp[i-1]包含s[i]，则截取出不包含的部分拼接\n * 若dp[i-1]不包含s[i]，则直接拼接\n\nvar lengthOfLongestSubstring = function(s) {\n    if (!s.length) return 0;\n    const dp = new Array(s.length).fill(\'\');\n    dp[0] = s[0];\n    for (let i = 1; i < s.length; i++) {\n        if (!dp[i - 1].includes(s[i])) {\n            dp[i] = dp[i - 1] + s[i];\n        }\n        else {\n            dp[i] = dp[i - 1].slice(dp[i - 1].indexOf(s[i]) + 1) + s[i];\n        }\n    }\n    return Math.max(...dp.map(s => s.length));\n}\n\n\n\n# 最长重复子数组\n\n * leetcode718\n * dp[i][j]：表示第一个数组 A 前 i 个元素和数组 B 前 j 个元素组成的最长公共子数组(相当于子串)的长度。\n\nvar findLength = function(nums1, nums2) {\n    const m = nums1.length\n    const n = nums2.length\n    const dp = Array.from(new Array(m + 1), () => new Array(n + 1).fill(0))                    \n    let res = 0\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (nums1[i - 1] == nums2[j - 1]) {     \n                dp[i][j] = dp[i - 1][j - 1] + 1\n            }\n            res = Math.max(dp[i][j], res)\n        }\n    }\n    return res\n};\n\n\n\n# 最长递增子序列\n\n * leetcode300\n\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n\n * dp[i]：以nums[i]结尾的最长子序列长度\n * i === 0: nums[0] = 10，dp[0] = 1\n * i === 1: nums[1] = 9， (9<10, 不能形成递增序列)，dp[1] = 1\n * i === 2: nums[2] = 2，(2<9 且 2<10, 不能与任何一个形成递增序列)，dp[2] = 1\n * i === 3: nums[3] = 5，(5<10, 5<9, 但是5>2，所以5可以拼到2后面)，dp[3] = 1 + dp[2] = 2\n * i === 4: nums[4] = 3，(3<10,3<9,3>2,3<5, 所以3可以拼到2后面)，dp[4] = 1 + dp[2] = 2\n * i === 5: nums[5] = 7，(7>2,7>5,7>3 所以7可以拼到2或5或3后面，所以要找一个最大的)，dp[5] = 1 + max(dp[2], dp[3], dp[4]) = 3\n * 依次类推\n * 转移方程： 设j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：\n   * 当 nums[i] > nums[j] 时： nums[i]可以接在 nums[j]之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1 ；\n   * 当 nums[i] <= nums[j] 时：nums[i] 无法接在 nums[j]之后，此情况上升子序列不成立，跳过。\n   * 故转移方程：dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)\n\nvar lengthOfLIS = function(nums) {\n    const dp = new Array(nums.length).fill(1);\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(1 + dp[j], dp[i]);\n            }\n        }\n    }\n    return Math.max(...dp);\n}\n\n\n\n# 最长公共子序列(LCS)\n\n * leetcode1143\n * 参考题解1，参考题解2(填表)\n\n示例 1:\n输入：text1 = "abcde", text2 = "ace" \n输出：3  \n解释：最长公共子序列是 "ace"，它的长度为 3。\n\n示例 2:\n输入：text1 = "abc", text2 = "abc"\n输出：3\n解释：最长公共子序列是 "abc"，它的长度为 3\n\n\n * dp[i][j]：字符串 text1 和 text2 中对应的前i，前j个字符的LCS的长度\n * 当text1[i] === text2[j]时，说明 text1[i] 或者 text2[j]对应的字符是最长公共子序列的一部分，所以有 dp[i][j] = 1 + dp[i-1][j-1]\n * 当text1[i] !== text2[j]时，此时我们要看两个字符串分别单独往回撤一个字符串的对比情况，获取两者的最大值即可，所以有dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\nTEXT2\\TEXT1   -   A   B   C   D   E\n-             0   0   0   0   0   0\na             0   1   1   1   1   1\nc             0   1   1   2   2   2\ne             0   1   1   2   2   3\n\nvar longestCommonSubsequence = function (text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    const dp = Array.from(new Array(m + 1), () => new Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            }\n            else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n\n\n# 编辑距离(SES)\n\n * leetcode72\n * 题解:微软又考了这道题\n\n输入：word1 = "horse", word2 = "ros"\n输出：3\n\nhorse -> rorse (将 \'h\' 替换为 \'r\')\nrorse -> rose (删除 \'r\')\nrose -> ros (删除 \'e\')\n\n\n状态定义：dp[i][j]是word1,word2的最小编辑距离\n\n * 当word1[i - 1] = word2[j - 1] 时，字符串最后一位相等，不需要任何操作， 也就是dp(i, j) = dp(i - 1, j - 1)， s1[0..i] 和 s2[0..j] 的最小编辑距离等于s1[0..i - 1] 和 s2[0..j - 1] 的最小编辑距离\n\n * 当 word1[i]！= word2[j]，则需要进行插入、删除、替换操作了 1、插入：dp[i][j] = dp(i, j - 1) + 1， 直接在 s1[i] 插入一个和 s2[j] 一样的字符， 操作数加一 2、删除：dp[i][j] = dp(i - 1, j) + 1，直接把 s[i] 这个字符删掉， 操作数加一 3、替换：dp[i][j] = dp(i - 1, j - 1) + 1 ， 直接把 s1[i] 替换成s2[j]， 操作数加一\n\nWORD1/WORD2   -   R   O   S\n-             0   1   2   3\nh             1   1   2   3\no             2   2   1   2\nr             3   2   2   2\ns             4   3   3   2\ne             5   4   4   3\n\nvar minDistance = function(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from(new Array(m + 1), () => new Array(n + 1).fill(0));\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else {\n                // 插入、删除、替换\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n\n\n# LCS和SES的关系\n\n对于LCS和SES如果我们细心想一下就不难发现两者其实就是同一个问题；\n\n> 存在字符串string1=ABCDE，string2=BCEGF；\n> \n> 则字符串的长度分别计作Length(string1)，Length(string2);\n> \n> 从LCS的角度来看，最长公共子序列就是BCE，长度计作Length(LCS);\n> \n> 从SES的角度来看，最短编辑路径就是A(-)D(-)G(+)F(+)，长度计作Length(SES);\n> \n> *Length(string1)+Length(string2)=Length(SES)+Length(LCS)2；\n\n\n# 最长回文子串\n\n * leetcode5\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n输入: "babad"\n输出: "bab"\n注意: "aba" 也是一个有效答案。\n\n示例 2：\n输入: "cbbd"\n输出: "bb"\n\n\n * 分析：i 到 j 是回文子串那么 i+1 到 j-1 也是回文子串\n * i 到 j 的最优子结构就是 i+1 到 j-1\n * 边界就是单个字符或者 aa 这种\n * 状态转移方程是：dp[i][j] = dp[i+1][j-1] && s[i] == s[j]\n\nvar longestPalindrome = function(s) {\n    if (!s) return ""\n    let res = [], dp = []\n\n    // 从后向前遍历，因为 dp[i] 依赖于 dp [i+1]\n    for (let i = s.length - 1; i >= 0; i--) {\n        dp[i] = []\n        for (let j = i; j < s.length; j++) {\n            // 边界\n            if (i === j || (j - i === 1 && s[i] === s[j])) {\n                dp[i][j] = true\n            }\n            // 状态转移\n            else if (s[i] === s[j] && dp[i + 1][j - 1]) {\n                dp[i][j] = true\n            }\n            if (dp[i][j] && j - i + 1 > res.length) {\n                res = s.slice(i, j + 1);\n            }\n        }\n    }\n    return res\n};\n\n\n\n# 不同路径\n\n * leetcode62\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n示例 1:\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n示例 2:\n输入: m = 7, n = 3\n输出: 28\n\n\n * 分析：到达终点总是向右或向下，故到达终点的走法=到达其上面点的走法 + 到达其左面点的走法\n * 状态转移：map[m][n] = map[m-1][n] + map[m][n-1]\n * 边界：map[0][j] = 1,map[i][0] = 1\n\n\t// 初始化二维数组\n    let map = Array.from(new Array(m),()=>(new Array(n).fill(0)))\n    for (let j = 0; j < n; j++) {\n        map[0][j] = 1\n    }\n    for (let i = 0; i < m; i++) {\n        map[i][0] = 1\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            map[i][j] = map[i-1][j] + map[i][j-1]\n        }\n    }\n    return map[m-1][n-1]\n\n\n# Array.from\n\n将一个类数组对象或者可遍历对象转换成一个真正的数组。\n\n * 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。\n\n * 该类数组对象的属性名必须为数值型或字符串型的数字\n\n * 该类数组对象的属性名可以加引号，也可以不加引号\n\n * Array.from可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n\n# 最小路径和\n\n * leetcode64\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例 1：\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n示例 2：\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n\n\n * 思路：到grid[i][j]的最小值，肯定等于到grid[i-1][j]的最小值和到grid[i][j-1]的最小值中较小的加上当前grid[i][j]的值\n * 最优子结构：dp[i-1][j], dp[i][j-1]中小的那个\n * 边界：dp[0][0] = grid[0][0]\n * 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]；\n\nvar minPathSum = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dp = Array.from(new Array(m), () => new Array(m).fill(0));\n    dp[0][0] = grid[0][0];\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    return dp[m - 1][n - 1];\n};\n\n\n\n# 正则表达式匹配\n\n * leetcode10\n\n * 题解\n\n\n# 分割等和子集\n\n * leetcode416\n\n> 这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。\n\n * 背包问题分析\n\n输入: n物品重W[1:n], 价值V[1:n], 背包容量C\n输出: 装包使得价值最大 (物品重量为整数).\n\ndp[i,k] = 由[1:i]组合出重量<=k的最大价值\n\n如果第i件物品没有包括在其中，则dp[i,k] = dp[i-1,k]\n如果第i件物品包括在其中，则dp[i,k] = dp[i-1,k-W[i]] + V[i]\n\n转移方程：dp[i,k] = max{ dp[i-1,k], dp[i-1,k-W[i]] + V[i] }\n\n\n * 例如输入为1，2，3，6，midSum = 6\n\n-   0   1   2   3   4   5   6\n0   0   0   0   0   0   0   0\n1   0   1   1   1   1   1   1\n2   0   1   2   3   3   3   3\n3   0   1   2   3   4   5   6\n5   0   1   2   3   4   5   6\n\nvar canPartition = function(nums) {\n    let len = nums.length\n    let sum = 0\n    for (let i = 0; i < len; i++) {\n        sum += nums[i]\n    }\n    let midSum = sum >> 1\n    let dp = Array.from(new Array(len + 1),()=>(new Array(midSum + 1).fill(0)))\n    for (let i = 1; i <= len; i++) {\n        for (let j = 1; j <= midSum; j++) {\n            if (j >= nums[i - 1]) {\n                // dp[i - 1][j] 为不装\n                // dp[i - 1][j - nums[i-1]] + nums[i - 1] 是装，且剩余空间继续装\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n            }\n            // 当前背包容量j不够装下第i个物品的重量nums[i-1]时，只有选择不装\n            else {\n                dp[i][j] = dp[i - 1][j]\n            }\n        }\n    }\n    return dp[len][midSum] === sum / 2\n};\n\n\n\n# 三角形的最小路径和\n\n * leetcode120\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n * dp[i][j]表示从三角形顶部走到位置 (i, j) 的最小路径和，因此要想走到位置 (i, j)，上一步就只能在位置 (i - 1, j - 1)或者位置 (i - 1, j)\n\n * 状态转移方程：dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]\n\n * 边界条件：dp[0][0] = triangle[0][0]\n\n * 三角形的两腰上的 dp 值是确定的\n   \n   * dp[i][0] = dp[i-1][0] + triangle[i][0]\n   * dp[i][i] = dp[i-1][i-1] + triangle[i][i]\n\nvar minimumTotal = function(triangle) {\n    const len = triangle.length;\n    // 初始化 dp 数组\n    const dp = new Array(len);\n    for (let i = 0; i < len; i++) {\n        dp[i] = new Array(i + 1).fill(0);\n    }\n    dp[0][0] = triangle[0][0];\n    for (let i = 1; i < len; i++) {\n        dp[i][0] = dp[i - 1][0] + triangle[i][0];\n        for (let j = 1; j < i; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];\n        }\n        dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];\n    }\n    return Math.min(...dp[len - 1]);\n};\n\n\n\n# 买卖股票的最佳时机\n\n * leetcode121\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n     \n示例 2:\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n> 设 dp[i] 为以第 i 支股票卖出的最大利润，需要维护一个股票最小值 min，因为卖出时的最大利润一定是与最小值做计算，最后返回 dp 数组中的最大值。\n\nvar maxProfit = function(prices) {\n    const dp = new Array(prices.length).fill(0);\n    let min = prices[0];\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > min) {\n            dp[i] = prices[i] - min;\n        }\n        else {\n            min = prices[i];\n        }\n    }\n    return Math.max(...dp);\n}\n\n\n\n# 买卖股票的最佳时机ii（多次交易）\n\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n\n> 由于可以无限次的买入和卖出，我们都知道炒股想要挣钱的话当然是低价买入，高价卖出，那么这里我们只需要从第二天开始，如果当天价格比之前的价格高，则把差价加入利润中，因为我们可以昨天买入，今日卖出，若明天价格更高的话，还可以今日买入，明天再抛出，以此类推遍历完整个数组，即可求出最大利润。 即使是连续上涨交易日： 设此上涨交易日股票价格分别为 p1,p2,...,pn ，则第一天买最后一天卖收益最大，即 pn−p1；等价于每天都买卖，即 pn−p1=(p2−p1)+(p3−p2)+...+(pn−pn−1)\n\n// 贪心\nvar maxProfit = function(prices) {\n    let res = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            res += prices[i] - prices[i - 1];\n        }\n    }\n    return res;\n}\n\n\n\n# 买卖股票的最佳时机iii（含冷冻期）\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n\n * 设 dp[i] 为 截止至第i天的最大收益\n * 对于每一天i都有两种状态持股和不持股，而不持股又分为当天卖出和本来就没有\n   * 持股：设为dp[i][1]\n   * 不持股\n     * 当天卖出了股票所以没有，设为dp[i][2]\n     * 前一天就没有，今天也没有，设为dp[i][0]\n * 状态确定好后，下面就是如何建立状态转移方程？\n   * 当天持股分为两种情况：当天买入和本来就有，找出效益最大值\n     * 当天买入，前一天一定没有并且前一天没有卖出（dp[i-1][0]）,此时效益为dp[i-1][0]-p[i]\n     * 前一天本来就有，此时的效益为dp[i-1][1]\n     * 状态转移方程：dp[i][1] = max(dp[i-1][1],dp[i-1][0]-p[i])\n   * 不持股（当天卖出所以没有）\n     * 当天卖出，前一天一定持有，此时的最大效益就是前一天的效益 + 卖出的价格\n     * 状态转移方程：dp[i][2] = dp[i-1][1] + p[i]\n   * 不持股（本来就没有）\n     * 说明前一天也没有，最大效益就是前一天两种没有状态的最大值\n     * 状态转移方程：dp[i][0] = max(dp[i-1][0],dp[i-1][2])\n * 截止最后一天的最大效益一定是不持有状态的\n * 边界：dp[0][0] = 0,dp[0][2] = 0,dp[0][1] = -p[0]\n\nvar maxProfit = function(prices) {\n    if (prices.length === 0) return 0\n    const len = prices.length\n    let dp = Array.from(new Array(len), () => new Array(3).fill(0))\n    dp[0][0] = 0\n    dp[0][2] = 0\n    dp[0][1] = -prices[0]\n    for (let i = 1; i < len; i++) {\n        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])\n        dp[i][2] = dp[i-1][1] + prices[i]\n        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2])\n    }\n    return Math.max(dp[len-1][0], dp[len-1][2])\n};\n',normalizedContent:'# 动态规划\n\n * 爬楼梯\n * 零钱兑换\n * 最大子序列和\n * 最长非重复子串\n * 最长重复子数组\n * 最长递增子序列\n * 最长公共子序列\n * 编辑距离\n * 最长回文子串\n * 不同路径\n * 最小路径和\n * 正则表达式匹配\n * 分割等和子集\n * 三角形的最小路径和\n * 买卖股票的最佳时机i/ii/iii\n * 打家劫舍\n\n> 动态规划的三个概念：最优子结构，边界，状态转移方程\n\n\n# 动态规划与贪心的区别\n\n> 贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。 贪心是求局部最优，以得到全局最优（不一定是正确的，需要证明）\n> \n> 比如某国的钱币分为1元3元4元，如果要拿6元钱怎么拿？贪心的话先拿4再拿两个1，一共3张钱，而实际最优其实是两张3元（类似于背包问题，需要考虑物品个数）\n> \n> 动态规划算法中，全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解\n\n动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。 区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。\n\n\n# 爬楼梯\n\n * leetcode70\n\n有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。\n\n\n * 思考：如果只差最后一步就走到第 10 级，此时分为两种：从第 9 级到 10 级，从第 8 级到 10 级\n * 0 到 9 级的走法有 x，0 到 8 级的走法有 y 种，那么 0 到 10 级的走法一共有 x+y\n * f(10) = f(9) + f(8)，f(8) = f(8) + f(7)\n * f(9) 和 f(8) 是 f(10) 的最优子结构\n * 边界是 f(1) 和 f(2)\n * 状态转移方程是 f(n) = f(n-1) + f(n-2)\n\nvar climbstairs = function(n) {\n    let dp = new array(n + 1).fill(0)\n    dp[1] = 1\n    dp[2] = 2\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n};\n\n\n\n# 零钱兑换\n\n * leetcode322\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n你可以认为每种硬币的数量是无限的。\n\n示例 1：\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n\n示例 2：\n输入：coins = [2], amount = 3\n输出：-1\n\n\n * 设dp[i] 表示总金额为 i 的时候最优解法的硬币数\n * 若面值有1，2，5要凑够120元，此时可以拿一枚面值为1的，最优个数为 dp[119] + 1，拿一枚面试为2的，最优个数为dp[118] + 1，拿一枚面值为5的，最优个数为dp[115] + 1，取三种的最小值即可\n * 状态转移方程：dp[i] = math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)\n * 边界：dp[0] = 0\n\nconst coinchange = (coins, amount) => {\n  \tlet dp = new array( amount + 1 ).fill( infinity );\n    dp[0] = 0;\n    for (let i = 1; i <= amount; i++) {\n        for (let coin of coins) {\n            if (i - coin >= 0) {\n                dp[i] = math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    return dp[amount] === infinity ? -1 : dp[amount];\n}\n\n\n\n# 最大子序列和（连续）\n\n * leetcode53\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n * 分析：答案肯定是在以下组合中：\n * 第一个子组合是以第一个数字结尾的连续序列，也就是[-2]，最大值-2\n * 第二个子组合是以第二个数字结尾的连续序列，也就是[-2,1], [1]，最大值1\n * 第三个子组合是以第三个数字结尾的连续序列，也就是[-2,1,-3], [1,-3], [-3]，最大值-2\n * 第四个子组合是以第四个数字结尾的连续序列，也就是[-2,1,-3,4],[1.-3,4],[-3,4],[4]，最大值4\n * 第n个子组合......\n\n----------------------------------------\n\n * 最优子结构：组合 n 只是在组合 n-1 的基础上每一个数组后面添加 1 个数字 num，然后增加一个只有第 n 个数字的数组[num]，只需要比较前一个组合的最大值 + num 和 num\n * 边界：dp[0] = nums[0]\n * 状态转移方程：dp[i] = max(dp[i-1] + nums[i], nums[i]) 或者 dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i]\n\n// 组合3只是在组合2的基础上每一个数组后面添加第3个数字，也就是3，然后增加一个只有第三个数字的数组[3]\n// 只需要比较前一个组合的最大值+num和num\n// 计算出九个组合的最大值，再取最大的即可\n\nvar maxsubarray = function(nums) {\n    const dp = new array(nums.length).fill(0);\n    dp[0] = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        dp[i] = math.max(nums[i], dp[i - 1] + nums[i]);\n    }\n    return math.max(...dp);\n};\n\n\n怎么求对应的数组呢？相比于上题，应该存储起始和结束的索引。\n\nvar maxsubarray = function(nums) {\n    const len = nums.length\n    const dp = new array(len).fill(0)\n    let start = end = 0\n    let finalstart = finalend = 0\n    let max = dp[0] = nums[0]\n    for (let i = 1; i < len; i++) {\n        if (dp[i - 1] > 0) {\n            dp[i] = dp[i - 1] + nums[i]\n            end = i\n        } else {\n            dp[i] = nums[i]\n            start = end = i\n        }\n        if (dp[i] > max) {\n            max = dp[i]\n            finalstart = start\n            finalend = end\n        }\n    }\n    return nums.slice(finalstart, finalend + 1)\n};\n\nconsole.log(maxsubarray([-2,1,-3,4,-1,2,1,-5,4]))\n// [4,-1,2,1]\n\n\n\n# 打家劫舍（非连续）\n\n * leetcode198\n * 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值\n * 状态转移方程：dp[n] = max( dp[n-1], dp[n-2] + num )\n * 举例来说：[3,4,2]，1 号房间可盗窃最大值为 3， 即为 dp[1]=3，2 号房间可盗窃最大值为 4， 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = max( dp[2], dp[1] + num ) = 5，3 号房间可盗窃最大值为 5\n * 时间复杂度：o(n)\n\nvar rob = function(nums) {\n    const dp = new array(nums.length).fill(0);\n  \n  \t// 初始化好前两个状态\n    dp[0] = nums[0];\n    dp[1] = nums[1] > nums[0] ? nums[1] : nums[0];\n\n    for (let i = 2; i < nums.length; i++) {\n        dp[i] = math.max(dp[i - 2] + nums[i], dp[i - 1]);\n    }\n\n    return dp[nums.length - 1]\n};\n\n\n\n# 最长非重复子串\n\n * 剑指offer48\n\n示例 1:\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n示例 2:\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n示例 3:\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n * dp[i]代表以s[i]结尾的最长非重复字串\n * 若dp[i-1]包含s[i]，则截取出不包含的部分拼接\n * 若dp[i-1]不包含s[i]，则直接拼接\n\nvar lengthoflongestsubstring = function(s) {\n    if (!s.length) return 0;\n    const dp = new array(s.length).fill(\'\');\n    dp[0] = s[0];\n    for (let i = 1; i < s.length; i++) {\n        if (!dp[i - 1].includes(s[i])) {\n            dp[i] = dp[i - 1] + s[i];\n        }\n        else {\n            dp[i] = dp[i - 1].slice(dp[i - 1].indexof(s[i]) + 1) + s[i];\n        }\n    }\n    return math.max(...dp.map(s => s.length));\n}\n\n\n\n# 最长重复子数组\n\n * leetcode718\n * dp[i][j]：表示第一个数组 a 前 i 个元素和数组 b 前 j 个元素组成的最长公共子数组(相当于子串)的长度。\n\nvar findlength = function(nums1, nums2) {\n    const m = nums1.length\n    const n = nums2.length\n    const dp = array.from(new array(m + 1), () => new array(n + 1).fill(0))                    \n    let res = 0\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (nums1[i - 1] == nums2[j - 1]) {     \n                dp[i][j] = dp[i - 1][j - 1] + 1\n            }\n            res = math.max(dp[i][j], res)\n        }\n    }\n    return res\n};\n\n\n\n# 最长递增子序列\n\n * leetcode300\n\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n\n * dp[i]：以nums[i]结尾的最长子序列长度\n * i === 0: nums[0] = 10，dp[0] = 1\n * i === 1: nums[1] = 9， (9<10, 不能形成递增序列)，dp[1] = 1\n * i === 2: nums[2] = 2，(2<9 且 2<10, 不能与任何一个形成递增序列)，dp[2] = 1\n * i === 3: nums[3] = 5，(5<10, 5<9, 但是5>2，所以5可以拼到2后面)，dp[3] = 1 + dp[2] = 2\n * i === 4: nums[4] = 3，(3<10,3<9,3>2,3<5, 所以3可以拼到2后面)，dp[4] = 1 + dp[2] = 2\n * i === 5: nums[5] = 7，(7>2,7>5,7>3 所以7可以拼到2或5或3后面，所以要找一个最大的)，dp[5] = 1 + max(dp[2], dp[3], dp[4]) = 3\n * 依次类推\n * 转移方程： 设j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：\n   * 当 nums[i] > nums[j] 时： nums[i]可以接在 nums[j]之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1 ；\n   * 当 nums[i] <= nums[j] 时：nums[i] 无法接在 nums[j]之后，此情况上升子序列不成立，跳过。\n   * 故转移方程：dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)\n\nvar lengthoflis = function(nums) {\n    const dp = new array(nums.length).fill(1);\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = math.max(1 + dp[j], dp[i]);\n            }\n        }\n    }\n    return math.max(...dp);\n}\n\n\n\n# 最长公共子序列(lcs)\n\n * leetcode1143\n * 参考题解1，参考题解2(填表)\n\n示例 1:\n输入：text1 = "abcde", text2 = "ace" \n输出：3  \n解释：最长公共子序列是 "ace"，它的长度为 3。\n\n示例 2:\n输入：text1 = "abc", text2 = "abc"\n输出：3\n解释：最长公共子序列是 "abc"，它的长度为 3\n\n\n * dp[i][j]：字符串 text1 和 text2 中对应的前i，前j个字符的lcs的长度\n * 当text1[i] === text2[j]时，说明 text1[i] 或者 text2[j]对应的字符是最长公共子序列的一部分，所以有 dp[i][j] = 1 + dp[i-1][j-1]\n * 当text1[i] !== text2[j]时，此时我们要看两个字符串分别单独往回撤一个字符串的对比情况，获取两者的最大值即可，所以有dp[i][j] = math.max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\ntext2\\text1   -   a   b   c   d   e\n-             0   0   0   0   0   0\na             0   1   1   1   1   1\nc             0   1   1   2   2   2\ne             0   1   1   2   2   3\n\nvar longestcommonsubsequence = function (text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    const dp = array.from(new array(m + 1), () => new array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            }\n            else {\n                dp[i][j] = math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n\n\n# 编辑距离(ses)\n\n * leetcode72\n * 题解:微软又考了这道题\n\n输入：word1 = "horse", word2 = "ros"\n输出：3\n\nhorse -> rorse (将 \'h\' 替换为 \'r\')\nrorse -> rose (删除 \'r\')\nrose -> ros (删除 \'e\')\n\n\n状态定义：dp[i][j]是word1,word2的最小编辑距离\n\n * 当word1[i - 1] = word2[j - 1] 时，字符串最后一位相等，不需要任何操作， 也就是dp(i, j) = dp(i - 1, j - 1)， s1[0..i] 和 s2[0..j] 的最小编辑距离等于s1[0..i - 1] 和 s2[0..j - 1] 的最小编辑距离\n\n * 当 word1[i]！= word2[j]，则需要进行插入、删除、替换操作了 1、插入：dp[i][j] = dp(i, j - 1) + 1， 直接在 s1[i] 插入一个和 s2[j] 一样的字符， 操作数加一 2、删除：dp[i][j] = dp(i - 1, j) + 1，直接把 s[i] 这个字符删掉， 操作数加一 3、替换：dp[i][j] = dp(i - 1, j - 1) + 1 ， 直接把 s1[i] 替换成s2[j]， 操作数加一\n\nword1/word2   -   r   o   s\n-             0   1   2   3\nh             1   1   2   3\no             2   2   1   2\nr             3   2   2   2\ns             4   3   3   2\ne             5   4   4   3\n\nvar mindistance = function(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = array.from(new array(m + 1), () => new array(n + 1).fill(0));\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else {\n                // 插入、删除、替换\n                dp[i][j] = math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n\n\n# lcs和ses的关系\n\n对于lcs和ses如果我们细心想一下就不难发现两者其实就是同一个问题；\n\n> 存在字符串string1=abcde，string2=bcegf；\n> \n> 则字符串的长度分别计作length(string1)，length(string2);\n> \n> 从lcs的角度来看，最长公共子序列就是bce，长度计作length(lcs);\n> \n> 从ses的角度来看，最短编辑路径就是a(-)d(-)g(+)f(+)，长度计作length(ses);\n> \n> *length(string1)+length(string2)=length(ses)+length(lcs)2；\n\n\n# 最长回文子串\n\n * leetcode5\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n输入: "babad"\n输出: "bab"\n注意: "aba" 也是一个有效答案。\n\n示例 2：\n输入: "cbbd"\n输出: "bb"\n\n\n * 分析：i 到 j 是回文子串那么 i+1 到 j-1 也是回文子串\n * i 到 j 的最优子结构就是 i+1 到 j-1\n * 边界就是单个字符或者 aa 这种\n * 状态转移方程是：dp[i][j] = dp[i+1][j-1] && s[i] == s[j]\n\nvar longestpalindrome = function(s) {\n    if (!s) return ""\n    let res = [], dp = []\n\n    // 从后向前遍历，因为 dp[i] 依赖于 dp [i+1]\n    for (let i = s.length - 1; i >= 0; i--) {\n        dp[i] = []\n        for (let j = i; j < s.length; j++) {\n            // 边界\n            if (i === j || (j - i === 1 && s[i] === s[j])) {\n                dp[i][j] = true\n            }\n            // 状态转移\n            else if (s[i] === s[j] && dp[i + 1][j - 1]) {\n                dp[i][j] = true\n            }\n            if (dp[i][j] && j - i + 1 > res.length) {\n                res = s.slice(i, j + 1);\n            }\n        }\n    }\n    return res\n};\n\n\n\n# 不同路径\n\n * leetcode62\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“finish”）。\n\n问总共有多少条不同的路径？\n\n示例 1:\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n示例 2:\n输入: m = 7, n = 3\n输出: 28\n\n\n * 分析：到达终点总是向右或向下，故到达终点的走法=到达其上面点的走法 + 到达其左面点的走法\n * 状态转移：map[m][n] = map[m-1][n] + map[m][n-1]\n * 边界：map[0][j] = 1,map[i][0] = 1\n\n\t// 初始化二维数组\n    let map = array.from(new array(m),()=>(new array(n).fill(0)))\n    for (let j = 0; j < n; j++) {\n        map[0][j] = 1\n    }\n    for (let i = 0; i < m; i++) {\n        map[i][0] = 1\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            map[i][j] = map[i-1][j] + map[i][j-1]\n        }\n    }\n    return map[m-1][n-1]\n\n\n# array.from\n\n将一个类数组对象或者可遍历对象转换成一个真正的数组。\n\n * 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。\n\n * 该类数组对象的属性名必须为数值型或字符串型的数字\n\n * 该类数组对象的属性名可以加引号，也可以不加引号\n\n * array.from可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n\n# 最小路径和\n\n * leetcode64\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例 1：\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n示例 2：\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n\n\n * 思路：到grid[i][j]的最小值，肯定等于到grid[i-1][j]的最小值和到grid[i][j-1]的最小值中较小的加上当前grid[i][j]的值\n * 最优子结构：dp[i-1][j], dp[i][j-1]中小的那个\n * 边界：dp[0][0] = grid[0][0]\n * 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]；\n\nvar minpathsum = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dp = array.from(new array(m), () => new array(m).fill(0));\n    dp[0][0] = grid[0][0];\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    return dp[m - 1][n - 1];\n};\n\n\n\n# 正则表达式匹配\n\n * leetcode10\n\n * 题解\n\n\n# 分割等和子集\n\n * leetcode416\n\n> 这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。\n\n * 背包问题分析\n\n输入: n物品重w[1:n], 价值v[1:n], 背包容量c\n输出: 装包使得价值最大 (物品重量为整数).\n\ndp[i,k] = 由[1:i]组合出重量<=k的最大价值\n\n如果第i件物品没有包括在其中，则dp[i,k] = dp[i-1,k]\n如果第i件物品包括在其中，则dp[i,k] = dp[i-1,k-w[i]] + v[i]\n\n转移方程：dp[i,k] = max{ dp[i-1,k], dp[i-1,k-w[i]] + v[i] }\n\n\n * 例如输入为1，2，3，6，midsum = 6\n\n-   0   1   2   3   4   5   6\n0   0   0   0   0   0   0   0\n1   0   1   1   1   1   1   1\n2   0   1   2   3   3   3   3\n3   0   1   2   3   4   5   6\n5   0   1   2   3   4   5   6\n\nvar canpartition = function(nums) {\n    let len = nums.length\n    let sum = 0\n    for (let i = 0; i < len; i++) {\n        sum += nums[i]\n    }\n    let midsum = sum >> 1\n    let dp = array.from(new array(len + 1),()=>(new array(midsum + 1).fill(0)))\n    for (let i = 1; i <= len; i++) {\n        for (let j = 1; j <= midsum; j++) {\n            if (j >= nums[i - 1]) {\n                // dp[i - 1][j] 为不装\n                // dp[i - 1][j - nums[i-1]] + nums[i - 1] 是装，且剩余空间继续装\n                dp[i][j] = math.max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n            }\n            // 当前背包容量j不够装下第i个物品的重量nums[i-1]时，只有选择不装\n            else {\n                dp[i][j] = dp[i - 1][j]\n            }\n        }\n    }\n    return dp[len][midsum] === sum / 2\n};\n\n\n\n# 三角形的最小路径和\n\n * leetcode120\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n * dp[i][j]表示从三角形顶部走到位置 (i, j) 的最小路径和，因此要想走到位置 (i, j)，上一步就只能在位置 (i - 1, j - 1)或者位置 (i - 1, j)\n\n * 状态转移方程：dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]\n\n * 边界条件：dp[0][0] = triangle[0][0]\n\n * 三角形的两腰上的 dp 值是确定的\n   \n   * dp[i][0] = dp[i-1][0] + triangle[i][0]\n   * dp[i][i] = dp[i-1][i-1] + triangle[i][i]\n\nvar minimumtotal = function(triangle) {\n    const len = triangle.length;\n    // 初始化 dp 数组\n    const dp = new array(len);\n    for (let i = 0; i < len; i++) {\n        dp[i] = new array(i + 1).fill(0);\n    }\n    dp[0][0] = triangle[0][0];\n    for (let i = 1; i < len; i++) {\n        dp[i][0] = dp[i - 1][0] + triangle[i][0];\n        for (let j = 1; j < i; j++) {\n            dp[i][j] = math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];\n        }\n        dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];\n    }\n    return math.min(...dp[len - 1]);\n};\n\n\n\n# 买卖股票的最佳时机\n\n * leetcode121\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n     \n示例 2:\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n> 设 dp[i] 为以第 i 支股票卖出的最大利润，需要维护一个股票最小值 min，因为卖出时的最大利润一定是与最小值做计算，最后返回 dp 数组中的最大值。\n\nvar maxprofit = function(prices) {\n    const dp = new array(prices.length).fill(0);\n    let min = prices[0];\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > min) {\n            dp[i] = prices[i] - min;\n        }\n        else {\n            min = prices[i];\n        }\n    }\n    return math.max(...dp);\n}\n\n\n\n# 买卖股票的最佳时机ii（多次交易）\n\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n\n> 由于可以无限次的买入和卖出，我们都知道炒股想要挣钱的话当然是低价买入，高价卖出，那么这里我们只需要从第二天开始，如果当天价格比之前的价格高，则把差价加入利润中，因为我们可以昨天买入，今日卖出，若明天价格更高的话，还可以今日买入，明天再抛出，以此类推遍历完整个数组，即可求出最大利润。 即使是连续上涨交易日： 设此上涨交易日股票价格分别为 p1,p2,...,pn ，则第一天买最后一天卖收益最大，即 pn−p1；等价于每天都买卖，即 pn−p1=(p2−p1)+(p3−p2)+...+(pn−pn−1)\n\n// 贪心\nvar maxprofit = function(prices) {\n    let res = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            res += prices[i] - prices[i - 1];\n        }\n    }\n    return res;\n}\n\n\n\n# 买卖股票的最佳时机iii（含冷冻期）\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n\n * 设 dp[i] 为 截止至第i天的最大收益\n * 对于每一天i都有两种状态持股和不持股，而不持股又分为当天卖出和本来就没有\n   * 持股：设为dp[i][1]\n   * 不持股\n     * 当天卖出了股票所以没有，设为dp[i][2]\n     * 前一天就没有，今天也没有，设为dp[i][0]\n * 状态确定好后，下面就是如何建立状态转移方程？\n   * 当天持股分为两种情况：当天买入和本来就有，找出效益最大值\n     * 当天买入，前一天一定没有并且前一天没有卖出（dp[i-1][0]）,此时效益为dp[i-1][0]-p[i]\n     * 前一天本来就有，此时的效益为dp[i-1][1]\n     * 状态转移方程：dp[i][1] = max(dp[i-1][1],dp[i-1][0]-p[i])\n   * 不持股（当天卖出所以没有）\n     * 当天卖出，前一天一定持有，此时的最大效益就是前一天的效益 + 卖出的价格\n     * 状态转移方程：dp[i][2] = dp[i-1][1] + p[i]\n   * 不持股（本来就没有）\n     * 说明前一天也没有，最大效益就是前一天两种没有状态的最大值\n     * 状态转移方程：dp[i][0] = max(dp[i-1][0],dp[i-1][2])\n * 截止最后一天的最大效益一定是不持有状态的\n * 边界：dp[0][0] = 0,dp[0][2] = 0,dp[0][1] = -p[0]\n\nvar maxprofit = function(prices) {\n    if (prices.length === 0) return 0\n    const len = prices.length\n    let dp = array.from(new array(len), () => new array(3).fill(0))\n    dp[0][0] = 0\n    dp[0][2] = 0\n    dp[0][1] = -prices[0]\n    for (let i = 1; i < len; i++) {\n        dp[i][1] = math.max(dp[i-1][1], dp[i-1][0] - prices[i])\n        dp[i][2] = dp[i-1][1] + prices[i]\n        dp[i][0] = math.max(dp[i-1][0], dp[i-1][2])\n    }\n    return math.max(dp[len-1][0], dp[len-1][2])\n};\n',charsets:{cjk:!0}},{title:"DFS、BFS",frontmatter:{title:"DFS、BFS",date:"2020-10-29T09:52:01.000Z",categories:"算法"},regularPath:"/algorithm/dfs-bfs.html",relativePath:"algorithm/dfs-bfs.md",key:"v-75ce495f",path:"/algorithm/dfs-bfs.html",headers:[{level:2,title:"深度优先，广度优先（层次遍历）",slug:"深度优先-广度优先-层次遍历",normalizedTitle:"深度优先，广度优先（层次遍历）",charIndex:125},{level:2,title:"求根到叶子节点数字之和",slug:"求根到叶子节点数字之和",normalizedTitle:"求根到叶子节点数字之和",charIndex:34},{level:2,title:"路径总和",slug:"路径总和",normalizedTitle:"路径总和",charIndex:54},{level:2,title:"岛屿数量",slug:"岛屿数量",normalizedTitle:"岛屿数量",charIndex:62},{level:2,title:"岛屿最大面积",slug:"岛屿最大面积",normalizedTitle:"岛屿最大面积",charIndex:70},{level:2,title:"单词接龙",slug:"单词接龙",normalizedTitle:"单词接龙",charIndex:80},{level:2,title:"N叉树的最大深度",slug:"n叉树的最大深度",normalizedTitle:"n叉树的最大深度",charIndex:93},{level:2,title:"打家劫舍iii（DFS）",slug:"打家劫舍iii-dfs",normalizedTitle:"打家劫舍iii（dfs）",charIndex:7413}],lastUpdated:"3/31/2023, 5:00:31 PM",lastUpdatedTimestamp:1680253231e3,headersStr:"深度优先，广度优先（层次遍历） 求根到叶子节点数字之和 路径总和 岛屿数量 岛屿最大面积 单词接龙 N叉树的最大深度 打家劫舍iii（DFS）",content:'# DFS、BFS\n\n * 深度优先遍历\n * 广度优先遍历\n * 求根到叶子节点数字之和（DFS）\n * 路径总和\n * 岛屿数量\n * 岛屿最大面积\n * 单词接龙（BFS）\n * N叉树的最大深度（BFS）\n * 打家劫舍三（DFS）\n\n\n# 深度优先，广度优先（层次遍历）\n\n//深度优先的递归实现\nconst deepTraversal = function(root) {\n    const res = [];\n    const dfs = function(node) {\n        res.push(node.val);\n        for (let i = 0; i < node.children.length; i++) {\n            dfs(node.children[i]);\n        }\n    }\n    dfs(root);\n    return res;\n}\n\n// 深度优先非递归\nconst deepTraversal = function(root) {\n    const res = [];\n    const stack = [root];\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        for (let i = tmp.children.length - 1; i >= 0; i--) {\n            stack.push(tmp.children[i]);\n        }\n    }\n    return res;\n};\n\n// 广度非递归\nconst wideTraversal = function(root) {\n    const res = [];\n    const queue = [root];\n    while (queue.length) {\n        const tmp = queue.shift();\n        res.push(tmp.val);\n        for (let i = 0; i < tmp.children.length; i++) {\n            queue.push(tmp.children[i]);\n        }\n    }\n    return res;\n};\n\n\n\n# 求根到叶子节点数字之和\n\n * leetcode129\n\n> 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1->2->3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。\n> \n> 示例 1: 输入: [1,2,3] 1 /\n> 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25.\n> \n> 示例 2: 输入: [4,9,0,5,1] 4 /\n> 9 0 /\n> 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026.\n\n * 从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n\nvar sumNumbers = function(root) {\n    const dfs = function(root, num) {\n        // 若节点是 null 直接返回 0\n        if (!root) {\n            return 0;\n        }\n        // 不是空节点就计算一下加到目前的值\n        num = num * 10 + root.val;\n        // 若是根节点返回该计算值，一条路就走完了\n        if (root.left === null && root.right === null) {\n            return num;\n        }\n        // 不是根节点则递归遍历\n        else {\n            return dfs(root.left, num) + dfs(root.right, num);\n        }\n    }\n    return dfs(root, 0);\n};\n\n// 另一种写法\nvar sumNumbers = function(root) {\n    let res = 0;\n    const fn = function(root, sum) {\n        // 到叶子节点即结算一次\n        if (!root.left && !root.right) {\n            res += sum;\n            return;\n        }\n        if (root.left) {\n            fn(root.left, sum * 10 + root.left.val);\n        }\n        if (root.right) {\n            fn(root.right, sum * 10 + root.right.val);\n        }\n    };\n    fn(root, root.val);\n    return res;\n}\n\n\n\n# 路径总和\n\n * leetcode112\n\nvar hasPathSum = function(root, targetSum) {\n    const res = [];\n    const dfs = function(root, num) {\n        if (!root) {\n            return;\n        }\n        num = num + root.val;\n        if (root.left === null && root.right === null) {\n            res.push(num);\n        }\n        else {\n            dfs(root.left, num);\n            dfs(root.right, num);\n        }\n    }\n    dfs(root, 0);\n    return res.includes(targetSum);\n};\n\n// 另一种写法\nvar hasPathSum = function(root, targetSum) {\n    if (!root) return false;\n    const res = [];\n    const fn = function(root, sum) {\n        if (!root.left && !root.right) {\n            res.push(sum);\n        }\n        if (root.left) {\n            fn(root.left, sum + root.left.val);\n        }\n        if (root.right) {\n            fn(root.right, sum + root.right.val);\n        }\n    };\n    fn(root, root.val);\n    return res.includes(targetSum);\n}\n\n\n\n# 岛屿数量\n\n * leetcode200\n * 思路：从为"1"的开始，向四周dfs，把遇到的"1"变为"0"\n\nvar numIslands = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dfs = function(i, j) {\n        if (i < 0 || j < 0 || i > m - 1 || j > n - 1 || grid[i][j] === \'0\') return;\n        grid[i][j] = \'0\';\n        dfs(i - 1, j);\n        dfs(i + 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    };\n\n    let count = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === \'1\') {\n                dfs(i, j);\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\n\n\n# 岛屿最大面积\n\n * leetcode695\n * 思路：和上题一样，在dfs的过程中计算面积即可\n\nvar maxAreaOfIsland = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dfs = function(i, j) {\n        if (i < 0 || j < 0 || i > m - 1 || j > n - 1 || grid[i][j] === 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n        let area = 1;\n        area += dfs(i - 1, j);\n        area += dfs(i + 1, j);\n        area += dfs(i, j + 1);\n        area += dfs(i, j - 1);\n        return area;\n    };\n\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                res = Math.max(dfs(i, j), res);\n            }\n        }\n    }\n    return res;\n};\n\n\n\n# 单词接龙\n\n * 题目来源：leetcode127\n\n> 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：\n> \n> 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明:\n> \n> 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n> \n> 示例 1: 输入: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"] 输出: 5 解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。\n> \n> 示例 2: 输入: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"] 输出: 0 解释: endWord "cog" 不在字典中，所以无法进行转换。\n\n * 抽象为图，若两个单词可以转换，则连一条双向边，BFS求起点到终点最短路径\n * 优化为：求图的最短路径，使用队列 + BFS 实现\n * 参考题解：BFS的应用\n\nvar ladderLength = function(beginWord, endWord, wordList) {\n    if (!wordList.includes(endWord)) return 0\n    let queue = []\n    // 用一个对象维护当前节点是否访问过\n    let visitedObj = {\n        beginWord: true\n    }\n    // 用 level 记录当前路径长度\n    queue.push({ word: beginWord, level: 1 })\n    // 队列实现 BFS\n    while (queue.length) {\n        let { word, level } = queue.shift()\n        if (visitedObj[word]) continue\n        for (let i = 0; i < wordList.length; i++) {\n            // 若只有一个字母不同则证明是相邻两边，入队列\n            if (isOneDiff(word, wordList[i])) {\n                if (wordList[i] == endWord) {\n                    return level + 1\n                }\n                queue.push({ word: wordList[i], level: level + 1 })\n                visitedObj[word] = true\n            }\n        }\n    }\n    return 0\n}\n\n\n// 判断两个单词是否只有一个字母不同\nfunction isOneDiff(source, target) {\n    let diff = 0\n    for (let i = 0; i < source.length; i++) {\n        if (source[i] !== target[i]) {\n            diff ++\n        }\n    }\n    if (diff === 1) {\n        return true\n    } else {\n        return false\n    }\n}\n\n\n\n# N叉树的最大深度\n\n * 题目来源:leetcode559\n\n> 给定一个 N 叉树，找到其最大深度。\n> \n> 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\n// BFS\nvar maxDepth = function(root) {\n    if (root === null) return 0\n    if (root.children.length === 0) return 1\n    let queue = []\n    let depthArr = []\n    queue.push({ node: root, depth: 1 })\n    while (queue.length) {\n        const { node, depth } = queue.shift()\n        for (let i = 0; i < node.children.length; i++) {\n            if (node.children[i].children.length === 0) {\n                depthArr.push(depth + 1)\n                continue\n            }\n            queue.push({ node: node.children[i], depth: depth + 1 })\n        }\n    }\n    return Math.max(...depthArr)\n};\n\n// 递归\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    let depth = 0;\n    for (let i = 0; i < root.children.length; i++) {\n        depth = Math.max(depth, maxDepth(root.children[i]));\n    }\n    return 1 + depth;\n};\n\n\n\n# 打家劫舍iii（DFS）\n\n * Leetcode337\n * 每个节点都设置：[不偷, 偷]\n * 当前节点被偷时，其左右孩子不能偷\n * 当前节点未被偷时，其左右孩子可以偷，也可以不偷，取 [不偷, 偷] 的较大者\n\nvar rob = function(root) {\n    let res = dfs(root);\n    return Math.max(res[0], res[1]);\n};\n\nfunction dfs(root) {\n    // [不偷, 偷]\n    let res = [0,0];\n    if (root === null) return res;\n    // left 为 root 左侧子节点的[不偷值, 偷值]\n    let left = dfs(root.left); \n  \t// right 为 root 右侧子节点的[不偷值, 偷值]\n    let right = dfs(root.right); \n    // 每一个节点的不偷值都是： 左侧子节点的最大值 + 右侧子节点的最大值\n    res[0] = Math.max(...left) + Math.max(...right);\n    // 每一个节点的偷值都是：左侧子节点的不偷值 + 右侧子节点的不偷值 + 该节点的值\n    res[1] = root.val + left[0] + right[0];\n    return res;\n}\n',normalizedContent:'# dfs、bfs\n\n * 深度优先遍历\n * 广度优先遍历\n * 求根到叶子节点数字之和（dfs）\n * 路径总和\n * 岛屿数量\n * 岛屿最大面积\n * 单词接龙（bfs）\n * n叉树的最大深度（bfs）\n * 打家劫舍三（dfs）\n\n\n# 深度优先，广度优先（层次遍历）\n\n//深度优先的递归实现\nconst deeptraversal = function(root) {\n    const res = [];\n    const dfs = function(node) {\n        res.push(node.val);\n        for (let i = 0; i < node.children.length; i++) {\n            dfs(node.children[i]);\n        }\n    }\n    dfs(root);\n    return res;\n}\n\n// 深度优先非递归\nconst deeptraversal = function(root) {\n    const res = [];\n    const stack = [root];\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        for (let i = tmp.children.length - 1; i >= 0; i--) {\n            stack.push(tmp.children[i]);\n        }\n    }\n    return res;\n};\n\n// 广度非递归\nconst widetraversal = function(root) {\n    const res = [];\n    const queue = [root];\n    while (queue.length) {\n        const tmp = queue.shift();\n        res.push(tmp.val);\n        for (let i = 0; i < tmp.children.length; i++) {\n            queue.push(tmp.children[i]);\n        }\n    }\n    return res;\n};\n\n\n\n# 求根到叶子节点数字之和\n\n * leetcode129\n\n> 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1->2->3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。\n> \n> 示例 1: 输入: [1,2,3] 1 /\n> 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25.\n> \n> 示例 2: 输入: [4,9,0,5,1] 4 /\n> 9 0 /\n> 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026.\n\n * 从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n\nvar sumnumbers = function(root) {\n    const dfs = function(root, num) {\n        // 若节点是 null 直接返回 0\n        if (!root) {\n            return 0;\n        }\n        // 不是空节点就计算一下加到目前的值\n        num = num * 10 + root.val;\n        // 若是根节点返回该计算值，一条路就走完了\n        if (root.left === null && root.right === null) {\n            return num;\n        }\n        // 不是根节点则递归遍历\n        else {\n            return dfs(root.left, num) + dfs(root.right, num);\n        }\n    }\n    return dfs(root, 0);\n};\n\n// 另一种写法\nvar sumnumbers = function(root) {\n    let res = 0;\n    const fn = function(root, sum) {\n        // 到叶子节点即结算一次\n        if (!root.left && !root.right) {\n            res += sum;\n            return;\n        }\n        if (root.left) {\n            fn(root.left, sum * 10 + root.left.val);\n        }\n        if (root.right) {\n            fn(root.right, sum * 10 + root.right.val);\n        }\n    };\n    fn(root, root.val);\n    return res;\n}\n\n\n\n# 路径总和\n\n * leetcode112\n\nvar haspathsum = function(root, targetsum) {\n    const res = [];\n    const dfs = function(root, num) {\n        if (!root) {\n            return;\n        }\n        num = num + root.val;\n        if (root.left === null && root.right === null) {\n            res.push(num);\n        }\n        else {\n            dfs(root.left, num);\n            dfs(root.right, num);\n        }\n    }\n    dfs(root, 0);\n    return res.includes(targetsum);\n};\n\n// 另一种写法\nvar haspathsum = function(root, targetsum) {\n    if (!root) return false;\n    const res = [];\n    const fn = function(root, sum) {\n        if (!root.left && !root.right) {\n            res.push(sum);\n        }\n        if (root.left) {\n            fn(root.left, sum + root.left.val);\n        }\n        if (root.right) {\n            fn(root.right, sum + root.right.val);\n        }\n    };\n    fn(root, root.val);\n    return res.includes(targetsum);\n}\n\n\n\n# 岛屿数量\n\n * leetcode200\n * 思路：从为"1"的开始，向四周dfs，把遇到的"1"变为"0"\n\nvar numislands = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dfs = function(i, j) {\n        if (i < 0 || j < 0 || i > m - 1 || j > n - 1 || grid[i][j] === \'0\') return;\n        grid[i][j] = \'0\';\n        dfs(i - 1, j);\n        dfs(i + 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    };\n\n    let count = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === \'1\') {\n                dfs(i, j);\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\n\n\n# 岛屿最大面积\n\n * leetcode695\n * 思路：和上题一样，在dfs的过程中计算面积即可\n\nvar maxareaofisland = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dfs = function(i, j) {\n        if (i < 0 || j < 0 || i > m - 1 || j > n - 1 || grid[i][j] === 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n        let area = 1;\n        area += dfs(i - 1, j);\n        area += dfs(i + 1, j);\n        area += dfs(i, j + 1);\n        area += dfs(i, j - 1);\n        return area;\n    };\n\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                res = math.max(dfs(i, j), res);\n            }\n        }\n    }\n    return res;\n};\n\n\n\n# 单词接龙\n\n * 题目来源：leetcode127\n\n> 给定两个单词（beginword 和 endword）和一个字典，找到从 beginword 到 endword 的最短转换序列的长度。转换需遵循如下规则：\n> \n> 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明:\n> \n> 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginword 和 endword 是非空的，且二者不相同。\n> \n> 示例 1: 输入: beginword = "hit", endword = "cog", wordlist = ["hot","dot","dog","lot","log","cog"] 输出: 5 解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。\n> \n> 示例 2: 输入: beginword = "hit" endword = "cog" wordlist = ["hot","dot","dog","lot","log"] 输出: 0 解释: endword "cog" 不在字典中，所以无法进行转换。\n\n * 抽象为图，若两个单词可以转换，则连一条双向边，bfs求起点到终点最短路径\n * 优化为：求图的最短路径，使用队列 + bfs 实现\n * 参考题解：bfs的应用\n\nvar ladderlength = function(beginword, endword, wordlist) {\n    if (!wordlist.includes(endword)) return 0\n    let queue = []\n    // 用一个对象维护当前节点是否访问过\n    let visitedobj = {\n        beginword: true\n    }\n    // 用 level 记录当前路径长度\n    queue.push({ word: beginword, level: 1 })\n    // 队列实现 bfs\n    while (queue.length) {\n        let { word, level } = queue.shift()\n        if (visitedobj[word]) continue\n        for (let i = 0; i < wordlist.length; i++) {\n            // 若只有一个字母不同则证明是相邻两边，入队列\n            if (isonediff(word, wordlist[i])) {\n                if (wordlist[i] == endword) {\n                    return level + 1\n                }\n                queue.push({ word: wordlist[i], level: level + 1 })\n                visitedobj[word] = true\n            }\n        }\n    }\n    return 0\n}\n\n\n// 判断两个单词是否只有一个字母不同\nfunction isonediff(source, target) {\n    let diff = 0\n    for (let i = 0; i < source.length; i++) {\n        if (source[i] !== target[i]) {\n            diff ++\n        }\n    }\n    if (diff === 1) {\n        return true\n    } else {\n        return false\n    }\n}\n\n\n\n# n叉树的最大深度\n\n * 题目来源:leetcode559\n\n> 给定一个 n 叉树，找到其最大深度。\n> \n> 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\n// bfs\nvar maxdepth = function(root) {\n    if (root === null) return 0\n    if (root.children.length === 0) return 1\n    let queue = []\n    let deptharr = []\n    queue.push({ node: root, depth: 1 })\n    while (queue.length) {\n        const { node, depth } = queue.shift()\n        for (let i = 0; i < node.children.length; i++) {\n            if (node.children[i].children.length === 0) {\n                deptharr.push(depth + 1)\n                continue\n            }\n            queue.push({ node: node.children[i], depth: depth + 1 })\n        }\n    }\n    return math.max(...deptharr)\n};\n\n// 递归\nvar maxdepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    let depth = 0;\n    for (let i = 0; i < root.children.length; i++) {\n        depth = math.max(depth, maxdepth(root.children[i]));\n    }\n    return 1 + depth;\n};\n\n\n\n# 打家劫舍iii（dfs）\n\n * leetcode337\n * 每个节点都设置：[不偷, 偷]\n * 当前节点被偷时，其左右孩子不能偷\n * 当前节点未被偷时，其左右孩子可以偷，也可以不偷，取 [不偷, 偷] 的较大者\n\nvar rob = function(root) {\n    let res = dfs(root);\n    return math.max(res[0], res[1]);\n};\n\nfunction dfs(root) {\n    // [不偷, 偷]\n    let res = [0,0];\n    if (root === null) return res;\n    // left 为 root 左侧子节点的[不偷值, 偷值]\n    let left = dfs(root.left); \n  \t// right 为 root 右侧子节点的[不偷值, 偷值]\n    let right = dfs(root.right); \n    // 每一个节点的不偷值都是： 左侧子节点的最大值 + 右侧子节点的最大值\n    res[0] = math.max(...left) + math.max(...right);\n    // 每一个节点的偷值都是：左侧子节点的不偷值 + 右侧子节点的不偷值 + 该节点的值\n    res[1] = root.val + left[0] + right[0];\n    return res;\n}\n',charsets:{cjk:!0}},{title:"贪心",frontmatter:{title:"贪心",date:"2020-10-28T16:00:54.000Z",categories:"算法"},regularPath:"/algorithm/greedy.html",relativePath:"algorithm/greedy.md",key:"v-8bc9b32a",path:"/algorithm/greedy.html",headers:[{level:2,title:"贪心算法",slug:"贪心算法",normalizedTitle:"贪心算法",charIndex:9},{level:2,title:"移掉 k 位数字",slug:"移掉-k-位数字",normalizedTitle:"移掉 k 位数字",charIndex:17},{level:2,title:"非递增顺序的最小子序列",slug:"非递增顺序的最小子序列",normalizedTitle:"非递增顺序的最小子序列",charIndex:29},{level:2,title:"柠檬水找零",slug:"柠檬水找零",normalizedTitle:"柠檬水找零",charIndex:44},{level:2,title:"跳跃游戏",slug:"跳跃游戏",normalizedTitle:"跳跃游戏",charIndex:53},{level:2,title:"加油站",slug:"加油站",normalizedTitle:"加油站",charIndex:61},{level:3,title:"暴力解法",slug:"暴力解法",normalizedTitle:"暴力解法",charIndex:3547},{level:3,title:"贪心解法",slug:"贪心解法",normalizedTitle:"贪心解法",charIndex:4310}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"贪心算法 移掉 k 位数字 非递增顺序的最小子序列 柠檬水找零 跳跃游戏 加油站 暴力解法 贪心解法",content:"# 贪心\n\n * 贪心算法\n * 移掉 k 位数字\n * 非递增顺序的最小子序列\n * 柠檬水找零\n * 跳跃游戏\n * 加油站\n\n\n# 贪心算法\n\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。\n\n**贪心算法一般按如下步骤进行： **\n\n①建立数学模型来描述问题 。\n\n②把求解的问题分成若干个子问题。\n\n③对每个子问题求解，得到子问题的局部最优解 。\n\n④把子问题的解局部最优解合成原来解问题的一个解 。\n\n贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯\n\n\n存在的问题\n\n * 不能保证求得的最后解是最佳的\n * 不能用来求最大值或最小值的问题\n * 只能求满足某些约束条件的可行解的范围\n\n\n# 移掉 k 位数字\n\n具体看 算法-栈 中的最后一题\n\n\n# 非递增顺序的最小子序列\n\n * leetcode1403\n\n给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。\n\n如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。\n\n与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。\n\n注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。\n\n\n示例 1：\n输入：nums = [4,3,10,9,8]\n输出：[10,9] \n解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 \n\n示例 2：\n输入：nums = [4,4,7,6,7]\n输出：[7,7,6] \n解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  \n\n示例 3：\n输入：nums = [6]\n输出：[6]\n\n\n * 数组从大到小排序\n * 取出最大值放入 ans 中，如果不选这个最大值将不是最优解，选了之后继续进行下一步子问题的选择(贪心)\n * 直到取出元素大于所有元素和的一半为止\n\nvar minSubsequence = function(nums) {\n    let sum = 0\n    let tmp = 0\n    let ans = []\n    for (let i of nums) {\n        sum += i\n    }\n    nums.sort((a, b) => b - a)\n    for (let i = 0; i < nums.length; i++) {\n        tmp += nums[i]\n        if (tmp * 2 > sum) {\n            ans = nums.slice(0, i + 1)\n            return ans\n        }\n    }   \n};\n\n\n\n# 柠檬水找零\n\n * leetcode860\n\n> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\n> \n> 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n> \n> 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n> \n> 注意，一开始你手头没有任何零钱。\n> \n> 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n> \n> 示例 1：\n> \n> 输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。\n\n * 贪心算法，每次找钱，总是先找大面额的\n\nvar lemonadeChange = function(bills) {\n    let five = 0, ten = 0\n    for (const bill of bills) {\n        if (bill === 5) {\n            five++\n        } else if (bill === 10) {\n            if (five < 0) {\n                return false\n            } else {\n                five--\n                ten++\n            }\n        } else {\n            if (ten > 0 && five > 0) {\n                ten--\n                five--\n            } else if (five > 3) {\n                five-=3\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n};\n\n\n\n# 跳跃游戏\n\n * leetcode55\n * 题解\n * 思路：从前向后遍历，维护最远跳跃距离\n\n> 给定一个非负整数数组，你最初位于数组的第一个位置。\n> \n> 数组中的每个元素代表你在该位置可以跳跃的最大长度。\n> \n> 判断你是否能够到达最后一个位置。\n> \n> 示例 1:\n> \n> 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:\n> \n> 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n\nvar canJump = function(nums) {\n    let distance = 0\n    for (let i = 0; i < nums.length; i++) {\n        if (i <= distance) {\n            distance = Math.max(distance, i + nums[i])\n            if (distance >= nums.length - 1) {\n                return true\n            }\n        }\n    }\n    return false\n};\n\n\n\n# 加油站\n\n * leetcode134\n\n> 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]\n> \n> 输出: 3\n> \n> 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。\n\n\n# 暴力解法\n\n * 首先计算 gas 与 cost 的差值，例如 gas = [1,2,3,4,5]，cost = [3,4,5,1,2]，sub为 [-2, -2, -2, 3, 3]\n * 其中 sub[i] > 0 才能作为起始点\n * 题目就变为找出sub数组中的索引值 i，从 i 开始轮一圈判断剩余油量大于0直到循环一轮结束\n * 时间复杂度 O(n^2)\n\nvar canCompleteCircuit = function(gas, cost) {\n    let n = gas.length\n    for (let i = 0; i < n; i++) {\n        if (gas[i] - cost[i] >= 0) {\n            let count = gas[i] - cost[i]\n            let pos = (i + 1) % n\n            let flag = true\n            while (pos !== i) {\n                count += gas[pos] - cost[pos]\n                if (count < 0) {\n                    flag = false\n                    break\n                }\n                pos = (pos + 1) % n\n            }\n            if (!flag) continue\n            else return i\n        }\n    }\n    return -1\n};\n\n\n\n# 贪心解法\n\n * 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，则一定可以找到一个解（即索引i），至于为什么可以参考这篇题解，如果小于零直接返回 -1\n * 同样的每个加油站的剩余量sub[i]为gas[i] - cost[i]。\n * i从0开始累加sub[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为小于0说明无法到达，这时起始位置从i+1算起，再从0计算curSum。\n * 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现负数？因为如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。\n * 时间复杂度 O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n  let total = 0; // 总的剩余油料\n  let sub = 0;  // 当前站点的剩余油料\n  let start = 0; // 起始点\n  for(let i = 0; i < gas.length; i++) {\n    sub += gas[i] - cost[i];\n    if (sub < 0) {\n      start = i + 1;\n      sub = 0;\n    }\n    total += gas[i] - cost[i]\n  }\n  return total >= 0 ? start: -1;\n};\n",normalizedContent:"# 贪心\n\n * 贪心算法\n * 移掉 k 位数字\n * 非递增顺序的最小子序列\n * 柠檬水找零\n * 跳跃游戏\n * 加油站\n\n\n# 贪心算法\n\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。\n\n**贪心算法一般按如下步骤进行： **\n\n①建立数学模型来描述问题 。\n\n②把求解的问题分成若干个子问题。\n\n③对每个子问题求解，得到子问题的局部最优解 。\n\n④把子问题的解局部最优解合成原来解问题的一个解 。\n\n贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯\n\n\n存在的问题\n\n * 不能保证求得的最后解是最佳的\n * 不能用来求最大值或最小值的问题\n * 只能求满足某些约束条件的可行解的范围\n\n\n# 移掉 k 位数字\n\n具体看 算法-栈 中的最后一题\n\n\n# 非递增顺序的最小子序列\n\n * leetcode1403\n\n给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。\n\n如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。\n\n与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。\n\n注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。\n\n\n示例 1：\n输入：nums = [4,3,10,9,8]\n输出：[10,9] \n解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 \n\n示例 2：\n输入：nums = [4,4,7,6,7]\n输出：[7,7,6] \n解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  \n\n示例 3：\n输入：nums = [6]\n输出：[6]\n\n\n * 数组从大到小排序\n * 取出最大值放入 ans 中，如果不选这个最大值将不是最优解，选了之后继续进行下一步子问题的选择(贪心)\n * 直到取出元素大于所有元素和的一半为止\n\nvar minsubsequence = function(nums) {\n    let sum = 0\n    let tmp = 0\n    let ans = []\n    for (let i of nums) {\n        sum += i\n    }\n    nums.sort((a, b) => b - a)\n    for (let i = 0; i < nums.length; i++) {\n        tmp += nums[i]\n        if (tmp * 2 > sum) {\n            ans = nums.slice(0, i + 1)\n            return ans\n        }\n    }   \n};\n\n\n\n# 柠檬水找零\n\n * leetcode860\n\n> 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\n> \n> 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n> \n> 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n> \n> 注意，一开始你手头没有任何零钱。\n> \n> 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n> \n> 示例 1：\n> \n> 输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。\n\n * 贪心算法，每次找钱，总是先找大面额的\n\nvar lemonadechange = function(bills) {\n    let five = 0, ten = 0\n    for (const bill of bills) {\n        if (bill === 5) {\n            five++\n        } else if (bill === 10) {\n            if (five < 0) {\n                return false\n            } else {\n                five--\n                ten++\n            }\n        } else {\n            if (ten > 0 && five > 0) {\n                ten--\n                five--\n            } else if (five > 3) {\n                five-=3\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n};\n\n\n\n# 跳跃游戏\n\n * leetcode55\n * 题解\n * 思路：从前向后遍历，维护最远跳跃距离\n\n> 给定一个非负整数数组，你最初位于数组的第一个位置。\n> \n> 数组中的每个元素代表你在该位置可以跳跃的最大长度。\n> \n> 判断你是否能够到达最后一个位置。\n> \n> 示例 1:\n> \n> 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:\n> \n> 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n\nvar canjump = function(nums) {\n    let distance = 0\n    for (let i = 0; i < nums.length; i++) {\n        if (i <= distance) {\n            distance = math.max(distance, i + nums[i])\n            if (distance >= nums.length - 1) {\n                return true\n            }\n        }\n    }\n    return false\n};\n\n\n\n# 加油站\n\n * leetcode134\n\n> 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]\n> \n> 输出: 3\n> \n> 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。\n\n\n# 暴力解法\n\n * 首先计算 gas 与 cost 的差值，例如 gas = [1,2,3,4,5]，cost = [3,4,5,1,2]，sub为 [-2, -2, -2, 3, 3]\n * 其中 sub[i] > 0 才能作为起始点\n * 题目就变为找出sub数组中的索引值 i，从 i 开始轮一圈判断剩余油量大于0直到循环一轮结束\n * 时间复杂度 o(n^2)\n\nvar cancompletecircuit = function(gas, cost) {\n    let n = gas.length\n    for (let i = 0; i < n; i++) {\n        if (gas[i] - cost[i] >= 0) {\n            let count = gas[i] - cost[i]\n            let pos = (i + 1) % n\n            let flag = true\n            while (pos !== i) {\n                count += gas[pos] - cost[pos]\n                if (count < 0) {\n                    flag = false\n                    break\n                }\n                pos = (pos + 1) % n\n            }\n            if (!flag) continue\n            else return i\n        }\n    }\n    return -1\n};\n\n\n\n# 贪心解法\n\n * 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，则一定可以找到一个解（即索引i），至于为什么可以参考这篇题解，如果小于零直接返回 -1\n * 同样的每个加油站的剩余量sub[i]为gas[i] - cost[i]。\n * i从0开始累加sub[i]，和记为cursum，一旦cursum小于零，说明[0, i]区间都不能作为起始位置，因为小于0说明无法到达，这时起始位置从i+1算起，再从0计算cursum。\n * 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现负数？因为如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。\n * 时间复杂度 o(n)\n\nvar cancompletecircuit = function(gas, cost) {\n  let total = 0; // 总的剩余油料\n  let sub = 0;  // 当前站点的剩余油料\n  let start = 0; // 起始点\n  for(let i = 0; i < gas.length; i++) {\n    sub += gas[i] - cost[i];\n    if (sub < 0) {\n      start = i + 1;\n      sub = 0;\n    }\n    total += gas[i] - cost[i]\n  }\n  return total >= 0 ? start: -1;\n};\n",charsets:{cjk:!0}},{title:"链表",frontmatter:{title:"链表",date:"2020-11-13T16:00:54.000Z",categories:"算法"},regularPath:"/algorithm/list.html",relativePath:"algorithm/list.md",key:"v-8eba8a22",path:"/algorithm/list.html",headers:[{level:2,title:"奇偶链表",slug:"奇偶链表",normalizedTitle:"奇偶链表",charIndex:9},{level:2,title:"旋转链表",slug:"旋转链表",normalizedTitle:"旋转链表",charIndex:17},{level:2,title:"两两交换链表元素",slug:"两两交换链表元素",normalizedTitle:"两两交换链表元素",charIndex:25},{level:2,title:"环形链表",slug:"环形链表",normalizedTitle:"环形链表",charIndex:37},{level:2,title:"环形链表2",slug:"环形链表2",normalizedTitle:"环形链表2",charIndex:45},{level:2,title:"删除链表的倒数第n个结点",slug:"删除链表的倒数第n个结点",normalizedTitle:"删除链表的倒数第n个结点",charIndex:54},{level:2,title:"合并两个有序链表",slug:"合并两个有序链表",normalizedTitle:"合并两个有序链表",charIndex:70},{level:2,title:"合并k个有序链表",slug:"合并k个有序链表",normalizedTitle:"合并k个有序链表",charIndex:82},{level:2,title:"链表反转",slug:"链表反转",normalizedTitle:"链表反转",charIndex:94},{level:2,title:"链表中倒数第k个结点",slug:"链表中倒数第k个结点",normalizedTitle:"链表中倒数第k个结点",charIndex:5303},{level:2,title:"排序链表",slug:"排序链表",normalizedTitle:"排序链表",charIndex:117},{level:2,title:"相交链表",slug:"相交链表",normalizedTitle:"相交链表",charIndex:125},{level:2,title:"k个一组反转链表",slug:"k个一组反转链表",normalizedTitle:"k个一组反转链表",charIndex:133}],lastUpdated:"4/14/2023, 5:31:58 PM",lastUpdatedTimestamp:1681464718e3,headersStr:"奇偶链表 旋转链表 两两交换链表元素 环形链表 环形链表2 删除链表的倒数第n个结点 合并两个有序链表 合并k个有序链表 链表反转 链表中倒数第k个结点 排序链表 相交链表 k个一组反转链表",content:"# 链表\n\n * 奇偶链表\n * 旋转链表\n * 两两交换链表元素\n * 环形链表\n * 环形链表2\n * 删除链表的倒数第n个结点\n * 合并两个有序链表\n * 合并k个有序链表\n * 链表反转\n * 输出链表倒数第K个结点\n * 排序链表\n * 相交链表\n * k个一组反转链表\n\n\n# 奇偶链表\n\n * leetcode328\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\n示例 1:\n\n输入: 1->2->3->4->5->NULL\n输出: 1->3->5->2->4->NULL\n示例 2:\n\n输入: 2->1->3->5->6->4->7->NULL \n输出: 2->3->6->7->1->5->4->NULL\n\n\n * 思路：拆分链表再组合\n\nvar oddEvenList = function(head) {\n    if (head === null) return head\n    let odd = head, evenHead = head.next\n    let even = evenHead\n    while (even !== null && even.next !== null) {\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    }\n    odd.next = evenHead\n    return head\n};\n\n\n\n# 旋转链表\n\n * leetcode61\n\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\n\n示例 1:\n输入: 1->2->3->4->5->NULL, k = 2\n输出: 4->5->1->2->3->NULL\n解释:\n向右旋转 1 步: 5->1->2->3->4->NULL\n向右旋转 2 步: 4->5->1->2->3->NULL\n\n示例 2:\n输入: 0->1->2->NULL, k = 4\n输出: 2->0->1->NULL\n解释:\n向右旋转 1 步: 2->0->1->NULL\n向右旋转 2 步: 1->2->0->NULL\n向右旋转 3 步: 0->1->2->NULL\n向右旋转 4 步: 2->0->1->NULL\n\n\n * 思路：成环再打开\n * 遍历链表，找到链尾接环，记录链表长度 n\n * k = k % n ，找到断开位置 n-k\n\nvar rotateRight = function(head, k) {\n    if (head === null) return head\n    let p = head, n = 1\n    while (p.next !== null) {\n        p = p.next\n        n++\n    }\n    p.next = head\n    k = k % n\n    for (let i = 0; i < n-k-1; i++) {\n        head = head.next\n    }\n    let tmp = head\n    head = head.next\n    tmp.next = null\n    return head\n};\n\n\n\n# 两两交换链表元素\n\n * leetcode24\n\n * 题解\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n示例 2：\n输入：head = []\n输出：[]\n\n示例 3：\n输入：head = [1]\n输出：[1]\n\n\nvar swapPairs = function(head) {\n    const dummy = new ListNode(0)\n    dummy.next = head\n    let prev = dummy\n    while (head && head.next) {\n        const next = head.next\n        head.next = next.next\n        next.next = head\n        prev.next = next\n\n        prev = head\n        head = head.next\n    }\n    return dummy.next\n}\n\n\n\n# 环形链表\n\n * leetcode141\n\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n * 快慢指针法\n * 快、慢指针，从头节点出发\n * 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值\n * 如果节点值相同，说明有环。如果不同，继续循环。\n\nvar hasCycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n};\n\n\n// 如果对象中存在循环引用，则 JSON.stringify 报错\nvar hasCycle = function(head) {\n    try {\n        JSON.stringify(head)\n    } catch(e) {\n        return true\n    }\n    return false\n};\n\n\n\n# 环形链表2\n\n * leetcode142\n * 相比上一题需要找到环形入口，具体可参考题解「手画图解+公式推导」链表有环，如何求入环点？\n\nvar detectCycle = function(head) {\n    let fast = head;\n    let slow = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            let slow = head;\n            while (slow !== fast) {\n                slow = slow.next;\n                fast = fast.next;\n            }\n            return slow;\n        }\n    }\n    return null;\n};\n\n\n\n# 删除链表的倒数第n个结点\n\n * leetcode19\n\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n * 思路：双指针，快的先走 n 步，然后两个一起走到最后，慢的就是倒数第 n 个，只遍历了一次\n\nvar removeNthFromEnd = function(head, n) {\n    // 创建头节点, 保证输入为 [1], 1 时不会出现错误，\n    let pre = new ListNode()\n    pre.next = head\n    let slow = pre\n    let fast = pre\n    // fast 先走 n 次\n    for (let i = 0; i < n; i++) {\n        fast = fast.next\n    }\n    // 走到尾部\n    while (fast.next !== null) {\n        slow = slow.next\n        fast = fast.next\n    }\n    // 删除\n    slow.next = slow.next.next\n    // 为什么不直接返回 head，因为 head 可能是被删除的节点\n    return pre.next\n};\n\n\n\n# 合并两个有序链表\n\n * leetcode21\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\nvar mergeTwoLists = function(l1, l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    }\n    else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n};\n\n\n\n# 合并k个有序链表\n\n * leetcode23\n\n给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n示例 1：\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n\n示例 2：\n输入：lists = []\n输出：[]\n\n示例 3：\n输入：lists = [[]]\n输出：[]\n\n\n * 分治：把 k 个链表拆分，利用合并两个链表来操作\n\nvar mergeKLists = function (lists) {\n  if (lists.length === 0) return null\n  if (lists.length === 1) return lists[0]\n  if (lists.length === 2) {\n    return mergeTwoLists(lists[0], lists[1])\n  }\n  \n  const mid = lists.length >> 1\n  const l1 = [], l2 = []\n  for (let i = 0; i < mid; i++) {\n    l1[i] = lists[i];\n  }\n  for (let i = mid, j = 0; i < lists.length; i++, j++) {\n    l2[j] = lists[i]\n  }\n  return mergeTwoLists(mergeKLists(l1), mergeKLists(l2))\n};\n\n\n\n# 链表反转\n\n * 剑指offer24\n\n * 题解\n\nvar reverseList = function(head) {\n    let pre = null\n    let cur = head\n    while (cur) {\n        tmp = cur.next // 暂存后继节点 cur.next\n        cur.next = pre // 修改 next 引用指向\n        pre = cur      // pre 暂存 cur\n        cur = tmp      // cur 访问下一节点\n    }\n    return pre\n};\n\n\n\n# 链表中倒数第k个结点\n\n * 剑指offer22\n\nvar getKthFromEnd = function(head, k) {\n    let arr = []\n    while (head) {\n        arr.unshift(head)\n        head = head.next\n    }\n    return arr[k - 1]\n};\n\n\n\n# 排序链表\n\n * leetcode148\n * 题解\n\n// 合并两个有序链表\nconst mergeTwoLists = function(l1, l2) {\n    if (l1 === null) return l2\n    if (l2 === null) return l1\n    if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}\n\n// 获取中间节点\n// - 如果链表长度为奇数，则返回中间节点\n// - 如果链表长度为偶数，则有两个中间节点，这里返回第一个\nconst middleNode = function(head) {\n    let fast = head, slow = head\n    while(fast.next && fast.next.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n}\n\nvar sortList = function(head) {\n    if (head === null || head.next === null) return head\n    // 获取中间节点\n    let middle = middleNode(head)\n    // 分裂成两个链表\n    let temp = middle.next\n    middle.next = null\n    let left = head, right = temp\n    // 继续分裂（递归分裂）\n    left = sortList(left)\n    right = sortList(right)\n    // 合并两个有序链表\n    return mergeTwoLists(left, right)\n};\n\n\n\n# 相交链表\n\n * leetcode160\n * 题解\n\nvar getIntersectionNode = function(headA, headB) {\n    if (headA === null || headB === null) return null\n    let p = headA, q = headB\n    while (p !== q) {\n        p = p === null ? headB : p.next\n        q = q === null ? headA : q.next\n    }\n    return p\n};\n\n\n\n# k个一组反转链表\n\n * leetcode25\n * 思路和反转链表类似，每K个反转一次\n\nvar reverseKGroup = function(head, k) {\n    let cur = head, count = 0\n    while (cur !== null && count !== k) {\n        cur = cur.next\n        count ++\n    }\n    if (count === k) {\n        pre = reverseKGroup(cur, k)\n        while (count --) {\n            let tmp = head.next\n            head.next = pre\n            pre = head\n            head = tmp\n        }\n        head = pre\n    }\n    return head\n}\n",normalizedContent:"# 链表\n\n * 奇偶链表\n * 旋转链表\n * 两两交换链表元素\n * 环形链表\n * 环形链表2\n * 删除链表的倒数第n个结点\n * 合并两个有序链表\n * 合并k个有序链表\n * 链表反转\n * 输出链表倒数第k个结点\n * 排序链表\n * 相交链表\n * k个一组反转链表\n\n\n# 奇偶链表\n\n * leetcode328\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 o(1)，时间复杂度应为 o(nodes)，nodes 为节点总数。\n\n示例 1:\n\n输入: 1->2->3->4->5->null\n输出: 1->3->5->2->4->null\n示例 2:\n\n输入: 2->1->3->5->6->4->7->null \n输出: 2->3->6->7->1->5->4->null\n\n\n * 思路：拆分链表再组合\n\nvar oddevenlist = function(head) {\n    if (head === null) return head\n    let odd = head, evenhead = head.next\n    let even = evenhead\n    while (even !== null && even.next !== null) {\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    }\n    odd.next = evenhead\n    return head\n};\n\n\n\n# 旋转链表\n\n * leetcode61\n\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\n\n示例 1:\n输入: 1->2->3->4->5->null, k = 2\n输出: 4->5->1->2->3->null\n解释:\n向右旋转 1 步: 5->1->2->3->4->null\n向右旋转 2 步: 4->5->1->2->3->null\n\n示例 2:\n输入: 0->1->2->null, k = 4\n输出: 2->0->1->null\n解释:\n向右旋转 1 步: 2->0->1->null\n向右旋转 2 步: 1->2->0->null\n向右旋转 3 步: 0->1->2->null\n向右旋转 4 步: 2->0->1->null\n\n\n * 思路：成环再打开\n * 遍历链表，找到链尾接环，记录链表长度 n\n * k = k % n ，找到断开位置 n-k\n\nvar rotateright = function(head, k) {\n    if (head === null) return head\n    let p = head, n = 1\n    while (p.next !== null) {\n        p = p.next\n        n++\n    }\n    p.next = head\n    k = k % n\n    for (let i = 0; i < n-k-1; i++) {\n        head = head.next\n    }\n    let tmp = head\n    head = head.next\n    tmp.next = null\n    return head\n};\n\n\n\n# 两两交换链表元素\n\n * leetcode24\n\n * 题解\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n示例 2：\n输入：head = []\n输出：[]\n\n示例 3：\n输入：head = [1]\n输出：[1]\n\n\nvar swappairs = function(head) {\n    const dummy = new listnode(0)\n    dummy.next = head\n    let prev = dummy\n    while (head && head.next) {\n        const next = head.next\n        head.next = next.next\n        next.next = head\n        prev.next = next\n\n        prev = head\n        head = head.next\n    }\n    return dummy.next\n}\n\n\n\n# 环形链表\n\n * leetcode141\n\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n * 快慢指针法\n * 快、慢指针，从头节点出发\n * 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值\n * 如果节点值相同，说明有环。如果不同，继续循环。\n\nvar hascycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n};\n\n\n// 如果对象中存在循环引用，则 json.stringify 报错\nvar hascycle = function(head) {\n    try {\n        json.stringify(head)\n    } catch(e) {\n        return true\n    }\n    return false\n};\n\n\n\n# 环形链表2\n\n * leetcode142\n * 相比上一题需要找到环形入口，具体可参考题解「手画图解+公式推导」链表有环，如何求入环点？\n\nvar detectcycle = function(head) {\n    let fast = head;\n    let slow = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            let slow = head;\n            while (slow !== fast) {\n                slow = slow.next;\n                fast = fast.next;\n            }\n            return slow;\n        }\n    }\n    return null;\n};\n\n\n\n# 删除链表的倒数第n个结点\n\n * leetcode19\n\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n * 思路：双指针，快的先走 n 步，然后两个一起走到最后，慢的就是倒数第 n 个，只遍历了一次\n\nvar removenthfromend = function(head, n) {\n    // 创建头节点, 保证输入为 [1], 1 时不会出现错误，\n    let pre = new listnode()\n    pre.next = head\n    let slow = pre\n    let fast = pre\n    // fast 先走 n 次\n    for (let i = 0; i < n; i++) {\n        fast = fast.next\n    }\n    // 走到尾部\n    while (fast.next !== null) {\n        slow = slow.next\n        fast = fast.next\n    }\n    // 删除\n    slow.next = slow.next.next\n    // 为什么不直接返回 head，因为 head 可能是被删除的节点\n    return pre.next\n};\n\n\n\n# 合并两个有序链表\n\n * leetcode21\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\nvar mergetwolists = function(l1, l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    if (l1.val < l2.val) {\n        l1.next = mergetwolists(l1.next, l2);\n        return l1;\n    }\n    else {\n        l2.next = mergetwolists(l1, l2.next);\n        return l2;\n    }\n};\n\n\n\n# 合并k个有序链表\n\n * leetcode23\n\n给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n示例 1：\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n\n示例 2：\n输入：lists = []\n输出：[]\n\n示例 3：\n输入：lists = [[]]\n输出：[]\n\n\n * 分治：把 k 个链表拆分，利用合并两个链表来操作\n\nvar mergeklists = function (lists) {\n  if (lists.length === 0) return null\n  if (lists.length === 1) return lists[0]\n  if (lists.length === 2) {\n    return mergetwolists(lists[0], lists[1])\n  }\n  \n  const mid = lists.length >> 1\n  const l1 = [], l2 = []\n  for (let i = 0; i < mid; i++) {\n    l1[i] = lists[i];\n  }\n  for (let i = mid, j = 0; i < lists.length; i++, j++) {\n    l2[j] = lists[i]\n  }\n  return mergetwolists(mergeklists(l1), mergeklists(l2))\n};\n\n\n\n# 链表反转\n\n * 剑指offer24\n\n * 题解\n\nvar reverselist = function(head) {\n    let pre = null\n    let cur = head\n    while (cur) {\n        tmp = cur.next // 暂存后继节点 cur.next\n        cur.next = pre // 修改 next 引用指向\n        pre = cur      // pre 暂存 cur\n        cur = tmp      // cur 访问下一节点\n    }\n    return pre\n};\n\n\n\n# 链表中倒数第k个结点\n\n * 剑指offer22\n\nvar getkthfromend = function(head, k) {\n    let arr = []\n    while (head) {\n        arr.unshift(head)\n        head = head.next\n    }\n    return arr[k - 1]\n};\n\n\n\n# 排序链表\n\n * leetcode148\n * 题解\n\n// 合并两个有序链表\nconst mergetwolists = function(l1, l2) {\n    if (l1 === null) return l2\n    if (l2 === null) return l1\n    if (l1.val < l2.val) {\n        l1.next = mergetwolists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergetwolists(l1, l2.next)\n        return l2\n    }\n}\n\n// 获取中间节点\n// - 如果链表长度为奇数，则返回中间节点\n// - 如果链表长度为偶数，则有两个中间节点，这里返回第一个\nconst middlenode = function(head) {\n    let fast = head, slow = head\n    while(fast.next && fast.next.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n}\n\nvar sortlist = function(head) {\n    if (head === null || head.next === null) return head\n    // 获取中间节点\n    let middle = middlenode(head)\n    // 分裂成两个链表\n    let temp = middle.next\n    middle.next = null\n    let left = head, right = temp\n    // 继续分裂（递归分裂）\n    left = sortlist(left)\n    right = sortlist(right)\n    // 合并两个有序链表\n    return mergetwolists(left, right)\n};\n\n\n\n# 相交链表\n\n * leetcode160\n * 题解\n\nvar getintersectionnode = function(heada, headb) {\n    if (heada === null || headb === null) return null\n    let p = heada, q = headb\n    while (p !== q) {\n        p = p === null ? headb : p.next\n        q = q === null ? heada : q.next\n    }\n    return p\n};\n\n\n\n# k个一组反转链表\n\n * leetcode25\n * 思路和反转链表类似，每k个反转一次\n\nvar reversekgroup = function(head, k) {\n    let cur = head, count = 0\n    while (cur !== null && count !== k) {\n        cur = cur.next\n        count ++\n    }\n    if (count === k) {\n        pre = reversekgroup(cur, k)\n        while (count --) {\n            let tmp = head.next\n            head.next = pre\n            pre = head\n            head = tmp\n        }\n        head = pre\n    }\n    return head\n}\n",charsets:{cjk:!0}},{title:"字符串操作",frontmatter:{title:"字符串操作",date:"2020-11-10T16:00:54.000Z",categories:"算法"},regularPath:"/algorithm/string.html",relativePath:"algorithm/string.md",key:"v-a9b7d16e",path:"/algorithm/string.html",headers:[{level:2,title:"下一个排列",slug:"下一个排列",normalizedTitle:"下一个排列",charIndex:12},{level:2,title:"对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'",slug:"对输入的字符串-去除其中的字符-b-以及连续出现的-a-和-c",normalizedTitle:"对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'",charIndex:21},{level:2,title:"外观数列",slug:"外观数列",normalizedTitle:"外观数列",charIndex:57},{level:3,title:"正则表达式：\\1捕获",slug:"正则表达式-1捕获",normalizedTitle:"正则表达式：\\1捕获",charIndex:1572},{level:3,title:"外观数列",slug:"外观数列-2",normalizedTitle:"外观数列",charIndex:57},{level:2,title:"算法：最长公共前缀4",slug:"算法-最长公共前缀4",normalizedTitle:"算法：最长公共前缀4",charIndex:2243},{level:2,title:"字符串的最大非重复子串长度",slug:"字符串的最大非重复子串长度",normalizedTitle:"字符串的最大非重复子串长度",charIndex:75},{level:2,title:"重复的子字符串",slug:"重复的子字符串",normalizedTitle:"重复的子字符串",charIndex:92},{level:2,title:"参数分解",slug:"参数分解",normalizedTitle:"参数分解",charIndex:103},{level:2,title:"字符串解码",slug:"字符串解码",normalizedTitle:"字符串解码",charIndex:111},{level:2,title:"字符串相加",slug:"字符串相加",normalizedTitle:"字符串相加",charIndex:120},{level:2,title:"比较版本号",slug:"比较版本号",normalizedTitle:"比较版本号",charIndex:129},{level:2,title:"z字形变换",slug:"z字形变换",normalizedTitle:"z字形变换",charIndex:6402}],lastUpdated:"4/26/2023, 3:48:58 PM",lastUpdatedTimestamp:1682495338e3,headersStr:"下一个排列 对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c' 外观数列 正则表达式：\\1捕获 外观数列 算法：最长公共前缀4 字符串的最大非重复子串长度 重复的子字符串 参数分解 字符串解码 字符串相加 比较版本号 z字形变换",content:'# 字符串操作\n\n * 下一个排列\n * 对输入的字符串，去除其中的字符\'b\'以及连续出现的\'a\'和\'c\'\n * 外观数列\n * 最长公共前缀\n * 字符串的最大非重复子串长度\n * 重复的子字符串\n * 参数分解\n * 字符串解码\n * 字符串相加\n * 比较版本号\n * z字型变换\n\n\n# 下一个排列\n\n * 题目来源：leetcode31\n\n * 参考题解：思路最清晰的题解\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n\n * 分析：就相当于找一个比当前数大并且最小的一个，比如比123大的有132,213,231,321,312，但是最小的是132\n * 思路：\n   * 从后向前遍历，找到nums[i] < nums[i+1]的数，记录下i需要交换\n   * 交换的对象应该是比他大但是最小的一个，只需从后向前遍历找即可，因为i后面已经是降序\n   * 交换后打乱了序列，应该将 i 后面的序列重新排序\n   * 注意题目要求，只能在原数组上改，用 nums = nums.concat的一些操作会有问题，最好还是用splice,push,unshift这些修改原数组的方法\n\n// 1234654\nvar nextPermutation = function(nums) {\n    let flag = false;\n    for (let i = nums.length - 2; i >= 0; i--) {\n        if (nums[i] < nums[i + 1]) {\n            flag = true;\n            for (let j = nums.length - 1; j > i; j--) {\n                if (nums[j] > nums[i]) {\n                    [nums[i], nums[j]] = [nums[j], nums[i]];\n                    break;\n                }\n            }\n            const head = nums.splice(0, i + 1);\n            nums.sort((a, b) => a - b);\n            for (let i = head.length - 1; i >= 0 ; i--) {\n                nums.unshift(head[i]);\n            }\n            break;\n        }\n    }\n    if (!flag) nums.reverse();\n};\n\n\n\n# 对输入的字符串，去除其中的字符\'b\'以及连续出现的\'a\'和\'c\'\n\n\'aacbd\' => \'ad\'\n\'aabcd\' => \'ad\'\n\'aaabbccc\' => \'\'\n\n\n * 正则解决\n\nfunction fn(str){\n    let res= str.replace(/b+/g,\'\')\n    while(res.match(/(ac)+/)){\n        res = res.replace(/ac/,\'\')\n    }\n    return res\n}\n\n\n\n# 外观数列\n\n\n# 正则表达式：\\1捕获\n\n> \\1表示匹配第一个括号里的内容\n> \n> 利用这个\\1，可以获取一个长字符串中的最长相同子串\n\n\t//寻找连续相同的最长子串\n\tvar str = "ABCCCDDDDDEFFFFFFFFFFFFGGGGHHIIII";\n\tvar reg = /(\\w)\\1+/g;\n\tvar arr = str.match(reg);\n\tconsole.log(arr) // ["CCC", "DDDDD", "FFFFFFFFFFFF", "GGGG", "HH", "IIII"]\n\n\n\n# 外观数列\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n\n给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。\n\n\n * 利用正则表达式\n\nvar countAndSay = function(n) {\n    let pre = \'1\'\n    for(let i=1;i<n;i++){\n        pre = pre.replace(/(\\d)\\1*/g, item =>`${item.length}${item[0]}`)\n    }\n    return pre\n};\n\n//  \\1*代表出现任意次\n// ${}代表字符串拼接\n// replace第二个参数为函数例如\n\nvar str1 = \'abbcbca\'\nstr1.replace(/(b)/g,item => item+\'*\')  //ab*b*cb*ca\n\n\n\n# 算法：最长公共前缀4\n\n * leetcode14\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n示例 1:\n\n输入: ["flower","flow","flight"]\n输出: "fl"\n\n输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n\n\n * 当字符串数组长度为 0 时则公共前缀为空，直接返回\n * 令最长公共前缀 ans 的值为第一个字符串，进行初始化\n * 遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀\n * 如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回\n * 时间复杂度：O(s)，s 为所有字符串的长度之和\n\nvar longestCommonPrefix = function(strs) {\n    if (!strs.length) return ""\n    let ans = strs[0]\n    for (let i = 1; i < strs.length; i++) {\n        for (let j = 0; j < ans.length; j++) {\n            if (ans[j] !== strs[i][j]) {\n                ans = ans.slice(0, j)\n            }\n        }\n    }\n    return ans\n};\n\n\n\n# 字符串的最大非重复子串长度\n\njs中，因为Array继承Object，那么Array也是可以用字符串作为数组下标的 ，c++可以，写一个参考的C++解法\n\nint lengthOfLongestSubstring(string s) {\n        vector dict(256, -1);\n        int maxLen = 0, start = -1;\n        for (int i = 0; i != s.length(); i++) {\n            if (dict[s[i]] > start)//当前字符“曾经”是否出现在此子串中？\n                start = dict[s[i]];//“曾经”出现那次作为新起点\n            dict[s[i]] = i;//标志该字符出现的位置\n            maxLen = max(maxLen, i - start);//每次都要更新最大长度\n        }\n        return maxLen;\n}\n\n\n例如：a,b,c,d,a,b,a 输出4\n\n无重复：a,b,c,d\n\na重复了：把上一个a之前的清除，现在b,c,d,a\n\nb重复了：把上一个b之前的清除，现在c,d,a,b\n\na重复了：现在b,a\n\n\n# 重复的子字符串\n\n * leetcode459\n\nvar repeatedSubstringPattern = function(s) {\n    if (s.length === 1) return false\n    for (let i = 0; i < s.length / 2; i++) {\n        const substr = s.slice(0, i + 1)\n        const count = s.length / substr.length\n        if (count === Math.floor(count)) {\n            let str = ""\n            for (let i = 0; i < count; i++) {\n                str += substr\n            }\n            if (str === s) return true\n        }\n    }\n    return false\n};\n\n\n * 简单解法\n\nvar repeatedSubstringPattern = function(s) {\n    let str = s + s\n    return str.slice(1, str.length - 1).includes(s)\n};\n\n\n\n# 参数分解\n\nlet str = "x=1&&y=2&&y=3&&z=4&&y=4"\n\n//输出\n// obj = {\n//     x:1,\n//     y:[2,3],\n//     z:4\n// }\n\nlet tmp = str.split("&&")\nlet left = []\nlet right = []\nfor(let i in tmp){\n    left.push(tmp[i].split("=")[0])\n    right.push(tmp[i].split("=")[1])\n}\nconsole.log(left,right)\nlet res = new Object()\nfor(let i in left){\n    if(res.hasOwnProperty(left[i])){//如果包含重复元素\n        if(Array.isArray(res[left[i]])){//如果已经是数组就直接添加\n            res[left[i]].push(right[i])\n        }else{//如果不是数组则构造成数组\n            let tmp = new Array(res[left[i]])\n            tmp.push(right[i])   //push的返回值为push的值\n            res[left[i]] = tmp\n        }    \n    }else{\n        res[left[i]] = right[i]\n    }   \n}\n\n\n\n# 字符串解码\n\n * leetcode394\n\n示例 1：\n输入：s = "3[a]2[bc]"\n输出："aaabcbc"\n\n示例 2：\n输入：s = "3[a2[c]]"\n输出："accaccacc"\n\n示例 3：\n输入：s = "2[abc]3[cd]ef"\n输出："abcabccdcdcdef"\n\n示例 4：\n输入：s = "abc3[cd]xyz"\n输出："abccdcdcdxyz"\n\n\n * 采用正则表达式将3[a] 的格式转换成aaa即可\n * 匹配到3[a]之后，找到[的位置，前面为数字，后面为字符，按次数拼接\n\nvar decodeString = function(s) {\n    const reg = /\\d+\\[[a-z]+\\]/g\n    while (reg.test(s)) {\n        s = s.replace(reg, item => {\n            let pos  = item.indexOf(\'[\') ,number = item.slice(0, pos)\n            let str = item.slice(pos + 1, item.length - 1), res = \'\'\n            for (let i = 0; i < number; i++) res += str\n            return res\n        })\n    }\n    return s\n};\n\n\n\n# 字符串相加\n\n * leetcode415\n\nvar addStrings = function(num1, num2) {\n   \tlet i = num1.length - 1,\n        j = num2.length - 1,\n        carry = 0,\n        res = ""\n    while (i >= 0 || j >= 0 || carry > 0) {\n        let c1 = num1[i] ? num1[i] - \'0\' : 0,\n            c2 = num2[j] ? num2[j] - \'0\' : 0\n            sum = (c1 + c2 + carry) % 10\n        carry = Math.floor((c1 + c2 + carry) / 10)\n        res = sum + res\n        i--\n        j--\n    }\n    return res\n};\n\n\n\n# 比较版本号\n\n * leetcode165\n\nvar compareVersion = function(version1, version2) {\n    let arr1 = version1.split(".")\n    let arr2 = version2.split(".")\n    let len = Math.max(arr1.length, arr2.length)\n    for (let i = 0; i < len; i++) {\n        let data1 = ~~arr1[i]\n        let data2 = ~~arr2[i]\n        if (data1 < data2) {\n            return -1\n        } else if (data1 > data2) {\n            return 1\n        }\n    }\n    return 0\n};\n\n~~undefined // 0\n~~001 === ~~ 01 //true\n\n\nJS按位非运算符(~)及双非(~~)的使用\n\n\n# z字形变换\n\n * leetcode6\n\n * 题解\n\nvar convert = function(s, numRows) {\n    if (numRows === 1) return s\n    const n = 2 * numRows - 2\n    const arr = new Array(n).fill("")\n    for (let i = 0; i < s.length; i++) {\n        let x = i % n\n        arr[x < numRows ? x : n - x] += s[i]\n    }\n    return arr.join("")\n};\n',normalizedContent:'# 字符串操作\n\n * 下一个排列\n * 对输入的字符串，去除其中的字符\'b\'以及连续出现的\'a\'和\'c\'\n * 外观数列\n * 最长公共前缀\n * 字符串的最大非重复子串长度\n * 重复的子字符串\n * 参数分解\n * 字符串解码\n * 字符串相加\n * 比较版本号\n * z字型变换\n\n\n# 下一个排列\n\n * 题目来源：leetcode31\n\n * 参考题解：思路最清晰的题解\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n\n * 分析：就相当于找一个比当前数大并且最小的一个，比如比123大的有132,213,231,321,312，但是最小的是132\n * 思路：\n   * 从后向前遍历，找到nums[i] < nums[i+1]的数，记录下i需要交换\n   * 交换的对象应该是比他大但是最小的一个，只需从后向前遍历找即可，因为i后面已经是降序\n   * 交换后打乱了序列，应该将 i 后面的序列重新排序\n   * 注意题目要求，只能在原数组上改，用 nums = nums.concat的一些操作会有问题，最好还是用splice,push,unshift这些修改原数组的方法\n\n// 1234654\nvar nextpermutation = function(nums) {\n    let flag = false;\n    for (let i = nums.length - 2; i >= 0; i--) {\n        if (nums[i] < nums[i + 1]) {\n            flag = true;\n            for (let j = nums.length - 1; j > i; j--) {\n                if (nums[j] > nums[i]) {\n                    [nums[i], nums[j]] = [nums[j], nums[i]];\n                    break;\n                }\n            }\n            const head = nums.splice(0, i + 1);\n            nums.sort((a, b) => a - b);\n            for (let i = head.length - 1; i >= 0 ; i--) {\n                nums.unshift(head[i]);\n            }\n            break;\n        }\n    }\n    if (!flag) nums.reverse();\n};\n\n\n\n# 对输入的字符串，去除其中的字符\'b\'以及连续出现的\'a\'和\'c\'\n\n\'aacbd\' => \'ad\'\n\'aabcd\' => \'ad\'\n\'aaabbccc\' => \'\'\n\n\n * 正则解决\n\nfunction fn(str){\n    let res= str.replace(/b+/g,\'\')\n    while(res.match(/(ac)+/)){\n        res = res.replace(/ac/,\'\')\n    }\n    return res\n}\n\n\n\n# 外观数列\n\n\n# 正则表达式：\\1捕获\n\n> \\1表示匹配第一个括号里的内容\n> \n> 利用这个\\1，可以获取一个长字符串中的最长相同子串\n\n\t//寻找连续相同的最长子串\n\tvar str = "abcccdddddeffffffffffffgggghhiiii";\n\tvar reg = /(\\w)\\1+/g;\n\tvar arr = str.match(reg);\n\tconsole.log(arr) // ["ccc", "ddddd", "ffffffffffff", "gggg", "hh", "iiii"]\n\n\n\n# 外观数列\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n\n给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。\n\n\n * 利用正则表达式\n\nvar countandsay = function(n) {\n    let pre = \'1\'\n    for(let i=1;i<n;i++){\n        pre = pre.replace(/(\\d)\\1*/g, item =>`${item.length}${item[0]}`)\n    }\n    return pre\n};\n\n//  \\1*代表出现任意次\n// ${}代表字符串拼接\n// replace第二个参数为函数例如\n\nvar str1 = \'abbcbca\'\nstr1.replace(/(b)/g,item => item+\'*\')  //ab*b*cb*ca\n\n\n\n# 算法：最长公共前缀4\n\n * leetcode14\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n示例 1:\n\n输入: ["flower","flow","flight"]\n输出: "fl"\n\n输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n\n\n * 当字符串数组长度为 0 时则公共前缀为空，直接返回\n * 令最长公共前缀 ans 的值为第一个字符串，进行初始化\n * 遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀\n * 如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回\n * 时间复杂度：o(s)，s 为所有字符串的长度之和\n\nvar longestcommonprefix = function(strs) {\n    if (!strs.length) return ""\n    let ans = strs[0]\n    for (let i = 1; i < strs.length; i++) {\n        for (let j = 0; j < ans.length; j++) {\n            if (ans[j] !== strs[i][j]) {\n                ans = ans.slice(0, j)\n            }\n        }\n    }\n    return ans\n};\n\n\n\n# 字符串的最大非重复子串长度\n\njs中，因为array继承object，那么array也是可以用字符串作为数组下标的 ，c++可以，写一个参考的c++解法\n\nint lengthoflongestsubstring(string s) {\n        vector dict(256, -1);\n        int maxlen = 0, start = -1;\n        for (int i = 0; i != s.length(); i++) {\n            if (dict[s[i]] > start)//当前字符“曾经”是否出现在此子串中？\n                start = dict[s[i]];//“曾经”出现那次作为新起点\n            dict[s[i]] = i;//标志该字符出现的位置\n            maxlen = max(maxlen, i - start);//每次都要更新最大长度\n        }\n        return maxlen;\n}\n\n\n例如：a,b,c,d,a,b,a 输出4\n\n无重复：a,b,c,d\n\na重复了：把上一个a之前的清除，现在b,c,d,a\n\nb重复了：把上一个b之前的清除，现在c,d,a,b\n\na重复了：现在b,a\n\n\n# 重复的子字符串\n\n * leetcode459\n\nvar repeatedsubstringpattern = function(s) {\n    if (s.length === 1) return false\n    for (let i = 0; i < s.length / 2; i++) {\n        const substr = s.slice(0, i + 1)\n        const count = s.length / substr.length\n        if (count === math.floor(count)) {\n            let str = ""\n            for (let i = 0; i < count; i++) {\n                str += substr\n            }\n            if (str === s) return true\n        }\n    }\n    return false\n};\n\n\n * 简单解法\n\nvar repeatedsubstringpattern = function(s) {\n    let str = s + s\n    return str.slice(1, str.length - 1).includes(s)\n};\n\n\n\n# 参数分解\n\nlet str = "x=1&&y=2&&y=3&&z=4&&y=4"\n\n//输出\n// obj = {\n//     x:1,\n//     y:[2,3],\n//     z:4\n// }\n\nlet tmp = str.split("&&")\nlet left = []\nlet right = []\nfor(let i in tmp){\n    left.push(tmp[i].split("=")[0])\n    right.push(tmp[i].split("=")[1])\n}\nconsole.log(left,right)\nlet res = new object()\nfor(let i in left){\n    if(res.hasownproperty(left[i])){//如果包含重复元素\n        if(array.isarray(res[left[i]])){//如果已经是数组就直接添加\n            res[left[i]].push(right[i])\n        }else{//如果不是数组则构造成数组\n            let tmp = new array(res[left[i]])\n            tmp.push(right[i])   //push的返回值为push的值\n            res[left[i]] = tmp\n        }    \n    }else{\n        res[left[i]] = right[i]\n    }   \n}\n\n\n\n# 字符串解码\n\n * leetcode394\n\n示例 1：\n输入：s = "3[a]2[bc]"\n输出："aaabcbc"\n\n示例 2：\n输入：s = "3[a2[c]]"\n输出："accaccacc"\n\n示例 3：\n输入：s = "2[abc]3[cd]ef"\n输出："abcabccdcdcdef"\n\n示例 4：\n输入：s = "abc3[cd]xyz"\n输出："abccdcdcdxyz"\n\n\n * 采用正则表达式将3[a] 的格式转换成aaa即可\n * 匹配到3[a]之后，找到[的位置，前面为数字，后面为字符，按次数拼接\n\nvar decodestring = function(s) {\n    const reg = /\\d+\\[[a-z]+\\]/g\n    while (reg.test(s)) {\n        s = s.replace(reg, item => {\n            let pos  = item.indexof(\'[\') ,number = item.slice(0, pos)\n            let str = item.slice(pos + 1, item.length - 1), res = \'\'\n            for (let i = 0; i < number; i++) res += str\n            return res\n        })\n    }\n    return s\n};\n\n\n\n# 字符串相加\n\n * leetcode415\n\nvar addstrings = function(num1, num2) {\n   \tlet i = num1.length - 1,\n        j = num2.length - 1,\n        carry = 0,\n        res = ""\n    while (i >= 0 || j >= 0 || carry > 0) {\n        let c1 = num1[i] ? num1[i] - \'0\' : 0,\n            c2 = num2[j] ? num2[j] - \'0\' : 0\n            sum = (c1 + c2 + carry) % 10\n        carry = math.floor((c1 + c2 + carry) / 10)\n        res = sum + res\n        i--\n        j--\n    }\n    return res\n};\n\n\n\n# 比较版本号\n\n * leetcode165\n\nvar compareversion = function(version1, version2) {\n    let arr1 = version1.split(".")\n    let arr2 = version2.split(".")\n    let len = math.max(arr1.length, arr2.length)\n    for (let i = 0; i < len; i++) {\n        let data1 = ~~arr1[i]\n        let data2 = ~~arr2[i]\n        if (data1 < data2) {\n            return -1\n        } else if (data1 > data2) {\n            return 1\n        }\n    }\n    return 0\n};\n\n~~undefined // 0\n~~001 === ~~ 01 //true\n\n\njs按位非运算符(~)及双非(~~)的使用\n\n\n# z字形变换\n\n * leetcode6\n\n * 题解\n\nvar convert = function(s, numrows) {\n    if (numrows === 1) return s\n    const n = 2 * numrows - 2\n    const arr = new array(n).fill("")\n    for (let i = 0; i < s.length; i++) {\n        let x = i % n\n        arr[x < numrows ? x : n - x] += s[i]\n    }\n    return arr.join("")\n};\n',charsets:{cjk:!0}},{title:"场景题",frontmatter:{title:"场景题",date:"2020-10-29T09:52:01.000Z",categories:"算法"},regularPath:"/algorithm/scene.html",relativePath:"algorithm/scene.md",key:"v-efe7e982",path:"/algorithm/scene.html",headers:[{level:2,title:"LRU缓存机制",slug:"lru缓存机制",normalizedTitle:"lru缓存机制",charIndex:10}],lastUpdated:"2/9/2023, 7:49:33 PM",lastUpdatedTimestamp:1675943373e3,headersStr:"LRU缓存机制",content:"# 场景题\n\n * LRU缓存机制\n\n\n# LRU缓存机制\n\n * leetcode146\n\n * 题解：利用Map对于set的数值为顺序插入的原理实现LRU\n\n// 1. 新数据插入到链表头部；\n// 2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；\n// 3. 当链表满的时候，将链表尾部的数据丢弃。\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.map = new Map()\n    }\n    get(key) {\n        let val = this.map.get(key)\n        if (val === undefined) return -1\n        this.map.delete(key)\n        this.map.set(key, val)\n        return val\n    }\n    put(key, val) {\n        if (this.map.has(key)) this.map.delete(key)\n        this.map.set(key, val)\n        if (this.map.size > this.capacity) {\n            this.map.delete(this.map.entries().next().value[0])\n        }\n    }\n}\n\n// 关于 map\nconst map = new Map([\n    [1, 'a'],\n    [2, 'b'],\n    [3, 'c']\n])\nmap.entries() // MapIterator {1 => \"a\", 2 => \"b\", 3 => \"c\"}\nmap.entries().next() // {value: Array(2), done: false}\nmap.entries().next().value[0] // 1\n",normalizedContent:"# 场景题\n\n * lru缓存机制\n\n\n# lru缓存机制\n\n * leetcode146\n\n * 题解：利用map对于set的数值为顺序插入的原理实现lru\n\n// 1. 新数据插入到链表头部；\n// 2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；\n// 3. 当链表满的时候，将链表尾部的数据丢弃。\nclass lrucache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.map = new map()\n    }\n    get(key) {\n        let val = this.map.get(key)\n        if (val === undefined) return -1\n        this.map.delete(key)\n        this.map.set(key, val)\n        return val\n    }\n    put(key, val) {\n        if (this.map.has(key)) this.map.delete(key)\n        this.map.set(key, val)\n        if (this.map.size > this.capacity) {\n            this.map.delete(this.map.entries().next().value[0])\n        }\n    }\n}\n\n// 关于 map\nconst map = new map([\n    [1, 'a'],\n    [2, 'b'],\n    [3, 'c']\n])\nmap.entries() // mapiterator {1 => \"a\", 2 => \"b\", 3 => \"c\"}\nmap.entries().next() // {value: array(2), done: false}\nmap.entries().next().value[0] // 1\n",charsets:{cjk:!0}},{title:"回溯算法",frontmatter:{},regularPath:"/algorithm/trace.html",relativePath:"algorithm/trace.md",key:"v-da398842",path:"/algorithm/trace.html",headers:[{level:2,title:"回溯算法",slug:"回溯算法-2",normalizedTitle:"回溯算法",charIndex:2},{level:2,title:"全排列",slug:"全排列",normalizedTitle:"全排列",charIndex:11},{level:2,title:"括号生成",slug:"括号生成",normalizedTitle:"括号生成",charIndex:18},{level:2,title:"电话号码的数字组合",slug:"电话号码的数字组合",normalizedTitle:"电话号码的数字组合",charIndex:26},{level:2,title:"子集",slug:"子集",normalizedTitle:"子集",charIndex:39},{level:2,title:"子集II",slug:"子集ii",normalizedTitle:"子集ii",charIndex:3260},{level:2,title:"二维数组全排列",slug:"二维数组全排列",normalizedTitle:"二维数组全排列",charIndex:45},{level:2,title:"组合总和",slug:"组合总和",normalizedTitle:"组合总和",charIndex:56},{level:2,title:"组合总和II",slug:"组合总和ii",normalizedTitle:"组合总和ii",charIndex:64},{level:2,title:"从数组中找n个数求和",slug:"从数组中找n个数求和",normalizedTitle:"从数组中找n个数求和",charIndex:5973},{level:2,title:"单词搜索",slug:"单词搜索",normalizedTitle:"单词搜索",charIndex:74},{level:2,title:"三角形的最小路径和",slug:"三角形的最小路径和",normalizedTitle:"三角形的最小路径和",charIndex:82},{level:2,title:"路径总和",slug:"路径总和",normalizedTitle:"路径总和",charIndex:95},{level:2,title:"路径总和II",slug:"路径总和ii",normalizedTitle:"路径总和ii",charIndex:103},{level:2,title:"根节点到叶节点数字之和",slug:"根节点到叶节点数字之和",normalizedTitle:"根节点到叶节点数字之和",charIndex:113},{level:2,title:"变式",slug:"变式",normalizedTitle:"变式",charIndex:10840}],lastUpdated:"6/25/2025, 8:09:31 PM",lastUpdatedTimestamp:1750853371e3,headersStr:"回溯算法 全排列 括号生成 电话号码的数字组合 子集 子集II 二维数组全排列 组合总和 组合总和II 从数组中找n个数求和 单词搜索 三角形的最小路径和 路径总和 路径总和II 根节点到叶节点数字之和 变式",content:"# 回溯算法\n\n * 全排列\n * 括号生成\n * 电话号码的数字组合\n * 子集\n * 二维数组全排列\n * 组合总和\n * 组合总和II\n * 单词搜索\n * 三角形的最小路径和\n * 路径总和\n * 路径总和II\n * 根节点到叶节点数字之和\n\n\n# 回溯算法\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程。基本原理就是递归，用白话解释就是：**从一条路往前走，能进则进，不能进则退回来，换一条路再试。**只需要思考 3 个问题：\n\n1、路径：也就是已经做出的选择。\n\n2、选择列表：也就是你当前可以做的选择。\n\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n\n代码方面，回溯算法的框架：\n\nresult = []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」\n\n> 递归，回溯，DFS的区别\n> \n> 递归就是在函数中调用函数本身来解决问题\n> \n> 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”\n> \n> 回溯搜索是深度优先搜索（DFS）的一种，回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n\n\n# 全排列\n\n * Leetcode46\n\n 给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n \n 示例:\n 输入: [1,2,3]\n 输出:\n [\n [1,2,3],\n [1,3,2],\n [2,1,3],\n [2,3,1],\n [3,1,2],\n [3,2,1]\n]\n\n\n我们要在这个包含解的空间树上，用 递归的方式搜索出所有的解。\n\nvar permute = function(nums) {\n    const res = [];\n    const fn = (path) => {\n        if (path.length === nums.length) {\n            // slice 的原因是防止 push 到 res 中的结果是引用类型，后面 path 改变时会影响 res\n            res.push(path.slice());\n        }\n        for (const item of nums) {\n            if (path.includes(item)) {\n                continue;\n            }\n            path.push(item); // 比如目前 path 是 [1]，push(2), 变成 [1, 2]\n            fn(path); // 递归到头了：[1,2,3] 就 return \n            path.pop(); // [1,2] pop 变为 [1]， 继续下一轮 for 循环, push(3)\n        }\n    }\n    fn([]);\n    return res;\n};\n\n\n\n# 括号生成\n\n * leetcode22\n * 题解\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n示例：\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n\n\nvar generateParenthesis = function(n) {\n    const res = [];\n    const backtrack = (left, right, path) => {\n        if (path.length === 2 * n) {\n            res.push(path);\n            return;\n        }\n        if (left > 0) {\n            backtrack(left - 1, right, path + '(');\n        }\n        if (right > left) {\n            backtrack(left, right - 1, path + ')');\n        }\n    }\n    backtrack(n, n, '');\n    return res;\n};\n\n\n\n# 电话号码的数字组合\n\n * leetcode17\n\n * 题解\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例:\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n\nvar letterCombinations = function(digits) {\n    if (!digits.length) {\n        return [];\n    }\n    const map = {2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz'};\n    const res = [];\n    const backtrack = (path, i) => {\n        if (path.length === digits.length) {\n            res.push(path);\n            return;\n        }\n        for (const item of map[digits[i]]) {\n            backtrack(path + item, i + 1);\n        }\n    }\n    backtrack('', 0);\n    return res;\n};\n\n\n\n# 子集\n\n * Leetcode78\n * 题解\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n\nvar subsets = function(nums) {\n    const res = [];\n    const backtrack = (path, index) => {\n        res.push(path.slice());\n        for (let i = index; i < nums.length; i++) {\n            path.push(nums[i]);\n            backtrack(path, i + 1);\n            path.pop();\n        }\n    }\n    backtrack([], 0);\n    return res;\n};\n\n\n\n# 子集II\n\n * leetocode90\n * 有重复元素先排序，每次取值时\n\nvar subsetsWithDup = function(nums) {\n    nums.sort((a, b) => a - b)\n    const res = []\n    const backTrack = (path, index) => {\n        res.push(path.slice())\n        for (let i = index; i < nums.length; i++) {\n            if (i >= index + 1 && nums[i] === nums[i - 1]) continue\n            path.push(nums[i])\n            backTrack(path, i + 1)\n            path.pop()\n        }\n    }\n    backTrack([], 0)\n    return res\n};\n\n\n\n# 二维数组全排列\n\n> var arr = [[‘A’,’B’],[‘a’,’b’],[1,2]]`\n> \n> 求二维数组的全排列组合 结果：[Aa1,Aa2,Ab1,Ab2,Ba1,Ba2,Bb1,Bb2]\n\nconst fullArray = (arr) => {\n    const res = []\n    const traceBack = (path, n) => {\n        if (path.length === arr.length) {\n            res.push(path)\n            return\n        }\n        for (const item of arr[n]) {\n            traceBack(path + item, n+1)\n        }\n    }\n    traceBack('', 0)\n    return res\n}\n\n\n\n# 组合总和\n\n * leetcode39\n * 题解\n\n> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n> \n> candidates 中的数字可以无限制重复被选取。\n> \n> 说明：\n> \n> 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。\n> \n> 示例 1：\n> \n> 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]\n> \n> 示例 2：\n> \n> 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]\n\nvar combinationSum = function(candidates, target) {\n    const res = [];\n    const fn = (path, sum, start) => {\n        if (sum > target) {\n            return;\n        }\n        if (sum === target) {\n            res.push(path.slice());\n            return;\n        }\n        for (let i = start; i < candidates.length; i++) {\n            path.push(candidates[i]);\n            fn(path, sum + candidates[i], i);\n            path.pop();\n        }\n    }\n    fn([], 0, 0);\n    return res;\n};\n\n\n\n# 组合总和II\n\n * leetcode40\n * 题解\n\n> 接上题，每个数字只可使用一次\n> \n> 示例 1:\n> \n> 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]\n> \n> 示例 2:\n> \n> 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ]\n\nvar combinationSum2 = function(candidates, target) {\n    candidates = candidates.sort((a, b) => a - b);\n    const res = [];\n    const fn = (path, sum, start) => {\n        if (sum > target) {\n            return;\n        }\n        if (sum === target) {\n            res.push(path.slice());\n            return;\n        }\n        for (let i = start; i < candidates.length; i++) {\n            // 数组中有重复元素时，当前选项和左邻选项一样，跳过达到去重\n            // 比如[1, 2, 2, 3]，选两次2会重复\n            if (i > start && candidates[i] === candidates[i - 1]) {\n                continue;\n            }\n            path.push(candidates[i]);\n            fn(path, sum + candidates[i], i + 1);\n            path.pop();\n        }\n    }\n    fn([], 0, 0);\n    return res;\n};\n\n\n\n# 从数组中找n个数求和\n\nlet arr = [1, 4, 5, 8, 10, 12], total = 19, n = 3\n// 返回结果为 [[1, 8, 10], [4, 5, 10]]\n\nlet arr = [1, 4, 5, 8, 10, 12], total = 9, n = 2\n// 返回结果为 [[1, 8], [4, 5]]\n\n\n * fn：从 arr 中找出 n 个数使其和为 total\n * path: 当前分支\n * sum：当前和\n * index：当前遍历到的索引，从该索引下一位置开始继续查找，避免结果出现 [1, 8], [8,1]\n * 需要考虑的问题\n   * 数组元素是否重复：重复的话，需要排序后再算\n   * 可否重复选取：backTrack(path, sum + arr[i], i + 1) 中i + 1为不重复选择，i为可以重复选择\n\nconst fn = (arr, total, n) => {\n    let res = []\n    const backTrack = (path, sum, index) => {\n        if (path.length > n || sum > total) return\n        if (path.length === n && sum === total) {\n            res.push(path.slice())\n            return\n        }\n        for (let i = index; i < arr.length; i++) {\n            path.push(arr[i])\n            backTrack(path, sum + arr[i], i + 1) // i + 1为不重复选择，i为可以重复选择\n            path.pop()\n        }\n    }\n    backTrack([], 0, 0)\n    return res\n}\n\n\n\n# 单词搜索\n\n * leetcode79\n * 题解\n\n> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n> \n> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n> \n> 示例:\n> \n> board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ]\n> \n> 给定 word = \"ABCCED\", 返回 true 给定 word = \"SEE\", 返回 true 给定 word = \"ABCB\", 返回 false\n\nvar exist = function(board, word) {\n    const m = board.length\n    const n = board[0].length\n    const used = Array.from(new Array(m),()=>(new Array(n).fill(0)))\n        \n    const traceback = (row, col, i) => {\n      if (i == word.length) {\n        return true\n      }\n      // 越界\n      if (row < 0 || row >= m || col < 0 || col >= n) {\n        return false\n      }\n      // 已访问或不匹配\n      if (used[row][col] || board[row][col] != word[i]) {\n        return false\n      }\n      // 匹配记录一下当前点被访问了\n      used[row][col] = true\n  \n      const canFindRest = traceback(row + 1, col, i + 1) || traceback(row - 1, col, i + 1) \t\t\t\t\t|| traceback(row, col + 1, i + 1) || traceback(row, col - 1, i + 1)\n      \n      // 能找到路径\n      if (canFindRest) {\n        return true\n      }\n\n      // 找不到路径\n      used[row][col] = false\n      return false\n    }\n\n    // 找入口\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        if (board[i][j] == word[0] && traceback(i, j, 0)) {\n          return true; \n        }\n      }\n    }\n    return false\n};\n\n\n\n# 三角形的最小路径和\n\n * leetcode120\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\nvar minimumTotal = function(triangle) {\n    let res = 999999\n    // path: 路径和 | n: 记录第几层 | index: 当前层选中的index\n    const backtrack = (path, n, index) => {\n        if (n > triangle.length - 1) {\n            res = Math.min(res, path)\n            return\n        }\n        backtrack(path + triangle[n][index], n + 1, index)\n        backtrack(path + triangle[n][index], n + 1, index + 1)\n    }\n    backtrack(0, 0, 0)\n    return res\n};\n\n\n回溯思路可行，但是给的测试用例会超时，更优的解法应该是dp\n\n\n# 路径总和\n\n * leetcode112\n\n> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。\n\n// ans 甚至可以求究竟有几条路径\nvar hasPathSum = function(root, targetSum) {\n    if (!root) {\n        return 0;\n    }\n    let res = 0;\n    const backtrack = (path, sum) => {\n        if (!path.left && !path.right && sum === targetSum) {\n            res++;\n        }\n        if (path.left) {\n            backtrack(path.left, sum + path.left.val);\n        }\n        if (path.right) {\n            backtrack(path.right, sum + path.right.val);\n        }\n    }\n    backtrack(root, root.val);\n    return res > 0;\n};\n\n\n\n# 路径总和II\n\n * leetcode113\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n返回:\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\nvar pathSum = function(root, targetSum) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const backtrack = (path, sum, arr) => {\n        if (!path.left && !path.right && sum === targetSum) {\n            res.push(arr.slice());\n        }\n        if (path.left) {\n            arr.push(path.left.val)\n            backtrack(path.left, sum + path.left.val, arr);\n            arr.pop();\n        }\n        if (path.right) {\n            arr.push(path.right.val)\n            backtrack(path.right, sum + path.right.val, arr);\n            arr.pop();\n        }\n    }\n    backtrack(root, root.val, [root.val]);\n    return res;\n};\n\n\n\n# 根节点到叶节点数字之和\n\n * leetcode129\n\nvar sumNumbers = function(root) {\n    let res = 0\n    const backTrack = (root, num) => {\n        if (root.left === null && root.right === null) {\n            res += num\n        }\n        if (root.left !== null) {\n            backTrack(root.left, num * 10 + root.left.val)\n        }\n        if (root.right !== null) {\n            backTrack(root.right, num * 10 + root.right.val)\n        }\n    }\n    backTrack(root, root.val)\n    return res\n};\n\n\n\n# 变式\n\n根据已有数据，实现一个find函数查找当前与所有父级的id(路径查找)\n\nconst data = [{id: 1, children: [{id: 2,children: [{id: 3},{id: 4}]}]}];\nconst find = id => {}\nfind(0) // []\nfind(3) // [1, 2, 3]\n\n\n其实可以把这个结构看成多叉树，也适用回溯\n\nconst find = id => {\n    const map = {};\n    const backtrack = (path, arr) => {\n        map[path.id] = arr.slice().concat(path.id);\n        if (!path.children) return;\n        for (let i = 0; i < path.children.length; i++) {\n            arr.push(path.id);\n            backtrack(path.children[i], arr);\n            arr.pop();\n        }\n    }\n    backtrack(data[0], []);\n    return map[id] || [];\n}\n",normalizedContent:"# 回溯算法\n\n * 全排列\n * 括号生成\n * 电话号码的数字组合\n * 子集\n * 二维数组全排列\n * 组合总和\n * 组合总和ii\n * 单词搜索\n * 三角形的最小路径和\n * 路径总和\n * 路径总和ii\n * 根节点到叶节点数字之和\n\n\n# 回溯算法\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程。基本原理就是递归，用白话解释就是：**从一条路往前走，能进则进，不能进则退回来，换一条路再试。**只需要思考 3 个问题：\n\n1、路径：也就是已经做出的选择。\n\n2、选择列表：也就是你当前可以做的选择。\n\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n\n代码方面，回溯算法的框架：\n\nresult = []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」\n\n> 递归，回溯，dfs的区别\n> \n> 递归就是在函数中调用函数本身来解决问题\n> \n> 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”\n> \n> 回溯搜索是深度优先搜索（dfs）的一种，回溯和dfs，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n\n\n# 全排列\n\n * leetcode46\n\n 给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n \n 示例:\n 输入: [1,2,3]\n 输出:\n [\n [1,2,3],\n [1,3,2],\n [2,1,3],\n [2,3,1],\n [3,1,2],\n [3,2,1]\n]\n\n\n我们要在这个包含解的空间树上，用 递归的方式搜索出所有的解。\n\nvar permute = function(nums) {\n    const res = [];\n    const fn = (path) => {\n        if (path.length === nums.length) {\n            // slice 的原因是防止 push 到 res 中的结果是引用类型，后面 path 改变时会影响 res\n            res.push(path.slice());\n        }\n        for (const item of nums) {\n            if (path.includes(item)) {\n                continue;\n            }\n            path.push(item); // 比如目前 path 是 [1]，push(2), 变成 [1, 2]\n            fn(path); // 递归到头了：[1,2,3] 就 return \n            path.pop(); // [1,2] pop 变为 [1]， 继续下一轮 for 循环, push(3)\n        }\n    }\n    fn([]);\n    return res;\n};\n\n\n\n# 括号生成\n\n * leetcode22\n * 题解\n\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n示例：\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n\n\nvar generateparenthesis = function(n) {\n    const res = [];\n    const backtrack = (left, right, path) => {\n        if (path.length === 2 * n) {\n            res.push(path);\n            return;\n        }\n        if (left > 0) {\n            backtrack(left - 1, right, path + '(');\n        }\n        if (right > left) {\n            backtrack(left, right - 1, path + ')');\n        }\n    }\n    backtrack(n, n, '');\n    return res;\n};\n\n\n\n# 电话号码的数字组合\n\n * leetcode17\n\n * 题解\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例:\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n\nvar lettercombinations = function(digits) {\n    if (!digits.length) {\n        return [];\n    }\n    const map = {2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz'};\n    const res = [];\n    const backtrack = (path, i) => {\n        if (path.length === digits.length) {\n            res.push(path);\n            return;\n        }\n        for (const item of map[digits[i]]) {\n            backtrack(path + item, i + 1);\n        }\n    }\n    backtrack('', 0);\n    return res;\n};\n\n\n\n# 子集\n\n * leetcode78\n * 题解\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n\nvar subsets = function(nums) {\n    const res = [];\n    const backtrack = (path, index) => {\n        res.push(path.slice());\n        for (let i = index; i < nums.length; i++) {\n            path.push(nums[i]);\n            backtrack(path, i + 1);\n            path.pop();\n        }\n    }\n    backtrack([], 0);\n    return res;\n};\n\n\n\n# 子集ii\n\n * leetocode90\n * 有重复元素先排序，每次取值时\n\nvar subsetswithdup = function(nums) {\n    nums.sort((a, b) => a - b)\n    const res = []\n    const backtrack = (path, index) => {\n        res.push(path.slice())\n        for (let i = index; i < nums.length; i++) {\n            if (i >= index + 1 && nums[i] === nums[i - 1]) continue\n            path.push(nums[i])\n            backtrack(path, i + 1)\n            path.pop()\n        }\n    }\n    backtrack([], 0)\n    return res\n};\n\n\n\n# 二维数组全排列\n\n> var arr = [[‘a’,’b’],[‘a’,’b’],[1,2]]`\n> \n> 求二维数组的全排列组合 结果：[aa1,aa2,ab1,ab2,ba1,ba2,bb1,bb2]\n\nconst fullarray = (arr) => {\n    const res = []\n    const traceback = (path, n) => {\n        if (path.length === arr.length) {\n            res.push(path)\n            return\n        }\n        for (const item of arr[n]) {\n            traceback(path + item, n+1)\n        }\n    }\n    traceback('', 0)\n    return res\n}\n\n\n\n# 组合总和\n\n * leetcode39\n * 题解\n\n> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n> \n> candidates 中的数字可以无限制重复被选取。\n> \n> 说明：\n> \n> 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。\n> \n> 示例 1：\n> \n> 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]\n> \n> 示例 2：\n> \n> 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]\n\nvar combinationsum = function(candidates, target) {\n    const res = [];\n    const fn = (path, sum, start) => {\n        if (sum > target) {\n            return;\n        }\n        if (sum === target) {\n            res.push(path.slice());\n            return;\n        }\n        for (let i = start; i < candidates.length; i++) {\n            path.push(candidates[i]);\n            fn(path, sum + candidates[i], i);\n            path.pop();\n        }\n    }\n    fn([], 0, 0);\n    return res;\n};\n\n\n\n# 组合总和ii\n\n * leetcode40\n * 题解\n\n> 接上题，每个数字只可使用一次\n> \n> 示例 1:\n> \n> 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]\n> \n> 示例 2:\n> \n> 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ]\n\nvar combinationsum2 = function(candidates, target) {\n    candidates = candidates.sort((a, b) => a - b);\n    const res = [];\n    const fn = (path, sum, start) => {\n        if (sum > target) {\n            return;\n        }\n        if (sum === target) {\n            res.push(path.slice());\n            return;\n        }\n        for (let i = start; i < candidates.length; i++) {\n            // 数组中有重复元素时，当前选项和左邻选项一样，跳过达到去重\n            // 比如[1, 2, 2, 3]，选两次2会重复\n            if (i > start && candidates[i] === candidates[i - 1]) {\n                continue;\n            }\n            path.push(candidates[i]);\n            fn(path, sum + candidates[i], i + 1);\n            path.pop();\n        }\n    }\n    fn([], 0, 0);\n    return res;\n};\n\n\n\n# 从数组中找n个数求和\n\nlet arr = [1, 4, 5, 8, 10, 12], total = 19, n = 3\n// 返回结果为 [[1, 8, 10], [4, 5, 10]]\n\nlet arr = [1, 4, 5, 8, 10, 12], total = 9, n = 2\n// 返回结果为 [[1, 8], [4, 5]]\n\n\n * fn：从 arr 中找出 n 个数使其和为 total\n * path: 当前分支\n * sum：当前和\n * index：当前遍历到的索引，从该索引下一位置开始继续查找，避免结果出现 [1, 8], [8,1]\n * 需要考虑的问题\n   * 数组元素是否重复：重复的话，需要排序后再算\n   * 可否重复选取：backtrack(path, sum + arr[i], i + 1) 中i + 1为不重复选择，i为可以重复选择\n\nconst fn = (arr, total, n) => {\n    let res = []\n    const backtrack = (path, sum, index) => {\n        if (path.length > n || sum > total) return\n        if (path.length === n && sum === total) {\n            res.push(path.slice())\n            return\n        }\n        for (let i = index; i < arr.length; i++) {\n            path.push(arr[i])\n            backtrack(path, sum + arr[i], i + 1) // i + 1为不重复选择，i为可以重复选择\n            path.pop()\n        }\n    }\n    backtrack([], 0, 0)\n    return res\n}\n\n\n\n# 单词搜索\n\n * leetcode79\n * 题解\n\n> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n> \n> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n> \n> 示例:\n> \n> board = [ ['a','b','c','e'], ['s','f','c','s'], ['a','d','e','e'] ]\n> \n> 给定 word = \"abcced\", 返回 true 给定 word = \"see\", 返回 true 给定 word = \"abcb\", 返回 false\n\nvar exist = function(board, word) {\n    const m = board.length\n    const n = board[0].length\n    const used = array.from(new array(m),()=>(new array(n).fill(0)))\n        \n    const traceback = (row, col, i) => {\n      if (i == word.length) {\n        return true\n      }\n      // 越界\n      if (row < 0 || row >= m || col < 0 || col >= n) {\n        return false\n      }\n      // 已访问或不匹配\n      if (used[row][col] || board[row][col] != word[i]) {\n        return false\n      }\n      // 匹配记录一下当前点被访问了\n      used[row][col] = true\n  \n      const canfindrest = traceback(row + 1, col, i + 1) || traceback(row - 1, col, i + 1) \t\t\t\t\t|| traceback(row, col + 1, i + 1) || traceback(row, col - 1, i + 1)\n      \n      // 能找到路径\n      if (canfindrest) {\n        return true\n      }\n\n      // 找不到路径\n      used[row][col] = false\n      return false\n    }\n\n    // 找入口\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        if (board[i][j] == word[0] && traceback(i, j, 0)) {\n          return true; \n        }\n      }\n    }\n    return false\n};\n\n\n\n# 三角形的最小路径和\n\n * leetcode120\n\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\nvar minimumtotal = function(triangle) {\n    let res = 999999\n    // path: 路径和 | n: 记录第几层 | index: 当前层选中的index\n    const backtrack = (path, n, index) => {\n        if (n > triangle.length - 1) {\n            res = math.min(res, path)\n            return\n        }\n        backtrack(path + triangle[n][index], n + 1, index)\n        backtrack(path + triangle[n][index], n + 1, index + 1)\n    }\n    backtrack(0, 0, 0)\n    return res\n};\n\n\n回溯思路可行，但是给的测试用例会超时，更优的解法应该是dp\n\n\n# 路径总和\n\n * leetcode112\n\n> 给你二叉树的根节点 root 和一个表示目标和的整数 targetsum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetsum 。\n\n// ans 甚至可以求究竟有几条路径\nvar haspathsum = function(root, targetsum) {\n    if (!root) {\n        return 0;\n    }\n    let res = 0;\n    const backtrack = (path, sum) => {\n        if (!path.left && !path.right && sum === targetsum) {\n            res++;\n        }\n        if (path.left) {\n            backtrack(path.left, sum + path.left.val);\n        }\n        if (path.right) {\n            backtrack(path.right, sum + path.right.val);\n        }\n    }\n    backtrack(root, root.val);\n    return res > 0;\n};\n\n\n\n# 路径总和ii\n\n * leetcode113\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n返回:\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\nvar pathsum = function(root, targetsum) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const backtrack = (path, sum, arr) => {\n        if (!path.left && !path.right && sum === targetsum) {\n            res.push(arr.slice());\n        }\n        if (path.left) {\n            arr.push(path.left.val)\n            backtrack(path.left, sum + path.left.val, arr);\n            arr.pop();\n        }\n        if (path.right) {\n            arr.push(path.right.val)\n            backtrack(path.right, sum + path.right.val, arr);\n            arr.pop();\n        }\n    }\n    backtrack(root, root.val, [root.val]);\n    return res;\n};\n\n\n\n# 根节点到叶节点数字之和\n\n * leetcode129\n\nvar sumnumbers = function(root) {\n    let res = 0\n    const backtrack = (root, num) => {\n        if (root.left === null && root.right === null) {\n            res += num\n        }\n        if (root.left !== null) {\n            backtrack(root.left, num * 10 + root.left.val)\n        }\n        if (root.right !== null) {\n            backtrack(root.right, num * 10 + root.right.val)\n        }\n    }\n    backtrack(root, root.val)\n    return res\n};\n\n\n\n# 变式\n\n根据已有数据，实现一个find函数查找当前与所有父级的id(路径查找)\n\nconst data = [{id: 1, children: [{id: 2,children: [{id: 3},{id: 4}]}]}];\nconst find = id => {}\nfind(0) // []\nfind(3) // [1, 2, 3]\n\n\n其实可以把这个结构看成多叉树，也适用回溯\n\nconst find = id => {\n    const map = {};\n    const backtrack = (path, arr) => {\n        map[path.id] = arr.slice().concat(path.id);\n        if (!path.children) return;\n        for (let i = 0; i < path.children.length; i++) {\n            arr.push(path.id);\n            backtrack(path.children[i], arr);\n            arr.pop();\n        }\n    }\n    backtrack(data[0], []);\n    return map[id] || [];\n}\n",charsets:{cjk:!0}},{title:"十大排序算法",frontmatter:{title:"十大排序算法",date:"2020-12-17T11:27:54.000Z",categories:"算法"},regularPath:"/algorithm/sort.html",relativePath:"algorithm/sort.md",key:"v-1901b0ef",path:"/algorithm/sort.html",headers:[{level:2,title:"常用术语",slug:"常用术语",normalizedTitle:"常用术语",charIndex:123},{level:2,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:13},{level:2,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:21},{level:2,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:29},{level:2,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:37},{level:2,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:45},{level:2,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:53},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:61},{level:2,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:68},{level:2,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:76},{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:83}],lastUpdated:"5/22/2025, 11:29:40 AM",lastUpdatedTimestamp:174788458e4,headersStr:"常用术语 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序",content:"# 十大排序算法\n\n * 冒泡排序\n * 选择排序\n * 插入排序\n * 希尔排序\n * 归并排序\n * 快速排序\n * 堆排序\n * 计数排序\n * 桶排序\n * 基数排序\n\n参考文章：十大经典排序算法总结（JavaScript描述）\n\n\n# 常用术语\n\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n\n不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n\n内排序：所有排序操作都在内存中完成；\n\n外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n\n时间复杂度: 一个算法执行所耗费的时间。\n\n空间复杂度: 运行完一个程序所需内存的大小。\n\n\n\n\n# 冒泡排序\n\n 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n 3. 针对所有的元素重复以上的步骤，除了最后一个。\n 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较\n\nconst bubbleSort = function(arr) {\n    const len = arr.length;\n    // len 长度只需循环 len - 1 次，就会把 len - 1 个大元素放在后面，即排序成功\n    for (let i = 0; i < len - 1; i++) {\n        // i 每循环一次后都会选出最大的放到最后\n        // 所以是 j 只需判断 len - i, 又因为下面是 j + 1 和 j 比较, 所以是 len - i - 1\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n\n\n# 选择排序\n\n 1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n 2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾\n 3. 以此类推，直到所有元素均排序完毕\n\nconst selectSort = nums => {\n    for (let i = 0; i < nums.length - 1; i++) {\n        let minIndex = i;\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[minIndex]) {\n                minIndex = j;\n            }\n        }\n        [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];\n    }\n    return nums;\n}\n\n\n\n# 插入排序\n\n 1. 从第一个元素开始，该元素可以认为已经被排序\n 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n 5. 将新元素插入到该位置后\n 6. 重复步骤2~5\n\nfunction insertionSort(array) {\n    for (var i = 1; i < array.length; i++) {\n      var key = array[i];\n      var j = i - 1;\n      while (j >= 0 && array[j] > key) {\n        array[j + 1] = array[j];\n        j--;\n      }\n      array[j + 1] = key;\n    }\n    return array;\n}\n\n\n\n# 希尔排序\n\n 1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n\n 2. 按增量序列个数k，对序列进行k 趟排序；\n\n 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    return arr;\n}\n\n\n\n# 归并排序\n\n> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n 1. 把长度为n的输入序列分成两个长度为n/2的子序列；\n\n 2. 对这两个子序列分别采用归并排序；\n\n 3. 将两个排序好的子序列合并成一个最终的排序序列。\n\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    return result;\n}\n\n\n\n# 快速排序\n\n * 图示\n\n// 快排的基本思想是分治，选择一个枢纽，小的放它左面，大的右面，这样pivot放在了最终位置\n// 然后再对 pivot 左右两个子表排序\n\nconst partition = (arr, low, high) => {\n    const pivot = arr[low];\n    while (low < high) { // 循环直到左右指针相遇\n        while (low < high && arr[high] >= pivot) high--; // 从右向左找第一个小于pivot的数\n        arr[low] = arr[high];\n        while (low < high && arr[low] <= pivot) low++; // 从左向右找第一个大于pivot的数\n        arr[high] = arr[low];\n    }\n    arr[low] = pivot;\n    return low;\n}\n\nconst quickSort = (arr, low, high) => {\n    if (low < high) { // 递归终止条件：子数组长度为1时，无需排序\n        const index = partition(arr, low, high);\n        quickSort(arr, low, index - 1);\n        quickSort(arr, index + 1, high);\n    }\n}\n\nconst sortArray = arr => {\n    quickSort(arr, 0, arr.length - 1);\n    return arr;\n}\n\n[4, 7, 6, 5, 3, 2, 8, 1]\n// 一次排序过程\n[1, 7, 6, 5, 3, 2, 8, -]\n[1, -, 6, 5, 3, 2, 8, 7]\n[1, 2, 6, 5, 3, -, 8, 7]\n[1, 2, -, 5, 3, 6, 8, 7]\n[1, 2, 3, 5, -, 6, 8, 7]\n[1, 2, 3, -, 5, 6, 8, 7]\n[1, 2, 3, 4, 5, 6, 8, 7]\n\n// 优化：\n// 1.子序列的规模较小时，不用在递归调用快排，可以采取直接插入排序\n// 2.尽量选一个可以将数据中分的枢纽元素，比如从序列的头，中，尾选3个，取这三个值的中间元素为枢纽\n\n\n时间复杂度\n\n * 若枢纽值选的好，则形成二叉树的高度为O(logn)，每一层排序需要O(n)，总复杂度为O(nlogn)\n * 若待排序的记录序列正序或逆序，二叉树的高度为O(n)，总复杂度为O(n^2)\n\n\n# 堆排序\n\n 1. 将待排序序列构成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点\n 2. 将其与末尾元素进行交换，此时末尾就是最大值\n 3. 然后将剩余n-1个元素重新构造成一个堆，就会得到n个元素的次小值，如此反复执行，便能得到一个有序序列\n\n * 堆排序图示\n * 原理解析\n * 时间复杂度：O(n*logn)，每次构造堆都需要O(logn)，一共构造n次\n * 堆的插入与删除？删除从根节点删，插入从最后插\n\n/*方法说明：堆排序\n@param  array 待排序数组*/\nfunction heapSort(array) {\n    // 建堆\n    let heapSize = array.length;\n    for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\n      heapify(array, i, heapSize);\n    }\n    // 堆排序\n    for (let j = heapSize - 1; j >= 1; j--) {\n        [array[0], array[j]] = [array[j], array[0]];\n        heapify(array, 0, --heapSize);\n    }\n    return array;\n}\n\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    let l = 2 * x + 1, r = 2 * x + 2, largest = x;\n    if (l < len && arr[l] > arr[largest]) {\n        largest = l;\n    }\n    if (r < len && arr[r] > arr[largest]) {\n        largest = r;\n    }\n    if (largest !== x) {\n        [arr[x], arr[largest]] = [arr[largest], arr[x]];\n        heapify(arr, largest, len);\n    }\n}\n\n\n * 数组第k大元素: leetcode215\n\nvar findKthLargest = function(nums, k) {\n    const heapSort = (arr, k) => {\n        let len = arr.length\n        // 构造堆\n        for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\n            heapify(arr, i, len)\n        }\n        for (let j = len - 1; j >= 0; j--) {\n            [arr[0], arr[j]] = [arr[j], arr[0]]\n            heapify(arr, 0, --len)\n            if (j === arr.length - k) return arr[arr.length - k] // 第 k 大\n        }\n    }\n\n    // 维护堆\n    const heapify = (arr, x, len) => {\n        let l = 2 * x + 1, r = 2 * x + 2, largest = x\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r\n        }\n        if (largest !== x) {\n            [arr[largest], arr[x]] = [arr[x], arr[largest]]\n            heapify(arr, largest, len)\n        }\n    }\n    return heapSort(nums, k)\n};\n\n\n> 下面要介绍的 计数排序、桶排序、基数排序 ，它们的平均时间复杂度都为 O(n)。\n> \n> 因为这三个排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作 线性排序（Linear sort）。\n> \n> 之所以能做到线性的时间复杂度，主要原因是，这三个算法不是基于比较的排序算法，都不涉及元素之间的比较操作。\n\n\n# 计数排序\n\n 1. 找出待排序的数组中最大和最小的元素。\n\n 2. 统计数组中每个值为 i 的元素出现的次数，存入新数组 countArr 的第 i 项。\n\n 3. 对所有的计数累加（从 countArr 中的第一个元素开始，每一项和前一项相加）。\n\n 4. 反向填充目标数组：将每个元素 i 放在新数组的第 countArr[i] 项，每放一个元素就将 countArr[i] 减去 1 。\n\n * 只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。\n * 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。\n\nfunction countingSort(array) {\n    var len = array.length,\n        B = [],\n        C = [],\n        min = max = array[0];\n    for (var i = 0; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;\n    }\n    for (var j = min; j < max; j++) {\n        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);\n    }\n    for (var k = len - 1; k >= 0; k--) {\n        B[C[array[k]] - 1] = array[k];\n        C[array[k]]--;\n    }\n    return B;\n}\n\n\n\n# 桶排序\n\n> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n> \n> 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n\nconst utils = {  \n\tswap(array, a, b) {\n    [array[a], array[b]] = [array[b], array[a]]\n  },\n  randomNum() {\n    return Math.floor(Math.random() * 100)\n  },\n  randomArray() {\n    return Array.from(Array(this.randomNum()), _ => this.randomNum())\n  }\n}\n\nfunction bucketSort(array, size = 10) {\n  let min = Math.min(...array)\n  let max = Math.max(...array)\n  let count = Math.floor((max - min) / size) + 1\n  let buckets = []\n  for (let i = 0; i < count; i++) {\n    buckets.push([])\n  }\n  for (let v of array) {\n    let num = Math.floor((v - min) / size)\n    buckets[num].push(v)\n  }\n  let result = []\n  for (bucket of buckets) {\n    result.push(...insertionSort(bucket)) \n  }\n  return result\n}\n\nconsole.log(bucketSort(utils.randomArray()))\n\nfunction insertionSort(array) {\n  for (let i = 1; i < array.length; i++) {\n    let j = i\n    let target = array[j]\n    while(j > 0 && array[j-1] > target) {\n      array[j] = array[j-1]\n      j--\n    }\n    array[j] = target\n  }\n  return array\n}\n\n\n\n# 基数排序\n\n 1. 取得数组中的最大数，并取得位数；\n 2. arr为原始数组，从最低位开始取每个位组成radix数组；\n 3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n\n/**\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n * @author xiazdong\n * @param  arr 待排序数组\n * @param  maxDigit 最大位数\n */\n//LSD Radix Sort\n\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    var counter = [];\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]== null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n",normalizedContent:"# 十大排序算法\n\n * 冒泡排序\n * 选择排序\n * 插入排序\n * 希尔排序\n * 归并排序\n * 快速排序\n * 堆排序\n * 计数排序\n * 桶排序\n * 基数排序\n\n参考文章：十大经典排序算法总结（javascript描述）\n\n\n# 常用术语\n\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n\n不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n\n内排序：所有排序操作都在内存中完成；\n\n外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n\n时间复杂度: 一个算法执行所耗费的时间。\n\n空间复杂度: 运行完一个程序所需内存的大小。\n\n\n\n\n# 冒泡排序\n\n 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n 3. 针对所有的元素重复以上的步骤，除了最后一个。\n 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较\n\nconst bubblesort = function(arr) {\n    const len = arr.length;\n    // len 长度只需循环 len - 1 次，就会把 len - 1 个大元素放在后面，即排序成功\n    for (let i = 0; i < len - 1; i++) {\n        // i 每循环一次后都会选出最大的放到最后\n        // 所以是 j 只需判断 len - i, 又因为下面是 j + 1 和 j 比较, 所以是 len - i - 1\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n\n\n# 选择排序\n\n 1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n 2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾\n 3. 以此类推，直到所有元素均排序完毕\n\nconst selectsort = nums => {\n    for (let i = 0; i < nums.length - 1; i++) {\n        let minindex = i;\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[j] < nums[minindex]) {\n                minindex = j;\n            }\n        }\n        [nums[i], nums[minindex]] = [nums[minindex], nums[i]];\n    }\n    return nums;\n}\n\n\n\n# 插入排序\n\n 1. 从第一个元素开始，该元素可以认为已经被排序\n 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n 5. 将新元素插入到该位置后\n 6. 重复步骤2~5\n\nfunction insertionsort(array) {\n    for (var i = 1; i < array.length; i++) {\n      var key = array[i];\n      var j = i - 1;\n      while (j >= 0 && array[j] > key) {\n        array[j + 1] = array[j];\n        j--;\n      }\n      array[j + 1] = key;\n    }\n    return array;\n}\n\n\n\n# 希尔排序\n\n 1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n\n 2. 按增量序列个数k，对序列进行k 趟排序；\n\n 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\nfunction shellsort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    return arr;\n}\n\n\n\n# 归并排序\n\n> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（divide and conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n 1. 把长度为n的输入序列分成两个长度为n/2的子序列；\n\n 2. 对这两个子序列分别采用归并排序；\n\n 3. 将两个排序好的子序列合并成一个最终的排序序列。\n\nfunction mergesort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergesort(left), mergesort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    return result;\n}\n\n\n\n# 快速排序\n\n * 图示\n\n// 快排的基本思想是分治，选择一个枢纽，小的放它左面，大的右面，这样pivot放在了最终位置\n// 然后再对 pivot 左右两个子表排序\n\nconst partition = (arr, low, high) => {\n    const pivot = arr[low];\n    while (low < high) { // 循环直到左右指针相遇\n        while (low < high && arr[high] >= pivot) high--; // 从右向左找第一个小于pivot的数\n        arr[low] = arr[high];\n        while (low < high && arr[low] <= pivot) low++; // 从左向右找第一个大于pivot的数\n        arr[high] = arr[low];\n    }\n    arr[low] = pivot;\n    return low;\n}\n\nconst quicksort = (arr, low, high) => {\n    if (low < high) { // 递归终止条件：子数组长度为1时，无需排序\n        const index = partition(arr, low, high);\n        quicksort(arr, low, index - 1);\n        quicksort(arr, index + 1, high);\n    }\n}\n\nconst sortarray = arr => {\n    quicksort(arr, 0, arr.length - 1);\n    return arr;\n}\n\n[4, 7, 6, 5, 3, 2, 8, 1]\n// 一次排序过程\n[1, 7, 6, 5, 3, 2, 8, -]\n[1, -, 6, 5, 3, 2, 8, 7]\n[1, 2, 6, 5, 3, -, 8, 7]\n[1, 2, -, 5, 3, 6, 8, 7]\n[1, 2, 3, 5, -, 6, 8, 7]\n[1, 2, 3, -, 5, 6, 8, 7]\n[1, 2, 3, 4, 5, 6, 8, 7]\n\n// 优化：\n// 1.子序列的规模较小时，不用在递归调用快排，可以采取直接插入排序\n// 2.尽量选一个可以将数据中分的枢纽元素，比如从序列的头，中，尾选3个，取这三个值的中间元素为枢纽\n\n\n时间复杂度\n\n * 若枢纽值选的好，则形成二叉树的高度为o(logn)，每一层排序需要o(n)，总复杂度为o(nlogn)\n * 若待排序的记录序列正序或逆序，二叉树的高度为o(n)，总复杂度为o(n^2)\n\n\n# 堆排序\n\n 1. 将待排序序列构成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点\n 2. 将其与末尾元素进行交换，此时末尾就是最大值\n 3. 然后将剩余n-1个元素重新构造成一个堆，就会得到n个元素的次小值，如此反复执行，便能得到一个有序序列\n\n * 堆排序图示\n * 原理解析\n * 时间复杂度：o(n*logn)，每次构造堆都需要o(logn)，一共构造n次\n * 堆的插入与删除？删除从根节点删，插入从最后插\n\n/*方法说明：堆排序\n@param  array 待排序数组*/\nfunction heapsort(array) {\n    // 建堆\n    let heapsize = array.length;\n    for (let i = math.floor(heapsize / 2) - 1; i >= 0; i--) {\n      heapify(array, i, heapsize);\n    }\n    // 堆排序\n    for (let j = heapsize - 1; j >= 1; j--) {\n        [array[0], array[j]] = [array[j], array[0]];\n        heapify(array, 0, --heapsize);\n    }\n    return array;\n}\n\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    let l = 2 * x + 1, r = 2 * x + 2, largest = x;\n    if (l < len && arr[l] > arr[largest]) {\n        largest = l;\n    }\n    if (r < len && arr[r] > arr[largest]) {\n        largest = r;\n    }\n    if (largest !== x) {\n        [arr[x], arr[largest]] = [arr[largest], arr[x]];\n        heapify(arr, largest, len);\n    }\n}\n\n\n * 数组第k大元素: leetcode215\n\nvar findkthlargest = function(nums, k) {\n    const heapsort = (arr, k) => {\n        let len = arr.length\n        // 构造堆\n        for (let i = math.floor(arr.length / 2); i >= 0; i--) {\n            heapify(arr, i, len)\n        }\n        for (let j = len - 1; j >= 0; j--) {\n            [arr[0], arr[j]] = [arr[j], arr[0]]\n            heapify(arr, 0, --len)\n            if (j === arr.length - k) return arr[arr.length - k] // 第 k 大\n        }\n    }\n\n    // 维护堆\n    const heapify = (arr, x, len) => {\n        let l = 2 * x + 1, r = 2 * x + 2, largest = x\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r\n        }\n        if (largest !== x) {\n            [arr[largest], arr[x]] = [arr[x], arr[largest]]\n            heapify(arr, largest, len)\n        }\n    }\n    return heapsort(nums, k)\n};\n\n\n> 下面要介绍的 计数排序、桶排序、基数排序 ，它们的平均时间复杂度都为 o(n)。\n> \n> 因为这三个排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作 线性排序（linear sort）。\n> \n> 之所以能做到线性的时间复杂度，主要原因是，这三个算法不是基于比较的排序算法，都不涉及元素之间的比较操作。\n\n\n# 计数排序\n\n 1. 找出待排序的数组中最大和最小的元素。\n\n 2. 统计数组中每个值为 i 的元素出现的次数，存入新数组 countarr 的第 i 项。\n\n 3. 对所有的计数累加（从 countarr 中的第一个元素开始，每一项和前一项相加）。\n\n 4. 反向填充目标数组：将每个元素 i 放在新数组的第 countarr[i] 项，每放一个元素就将 countarr[i] 减去 1 。\n\n * 只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。\n * 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。\n\nfunction countingsort(array) {\n    var len = array.length,\n        b = [],\n        c = [],\n        min = max = array[0];\n    for (var i = 0; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n        c[array[i]] = c[array[i]] ? c[array[i]] + 1 : 1;\n    }\n    for (var j = min; j < max; j++) {\n        c[j + 1] = (c[j + 1] || 0) + (c[j] || 0);\n    }\n    for (var k = len - 1; k >= 0; k--) {\n        b[c[array[k]] - 1] = array[k];\n        c[array[k]]--;\n    }\n    return b;\n}\n\n\n\n# 桶排序\n\n> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n> \n> 桶排序 (bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n\nconst utils = {  \n\tswap(array, a, b) {\n    [array[a], array[b]] = [array[b], array[a]]\n  },\n  randomnum() {\n    return math.floor(math.random() * 100)\n  },\n  randomarray() {\n    return array.from(array(this.randomnum()), _ => this.randomnum())\n  }\n}\n\nfunction bucketsort(array, size = 10) {\n  let min = math.min(...array)\n  let max = math.max(...array)\n  let count = math.floor((max - min) / size) + 1\n  let buckets = []\n  for (let i = 0; i < count; i++) {\n    buckets.push([])\n  }\n  for (let v of array) {\n    let num = math.floor((v - min) / size)\n    buckets[num].push(v)\n  }\n  let result = []\n  for (bucket of buckets) {\n    result.push(...insertionsort(bucket)) \n  }\n  return result\n}\n\nconsole.log(bucketsort(utils.randomarray()))\n\nfunction insertionsort(array) {\n  for (let i = 1; i < array.length; i++) {\n    let j = i\n    let target = array[j]\n    while(j > 0 && array[j-1] > target) {\n      array[j] = array[j-1]\n      j--\n    }\n    array[j] = target\n  }\n  return array\n}\n\n\n\n# 基数排序\n\n 1. 取得数组中的最大数，并取得位数；\n 2. arr为原始数组，从最低位开始取每个位组成radix数组；\n 3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n\n/**\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n * @author xiazdong\n * @param  arr 待排序数组\n * @param  maxdigit 最大位数\n */\n//lsd radix sort\n\nfunction radixsort(arr, maxdigit) {\n    var mod = 10;\n    var dev = 1;\n    var counter = [];\n    for (var i = 0; i < maxdigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseint((arr[j] % mod) / dev);\n            if(counter[bucket]== null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n",charsets:{cjk:!0}},{title:"双指针",frontmatter:{title:"双指针",date:"2020-11-30T16:00:54.000Z",categories:"算法"},regularPath:"/algorithm/two-pointer.html",relativePath:"algorithm/two-pointer.md",key:"v-7e657abf",path:"/algorithm/two-pointer.html",headers:[{level:2,title:"盛水最多的容器",slug:"盛水最多的容器",normalizedTitle:"盛水最多的容器",charIndex:10},{level:2,title:"删除链表的倒数第n个结点",slug:"删除链表的倒数第n个结点",normalizedTitle:"删除链表的倒数第n个结点",charIndex:21},{level:2,title:"环形链表",slug:"环形链表",normalizedTitle:"环形链表",charIndex:37},{level:2,title:"验证回文字符串",slug:"验证回文字符串",normalizedTitle:"验证回文字符串",charIndex:45},{level:2,title:"x的平方根",slug:"x的平方根",normalizedTitle:"x的平方根",charIndex:56}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"盛水最多的容器 删除链表的倒数第n个结点 环形链表 验证回文字符串 x的平方根",content:'# 双指针\n\n * 盛水最多的容器\n * 删除链表的倒数第n个结点\n * 环形链表\n * 验证回文字符串\n * x的平方根\n\n\n# 盛水最多的容器\n\n * leetcode11\n * 题解\n\n> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n> \n> 说明：你不能倾斜容器。\n> \n> 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> \n> 示例 2： 输入：height = [1,1] 输出：1\n> \n> 示例 3： 输入：height = [4,3,2,1,4] 输出：16\n> \n> 示例 4： 输入：height = [1,2,1] 输出：2\n\n * 双指针法，原理详看题解\n\nvar maxArea = function(height) {\n    let left = 0\n    let right = height.length - 1\n    let ans = 0\n    while (left !== right) {\n        ans = Math.max(ans, Math.min(height[left], height[right]) * (right - left))\n        if (height[left] > height[right]) {\n            right --\n        } else {\n            left ++\n        }\n    }\n    return ans\n};\n\n\n\n# 删除链表的倒数第n个结点\n\n * leetcode19\n\n> 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n> \n> 示例：\n> \n> 给定一个链表: 1->2->3->4->5, 和 n = 2.\n> \n> 当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n * 思路：双指针，快的先走 n 步，然后两个一起走到最后，慢的就是倒数第 n 个，只遍历了一次\n\nvar removeNthFromEnd = function(head, n) {\n    // 创建头节点, 保证输入为 [1], 1 时，不会出现错误\n    let pre = new ListNode()\n    pre.next = head\n    let slow = pre\n    let fast = pre\n    // fast 先走 n 次\n    for (let i = 0; i < n; i++) {\n        fast = fast.next\n    }\n    // 走到尾部\n    while (fast.next !== null) {\n        slow = slow.next\n        fast = fast.next\n    }\n    // 删除\n    slow.next = slow.next.next\n    return pre.next\n};\n\n\n\n# 环形链表\n\n * leetcode141\n\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n * 快慢指针法\n * 快、慢指针，从头节点出发\n * 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值\n * 如果节点值相同，说明有环。如果不同，继续循环。\n\n\n# 验证回文字符串\n\n * leetcode125\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n输入: "A man, a plan, a canal: Panama"\n输出: true\n\n示例 2:\n输入: "race a car"\n输出: false\n\n\n * toUpperCase 方法用于把字符串转换为大写\n * toLowerCase 方法用于把字符串转换为小写\n * toLocaleLowerCase() 和 toLocaleUpperCase()和上面的区别是根据地区语言来转换，一般用不到\n * 正则中\\w是字符组[0-9a-zA-Z_]的简写形式\n\nvar isPalindrome = function(s) {\n    let i = 0, j = s.length - 1\n    s = s.toLowerCase()\n    function isValid(str) {\n        // const reg = /\\w/ , 其中包含下划线，不正确\n        const reg = /[0-9a-zA-Z]/\n        return reg.test(str)\n    }\n    while (j >= i) {\n        while (!isValid(s[j])) j--\n        while (!isValid(s[i])) i++\n        if (s[i] !== s[j]) return false\n        i++\n        j--\n    }\n    return true\n};\n\n\n\n# x的平方根\n\n * leetcode69\n\nvar mySqrt = function(x) {\n    let left = 0, right = x, ans = -1\n    while (left <= right) {\n        mid = Math.floor((left + right) / 2)\n        if (mid * mid <= x) {\n            left = mid + 1\n            ans = mid // 保证结果是向下取整的，很巧妙\n        } else if (mid * mid > x) {\n            right = mid - 1\n        }\n    }\n    return ans\n};\n',normalizedContent:'# 双指针\n\n * 盛水最多的容器\n * 删除链表的倒数第n个结点\n * 环形链表\n * 验证回文字符串\n * x的平方根\n\n\n# 盛水最多的容器\n\n * leetcode11\n * 题解\n\n> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n> \n> 说明：你不能倾斜容器。\n> \n> 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> \n> 示例 2： 输入：height = [1,1] 输出：1\n> \n> 示例 3： 输入：height = [4,3,2,1,4] 输出：16\n> \n> 示例 4： 输入：height = [1,2,1] 输出：2\n\n * 双指针法，原理详看题解\n\nvar maxarea = function(height) {\n    let left = 0\n    let right = height.length - 1\n    let ans = 0\n    while (left !== right) {\n        ans = math.max(ans, math.min(height[left], height[right]) * (right - left))\n        if (height[left] > height[right]) {\n            right --\n        } else {\n            left ++\n        }\n    }\n    return ans\n};\n\n\n\n# 删除链表的倒数第n个结点\n\n * leetcode19\n\n> 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n> \n> 示例：\n> \n> 给定一个链表: 1->2->3->4->5, 和 n = 2.\n> \n> 当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n * 思路：双指针，快的先走 n 步，然后两个一起走到最后，慢的就是倒数第 n 个，只遍历了一次\n\nvar removenthfromend = function(head, n) {\n    // 创建头节点, 保证输入为 [1], 1 时，不会出现错误\n    let pre = new listnode()\n    pre.next = head\n    let slow = pre\n    let fast = pre\n    // fast 先走 n 次\n    for (let i = 0; i < n; i++) {\n        fast = fast.next\n    }\n    // 走到尾部\n    while (fast.next !== null) {\n        slow = slow.next\n        fast = fast.next\n    }\n    // 删除\n    slow.next = slow.next.next\n    return pre.next\n};\n\n\n\n# 环形链表\n\n * leetcode141\n\n示例 1：\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n示例 2：\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n * 快慢指针法\n * 快、慢指针，从头节点出发\n * 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值\n * 如果节点值相同，说明有环。如果不同，继续循环。\n\n\n# 验证回文字符串\n\n * leetcode125\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n输入: "a man, a plan, a canal: panama"\n输出: true\n\n示例 2:\n输入: "race a car"\n输出: false\n\n\n * touppercase 方法用于把字符串转换为大写\n * tolowercase 方法用于把字符串转换为小写\n * tolocalelowercase() 和 tolocaleuppercase()和上面的区别是根据地区语言来转换，一般用不到\n * 正则中\\w是字符组[0-9a-za-z_]的简写形式\n\nvar ispalindrome = function(s) {\n    let i = 0, j = s.length - 1\n    s = s.tolowercase()\n    function isvalid(str) {\n        // const reg = /\\w/ , 其中包含下划线，不正确\n        const reg = /[0-9a-za-z]/\n        return reg.test(str)\n    }\n    while (j >= i) {\n        while (!isvalid(s[j])) j--\n        while (!isvalid(s[i])) i++\n        if (s[i] !== s[j]) return false\n        i++\n        j--\n    }\n    return true\n};\n\n\n\n# x的平方根\n\n * leetcode69\n\nvar mysqrt = function(x) {\n    let left = 0, right = x, ans = -1\n    while (left <= right) {\n        mid = math.floor((left + right) / 2)\n        if (mid * mid <= x) {\n            left = mid + 1\n            ans = mid // 保证结果是向下取整的，很巧妙\n        } else if (mid * mid > x) {\n            right = mid - 1\n        }\n    }\n    return ans\n};\n',charsets:{cjk:!0}},{title:"Ethers.js",frontmatter:{},regularPath:"/blockchain/ethersjs.html",relativePath:"blockchain/ethersjs.md",key:"v-b1fb6c42",path:"/blockchain/ethersjs.html",lastUpdated:"5/23/2025, 5:16:31 PM",lastUpdatedTimestamp:1747991791e3,headersStr:null,content:"# Ethers.js\n\n * Github: https://github.com/ethers-io/ethers.js\n * 官方文档：https://docs.ethers.org/v5/",normalizedContent:"# ethers.js\n\n * github: https://github.com/ethers-io/ethers.js\n * 官方文档：https://docs.ethers.org/v5/",charsets:{cjk:!0}},{title:"常见概念",frontmatter:{},regularPath:"/blockchain/base.html",relativePath:"blockchain/base.md",key:"v-06da033f",path:"/blockchain/base.html",headers:[{level:2,title:"NFT",slug:"nft",normalizedTitle:"nft",charIndex:11},{level:3,title:"同质化",slug:"同质化",normalizedTitle:"同质化",charIndex:47},{level:3,title:"非同质化",slug:"非同质化",normalizedTitle:"非同质化",charIndex:46},{level:3,title:"NFT",slug:"nft-2",normalizedTitle:"nft",charIndex:11},{level:3,title:"ERC20/ERC721",slug:"erc20-erc721",normalizedTitle:"erc20/erc721",charIndex:564},{level:2,title:"DAPP",slug:"dapp",normalizedTitle:"dapp",charIndex:1967},{level:2,title:"Defi",slug:"defi",normalizedTitle:"defi",charIndex:2299},{level:2,title:"DAO",slug:"dao",normalizedTitle:"dao",charIndex:2907},{level:2,title:"共识机制",slug:"共识机制",normalizedTitle:"共识机制",charIndex:3235},{level:2,title:"撸空投",slug:"撸空投",normalizedTitle:"撸空投",charIndex:3445},{level:2,title:"智能合约",slug:"智能合约",normalizedTitle:"智能合约",charIndex:426},{level:2,title:"MetaMask/DAPP",slug:"metamask-dapp",normalizedTitle:"metamask/dapp",charIndex:3939},{level:2,title:"期货和现货",slug:"期货和现货",normalizedTitle:"期货和现货",charIndex:4649},{level:3,title:"1. 现货（Spot）",slug:"_1-现货-spot",normalizedTitle:"1. 现货（spot）",charIndex:4659},{level:3,title:"2. 期货（Futures）",slug:"_2-期货-futures",normalizedTitle:"2. 期货（futures）",charIndex:4883},{level:3,title:"保证金制度",slug:"保证金制度",normalizedTitle:"保证金制度",charIndex:5065},{level:2,title:"做空与做多",slug:"做空与做多",normalizedTitle:"做空与做多",charIndex:5768}],lastUpdated:"6/20/2025, 5:49:03 PM",lastUpdatedTimestamp:1750412943e3,headersStr:"NFT 同质化 非同质化 NFT ERC20/ERC721 DAPP Defi DAO 共识机制 撸空投 智能合约 MetaMask/DAPP 期货和现货 1. 现货（Spot） 2. 期货（Futures） 保证金制度 做空与做多",content:"# 常见概念\n\n\n# NFT\n\nNFT 全称为 Non-fungible token，解释为非同质化代币。\n\n\n# 同质化\n\n同质化代币的开发方式决定了每一个代币都是相同的。一个同质化代币可以与任何一个同类代币进行交换。这些代币是完全相同的，因此同质化代币可以互换。事实上，大部分加密货币是同质化的。例如，比特币和以太币就是同质化的。一个比特币（或其中一部分）可以与另一个代币互换，因为它们代表相同的价值。以太币也是如此。\n\n\n# 非同质化\n\n而非同质化资产不能互换。每一个非同质化资产都是独一无二的，与任何其他资产的价值都不相同。 非同质化资产一般是收藏品，但也不全是。比如，一辆汽车就是一个非同质化商品。如果您把车送去维修，对方给您另一辆车况更好的车先用着，您会很高兴。如果这辆车的车况还不如您自己的车，您就会不高兴。但这辆车和您的车价值不同，所以它是非同质化商品。\n\n\n# NFT\n\nNFT 是一种加密代币，基于以太坊的 ERC-721 不可分割智能合约，每一个都是独一无二的，可用于追踪个人知识产权。\n\nNFT 是一种数字资产，其创建方式是在智能合约中编写代码。NFT 无法复制，因此代表着独一无二的事物，其性质类似于收藏品。一个 NFT 不能与另一个 NFT 互换，因为每个 NFT 本身都包含了独特的内容。\n\n\n# ERC20/ERC721\n\nERC 是 Ethereum Request for Comments 的缩写，即以太坊征求意见，是以太坊开发者的协议提案，是以太坊智能合约开发人员使用的技术文档，为以太坊生态系统中的特定用户组提供方法、创新、研究和特征的规范。 以太坊的 ERC 标准有很多，目前使用最多的通证标准为：ERC-20、ERC-777、ERC-721 和 ERC-1155。\n\n# ERC20（同质化代币标准）\n\n核心特性：\n\n 1. 可替代性：每个代币完全相同（如1 USDT = 1 USDT），可无限分割（如0.1个ETH）。\n 2. 简单结构：通过balanceOf（查询余额）和transfer（转账）等函数实现基础功能。\n 3. 典型场景：稳定币（USDT、USDC）、平台币（UNI）、治理代币（COMP）等。 转账优势：\n\n * 低成本：交易数据量小（仅需指定金额和接收地址），Gas费低。\n * 高兼容性：所有以太坊钱包原生支持ERC20，无需额外适配。\n * 流动性强：广泛用于交易所、DeFi协议，转账即代表价值转移。\n\n# ERC721（非同质化代币标准）\n\n核心特性：\n\n 1. 唯一性：每个代币独立存在（如CryptoPunks #8348），不可分割。\n 2. 元数据支持：可绑定图片、属性等链上信息（通过tokenURI函数）。\n 3. 典型场景：数字艺术品（BAYC）、游戏道具（Axie Infinity）、域名（ENS）。 转账特点：\n\n * 复杂度高：需传递Token ID、元数据哈希等信息，交易数据量更大。\n * Gas费更高：单次操作成本可能达ERC20的数倍（尤其涉及复杂逻辑时）。\n * 功能扩展：需支持safeTransferFrom等安全函数防止数据丢失。\n\n# 为何转账优先选ERC20？\n\n 1. 经济性： ERC20转账仅需记录金额和地址，数据量小；ERC721需包含Token ID、元数据等，导致Gas费显著增加。例如，发送1000 USDT（ERC20）的Gas费可能为0.1，而发送一个CryptoPunk（ERC721）可能达5。\n 2. 技术兼容性： 所有钱包默认集成ERC20标准，用户无需额外操作；ERC721需调用特定函数（如safeTransferFrom），部分钱包需手动开启“NFT支持”功能。\n 3. 场景适配性： ERC20天然适配价值传输场景（如支付、借贷）；ERC721的独特性使其更适合资产确权（如数字所有权证明），但日常转账需求较低。\n 4. 流动性网络效应： 90%以上的DeFi协议和交易所仅支持ERC20，转账ERC20可直接参与交易、质押等生态；ERC721需通过专用市场（如OpenSea）交易，流动性分散。\n\n# 总结\n\n * ERC20：价值转移的“通用货币”，低成本、高效率，适合日常金融活动。\n * ERC721：数字资产的“产权证书”，通过唯一性创造稀缺性，但转账成本高且生态分散。 因此，当用户需要向钱包转账时，ERC20因其标准化、低成本和即时可用性成为首选，而ERC721更多用于特定资产的所有权转移。由于 NFT 是不可复制的数字所有权证书，它可让作者根据自己的意愿进行转售、分配或许可数字资产的数字权利，这也使艺术家可以完全自由地买卖艺术品，而无需第三方的参与。\n\n\n# DAPP\n\nDAPP 是 Decentralized Application 的缩写，即去中心化应用，也有人称为分布式应用。它被认为开启了区块链3.0时代。\n\nDAPP 就是在底层区块链平台衍生的各种分布式应用，是区块链世界中的服务提供形式。DAPP 之于区块链，有些类似 APP 之于IOS 和 Android。\n\nDApp 允许大家使用区块链网络，其中智能合约允许它连接到区块链。例如一个曾经很火的游戏 CryptoKitties。\n\n * 传统的应用程序：前端→API→数据库\n * DApp: 类似于传统的应用程序。前端使用完全相同的技术来渲染页面。一个关键的区别是，不是连接到数据库的API，而是通过智能合约连接到区块链：前端→智能合约→区块链\n\n\n# Defi\n\nDeFi 的全称是 Decentralized Finance，即 去中心化金融，当前几乎全部的 DeFi 项目都在以太坊的区块链上进行。\n\n我们在现实世界中的取款、转账、贷款都是在银行/金融公司等第三方机构作为担保的情况下参与的。去中心化的金融，指的就是我们通过区块链这个去中心化的数据库和智能合约等技术代替了银行/金融公司等第三方机构。创建了一个没有中心机构掌控，人人都可以自由参与的金融系统。\n\n> 我们都知道 USDT 是属于中心化的稳定币。在 DeFi 的世界，用的是去中心化的稳定币，我们称之为 DAI。 例如项目 M 发行了属于自己的代币 m。由于是去中心化的平台，所有每一个持有 m 的用户都可以参与平台上重大决策的投票；另外也作为本平台借贷的利息。这个平台上有两个池子。一个叫做以太池，一个叫做抵押仓。首先，你需要拿着一定的资产去以太池里进行抵押，智能合约在对你的资产进行估值后返还你一定的代币作为抵押后的凭证。比如你抵押 ETH,就给你返还 PETH(集合以太)。其次，你再拿着这个 PETH 去抵押仓。抵押仓会生成你的债务，锁定你的资产，并给你发放相应数量的 DAI，你可以拿着 DAI 去兑换法币消费。最后当你想要赎回自己资产的时候，你不仅要返还相应数量的 DAI，还要购买 m 代币作为利息，交给 M 平台。如果你最后没有钱赎回资产，那么平台就会拍卖你的资产完成清算。\n\n\n# DAO\n\nDAO 的全名是 decentralized autonomous organization ，中文是 去中心化的自治组织 。DAO 的主要目的是超越传统组织形式，以分布式、透明和信任最小化的方式来进行集体决策。简而言之，DAO 是一种新型的组织架构。人们可以独立验证组织的运行方式，并基于这样的共识朝着共同的目标努力。\n\nDAO 的独特之处在于其利用了区块链智能合约，将部分或全部流程写入合约代码中，以执行决策并分配所有权。智能合约的出现为创新奠定了基础，因为智能合约可以让 DAO 的治理规则完全透明化，而且无法被任何 DAO 成员或外部方篡改。这是因为区块链（即智能合约）运行的代码可以被公开审计，并由去中心化的节点网络保障安全。\n\n\n# 共识机制\n\n共识机制是区块链技术的核心基础，用于确保分布式网络中的节点（参与者）在没有中心化权威的情况下，达成对数据一致性的共同认可。它的本质是解决信任问题，让互不信任的节点通过特定规则实现协作，保证区块链的安全性、去中心化和不可篡改性。在传统中心化系统中（如银行），数据的真实性由中心机构（如服务器）保证。但在区块链的分布式网络中，所有节点平等参与，必须通过共识机制解决，场景的共识机制 PoW, PoS等。\n\n\n# 撸空投\n\n本质是一种营销活动：项目方（通常是新兴的区块链项目）为了推广产品、扩大用户群或测试功能，会将代币免费分发给特定用户。用户通过完成任务（如社交媒体互动、测试产品等）参与其中，无需投入资金或仅需少量手续费。\n\n * 低成本高回报潜力：部分空投代币上线后价值飙升（如APT空投曾达万元人民币），用户可通过出售变现。\n * 时间投入：筛选项目、完成任务耗时较多，需平衡效率。\n * 诈骗风险：虚假空投泛滥，常见骗局包括要求支付“升级费”、提供私钥或授权恶意合约，导致资产被盗。\n\n\n# 智能合约\n\n智能合约是部署在区块链上的自动化执行程序，代码即法律（Code is Law）\n\n核心特性：\n\n * 不可篡改：一旦部署，代码无法修改\n * 透明可信：所有操作记录在公开账本\n * 自动执行：满足条件时自动触发预设操作\n\n> 为什么部署智能合约到区块链要支付 gas\n\n以太坊提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致无法预知智能合约是否会导致死循环（停机问题）因此，以太坊引入汽油费机制，Gas 机制要求每条指令付费，从经济层面限制了恶意用户。\n\n\n# MetaMask/DAPP\n\n * MetaMask是一个钱包应用，它支持多种充值方式，包括法币入口，比如通过第三方服务如Transak、MoonPay或Wyre。这些服务允许用户直接用信用卡或银行账户购买加密货币，然后转入MetaMask钱包。\n   * 银行卡 → 第三方支付网关 → 中心化交易所 → 用户MetaMask地址\n * 而DApp通常是去中心化应用，它们主要处理链上操作，比如智能合约交互，但可能不直接集成法币入口，因为这涉及到合规、监管和复杂的支付处理流程\n   * 用户钱包 → 调用DApp智能合约 → 更新链上余额\n\n> metamask是区块链的去中心化钱包，跟我们平时用的app不同，它是一款去中心化的应用，官方并不会保存你的密码，你也不能使用官方来找回密码，你只能把自己的密码写在纸上放在保险箱里。而且里面存放的钱或者币并不像你将钱存在银行里，银行如果倒闭了那你的钱也可能没了，但是这款钱包就是你自己的，钱不会消失。\n\n举几个例子：\n\n特性     COINBASE          METAMASK      币安（BINANCE）\n性质     中心化交易所，已上市        钱包工具+DEX入口    中心化交易所\n合规性    高（多国牌照）           无（用户自担风险）     中（全球布局但部分地区受限）\n支持的链   有限（BTC、ETH等主流链）   全链兼容（EVM生态）   广泛（BTC、ETH、BNB Chain等）\n费用     较高（交易费+提现费）       仅Gas费         较低（现货0.1%，合约0.02%）\n\n\n# 期货和现货\n\n\n# 1. 现货（Spot）\n\n * 定义：现货交易是即时或短期交割的买卖行为。买卖双方约定在交易完成后立即或极短时间内（通常2个工作日内）完成标的资产的交付和资金结算。\n * 特点\n   * 实物或金融资产直接交割：如黄金、原油、外汇、股票等。\n   * 价格反映当前市场供需：现货价格由即时的供求关系决定。\n   * 无杠杆或低杠杆：通常需要全额资金交易（如股票需全额支付）。\n * 例子：你今天用人民币买入1克黄金，明天就能拿到实物黄金。\n\n\n# 2. 期货（Futures）\n\n * 定义：期货是标准化合约，约定在未来某一特定日期（到期日），以预先确定的价格买入或卖出一定数量的标的资产（如商品、股指、外汇等）。\n * 杠杆交易：只需支付合约价值的一小部分作为保证金（如5%-20%），可放大收益和风险。\n * 例子：3个月后以5000元/吨的价格买入10吨大豆，无论到期时市场价如何，都按合约执行。\n\n\n# 保证金制度\n\n用“定金”撬动大额交易\n\n * 定义：期货交易不需要支付合约全额价值，只需缴纳一定比例的保证金（通常为合约价值的5%-20%）。\n\n * 例子\n   \n   * 假设黄金期货合约价值100万元（1手=1公斤黄金，假设价格100万元/公斤）。\n   * 交易所规定保证金比例为10%，则投资者只需支付10万元即可买入1手合约。\n   * 此时，10万元控制了100万元的资产，杠杆率 = 100万 / 10万 = 10倍。\n\n * 收益放大\n   \n   * 若黄金价格上涨10%（至110万元/公斤），合约价值变为110万元。\n   * 投资者卖出合约后，盈利为10万元（110万 - 100万）。\n   * 收益率 = 盈利 / 初始投入 = 10万 / 10万 = 100%（现货收益仅10%）。\n\n * 风险放大\n   \n   * 若黄金价格下跌10%（至90万元/公斤），合约价值变为90万元。\n   * 投资者亏损10万元，亏损率 = 10万 / 10万 = 100%（现货亏损仅10%）。\n   * 若未及时追加保证金，可能被强制平仓（爆仓）。\n\n步骤             黄金价格    账户余额    操作\n开仓（买入1手）       100万元   10万元    缴纳初始保证金10万元\n价格跌至93万元       93万元    3万元     触发追加保证金通知（需补至7万）\n未追加保证金         90万元    0万元     强制平仓，亏损10万元\n极端情况（跌至80万元）   80万元    -10万元   穿仓，需追加偿还10万元\n\n\n# 做空与做多\n\n# 1. 做多（Buy/Long）\n\n * 定义：买入某种资产，预期其价格上涨，未来以更高价格卖出获利。\n * 类比：相当于“低买高卖”，如股票投资。\n * 期货/永续合约中的操作\n   * 支付保证金，开仓买入合约（如黄金期货）。\n   * 若价格上涨，平仓时卖出合约，赚取差价。\n\n# 2. 做空（Sell/Short）\n\n * 定义：借入并卖出某种资产，预期其价格下跌，未来以更低价格买回归还，赚取差价。\n * 类比：相当于“高卖低买”，如融券卖空股票。\n * 期货/永续合约中的操作\n   * 支付保证金，开仓卖出合约（如比特币永续合约）。\n   * 若价格下跌，平仓时买入合约，赚取差价。",normalizedContent:"# 常见概念\n\n\n# nft\n\nnft 全称为 non-fungible token，解释为非同质化代币。\n\n\n# 同质化\n\n同质化代币的开发方式决定了每一个代币都是相同的。一个同质化代币可以与任何一个同类代币进行交换。这些代币是完全相同的，因此同质化代币可以互换。事实上，大部分加密货币是同质化的。例如，比特币和以太币就是同质化的。一个比特币（或其中一部分）可以与另一个代币互换，因为它们代表相同的价值。以太币也是如此。\n\n\n# 非同质化\n\n而非同质化资产不能互换。每一个非同质化资产都是独一无二的，与任何其他资产的价值都不相同。 非同质化资产一般是收藏品，但也不全是。比如，一辆汽车就是一个非同质化商品。如果您把车送去维修，对方给您另一辆车况更好的车先用着，您会很高兴。如果这辆车的车况还不如您自己的车，您就会不高兴。但这辆车和您的车价值不同，所以它是非同质化商品。\n\n\n# nft\n\nnft 是一种加密代币，基于以太坊的 erc-721 不可分割智能合约，每一个都是独一无二的，可用于追踪个人知识产权。\n\nnft 是一种数字资产，其创建方式是在智能合约中编写代码。nft 无法复制，因此代表着独一无二的事物，其性质类似于收藏品。一个 nft 不能与另一个 nft 互换，因为每个 nft 本身都包含了独特的内容。\n\n\n# erc20/erc721\n\nerc 是 ethereum request for comments 的缩写，即以太坊征求意见，是以太坊开发者的协议提案，是以太坊智能合约开发人员使用的技术文档，为以太坊生态系统中的特定用户组提供方法、创新、研究和特征的规范。 以太坊的 erc 标准有很多，目前使用最多的通证标准为：erc-20、erc-777、erc-721 和 erc-1155。\n\n# erc20（同质化代币标准）\n\n核心特性：\n\n 1. 可替代性：每个代币完全相同（如1 usdt = 1 usdt），可无限分割（如0.1个eth）。\n 2. 简单结构：通过balanceof（查询余额）和transfer（转账）等函数实现基础功能。\n 3. 典型场景：稳定币（usdt、usdc）、平台币（uni）、治理代币（comp）等。 转账优势：\n\n * 低成本：交易数据量小（仅需指定金额和接收地址），gas费低。\n * 高兼容性：所有以太坊钱包原生支持erc20，无需额外适配。\n * 流动性强：广泛用于交易所、defi协议，转账即代表价值转移。\n\n# erc721（非同质化代币标准）\n\n核心特性：\n\n 1. 唯一性：每个代币独立存在（如cryptopunks #8348），不可分割。\n 2. 元数据支持：可绑定图片、属性等链上信息（通过tokenuri函数）。\n 3. 典型场景：数字艺术品（bayc）、游戏道具（axie infinity）、域名（ens）。 转账特点：\n\n * 复杂度高：需传递token id、元数据哈希等信息，交易数据量更大。\n * gas费更高：单次操作成本可能达erc20的数倍（尤其涉及复杂逻辑时）。\n * 功能扩展：需支持safetransferfrom等安全函数防止数据丢失。\n\n# 为何转账优先选erc20？\n\n 1. 经济性： erc20转账仅需记录金额和地址，数据量小；erc721需包含token id、元数据等，导致gas费显著增加。例如，发送1000 usdt（erc20）的gas费可能为0.1，而发送一个cryptopunk（erc721）可能达5。\n 2. 技术兼容性： 所有钱包默认集成erc20标准，用户无需额外操作；erc721需调用特定函数（如safetransferfrom），部分钱包需手动开启“nft支持”功能。\n 3. 场景适配性： erc20天然适配价值传输场景（如支付、借贷）；erc721的独特性使其更适合资产确权（如数字所有权证明），但日常转账需求较低。\n 4. 流动性网络效应： 90%以上的defi协议和交易所仅支持erc20，转账erc20可直接参与交易、质押等生态；erc721需通过专用市场（如opensea）交易，流动性分散。\n\n# 总结\n\n * erc20：价值转移的“通用货币”，低成本、高效率，适合日常金融活动。\n * erc721：数字资产的“产权证书”，通过唯一性创造稀缺性，但转账成本高且生态分散。 因此，当用户需要向钱包转账时，erc20因其标准化、低成本和即时可用性成为首选，而erc721更多用于特定资产的所有权转移。由于 nft 是不可复制的数字所有权证书，它可让作者根据自己的意愿进行转售、分配或许可数字资产的数字权利，这也使艺术家可以完全自由地买卖艺术品，而无需第三方的参与。\n\n\n# dapp\n\ndapp 是 decentralized application 的缩写，即去中心化应用，也有人称为分布式应用。它被认为开启了区块链3.0时代。\n\ndapp 就是在底层区块链平台衍生的各种分布式应用，是区块链世界中的服务提供形式。dapp 之于区块链，有些类似 app 之于ios 和 android。\n\ndapp 允许大家使用区块链网络，其中智能合约允许它连接到区块链。例如一个曾经很火的游戏 cryptokitties。\n\n * 传统的应用程序：前端→api→数据库\n * dapp: 类似于传统的应用程序。前端使用完全相同的技术来渲染页面。一个关键的区别是，不是连接到数据库的api，而是通过智能合约连接到区块链：前端→智能合约→区块链\n\n\n# defi\n\ndefi 的全称是 decentralized finance，即 去中心化金融，当前几乎全部的 defi 项目都在以太坊的区块链上进行。\n\n我们在现实世界中的取款、转账、贷款都是在银行/金融公司等第三方机构作为担保的情况下参与的。去中心化的金融，指的就是我们通过区块链这个去中心化的数据库和智能合约等技术代替了银行/金融公司等第三方机构。创建了一个没有中心机构掌控，人人都可以自由参与的金融系统。\n\n> 我们都知道 usdt 是属于中心化的稳定币。在 defi 的世界，用的是去中心化的稳定币，我们称之为 dai。 例如项目 m 发行了属于自己的代币 m。由于是去中心化的平台，所有每一个持有 m 的用户都可以参与平台上重大决策的投票；另外也作为本平台借贷的利息。这个平台上有两个池子。一个叫做以太池，一个叫做抵押仓。首先，你需要拿着一定的资产去以太池里进行抵押，智能合约在对你的资产进行估值后返还你一定的代币作为抵押后的凭证。比如你抵押 eth,就给你返还 peth(集合以太)。其次，你再拿着这个 peth 去抵押仓。抵押仓会生成你的债务，锁定你的资产，并给你发放相应数量的 dai，你可以拿着 dai 去兑换法币消费。最后当你想要赎回自己资产的时候，你不仅要返还相应数量的 dai，还要购买 m 代币作为利息，交给 m 平台。如果你最后没有钱赎回资产，那么平台就会拍卖你的资产完成清算。\n\n\n# dao\n\ndao 的全名是 decentralized autonomous organization ，中文是 去中心化的自治组织 。dao 的主要目的是超越传统组织形式，以分布式、透明和信任最小化的方式来进行集体决策。简而言之，dao 是一种新型的组织架构。人们可以独立验证组织的运行方式，并基于这样的共识朝着共同的目标努力。\n\ndao 的独特之处在于其利用了区块链智能合约，将部分或全部流程写入合约代码中，以执行决策并分配所有权。智能合约的出现为创新奠定了基础，因为智能合约可以让 dao 的治理规则完全透明化，而且无法被任何 dao 成员或外部方篡改。这是因为区块链（即智能合约）运行的代码可以被公开审计，并由去中心化的节点网络保障安全。\n\n\n# 共识机制\n\n共识机制是区块链技术的核心基础，用于确保分布式网络中的节点（参与者）在没有中心化权威的情况下，达成对数据一致性的共同认可。它的本质是解决信任问题，让互不信任的节点通过特定规则实现协作，保证区块链的安全性、去中心化和不可篡改性。在传统中心化系统中（如银行），数据的真实性由中心机构（如服务器）保证。但在区块链的分布式网络中，所有节点平等参与，必须通过共识机制解决，场景的共识机制 pow, pos等。\n\n\n# 撸空投\n\n本质是一种营销活动：项目方（通常是新兴的区块链项目）为了推广产品、扩大用户群或测试功能，会将代币免费分发给特定用户。用户通过完成任务（如社交媒体互动、测试产品等）参与其中，无需投入资金或仅需少量手续费。\n\n * 低成本高回报潜力：部分空投代币上线后价值飙升（如apt空投曾达万元人民币），用户可通过出售变现。\n * 时间投入：筛选项目、完成任务耗时较多，需平衡效率。\n * 诈骗风险：虚假空投泛滥，常见骗局包括要求支付“升级费”、提供私钥或授权恶意合约，导致资产被盗。\n\n\n# 智能合约\n\n智能合约是部署在区块链上的自动化执行程序，代码即法律（code is law）\n\n核心特性：\n\n * 不可篡改：一旦部署，代码无法修改\n * 透明可信：所有操作记录在公开账本\n * 自动执行：满足条件时自动触发预设操作\n\n> 为什么部署智能合约到区块链要支付 gas\n\n以太坊提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致无法预知智能合约是否会导致死循环（停机问题）因此，以太坊引入汽油费机制，gas 机制要求每条指令付费，从经济层面限制了恶意用户。\n\n\n# metamask/dapp\n\n * metamask是一个钱包应用，它支持多种充值方式，包括法币入口，比如通过第三方服务如transak、moonpay或wyre。这些服务允许用户直接用信用卡或银行账户购买加密货币，然后转入metamask钱包。\n   * 银行卡 → 第三方支付网关 → 中心化交易所 → 用户metamask地址\n * 而dapp通常是去中心化应用，它们主要处理链上操作，比如智能合约交互，但可能不直接集成法币入口，因为这涉及到合规、监管和复杂的支付处理流程\n   * 用户钱包 → 调用dapp智能合约 → 更新链上余额\n\n> metamask是区块链的去中心化钱包，跟我们平时用的app不同，它是一款去中心化的应用，官方并不会保存你的密码，你也不能使用官方来找回密码，你只能把自己的密码写在纸上放在保险箱里。而且里面存放的钱或者币并不像你将钱存在银行里，银行如果倒闭了那你的钱也可能没了，但是这款钱包就是你自己的，钱不会消失。\n\n举几个例子：\n\n特性     coinbase          metamask      币安（binance）\n性质     中心化交易所，已上市        钱包工具+dex入口    中心化交易所\n合规性    高（多国牌照）           无（用户自担风险）     中（全球布局但部分地区受限）\n支持的链   有限（btc、eth等主流链）   全链兼容（evm生态）   广泛（btc、eth、bnb chain等）\n费用     较高（交易费+提现费）       仅gas费         较低（现货0.1%，合约0.02%）\n\n\n# 期货和现货\n\n\n# 1. 现货（spot）\n\n * 定义：现货交易是即时或短期交割的买卖行为。买卖双方约定在交易完成后立即或极短时间内（通常2个工作日内）完成标的资产的交付和资金结算。\n * 特点\n   * 实物或金融资产直接交割：如黄金、原油、外汇、股票等。\n   * 价格反映当前市场供需：现货价格由即时的供求关系决定。\n   * 无杠杆或低杠杆：通常需要全额资金交易（如股票需全额支付）。\n * 例子：你今天用人民币买入1克黄金，明天就能拿到实物黄金。\n\n\n# 2. 期货（futures）\n\n * 定义：期货是标准化合约，约定在未来某一特定日期（到期日），以预先确定的价格买入或卖出一定数量的标的资产（如商品、股指、外汇等）。\n * 杠杆交易：只需支付合约价值的一小部分作为保证金（如5%-20%），可放大收益和风险。\n * 例子：3个月后以5000元/吨的价格买入10吨大豆，无论到期时市场价如何，都按合约执行。\n\n\n# 保证金制度\n\n用“定金”撬动大额交易\n\n * 定义：期货交易不需要支付合约全额价值，只需缴纳一定比例的保证金（通常为合约价值的5%-20%）。\n\n * 例子\n   \n   * 假设黄金期货合约价值100万元（1手=1公斤黄金，假设价格100万元/公斤）。\n   * 交易所规定保证金比例为10%，则投资者只需支付10万元即可买入1手合约。\n   * 此时，10万元控制了100万元的资产，杠杆率 = 100万 / 10万 = 10倍。\n\n * 收益放大\n   \n   * 若黄金价格上涨10%（至110万元/公斤），合约价值变为110万元。\n   * 投资者卖出合约后，盈利为10万元（110万 - 100万）。\n   * 收益率 = 盈利 / 初始投入 = 10万 / 10万 = 100%（现货收益仅10%）。\n\n * 风险放大\n   \n   * 若黄金价格下跌10%（至90万元/公斤），合约价值变为90万元。\n   * 投资者亏损10万元，亏损率 = 10万 / 10万 = 100%（现货亏损仅10%）。\n   * 若未及时追加保证金，可能被强制平仓（爆仓）。\n\n步骤             黄金价格    账户余额    操作\n开仓（买入1手）       100万元   10万元    缴纳初始保证金10万元\n价格跌至93万元       93万元    3万元     触发追加保证金通知（需补至7万）\n未追加保证金         90万元    0万元     强制平仓，亏损10万元\n极端情况（跌至80万元）   80万元    -10万元   穿仓，需追加偿还10万元\n\n\n# 做空与做多\n\n# 1. 做多（buy/long）\n\n * 定义：买入某种资产，预期其价格上涨，未来以更高价格卖出获利。\n * 类比：相当于“低买高卖”，如股票投资。\n * 期货/永续合约中的操作\n   * 支付保证金，开仓买入合约（如黄金期货）。\n   * 若价格上涨，平仓时卖出合约，赚取差价。\n\n# 2. 做空（sell/short）\n\n * 定义：借入并卖出某种资产，预期其价格下跌，未来以更低价格买回归还，赚取差价。\n * 类比：相当于“高卖低买”，如融券卖空股票。\n * 期货/永续合约中的操作\n   * 支付保证金，开仓卖出合约（如比特币永续合约）。\n   * 若价格下跌，平仓时买入合约，赚取差价。",charsets:{cjk:!0}},{title:"栈的应用",frontmatter:{},regularPath:"/algorithm/stack.html",relativePath:"algorithm/stack.md",key:"v-ba589682",path:"/algorithm/stack.html",headers:[{level:2,title:"括号匹配问题",slug:"括号匹配问题",normalizedTitle:"括号匹配问题",charIndex:11},{level:2,title:"最长有效括号",slug:"最长有效括号",normalizedTitle:"最长有效括号",charIndex:776},{level:2,title:"有效的括号",slug:"有效的括号",normalizedTitle:"有效的括号",charIndex:1707},{level:2,title:"最大宽度坡",slug:"最大宽度坡",normalizedTitle:"最大宽度坡",charIndex:2333},{level:2,title:"表现良好的最长时间段",slug:"表现良好的最长时间段",normalizedTitle:"表现良好的最长时间段",charIndex:3029},{level:3,title:"前置知识：前缀和，单调栈",slug:"前置知识-前缀和-单调栈",normalizedTitle:"前置知识：前缀和，单调栈",charIndex:3058},{level:3,title:"回归题目",slug:"回归题目",normalizedTitle:"回归题目",charIndex:3550},{level:2,title:"字符串解码",slug:"字符串解码",normalizedTitle:"字符串解码",charIndex:4541},{level:2,title:"去除重复字母（单调栈）",slug:"去除重复字母-单调栈",normalizedTitle:"去除重复字母（单调栈）",charIndex:5142},{level:2,title:"移掉 k 位数字（单调栈）",slug:"移掉-k-位数字-单调栈",normalizedTitle:"移掉 k 位数字（单调栈）",charIndex:5949},{level:2,title:"接雨水",slug:"接雨水",normalizedTitle:"接雨水",charIndex:7449},{level:2,title:"柱状图中的最大矩形",slug:"柱状图中的最大矩形",normalizedTitle:"柱状图中的最大矩形",charIndex:8557},{level:2,title:"最大矩形",slug:"最大矩形",normalizedTitle:"最大矩形",charIndex:8562},{level:2,title:"对于任意子序列可以计算一个X值",slug:"对于任意子序列可以计算一个x值",normalizedTitle:"对于任意子序列可以计算一个x值",charIndex:10722},{level:2,title:"每日温度",slug:"每日温度",normalizedTitle:"每日温度",charIndex:12071},{level:3,title:"暴力法",slug:"暴力法",normalizedTitle:"暴力法",charIndex:12332},{level:3,title:"单调栈",slug:"单调栈",normalizedTitle:"单调栈",charIndex:2444},{level:2,title:"下一个更大元素",slug:"下一个更大元素",normalizedTitle:"下一个更大元素",charIndex:7742},{level:2,title:"两个栈实现队列",slug:"两个栈实现队列",normalizedTitle:"两个栈实现队列",charIndex:13523},{level:2,title:"最小栈",slug:"最小栈",normalizedTitle:"最小栈",charIndex:14205},{level:2,title:"滑动窗口最大值（单调队列）",slug:"滑动窗口最大值-单调队列",normalizedTitle:"滑动窗口最大值（单调队列）",charIndex:14874}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"括号匹配问题 最长有效括号 有效的括号 最大宽度坡 表现良好的最长时间段 前置知识：前缀和，单调栈 回归题目 字符串解码 去除重复字母（单调栈） 移掉 k 位数字（单调栈） 接雨水 柱状图中的最大矩形 最大矩形 对于任意子序列可以计算一个X值 每日温度 暴力法 单调栈 下一个更大元素 两个栈实现队列 最小栈 滑动窗口最大值（单调队列）",content:'# 栈的应用\n\n\n# 括号匹配问题\n\n大致思路是遇到左括号入栈，遇到右括号将左括号出栈，复杂度为O(n)\n\nconst isBalanced = str => {\n    const stack = []\n    for (const item of str) {\n        if (item === \'(\') {\n            stack.push(item)\n        } else {\n            if (!stack.length) return false\n            stack.pop()\n        }\n    }\n    return stack.length === 0\n}\n\n\n我们还可以把题目再向前面推进一步，如果包含三种括号怎么办：\n\nconst isBalanced = str => {\n    const map = new Map([\n        [\')\', \'(\'],\n        [\'}\', \'{\'],\n        [\']\', \'[\']\n    ])\n    const stack = []\n    for (const item of str) {\n        if (/\\(|\\[|\\{/.test(item)) {\n            stack.push(item)\n        } else {\n            if (!stack.length || stack[stack.length - 1] !== map.get(item)) return false\n            stack.pop()\n        }\n    }\n    return stack.length === 0\n}\n\n\n\n# 最长有效括号\n\n * leetcode32\n * 题解\n\n给定一个只包含 \'(\' 和 \')\' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n输入: "(()"\n输出: 2\n解释: 最长有效括号子串为 "()"\n\n示例 2:\n输入: ")()())"\n输出: 4\n解释: 最长有效括号子串为 "()()"\n\n\n * 对于遇到的每个 \'(\'，我们将它的下标放入栈中\n * 对于遇到的每个 \')\'，我们先弹出栈顶元素表示匹配了当前右括号：\n   * 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」\n   * 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」我们从前往后遍历字符串并更新答案即可。\n * 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1的元素。\n\nvar longestValidParentheses = function(s) {\n    const stack = [-1]; // 栈中始终保存的是无法匹配的位置\n    let res = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === \'(\') {\n            stack.push(i);\n        }\n        else {\n            stack.pop();\n            if (!stack.length) {\n                stack.push(i);\n            }\n            else {\n                res = Math.max(res, i - stack[stack.length - 1]);\n            }\n        }\n    }\n    return res;\n};\n\n\n\n# 有效的括号\n\nhttps://leetcode.cn/problems/valid-parentheses/submissions/\n\nvar isValid = function(s) {\n    const map = new Map([\n        [\'}\', \'{\'],\n        [\']\', \'[\'],\n        [\')\', \'(\'],\n    ]);\n    const stack = [];\n    for (let i = 0; i < s.length; i++) {\n        // 如果是左括号则入栈\n        if (!map.has(s[i])) {\n            stack.push(s[i]);\n        }\n        // 如果是右括号则出栈\n        else {\n            // 栈里没有可出的 或 出栈的元素不匹配则返回 false\n            if (!stack.length || map.get(s[i]) !== stack[stack.length - 1]) {\n                 return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n};\n\n\n\n# 最大宽度坡\n\nleetcode962:最大宽度坡\n\nvar maxWidthRamp = function(nums) {\n    const stack = [0];\n    let res = 0;\n    // 构造单调栈，坡的起点必定在此栈中\n    // 反证法: 假设存在某个元素位置 k 不存在于上面的递减序列中，且有最大宽度 j-k，\n    // 这也就说明 k 位置的元素一定是小于 k 前面所有的元素的，否则就会有更长的宽度，\n    // 但是既然 k 小于前面所有的元素，那么 k 就一定会被加入到序列中，与假设矛盾，所以不存在k，那么解一定存在递减序列中\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < nums[stack[stack.length - 1]]) {\n            stack.push(i);\n        }\n    }\n    // nums 从后向前遍历，每一个元素都与单调栈中的可能的坡起点进行计算，取最大即可\n    for (let i = nums.length - 1; i >= 0; i--) {\n        while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {\n            res = Math.max(res, i - stack.pop());\n        }\n    }\n    return res;\n};\n\n\n\n# 表现良好的最长时间段\n\nleetcode1124\n\n\n# 前置知识：前缀和，单调栈\n\n * 数组转换并计算前缀和\n\nhours = [9, 9, 6, 0, 6, 6, 9]\nscore = [1, 1, -1, -1, -1, -1, 1] // 大于 8 记 1，小于 8 记 -1\npresum = [0, 1, 2, 1, 0, -1, -2, -1] // 前缀和\n\n// presum[j] - presum[i] 代表的是 score[i] 到 score[j - 1] 的区间元素和\n\n\n * 单调栈：就是栈中元素，按递增顺序或者递减顺序排列，最大好处就是时间复杂度是线性的，每个元素遍历一次\n * 单调递增栈可以找到左起第一个比当前数字小的元素\n * 比如数组:[3, 5, 4, 1] 的单调递减栈为 [3, 1]\n\n// 单调栈伪代码\ninsert x\nwhile (stack.length && stack[stack.length - 1] < x) {\n    stack.pop()\n}\nstack.push(x)\n\n\n----------------------------------------\n\n\n# 回归题目\n\n * 我们要找的是：一个最长的区间 能使 score的区间元素和大于 0\n * 有了前缀和就变成了：寻找最长的区间使得 presum[j] - presum[i] > 0\n * 即求 presum 的最大宽度坡\n\n/**\n * @param {number[]} hours\n * @return {number}\n */\n\nvar longestWPI = function(hours) {\n    // 简化数组：[9, 9, 6, 0, 6, 6, 9] => [1, 1, -1, -1, -1, -1, 1]\n    hours = hours.map(h => h > 8 ? 1 : -1);\n    // 构造前缀和：[1, 1, -1, -1, -1, -1, 1] => [0, 1, 2, 1, 0, -1, -2, -1]\n    const presum = [0];\n    for (let i = 0; i < hours.length; i++) {\n        presum[i + 1] = hours[i] + presum[i];\n    }\n    // 求前缀和数组的最大宽度坡\n    const stack = [0];\n    // 构造单调栈\n    for (let i = 1; i < presum.length; i++) {\n        if (presum[i] < presum[stack[stack.length - 1]]) {\n            stack.push(i);\n        }\n    }\n    let res = 0;\n    // presum 从后向前遍历，每一个元素都与单调栈中的可能的坡起点进行计算，取最大即可\n    for (let i = presum.length - 1; i >= 0; i--) {\n        while (stack.length && presum[i] > presum[stack[stack.length - 1]]) {\n            res = Math.max(res, i - stack.pop());\n        }\n    }\n    return res;\n}\n\n\n\n# 字符串解码\n\n示例 1：\n输入：s = "3[a]2[bc]"\n输出："aaabcbc"\n\n示例 2：\n输入：s = "3[a2[c]]"\n输出："accaccacc"\n\n示例 3：\n输入：s = "2[abc]3[cd]ef"\n输出："abcabccdcdcdef"\n\n示例 4：\n输入：s = "abc3[cd]xyz"\n输出："abccdcdcdxyz"\n\n\n * 题目来源：leetcode394\n * 正则解法\n\n\tdecodeString(s) {\n      let reg = /(\\d+)\\[(\\w+)\\]/g\n      while (reg.test(s)) {\n        // replace 第二个参数可以为函数\n        // 参数：匹配到的，$1，$2，索引，源字符串\n        s = s.replace(reg, function(matchStr, group1, group2, index, sourceStr) {\n          let str = ""\n          while(group1--) {\n            str +=  group2\n          }\n          return str;\n        })\n      }\n      console.log(s)\n    }\n\n\n\n# 去除重复字母（单调栈）\n\n * leetcode316\n\n给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 \n\n示例 1：\n输入：s = "bcabc"\n输出："abc"\n\n示例 2：\n输入：s = "cbacdcbc"\n输出："acdb"\n\n\n * 用 map 存储字符串中每个字符出现的次数\n * 遍历字符串，每访问一个字符，将字符入栈，并且当前字符次数减1。入栈之前首先需要判断，当前字符的字典序若小于栈顶字符（栈顶字符次数大于0），则栈顶字符先出栈\n\nvar removeDuplicateLetters = function(s) {\n    const stack = []\n    const map = new Map()\n    for (let i in s) {\n        map.has(s[i]) ? map.set(s[i], map.get(s[i]) + 1) : map.set(s[i], 1)\n    }\n    for (let i in s) {\n        if (!stack.includes(s[i])) {\n            const len = stack.length\n            while (len && s[i] < stack[len - 1] && map.get(stack[len - 1])) {\n                stack.pop()\n            }\n            stack.push(s[i])\n        }\n        map.set(s[i], map.get(s[i]) - 1)\n    }\n    return stack.join("")\n};\n\n\n\n# 移掉 k 位数字（单调栈）\n\n * 题目：leetcode402\n * 可参考：一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\n\n给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。\n\n注意:\nnum 的长度小于 10002 且 ≥ k。\nnum 不会包含任何前导零。\n\n示例 1 :\n输入: num = "1432219", k = 3\n输出: "1219"\n解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。\n\n示例 2 :\n输入: num = "10200", k = 1\n输出: "200"\n解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n\n示例 3 :\n输入: num = "10", k = 2\n输出: "0"\n解释: 从原数字移除所有的数字，剩余为空就是0。\n\n\n给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，小于它的左邻居 4。则我们应该去掉数字 4。如果不这么做，则随后无论做什么，都不会得到最小数。\n\n如果我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果去掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。\n\n这个问题可以用贪心算法来解决。上述规则阐明了我们如何接近最终答案的基本逻辑。一旦我们从序列中删除一个数字，剩下的数字就形成了一个新的问题，我们可以继续使用这个规则。\n\n\n * 思路：从左向右遍历入栈，若下一个数更小，则上一个数出栈。\n\n * 问题： num 是一个增序序列，则不会出栈；是一个降序序列，则会一直出栈。\n\n * 解决：\n   \n   * 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。\n   * 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素 (因为剩下的元素肯定为递增序列，所以优先删除后面的)。。\n\n * 若输入为("1234567890", 9)，按照以上逻辑最后输出的 stack 为 [1,2,3,4,5,6,7,8,0]，所以要设置 while 循环，当 num[i] 一直比栈顶元素小时，则继续出栈\n\n * 使用 Number 处理 0200 => 200，但是保证数字范围使用 BigInt\n\n * 若 num.length === k，说明全部删除，直接返回 "0"\n\nvar removeKdigits = function(num, k) {\n    if (num.length === k) return "0";\n    let n = k;\n    const stack = [num[0]];\n    for (let i = 1; i < num.length; i++) {\n        while (stack.length && num[i] < stack[stack.length - 1] && n) {\n            stack.pop();\n            n--;\n        }\n        stack.push(num[i]);\n    }\n    return BigInt(stack.slice(0, num.length - k).join(\'\')) + \'\';\n}\n\n\n\n# 接雨水\n\n * leetcode42\n * 题解1，题解2\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n\n * 数据结构：单调栈\n * 当后面的柱子高度比前面的低时，是无法接雨水的，当找到一根比前面高的柱子，就可以计算接到的雨水，所以使用单调递减栈\n * 当出现高于栈顶的柱子时，说明可以对前面的柱子结算了，计算已经到手的雨水，然后出栈前面更低的柱子\n * 相当于构造单调递减栈，每一次找到下一个更大元素，就是结算的时机。\n\nvar trap = function(height) {\n    const stack = [];\n    let res = 0;\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length && height[i] > height[stack[stack.length - 1]]) {\n            // 有低洼则弹出\n            let bottom = stack.pop();\n            // 有右墙有低洼但是栈为空说明没有左墙, 则没有用直接 break\n            if (!stack.length) {\n                break;\n            }\n            let left = stack[stack.length - 1]; // 左墙索引\n            let leftHeight = height[left]; // 左墙高度\n            let rightHeight = height[i]; // 右墙高度\n            let bottomHight = height[bottom]; // 低洼高度\n            // 能积攒的水 = (右墙索引 - 左墙索引 - 1) * (min(左墙高度, 右墙高度) - 低洼高度)\n            res += (i - left - 1) * (Math.min(leftHeight, rightHeight) - bottomHight);\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 柱状图中的最大矩形\n\n * leetcode84\n * 题解\n\n> 首先，要想找到第 i 位置最大面积是什么？\n> \n> 是以i 为中心，向左找第一个小于heights[i]的位置left；向右找第一个小于heights[i]的位置 right，即最大面积为 heights[i] * (right - left -1)\n> \n> 单调递增栈，栈内的元素是递增的\n> \n> 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素\n> \n> 举个例子，栈里是 1 5 6 。接下来新元素是 2 ，那么 6 需要出栈。 当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。\n> \n> 当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素 当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。\n\n * 思路：每次出栈时，tmp = stack.pop，当前的 i 是右边第一个比他小的，栈顶为左边第一个比他小的，只需要heights[tmp] * (right - left -1)\n\nvar largestRectangleArea = function(heights) {\n    if (heights.length === 0) return 0;\n    if (heights.length === 1) return heights[0];\n    heights.unshift(0);\n    heights.push(0);\n    const stack = [0];\n    let res = 0;\n    for (let i = 1; i < heights.length; i++) {\n        while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n            // 计算以 tmp 为中心的最大面积\n            let tmp = stack.pop();\n            res = Math.max(res, heights[tmp] * (i - stack[stack.length - 1] - 1));\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 最大矩形\n\n * leetcode85\n * 完全可以把问题转换成上一题，针对每一行求最大高度\n\n// 求柱状图最大矩形\nconst maxArea = function(heights) {\n    if (heights.length === 0) return 0\n    if (heights.length === 1) return heights[0]\n    heights.unshift(0)\n    heights.push(0)\n    const stack = []\n    let res = 0\n    for (let i = 0; i < heights.length; i++) {\n        while(stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n            let tmp = stack.pop()\n            res = Math.max(res, heights[tmp] * (i - stack[stack.length - 1] - 1))\n        }\n        stack.push(i)\n    }\n    return res\n }\n\n// 针对每一行求最大高度\nvar maximalRectangle = function(matrix) {\n    if (!matrix.length) return 0;\n    const m = matrix.length\n    const n = matrix[0].length;\n    const arr = Array.from(new Array(m), () => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === \'1\') {\n                arr[i][j] = i === 0 ? +matrix[i][j] : arr[i - 1][j] + 1;\n            }\n        }\n    }\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        res = Math.max(maxArea(arr[i]), res);\n    }\n    return res;\n};\n\n\n\n# 对于任意子序列可以计算一个X值\n\n> X = sum(subArray) * min(subArray)， 求最大X\n> \n> 例如：[3,1,6,4,5,2]\n> \n> X = (6+4+5) * 4 = 60\n\n * 单调递增栈，若遍历到某元素比栈顶元素小，那么这个元素就是右侧第一比他小的，出栈，此时栈顶为左侧第一比他小的，所以此时可以结算以出栈元素为最小值的子序列\n * 首先3入栈，[3]，遇到1 < 3，3出栈，left = arr[-1] = 0，right = arr[1] = 1，res = 3 * 3 = 9\n * 1和6入栈，[1, 6]，遇到 4 < 6，6出栈，left = arr[1] = 1，right = arr[3] = 4, res = 6 * 6 = 36\n * [1, 4, 5]，遇到 2 < 5，5出栈，同理 res = 25\n * [1, 4]，遇到 2< 4，4出栈，左侧为1，右侧为2，找中间的，res = 4 * (6 + 4 + 5) = 60\n * [1, 2]，需要把剩下的全部结算\n\nfunction calX(arr) {\n    let res = 0\n    const stack = []\n    stack.push(0)\n    for (let i = 1; i < arr.length; i++) {\n        while (stack.length && arr[i] <= arr[stack[stack.length - 1]]) {\n            let tmp = stack.pop()\n            let left = stack[stack.length - 1] || -1\n            let right = i\n            let ans = 0\n            for (let j = left + 1; j < right; j++) {\n                ans += arr[j]\n            }\n            res = Math.max(res, ans * arr[tmp])\n        }\n        stack.push(i)\n    }\n    console.log(stack) // 此时为 [1, 2],需要将栈中剩余元素结算\n    while (stack.length) {\n        let tmp = stack.pop()\n        let left = stack[stack.length - 1] || -1\n        let right = arr.length\n        let ans = 0\n        for (let j = left + 1; j < right; j++) {\n            ans += arr[j]\n        }\n        res = Math.max(res, ans * arr[tmp])\n    }\n    return res\n}\n\n\n\n# 每日温度\n\n * leetcode739\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n\n\n# 暴力法\n\nvar dailyTemperatures = function(T) {\n    let len = T.length\n    let res = new Array(len).fill(0)\n    for (let i = 1; i < len; i++) {\n        for (let j = 0; j < i; j++) {\n            if (res[j] === 0 && T[i] > T[j]) {\n                res[j] = i - j\n            } \n        }\n    }\n   return res\n};\n\n\n\n# 单调栈\n\n * 维护单调递减栈，一旦入栈元素大于栈顶元素，则 pop，并记录索引的差值\n * 图示\n\n// 可以理解为数组中找到右侧第一个比自己大的数\nvar dailyTemperatures = function(T) {\n    const res = new Array(T.length).fill(0);\n    const stack = [];\n    for (let i = 0; i < T.length; i++) {\n        while (stack.length && T[i] > T[stack[stack.length - 1]]) {\n            res[stack[stack.length - 1]] = i - stack.pop();\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 下一个更大元素\n\n * leetcode496\n\nvar nextGreaterElement = function(nums1, nums2) {\n    const map = new Array(nums2.length).fill(-1);\n    const stack = [];\n    // 求 nums2 中每个元素的下一最大元素\n    for (let i = 0; i < nums2.length; i++) {\n        while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {\n            map[stack[stack.length - 1]] = nums2[i];\n            stack.pop();\n        }\n        stack.push(i);\n    }\n    return nums1.map(n => map[nums2.indexOf(n)]);\n};\n\n\n\n# 两个栈实现队列\n\nclass CQueue {\n    constructor () {\n        this.pushStack = []; // 存储入队的值   模拟入队行为\n        this.deleStack = []; // 存储待出队的项 模拟出队行为\n    }\n    appendTail(v) {\n        this.pushStack.push(v);\n    }\n    deleteHead() {\n        // 若待删除栈中有值则直接pop 模拟出队行为\n        if (this.deleStack.length) {\n            return this.deleStack.pop();\n        }\n        // 若 push 栈中有值 则全部推入 delete 栈中\n        while (this.pushStack.length) {\n            this.deleStack.push(this.pushStack.pop());\n        }\n        // 此时出栈对还无内容，返回 -1\n        if(!this.deleStack.length) {\n            return -1;\n        // 有内容，弹出栈顶，且返回即可\n        } else {\n            return this.deleStack.pop();\n        }\n    }\n}\n\n\n\n# 最小栈\n\n * leetcode155\n * 题解\n\nclass MinStack {\n    // 定义一个辅助栈记录最小值，长度和主栈长度一致\n    constructor() {\n        this.stack = [];\n        this.helper = [];\n    }\n    push(val) {\n        this.stack.push(val);\n        // 如果空 或者 当前值小于等于辅助栈栈顶 则直接入队\n        if (!this.helper.length || val <= this.helper[this.helper.length - 1]) {\n            this.helper.push(val);\n        } else {\n            this.helper.push(this.helper[this.helper.length - 1]);\n        }\n    }\n    pop() {\n        this.stack.pop();\n        this.helper.pop();\n    }\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n    getMin() {\n        return this.helper[this.helper.length - 1];\n    }\n}\n\n\n\n# 滑动窗口最大值（单调队列）\n\n * leetcode239\n * 题解\n\nvar maxSlidingWindow = function(nums, k) {\n    class Queue {\n        constructor() {\n            this.queue = [];\n        }\n        appendTail(val) {\n            // 保证队列单调递减\n            while (this.queue.length && val > this.queue[this.queue.length - 1]) {\n                this.queue.pop();\n            }\n            this.queue.push(val);\n        }\n        deleteHead(val) {\n            if (this.queue[0] === val) {\n                this.queue.shift();\n            }\n        }\n        head() {\n            return this.queue[0];\n        }\n    }\n    const queue = new Queue();\n    const res = [];\n    // 先放进去 k 个\n    for (let i = 0; i < k; i++) {\n        queue.appendTail(nums[i]);\n    }\n    res.push(queue.head());\n    for (let i = k; i < nums.length; i++) {\n        // 移动窗口并计算最大值\n        queue.deleteHead(nums[i - k]);\n        queue.appendTail(nums[i]);\n        res.push(queue.head());\n    }\n    return res;\n};\n',normalizedContent:'# 栈的应用\n\n\n# 括号匹配问题\n\n大致思路是遇到左括号入栈，遇到右括号将左括号出栈，复杂度为o(n)\n\nconst isbalanced = str => {\n    const stack = []\n    for (const item of str) {\n        if (item === \'(\') {\n            stack.push(item)\n        } else {\n            if (!stack.length) return false\n            stack.pop()\n        }\n    }\n    return stack.length === 0\n}\n\n\n我们还可以把题目再向前面推进一步，如果包含三种括号怎么办：\n\nconst isbalanced = str => {\n    const map = new map([\n        [\')\', \'(\'],\n        [\'}\', \'{\'],\n        [\']\', \'[\']\n    ])\n    const stack = []\n    for (const item of str) {\n        if (/\\(|\\[|\\{/.test(item)) {\n            stack.push(item)\n        } else {\n            if (!stack.length || stack[stack.length - 1] !== map.get(item)) return false\n            stack.pop()\n        }\n    }\n    return stack.length === 0\n}\n\n\n\n# 最长有效括号\n\n * leetcode32\n * 题解\n\n给定一个只包含 \'(\' 和 \')\' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n输入: "(()"\n输出: 2\n解释: 最长有效括号子串为 "()"\n\n示例 2:\n输入: ")()())"\n输出: 4\n解释: 最长有效括号子串为 "()()"\n\n\n * 对于遇到的每个 \'(\'，我们将它的下标放入栈中\n * 对于遇到的每个 \')\'，我们先弹出栈顶元素表示匹配了当前右括号：\n   * 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」\n   * 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」我们从前往后遍历字符串并更新答案即可。\n * 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1的元素。\n\nvar longestvalidparentheses = function(s) {\n    const stack = [-1]; // 栈中始终保存的是无法匹配的位置\n    let res = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === \'(\') {\n            stack.push(i);\n        }\n        else {\n            stack.pop();\n            if (!stack.length) {\n                stack.push(i);\n            }\n            else {\n                res = math.max(res, i - stack[stack.length - 1]);\n            }\n        }\n    }\n    return res;\n};\n\n\n\n# 有效的括号\n\nhttps://leetcode.cn/problems/valid-parentheses/submissions/\n\nvar isvalid = function(s) {\n    const map = new map([\n        [\'}\', \'{\'],\n        [\']\', \'[\'],\n        [\')\', \'(\'],\n    ]);\n    const stack = [];\n    for (let i = 0; i < s.length; i++) {\n        // 如果是左括号则入栈\n        if (!map.has(s[i])) {\n            stack.push(s[i]);\n        }\n        // 如果是右括号则出栈\n        else {\n            // 栈里没有可出的 或 出栈的元素不匹配则返回 false\n            if (!stack.length || map.get(s[i]) !== stack[stack.length - 1]) {\n                 return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n};\n\n\n\n# 最大宽度坡\n\nleetcode962:最大宽度坡\n\nvar maxwidthramp = function(nums) {\n    const stack = [0];\n    let res = 0;\n    // 构造单调栈，坡的起点必定在此栈中\n    // 反证法: 假设存在某个元素位置 k 不存在于上面的递减序列中，且有最大宽度 j-k，\n    // 这也就说明 k 位置的元素一定是小于 k 前面所有的元素的，否则就会有更长的宽度，\n    // 但是既然 k 小于前面所有的元素，那么 k 就一定会被加入到序列中，与假设矛盾，所以不存在k，那么解一定存在递减序列中\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < nums[stack[stack.length - 1]]) {\n            stack.push(i);\n        }\n    }\n    // nums 从后向前遍历，每一个元素都与单调栈中的可能的坡起点进行计算，取最大即可\n    for (let i = nums.length - 1; i >= 0; i--) {\n        while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {\n            res = math.max(res, i - stack.pop());\n        }\n    }\n    return res;\n};\n\n\n\n# 表现良好的最长时间段\n\nleetcode1124\n\n\n# 前置知识：前缀和，单调栈\n\n * 数组转换并计算前缀和\n\nhours = [9, 9, 6, 0, 6, 6, 9]\nscore = [1, 1, -1, -1, -1, -1, 1] // 大于 8 记 1，小于 8 记 -1\npresum = [0, 1, 2, 1, 0, -1, -2, -1] // 前缀和\n\n// presum[j] - presum[i] 代表的是 score[i] 到 score[j - 1] 的区间元素和\n\n\n * 单调栈：就是栈中元素，按递增顺序或者递减顺序排列，最大好处就是时间复杂度是线性的，每个元素遍历一次\n * 单调递增栈可以找到左起第一个比当前数字小的元素\n * 比如数组:[3, 5, 4, 1] 的单调递减栈为 [3, 1]\n\n// 单调栈伪代码\ninsert x\nwhile (stack.length && stack[stack.length - 1] < x) {\n    stack.pop()\n}\nstack.push(x)\n\n\n----------------------------------------\n\n\n# 回归题目\n\n * 我们要找的是：一个最长的区间 能使 score的区间元素和大于 0\n * 有了前缀和就变成了：寻找最长的区间使得 presum[j] - presum[i] > 0\n * 即求 presum 的最大宽度坡\n\n/**\n * @param {number[]} hours\n * @return {number}\n */\n\nvar longestwpi = function(hours) {\n    // 简化数组：[9, 9, 6, 0, 6, 6, 9] => [1, 1, -1, -1, -1, -1, 1]\n    hours = hours.map(h => h > 8 ? 1 : -1);\n    // 构造前缀和：[1, 1, -1, -1, -1, -1, 1] => [0, 1, 2, 1, 0, -1, -2, -1]\n    const presum = [0];\n    for (let i = 0; i < hours.length; i++) {\n        presum[i + 1] = hours[i] + presum[i];\n    }\n    // 求前缀和数组的最大宽度坡\n    const stack = [0];\n    // 构造单调栈\n    for (let i = 1; i < presum.length; i++) {\n        if (presum[i] < presum[stack[stack.length - 1]]) {\n            stack.push(i);\n        }\n    }\n    let res = 0;\n    // presum 从后向前遍历，每一个元素都与单调栈中的可能的坡起点进行计算，取最大即可\n    for (let i = presum.length - 1; i >= 0; i--) {\n        while (stack.length && presum[i] > presum[stack[stack.length - 1]]) {\n            res = math.max(res, i - stack.pop());\n        }\n    }\n    return res;\n}\n\n\n\n# 字符串解码\n\n示例 1：\n输入：s = "3[a]2[bc]"\n输出："aaabcbc"\n\n示例 2：\n输入：s = "3[a2[c]]"\n输出："accaccacc"\n\n示例 3：\n输入：s = "2[abc]3[cd]ef"\n输出："abcabccdcdcdef"\n\n示例 4：\n输入：s = "abc3[cd]xyz"\n输出："abccdcdcdxyz"\n\n\n * 题目来源：leetcode394\n * 正则解法\n\n\tdecodestring(s) {\n      let reg = /(\\d+)\\[(\\w+)\\]/g\n      while (reg.test(s)) {\n        // replace 第二个参数可以为函数\n        // 参数：匹配到的，$1，$2，索引，源字符串\n        s = s.replace(reg, function(matchstr, group1, group2, index, sourcestr) {\n          let str = ""\n          while(group1--) {\n            str +=  group2\n          }\n          return str;\n        })\n      }\n      console.log(s)\n    }\n\n\n\n# 去除重复字母（单调栈）\n\n * leetcode316\n\n给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 \n\n示例 1：\n输入：s = "bcabc"\n输出："abc"\n\n示例 2：\n输入：s = "cbacdcbc"\n输出："acdb"\n\n\n * 用 map 存储字符串中每个字符出现的次数\n * 遍历字符串，每访问一个字符，将字符入栈，并且当前字符次数减1。入栈之前首先需要判断，当前字符的字典序若小于栈顶字符（栈顶字符次数大于0），则栈顶字符先出栈\n\nvar removeduplicateletters = function(s) {\n    const stack = []\n    const map = new map()\n    for (let i in s) {\n        map.has(s[i]) ? map.set(s[i], map.get(s[i]) + 1) : map.set(s[i], 1)\n    }\n    for (let i in s) {\n        if (!stack.includes(s[i])) {\n            const len = stack.length\n            while (len && s[i] < stack[len - 1] && map.get(stack[len - 1])) {\n                stack.pop()\n            }\n            stack.push(s[i])\n        }\n        map.set(s[i], map.get(s[i]) - 1)\n    }\n    return stack.join("")\n};\n\n\n\n# 移掉 k 位数字（单调栈）\n\n * 题目：leetcode402\n * 可参考：一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\n\n给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。\n\n注意:\nnum 的长度小于 10002 且 ≥ k。\nnum 不会包含任何前导零。\n\n示例 1 :\n输入: num = "1432219", k = 3\n输出: "1219"\n解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。\n\n示例 2 :\n输入: num = "10200", k = 1\n输出: "200"\n解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n\n示例 3 :\n输入: num = "10", k = 2\n输出: "0"\n解释: 从原数字移除所有的数字，剩余为空就是0。\n\n\n给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，小于它的左邻居 4。则我们应该去掉数字 4。如果不这么做，则随后无论做什么，都不会得到最小数。\n\n如果我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果去掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。\n\n这个问题可以用贪心算法来解决。上述规则阐明了我们如何接近最终答案的基本逻辑。一旦我们从序列中删除一个数字，剩下的数字就形成了一个新的问题，我们可以继续使用这个规则。\n\n\n * 思路：从左向右遍历入栈，若下一个数更小，则上一个数出栈。\n\n * 问题： num 是一个增序序列，则不会出栈；是一个降序序列，则会一直出栈。\n\n * 解决：\n   \n   * 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。\n   * 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素 (因为剩下的元素肯定为递增序列，所以优先删除后面的)。。\n\n * 若输入为("1234567890", 9)，按照以上逻辑最后输出的 stack 为 [1,2,3,4,5,6,7,8,0]，所以要设置 while 循环，当 num[i] 一直比栈顶元素小时，则继续出栈\n\n * 使用 number 处理 0200 => 200，但是保证数字范围使用 bigint\n\n * 若 num.length === k，说明全部删除，直接返回 "0"\n\nvar removekdigits = function(num, k) {\n    if (num.length === k) return "0";\n    let n = k;\n    const stack = [num[0]];\n    for (let i = 1; i < num.length; i++) {\n        while (stack.length && num[i] < stack[stack.length - 1] && n) {\n            stack.pop();\n            n--;\n        }\n        stack.push(num[i]);\n    }\n    return bigint(stack.slice(0, num.length - k).join(\'\')) + \'\';\n}\n\n\n\n# 接雨水\n\n * leetcode42\n * 题解1，题解2\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n\n * 数据结构：单调栈\n * 当后面的柱子高度比前面的低时，是无法接雨水的，当找到一根比前面高的柱子，就可以计算接到的雨水，所以使用单调递减栈\n * 当出现高于栈顶的柱子时，说明可以对前面的柱子结算了，计算已经到手的雨水，然后出栈前面更低的柱子\n * 相当于构造单调递减栈，每一次找到下一个更大元素，就是结算的时机。\n\nvar trap = function(height) {\n    const stack = [];\n    let res = 0;\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length && height[i] > height[stack[stack.length - 1]]) {\n            // 有低洼则弹出\n            let bottom = stack.pop();\n            // 有右墙有低洼但是栈为空说明没有左墙, 则没有用直接 break\n            if (!stack.length) {\n                break;\n            }\n            let left = stack[stack.length - 1]; // 左墙索引\n            let leftheight = height[left]; // 左墙高度\n            let rightheight = height[i]; // 右墙高度\n            let bottomhight = height[bottom]; // 低洼高度\n            // 能积攒的水 = (右墙索引 - 左墙索引 - 1) * (min(左墙高度, 右墙高度) - 低洼高度)\n            res += (i - left - 1) * (math.min(leftheight, rightheight) - bottomhight);\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 柱状图中的最大矩形\n\n * leetcode84\n * 题解\n\n> 首先，要想找到第 i 位置最大面积是什么？\n> \n> 是以i 为中心，向左找第一个小于heights[i]的位置left；向右找第一个小于heights[i]的位置 right，即最大面积为 heights[i] * (right - left -1)\n> \n> 单调递增栈，栈内的元素是递增的\n> \n> 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素\n> \n> 举个例子，栈里是 1 5 6 。接下来新元素是 2 ，那么 6 需要出栈。 当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。\n> \n> 当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素 当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。\n\n * 思路：每次出栈时，tmp = stack.pop，当前的 i 是右边第一个比他小的，栈顶为左边第一个比他小的，只需要heights[tmp] * (right - left -1)\n\nvar largestrectanglearea = function(heights) {\n    if (heights.length === 0) return 0;\n    if (heights.length === 1) return heights[0];\n    heights.unshift(0);\n    heights.push(0);\n    const stack = [0];\n    let res = 0;\n    for (let i = 1; i < heights.length; i++) {\n        while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n            // 计算以 tmp 为中心的最大面积\n            let tmp = stack.pop();\n            res = math.max(res, heights[tmp] * (i - stack[stack.length - 1] - 1));\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 最大矩形\n\n * leetcode85\n * 完全可以把问题转换成上一题，针对每一行求最大高度\n\n// 求柱状图最大矩形\nconst maxarea = function(heights) {\n    if (heights.length === 0) return 0\n    if (heights.length === 1) return heights[0]\n    heights.unshift(0)\n    heights.push(0)\n    const stack = []\n    let res = 0\n    for (let i = 0; i < heights.length; i++) {\n        while(stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n            let tmp = stack.pop()\n            res = math.max(res, heights[tmp] * (i - stack[stack.length - 1] - 1))\n        }\n        stack.push(i)\n    }\n    return res\n }\n\n// 针对每一行求最大高度\nvar maximalrectangle = function(matrix) {\n    if (!matrix.length) return 0;\n    const m = matrix.length\n    const n = matrix[0].length;\n    const arr = array.from(new array(m), () => new array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === \'1\') {\n                arr[i][j] = i === 0 ? +matrix[i][j] : arr[i - 1][j] + 1;\n            }\n        }\n    }\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        res = math.max(maxarea(arr[i]), res);\n    }\n    return res;\n};\n\n\n\n# 对于任意子序列可以计算一个x值\n\n> x = sum(subarray) * min(subarray)， 求最大x\n> \n> 例如：[3,1,6,4,5,2]\n> \n> x = (6+4+5) * 4 = 60\n\n * 单调递增栈，若遍历到某元素比栈顶元素小，那么这个元素就是右侧第一比他小的，出栈，此时栈顶为左侧第一比他小的，所以此时可以结算以出栈元素为最小值的子序列\n * 首先3入栈，[3]，遇到1 < 3，3出栈，left = arr[-1] = 0，right = arr[1] = 1，res = 3 * 3 = 9\n * 1和6入栈，[1, 6]，遇到 4 < 6，6出栈，left = arr[1] = 1，right = arr[3] = 4, res = 6 * 6 = 36\n * [1, 4, 5]，遇到 2 < 5，5出栈，同理 res = 25\n * [1, 4]，遇到 2< 4，4出栈，左侧为1，右侧为2，找中间的，res = 4 * (6 + 4 + 5) = 60\n * [1, 2]，需要把剩下的全部结算\n\nfunction calx(arr) {\n    let res = 0\n    const stack = []\n    stack.push(0)\n    for (let i = 1; i < arr.length; i++) {\n        while (stack.length && arr[i] <= arr[stack[stack.length - 1]]) {\n            let tmp = stack.pop()\n            let left = stack[stack.length - 1] || -1\n            let right = i\n            let ans = 0\n            for (let j = left + 1; j < right; j++) {\n                ans += arr[j]\n            }\n            res = math.max(res, ans * arr[tmp])\n        }\n        stack.push(i)\n    }\n    console.log(stack) // 此时为 [1, 2],需要将栈中剩余元素结算\n    while (stack.length) {\n        let tmp = stack.pop()\n        let left = stack[stack.length - 1] || -1\n        let right = arr.length\n        let ans = 0\n        for (let j = left + 1; j < right; j++) {\n            ans += arr[j]\n        }\n        res = math.max(res, ans * arr[tmp])\n    }\n    return res\n}\n\n\n\n# 每日温度\n\n * leetcode739\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n\n\n# 暴力法\n\nvar dailytemperatures = function(t) {\n    let len = t.length\n    let res = new array(len).fill(0)\n    for (let i = 1; i < len; i++) {\n        for (let j = 0; j < i; j++) {\n            if (res[j] === 0 && t[i] > t[j]) {\n                res[j] = i - j\n            } \n        }\n    }\n   return res\n};\n\n\n\n# 单调栈\n\n * 维护单调递减栈，一旦入栈元素大于栈顶元素，则 pop，并记录索引的差值\n * 图示\n\n// 可以理解为数组中找到右侧第一个比自己大的数\nvar dailytemperatures = function(t) {\n    const res = new array(t.length).fill(0);\n    const stack = [];\n    for (let i = 0; i < t.length; i++) {\n        while (stack.length && t[i] > t[stack[stack.length - 1]]) {\n            res[stack[stack.length - 1]] = i - stack.pop();\n        }\n        stack.push(i);\n    }\n    return res;\n}\n\n\n\n# 下一个更大元素\n\n * leetcode496\n\nvar nextgreaterelement = function(nums1, nums2) {\n    const map = new array(nums2.length).fill(-1);\n    const stack = [];\n    // 求 nums2 中每个元素的下一最大元素\n    for (let i = 0; i < nums2.length; i++) {\n        while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {\n            map[stack[stack.length - 1]] = nums2[i];\n            stack.pop();\n        }\n        stack.push(i);\n    }\n    return nums1.map(n => map[nums2.indexof(n)]);\n};\n\n\n\n# 两个栈实现队列\n\nclass cqueue {\n    constructor () {\n        this.pushstack = []; // 存储入队的值   模拟入队行为\n        this.delestack = []; // 存储待出队的项 模拟出队行为\n    }\n    appendtail(v) {\n        this.pushstack.push(v);\n    }\n    deletehead() {\n        // 若待删除栈中有值则直接pop 模拟出队行为\n        if (this.delestack.length) {\n            return this.delestack.pop();\n        }\n        // 若 push 栈中有值 则全部推入 delete 栈中\n        while (this.pushstack.length) {\n            this.delestack.push(this.pushstack.pop());\n        }\n        // 此时出栈对还无内容，返回 -1\n        if(!this.delestack.length) {\n            return -1;\n        // 有内容，弹出栈顶，且返回即可\n        } else {\n            return this.delestack.pop();\n        }\n    }\n}\n\n\n\n# 最小栈\n\n * leetcode155\n * 题解\n\nclass minstack {\n    // 定义一个辅助栈记录最小值，长度和主栈长度一致\n    constructor() {\n        this.stack = [];\n        this.helper = [];\n    }\n    push(val) {\n        this.stack.push(val);\n        // 如果空 或者 当前值小于等于辅助栈栈顶 则直接入队\n        if (!this.helper.length || val <= this.helper[this.helper.length - 1]) {\n            this.helper.push(val);\n        } else {\n            this.helper.push(this.helper[this.helper.length - 1]);\n        }\n    }\n    pop() {\n        this.stack.pop();\n        this.helper.pop();\n    }\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n    getmin() {\n        return this.helper[this.helper.length - 1];\n    }\n}\n\n\n\n# 滑动窗口最大值（单调队列）\n\n * leetcode239\n * 题解\n\nvar maxslidingwindow = function(nums, k) {\n    class queue {\n        constructor() {\n            this.queue = [];\n        }\n        appendtail(val) {\n            // 保证队列单调递减\n            while (this.queue.length && val > this.queue[this.queue.length - 1]) {\n                this.queue.pop();\n            }\n            this.queue.push(val);\n        }\n        deletehead(val) {\n            if (this.queue[0] === val) {\n                this.queue.shift();\n            }\n        }\n        head() {\n            return this.queue[0];\n        }\n    }\n    const queue = new queue();\n    const res = [];\n    // 先放进去 k 个\n    for (let i = 0; i < k; i++) {\n        queue.appendtail(nums[i]);\n    }\n    res.push(queue.head());\n    for (let i = k; i < nums.length; i++) {\n        // 移动窗口并计算最大值\n        queue.deletehead(nums[i - k]);\n        queue.appendtail(nums[i]);\n        res.push(queue.head());\n    }\n    return res;\n};\n',charsets:{cjk:!0}},{title:"二叉树相关",frontmatter:{title:"二叉树相关",date:"2020-12-29T09:52:01.000Z",categories:"算法"},regularPath:"/algorithm/tree.html",relativePath:"algorithm/tree.md",key:"v-401c9622",path:"/algorithm/tree.html",headers:[{level:2,title:"二叉树的前序遍历，中序遍历，后序遍历的递归与非递归",slug:"二叉树的前序遍历-中序遍历-后序遍历的递归与非递归",normalizedTitle:"二叉树的前序遍历，中序遍历，后序遍历的递归与非递归",charIndex:12},{level:2,title:"相同的树",slug:"相同的树",normalizedTitle:"相同的树",charIndex:2417},{level:2,title:"判断二叉树是否对称",slug:"判断二叉树是否对称",normalizedTitle:"判断二叉树是否对称",charIndex:54},{level:2,title:"合并二叉树",slug:"合并二叉树",normalizedTitle:"合并二叉树",charIndex:67},{level:2,title:"求二叉树的深度(最大，最小)",slug:"求二叉树的深度-最大-最小",normalizedTitle:"求二叉树的深度(最大，最小)",charIndex:3665},{level:2,title:"翻转二叉树",slug:"翻转二叉树",normalizedTitle:"翻转二叉树",charIndex:87},{level:2,title:"二叉树的层次遍历",slug:"二叉树的层次遍历",normalizedTitle:"二叉树的层次遍历",charIndex:96},{level:2,title:"有序数组转二叉搜索树",slug:"有序数组转二叉搜索树",normalizedTitle:"有序数组转二叉搜索树",charIndex:108},{level:2,title:"有序链表转二叉搜索树",slug:"有序链表转二叉搜索树",normalizedTitle:"有序链表转二叉搜索树",charIndex:8493},{level:2,title:"验证二叉搜索树",slug:"验证二叉搜索树",normalizedTitle:"验证二叉搜索树",charIndex:122},{level:2,title:"判断平衡二叉树",slug:"判断平衡二叉树",normalizedTitle:"判断平衡二叉树",charIndex:133},{level:2,title:"验证前序序列",slug:"验证前序序列",normalizedTitle:"验证前序序列",charIndex:144},{level:2,title:"求二叉树的宽度",slug:"求二叉树的宽度",normalizedTitle:"求二叉树的宽度",charIndex:154},{level:2,title:"前序中序构造二叉树",slug:"前序中序构造二叉树",normalizedTitle:"前序中序构造二叉树",charIndex:165},{level:2,title:"二叉树的右视图",slug:"二叉树的右视图",normalizedTitle:"二叉树的右视图",charIndex:178},{level:2,title:"二叉树展开为链表",slug:"二叉树展开为链表",normalizedTitle:"二叉树展开为链表",charIndex:189},{level:2,title:"最近公共祖先",slug:"最近公共祖先",normalizedTitle:"最近公共祖先",charIndex:201},{level:2,title:"根据边构造二叉树",slug:"根据边构造二叉树",normalizedTitle:"根据边构造二叉树",charIndex:211},{level:2,title:"扁平数据结构转Tree",slug:"扁平数据结构转tree",normalizedTitle:"扁平数据结构转tree",charIndex:223}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"二叉树的前序遍历，中序遍历，后序遍历的递归与非递归 相同的树 判断二叉树是否对称 合并二叉树 求二叉树的深度(最大，最小) 翻转二叉树 二叉树的层次遍历 有序数组转二叉搜索树 有序链表转二叉搜索树 验证二叉搜索树 判断平衡二叉树 验证前序序列 求二叉树的宽度 前序中序构造二叉树 二叉树的右视图 二叉树展开为链表 最近公共祖先 根据边构造二叉树 扁平数据结构转Tree",content:'# 二叉树相关\n\n * 二叉树的前序遍历，中序遍历，后序遍历的递归与非递归\n * 判断二叉树是否相同\n * 判断二叉树是否对称\n * 合并二叉树\n * 求二叉树的深度\n * 翻转二叉树\n * 二叉树的层次遍历\n * 有序数组转二叉搜索树\n * 验证二叉搜索树\n * 判断平衡二叉树\n * 验证前序序列\n * 求二叉树的宽度\n * 前序中序构造二叉树\n * 二叉树的右视图\n * 二叉树展开为链表\n * 最近公共祖先\n * 根据边构造二叉树\n * 扁平数据结构转Tree\n\n\n# 二叉树的前序遍历，中序遍历，后序遍历的递归与非递归\n\n * 前序遍历\n * 中序遍历\n * 后序遍历\n\n给一棵二叉树\n\nvar root = {\nval: 1,\nleft: {\n    val: 2,\n    left: {\n      val: 4,\n    },\n    right:{\n      val:5\n    }\n},\nright: {\n    val: 3,\n    left: {\n      val: 6\n    },\n    right: {\n      val: 7\n    }\n}\n}\n\n\nfunction TreeNode(val) {  // 树节点构造方式\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\n\n//先序递归\nvar preorderTraversal = function(root) {\n    const res = []; \n    function DLR (root) {\n      if (root) {\n          res.push(root.val);\n          DLR(root.left);\n          DLR(root.right);\n      }\n  \t}\n    DLR(root);\n    return res;\n};\n\n//中序递归\nvar inorderTraversal = function(root) {\n    const res = []; \n    function LDR (root) {\n    \tif (root) {\n        LDR(root.left);//先遍历到最左边的节点，然后输出\n        res.push(root.val);\n        LDR(root.right);\n      }\n    }\n    LDR(root);\n    return res;\n};\n\n//后序递归\nvar postorderTraversal = function(root) {\n    const res = []; \n    function LRD (root) {\n      if(root){\n        LRD(root.left);\n        LRD(root.right);\n        res.push(root.val);\n      }\n    }\n    LRD(root);\n    return res;\n};\n\n//先序非递归\nvar preorderTraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res = [];\n    stack.push(root);\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        if (tmp.right) stack.push(tmp.right);\n        if (tmp.left) stack.push(tmp.left);\n    } \n    return res;\n};\n\n//中序非递归\nvar inorderTraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res= [];\n    while (true) {\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n        if (stack.length === 0) break;\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        root = tmp.right;\n    }\n    return res;\n};\n\n//后序非递归\nvar postorderTraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res = [];\n    stack.push(root);\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        if (tmp.left) stack.push(tmp.left);\n        if (tmp.right) stack.push(tmp.right);\n    } \n    return res.reverse();\n};\n\n\n\n# 相同的树\n\nleetcode100\n\nvar isSameTree = function(p, q) {\n    if (!p && !q) {\n        return true;\n    }\n    else if ((!p && q) || (p && !q)) {\n        return false;\n    }\n    else if (p.val !== q.val) {\n        return false;\n    }\n    else {\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n    }\n};\n\n\n\n# 判断二叉树是否对称\n\n * leetcode101\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n \n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n * 和上题类似，把根节点拿掉，就是判断两个树的关系\n\nvar isSymmetric = function(root) {\n    let p = root.left;\n    let q = root.right;\n    const fn = (p, q) => {\n        if (!p && !q) return true;\n        else if ((p && !q) || (!p && q)) return false;\n        else if (p.val !== q.val) return false;\n        else return fn(p.left, q.right) && fn(p.right, q.left);\n    }\n    return fn(p, q);\n};\n\n\n\n# 合并二叉树\n\n * leetcode617\n\nvar mergeTrees = function(root1, root2) {\n    // 有一个树为 null 就直接替换\n    if (!root1 || !root2) return root1 || root2;\n    else {\n        root1.val = root1.val + root2.val;\n        root1.left = mergeTrees(root1.left, root2.left);\n        root1.right = mergeTrees(root1.right, root2.right);\n    }\n    return root1;\n};\n\n\n\n# 求二叉树的深度(最大，最小)\n\n * leetcode104\n * leetcode111\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n\n// 递归\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    else return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n//递归2\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    let res = [];\n    const fn = (path, depth) => {\n        if (!path.left && !path.right) {\n            res.push(depth);\n        }\n        if (path.left) {\n            fn(path.left, depth + 1);\n        }\n        if (path.right) {\n            fn(path.right, depth + 1);\n        }\n    }\n    fn(root, 1);\n    return Math.max(...res);\n}\n\n// BFS\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    const queue = [root];\n    let depth = 0;\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            if (tmp.left) queue.push(tmp.left);\n            if (tmp.right) queue.push(tmp.right);\n        }\n        depth++;\n    }\n    return depth;\n}\n\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n给定二叉树 [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最小深度  2.\n\n\n// 递归\nvar minDepth = function(root) {\n    if (!root) return 0;\n    let res = [];\n    const fn = (path, depth) => {\n        if (!path.left && !path.right) {\n            res.push(depth);\n        }\n        if (path.left) {\n            fn(path.left, depth + 1);\n        }\n        if (path.right) {\n            fn(path.right, depth + 1);\n        }\n    }\n    fn(root, 1);\n    return Math.min(...res);\n}\n\n// BFS\nvar minDepth = function(root) {\n    if (!root) return 0;\n    const queue = [root];\n    let depth = 1;\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            // 遍历到一层时，只要该层有叶子节点则返回最小值\n            if (!tmp.left && !tmp.right) return depth;\n            if (tmp.left) queue.push(tmp.left);\n            if (tmp.right) queue.push(tmp.right);\n        }\n        depth++;\n    }\n}\n\n\n求数组的最大深度\n\n// 递归1\nconst getMaxDepth = arr => {\n    if (!Array.isArray(arr)) return 0; // 非数组深度为 0\n\n    let maxDepth = 0;\n    for (const item of arr) {\n        maxDepth = Math.max(maxDepth, getMaxDepth(item));\n    }\n    return maxDepth + 1;\n}\n\n// 递归2\nconst getMaxDepth = arr => {\n    const res = [];\n    const fn = (path, depth) => {\n        for (let i = 0; i < path.length; i++) {\n            if (Array.isArray(path[i])) {\n                fn(path[i], depth + 1);\n            }\n            else {\n                res.push(depth);\n            }\n        }\n    }\n    fn(arr, 1);\n    return Math.max(...res);\n}\n\n\n\n# 翻转二叉树\n\n * leetcode226\n\nvar invertTree = function(root) {\n    if (!root) return null;\n    [root.left, root.right] = [root.right, root.left];\n    invertTree(root.left);\n    invertTree(root.right);\n    return root;\n};\n\n\n\n# 二叉树的层次遍历\n\n * leetcode102\n\n// 队列\nvar levelOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const queue = [root];\n    while (queue.length) {\n        const len = queue.length;\n        const arr = [];\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            arr.push(tmp.val);\n            if (tmp.left) {\n                queue.push(tmp.left);\n            }\n            if (tmp.right) {\n                queue.push(tmp.right);\n            }\n        }\n        res.push(arr);\n    }\n    return res;\n};\n\n// 改变题型，输出二维数组\n// leetcode 102\n\n二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\nvar levelOrder = function(root) {\n    let queue = [], arr = [], res = []\n    if (root !== null) queue.push(root)\n    while (queue.length !== 0) {\n        const len = queue.length // 一定要暂存长度，不然后面push的时候会改变queue的长度\n        for (let i = 0; i < len; i++) {\n            const node = queue.shift()\n            arr.push(node.val)\n            if (node.left) queue.push(node.left)\n            if (node.right) queue.push(node.right)\n        }\n        res.push(arr)\n        arr = []\n    }\n    return res\n};\n\n\n\n# 有序数组转二叉搜索树\n\n * leetcode108\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n * 每次取中间的值作为根节点\n\nvar sortedArrayToBST = function(nums) {\n    if(nums.length === 0) return null\n    let mid = parseInt(nums.length / 2)\n    let root = new TreeNode(nums[mid])\n    root.left = sortedArrayToBST(nums.slice(0, mid))\n    root.right = sortedArrayToBST(nums.slice(mid + 1))\n    return root\n};\n\n// parseInt(nums.length / 2)      =>     nums.length >> 1\n\n\n\n# 有序链表转二叉搜索树\n\n * leetcode109\n * 首先将链表转数组，再按上题做\n\nvar sortedListToBST = function(head) {\n    const arr = []\n    while (head) {\n        arr.push(head.val)\n        head = head.next\n    }\n    return sortedArrayToBST(arr)\n};\n\n\n\n# 验证二叉搜索树\n\n * leetcode98\n\n> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n> \n> 假设一个二叉搜索树具有如下特征：\n> \n> 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。\n\n// 结合中序遍历即可\nvar isValidBST = function(root) {\n    const res = [-Infinity];\n    const stack = [];\n    while (true) {\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n        if (!stack.length) break;\n        const tmp = stack.pop();\n        if (tmp.val <= res[res.length - 1]) return false;\n        res.push(tmp.val);\n        root = tmp.right;\n    }\n    return true;\n}\n\n\n\n# 判断平衡二叉树\n\nvar isBalanced = function(root) {\n    let flag = true; // 先把所有二叉树先当做平衡二叉树\n    function maxHeight (r) {\n        if(!r) return 0;//当节点不存在时，高度为0\n        let left = maxHeight(r.left);\n        let right = maxHeight(r.right);//dfs常规操作,求出左右子树高度\n        if(Math.abs(left-right)>1){\n            flag = false;//高度差超过1时，非平衡二叉树，直接false\n        }\n        return Math.max(left,right)+1 // 这里加1是因为要把父节点高度算进去\n    };\n    maxHeight(root);\n    return flag;\n};\n\n\n\n# 验证前序序列\n\nleetcode331\n\n序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n\n示例 1:\n输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"\n输出: true\n\n示例 2:\n输入: "1,#"\n输出: false\n\n示例 3:\n输入: "9,#,#,1"\n输出: false\n\n\n * 题解\n\n * 初始化可用槽位：slots = 1。\n\n * 根据逗号分隔前序序列化，将结果数组存储，随后遍历该数组：\n   \n   * 空节点和非空节点都消耗一个槽位：slots = slot - 1.\n   \n   * 如果当前的可用槽位是负数，那么这个前序序列化是非法的，返回 False。\n   \n   * 非空节点（node != \'#\'）新增两个可用槽位：slots = slots + 2.\n\n * 如果所有的槽位都消耗完，那么这个前序序列化就是合法的：返回 slots == 0。\n\n\t\tisValidSerialization (preorder) {\n            // "9,3,4,#,#,1,#,#,2,#,6,#,#"\n            let slot = 1\n            let arr = preorder.split(",")\n            for (let i in arr) {\n                slot--\n                if (slot < 0) return false\n                if (arr[i] !== "#") {\n                    slot += 2\n                }\n            }\n            return slot === 0\n        }\n\n\n\n# 求二叉树的宽度\n\n * leetcode662\n * 思路：层次遍历，记录每层的宽度\n * 左孩子的索引值为 index * 2 + 1，右孩子的索引值为index * 2 + 2，利用节点值来记录索引值\n * 为了防止无限乘2超出范围，每层索引都减去该层第一个索引的值\n\nvar widthOfBinaryTree = function(root) {\n    if (!root) return [];\n    const stack = [root];\n    let res = 0n; // 防止计算溢出, 均用BigInt类型表示\n    root.val = 0n;\n    while (stack.length) {\n        const len = stack.length;\n        const left = stack[0].val;\n        const right = stack[len - 1].val;\n        if (right - left + 1n > res) {\n            res = right - left + 1n;\n        }\n        for (let i = 0; i < len; i++) {\n            const tmp = stack.shift();\n            if (tmp.left) {\n                stack.push(tmp.left)\n                tmp.left.val = 2n * tmp.val\n            }\n            if (tmp.right) {\n                stack.push(tmp.right)\n                tmp.right.val = 2n * tmp.val + 1n\n            }\n        }\n    }\n    return Number(res);\n};\n\n\n\n# 前序中序构造二叉树\n\n * leetcode105\n\n> 根据一棵树的前序遍历与中序遍历构造二叉树。\n> \n> 注意: 你可以假设树中没有重复的元素。\n> \n> 例如，给出\n> \n> 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：\n> \n> 3\n> \n> /\n> 9 20 /\n> 15 7\n\nvar buildTree = function(preorder, inorder) {\n    if (!preorder.length) return null;\n    const root = new TreeNode(preorder[0]);\n    const mid = inorder.indexOf(preorder[0]);\n    root.left = buildTree(preorder.slice(1, 1 + mid), inorder.slice(0, mid));\n    root.right = buildTree(preorder.slice(1 + mid), inorder.slice(mid + 1));\n    return root;\n};\n\n\n\n# 二叉树的右视图\n\n * leetcode199\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n * 层次遍历记录每层最后一个就好\n\nvar rightSideView = function(root) {\n    if (!root) {\n        return [];\n    }\n    const queue = [root];\n    const res = [];\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            if (i === len - 1) {\n                res.push(tmp.val);\n            }\n            if (tmp.left) {\n                queue.push(tmp.left);\n            } \n            if (tmp.right) {\n                queue.push(tmp.right);\n            } \n        }\n    }\n    return res;\n};\n\n\n\n# 二叉树展开为链表\n\n * leetcode114\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n\n * 先序遍历后构造链表（一定要手写一下，构造链表很容易出错）\n\nvar flatten = function(root) {\n    const stack = []\n    const arr = []\n    if (root !== null) stack.push(root)\n    while (stack.length) {\n        let tmp = stack.pop()\n        arr.push(tmp)\n        if (tmp.right !== null) stack.push(tmp.right)\n        if (tmp.left !== null) stack.push(tmp.left)\n    }\n    for (let i = 1; i < arr.length; i++) {\n        const prev = arr[i - 1], curr = arr[i]\n        prev.left = null\n        prev.right = curr\n    }\n};\n\n\n\n# 最近公共祖先\n\n * leetcode236\n * 视频讲解\n\nvar lowestCommonAncestor = function(root, p, q) {\n    if (root === null || root === p || root === q) {\n        return root;\n    }\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    // 左右子树都找到，说明左子树和右子树各有一个寻找的节点，此时 root 就是最近公共祖先\n    if (left && right) {\n        return root;\n    }\n    // 只有左子树找到, 返回递归左子树的结果\n    else if (left) {\n        return left;\n    }\n    // 只有右子树找到, 返回递归右子树的结果\n    else if (right) {\n        return right;\n    }\n};\n\n\n\n# 根据边构造二叉树\n\n[[1, 2], [1, 3], [3, 4], [3, 5], [1, 6]]\n\n{  \n    value: 1,\n    children: [\n   \t\t{ value:2, children: []},\n     \t{ \n          value: 3,\n       \t  children: [{ value: 4, children:[]}, { value: 5, children:[]}]\n        },\n   \t\t{ value:6, children: []},\n\t]\n}\n\n\n// O(2n)\nfunction build(sides) {\n    const map = {};\n    // 找到根节点\n    const pids = sides.map(s => s[0]);\n    const ids = sides.map(s => s[1]);\n    const root = pids.find(p => !ids.includes(p));\n    // 初始化 map\n    for (const side of sides) {\n        for (const id of side) {\n            map[id] = {val: id, children: []};\n        }\n    }\n    // 根据边构造\n    for (const side of sides) {\n        const pid = side[0];\n        const id = side[1];\n        const node = map[id];\n        map[pid].children.push(node);\n    }\n    return map[root];\n}\n\n// O(n): 边遍历边初始化 map\nfunction builds(sides) {\n    const map = {};\n    // 找到根节点\n    const pids = sides.map(s => s[0]);\n    const ids = sides.map(s => s[1]);\n    const root = pids.find(p => !ids.includes(p));\n    for (const side of sides) {\n        const pid = side[0];\n        const id = side[1];\n        if (!map[id]) {\n            map[id] = {val: id, children: []};\n        }\n        const node = map[id];\n        if (!map[pid]) {\n            map[pid] = {val: pid, children: []};\n        }\n        map[pid].children.push(node);\n    }\n    return map[root];\n}\n\n\n\n# 扁平数据结构转Tree\n\n// 输入\n[\n    {id: 1, name: \'部门1\', pid: 0},\n    {id: 2, name: \'部门2\', pid: 1},\n    {id: 3, name: \'部门3\', pid: 1},\n    {id: 4, name: \'部门4\', pid: 3},\n    {id: 5, name: \'部门5\', pid: 4},\n]\n// 输出\n[\n    {\n        "id": 1,\n        "name": "部门1",\n        "pid": 0,\n        "children": [\n            {\n                "id": 2,\n                "name": "部门2",\n                "pid": 1,\n                "children": []\n            },\n            {\n                "id": 3,\n                "name": "部门3",\n                "pid": 1,\n                "children": [\n                    // 结果 ,,,\n                ]\n            }\n        ]\n    }\n]\n\n\n// 递归\nconst fn = function(arr, id) {\n    const nodes = arr.filter(item => item.pid === id);\n    const res = [];\n    nodes.forEach(n => {\n        res.push({\n            ...n,\n            children: this.fn(arr, n.id),\n        })\n    })\n    return res;\n}\nfn(arr, 0);\n\n// 非递归 O(2n)\nfn(arr) {\n    const result = [];\n    const map = {};\n    // 初始化 map\n    for (const item of arr) {\n        map[item.id] = {\n            ...item,\n            children: [],\n        };\n    }\n    for(const item of arr) {\n        const node = map[item.id];\n        if (item.pid === 0) {\n            result.push(node);\n        }\n        else {\n            map[item.pid].children.push(node);\n        }\n    }\n    return result;\n}\nfn(arr);\n\n// 非递归 O(n): 边遍历边初始化 map\nfn(arr) {\n    const result = [];\n    const map = {};\n    for(const item of arr) {\n        if (!map[item.id]) {\n            map[item.id] = {\n                ...item,\n                children: [],\n            };\n        }\n        const node = map[item.id];\n        if (item.pid === 0) {\n            result.push(node);\n        }\n        else {\n            if (!map[item.pid]) {\n                map[item.pid] = {\n                    ...item,\n                    children: [],\n                };\n            }\n            map[item.pid].children.push(node);\n        }\n    }\n    return result;\n}\n',normalizedContent:'# 二叉树相关\n\n * 二叉树的前序遍历，中序遍历，后序遍历的递归与非递归\n * 判断二叉树是否相同\n * 判断二叉树是否对称\n * 合并二叉树\n * 求二叉树的深度\n * 翻转二叉树\n * 二叉树的层次遍历\n * 有序数组转二叉搜索树\n * 验证二叉搜索树\n * 判断平衡二叉树\n * 验证前序序列\n * 求二叉树的宽度\n * 前序中序构造二叉树\n * 二叉树的右视图\n * 二叉树展开为链表\n * 最近公共祖先\n * 根据边构造二叉树\n * 扁平数据结构转tree\n\n\n# 二叉树的前序遍历，中序遍历，后序遍历的递归与非递归\n\n * 前序遍历\n * 中序遍历\n * 后序遍历\n\n给一棵二叉树\n\nvar root = {\nval: 1,\nleft: {\n    val: 2,\n    left: {\n      val: 4,\n    },\n    right:{\n      val:5\n    }\n},\nright: {\n    val: 3,\n    left: {\n      val: 6\n    },\n    right: {\n      val: 7\n    }\n}\n}\n\n\nfunction treenode(val) {  // 树节点构造方式\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\n\n//先序递归\nvar preordertraversal = function(root) {\n    const res = []; \n    function dlr (root) {\n      if (root) {\n          res.push(root.val);\n          dlr(root.left);\n          dlr(root.right);\n      }\n  \t}\n    dlr(root);\n    return res;\n};\n\n//中序递归\nvar inordertraversal = function(root) {\n    const res = []; \n    function ldr (root) {\n    \tif (root) {\n        ldr(root.left);//先遍历到最左边的节点，然后输出\n        res.push(root.val);\n        ldr(root.right);\n      }\n    }\n    ldr(root);\n    return res;\n};\n\n//后序递归\nvar postordertraversal = function(root) {\n    const res = []; \n    function lrd (root) {\n      if(root){\n        lrd(root.left);\n        lrd(root.right);\n        res.push(root.val);\n      }\n    }\n    lrd(root);\n    return res;\n};\n\n//先序非递归\nvar preordertraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res = [];\n    stack.push(root);\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        if (tmp.right) stack.push(tmp.right);\n        if (tmp.left) stack.push(tmp.left);\n    } \n    return res;\n};\n\n//中序非递归\nvar inordertraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res= [];\n    while (true) {\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n        if (stack.length === 0) break;\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        root = tmp.right;\n    }\n    return res;\n};\n\n//后序非递归\nvar postordertraversal = function(root) {\n    if (!root) return [];\n    const stack = [];\n    const res = [];\n    stack.push(root);\n    while (stack.length) {\n        const tmp = stack.pop();\n        res.push(tmp.val);\n        if (tmp.left) stack.push(tmp.left);\n        if (tmp.right) stack.push(tmp.right);\n    } \n    return res.reverse();\n};\n\n\n\n# 相同的树\n\nleetcode100\n\nvar issametree = function(p, q) {\n    if (!p && !q) {\n        return true;\n    }\n    else if ((!p && q) || (p && !q)) {\n        return false;\n    }\n    else if (p.val !== q.val) {\n        return false;\n    }\n    else {\n        return issametree(p.left, q.left) && issametree(p.right, q.right)\n    }\n};\n\n\n\n# 判断二叉树是否对称\n\n * leetcode101\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n \n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n * 和上题类似，把根节点拿掉，就是判断两个树的关系\n\nvar issymmetric = function(root) {\n    let p = root.left;\n    let q = root.right;\n    const fn = (p, q) => {\n        if (!p && !q) return true;\n        else if ((p && !q) || (!p && q)) return false;\n        else if (p.val !== q.val) return false;\n        else return fn(p.left, q.right) && fn(p.right, q.left);\n    }\n    return fn(p, q);\n};\n\n\n\n# 合并二叉树\n\n * leetcode617\n\nvar mergetrees = function(root1, root2) {\n    // 有一个树为 null 就直接替换\n    if (!root1 || !root2) return root1 || root2;\n    else {\n        root1.val = root1.val + root2.val;\n        root1.left = mergetrees(root1.left, root2.left);\n        root1.right = mergetrees(root1.right, root2.right);\n    }\n    return root1;\n};\n\n\n\n# 求二叉树的深度(最大，最小)\n\n * leetcode104\n * leetcode111\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n\n// 递归\nvar maxdepth = function(root) {\n    if (!root) return 0;\n    else return 1 + math.max(maxdepth(root.left), maxdepth(root.right));\n}\n\n//递归2\nvar maxdepth = function(root) {\n    if (!root) return 0;\n    let res = [];\n    const fn = (path, depth) => {\n        if (!path.left && !path.right) {\n            res.push(depth);\n        }\n        if (path.left) {\n            fn(path.left, depth + 1);\n        }\n        if (path.right) {\n            fn(path.right, depth + 1);\n        }\n    }\n    fn(root, 1);\n    return math.max(...res);\n}\n\n// bfs\nvar maxdepth = function(root) {\n    if (!root) return 0;\n    const queue = [root];\n    let depth = 0;\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            if (tmp.left) queue.push(tmp.left);\n            if (tmp.right) queue.push(tmp.right);\n        }\n        depth++;\n    }\n    return depth;\n}\n\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例:\n\n给定二叉树 [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最小深度  2.\n\n\n// 递归\nvar mindepth = function(root) {\n    if (!root) return 0;\n    let res = [];\n    const fn = (path, depth) => {\n        if (!path.left && !path.right) {\n            res.push(depth);\n        }\n        if (path.left) {\n            fn(path.left, depth + 1);\n        }\n        if (path.right) {\n            fn(path.right, depth + 1);\n        }\n    }\n    fn(root, 1);\n    return math.min(...res);\n}\n\n// bfs\nvar mindepth = function(root) {\n    if (!root) return 0;\n    const queue = [root];\n    let depth = 1;\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            // 遍历到一层时，只要该层有叶子节点则返回最小值\n            if (!tmp.left && !tmp.right) return depth;\n            if (tmp.left) queue.push(tmp.left);\n            if (tmp.right) queue.push(tmp.right);\n        }\n        depth++;\n    }\n}\n\n\n求数组的最大深度\n\n// 递归1\nconst getmaxdepth = arr => {\n    if (!array.isarray(arr)) return 0; // 非数组深度为 0\n\n    let maxdepth = 0;\n    for (const item of arr) {\n        maxdepth = math.max(maxdepth, getmaxdepth(item));\n    }\n    return maxdepth + 1;\n}\n\n// 递归2\nconst getmaxdepth = arr => {\n    const res = [];\n    const fn = (path, depth) => {\n        for (let i = 0; i < path.length; i++) {\n            if (array.isarray(path[i])) {\n                fn(path[i], depth + 1);\n            }\n            else {\n                res.push(depth);\n            }\n        }\n    }\n    fn(arr, 1);\n    return math.max(...res);\n}\n\n\n\n# 翻转二叉树\n\n * leetcode226\n\nvar inverttree = function(root) {\n    if (!root) return null;\n    [root.left, root.right] = [root.right, root.left];\n    inverttree(root.left);\n    inverttree(root.right);\n    return root;\n};\n\n\n\n# 二叉树的层次遍历\n\n * leetcode102\n\n// 队列\nvar levelorder = function(root) {\n    if (!root) {\n        return [];\n    }\n    const res = [];\n    const queue = [root];\n    while (queue.length) {\n        const len = queue.length;\n        const arr = [];\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            arr.push(tmp.val);\n            if (tmp.left) {\n                queue.push(tmp.left);\n            }\n            if (tmp.right) {\n                queue.push(tmp.right);\n            }\n        }\n        res.push(arr);\n    }\n    return res;\n};\n\n// 改变题型，输出二维数组\n// leetcode 102\n\n二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\nvar levelorder = function(root) {\n    let queue = [], arr = [], res = []\n    if (root !== null) queue.push(root)\n    while (queue.length !== 0) {\n        const len = queue.length // 一定要暂存长度，不然后面push的时候会改变queue的长度\n        for (let i = 0; i < len; i++) {\n            const node = queue.shift()\n            arr.push(node.val)\n            if (node.left) queue.push(node.left)\n            if (node.right) queue.push(node.right)\n        }\n        res.push(arr)\n        arr = []\n    }\n    return res\n};\n\n\n\n# 有序数组转二叉搜索树\n\n * leetcode108\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n * 每次取中间的值作为根节点\n\nvar sortedarraytobst = function(nums) {\n    if(nums.length === 0) return null\n    let mid = parseint(nums.length / 2)\n    let root = new treenode(nums[mid])\n    root.left = sortedarraytobst(nums.slice(0, mid))\n    root.right = sortedarraytobst(nums.slice(mid + 1))\n    return root\n};\n\n// parseint(nums.length / 2)      =>     nums.length >> 1\n\n\n\n# 有序链表转二叉搜索树\n\n * leetcode109\n * 首先将链表转数组，再按上题做\n\nvar sortedlisttobst = function(head) {\n    const arr = []\n    while (head) {\n        arr.push(head.val)\n        head = head.next\n    }\n    return sortedarraytobst(arr)\n};\n\n\n\n# 验证二叉搜索树\n\n * leetcode98\n\n> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n> \n> 假设一个二叉搜索树具有如下特征：\n> \n> 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。\n\n// 结合中序遍历即可\nvar isvalidbst = function(root) {\n    const res = [-infinity];\n    const stack = [];\n    while (true) {\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n        if (!stack.length) break;\n        const tmp = stack.pop();\n        if (tmp.val <= res[res.length - 1]) return false;\n        res.push(tmp.val);\n        root = tmp.right;\n    }\n    return true;\n}\n\n\n\n# 判断平衡二叉树\n\nvar isbalanced = function(root) {\n    let flag = true; // 先把所有二叉树先当做平衡二叉树\n    function maxheight (r) {\n        if(!r) return 0;//当节点不存在时，高度为0\n        let left = maxheight(r.left);\n        let right = maxheight(r.right);//dfs常规操作,求出左右子树高度\n        if(math.abs(left-right)>1){\n            flag = false;//高度差超过1时，非平衡二叉树，直接false\n        }\n        return math.max(left,right)+1 // 这里加1是因为要把父节点高度算进去\n    };\n    maxheight(root);\n    return flag;\n};\n\n\n\n# 验证前序序列\n\nleetcode331\n\n序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n\n示例 1:\n输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"\n输出: true\n\n示例 2:\n输入: "1,#"\n输出: false\n\n示例 3:\n输入: "9,#,#,1"\n输出: false\n\n\n * 题解\n\n * 初始化可用槽位：slots = 1。\n\n * 根据逗号分隔前序序列化，将结果数组存储，随后遍历该数组：\n   \n   * 空节点和非空节点都消耗一个槽位：slots = slot - 1.\n   \n   * 如果当前的可用槽位是负数，那么这个前序序列化是非法的，返回 false。\n   \n   * 非空节点（node != \'#\'）新增两个可用槽位：slots = slots + 2.\n\n * 如果所有的槽位都消耗完，那么这个前序序列化就是合法的：返回 slots == 0。\n\n\t\tisvalidserialization (preorder) {\n            // "9,3,4,#,#,1,#,#,2,#,6,#,#"\n            let slot = 1\n            let arr = preorder.split(",")\n            for (let i in arr) {\n                slot--\n                if (slot < 0) return false\n                if (arr[i] !== "#") {\n                    slot += 2\n                }\n            }\n            return slot === 0\n        }\n\n\n\n# 求二叉树的宽度\n\n * leetcode662\n * 思路：层次遍历，记录每层的宽度\n * 左孩子的索引值为 index * 2 + 1，右孩子的索引值为index * 2 + 2，利用节点值来记录索引值\n * 为了防止无限乘2超出范围，每层索引都减去该层第一个索引的值\n\nvar widthofbinarytree = function(root) {\n    if (!root) return [];\n    const stack = [root];\n    let res = 0n; // 防止计算溢出, 均用bigint类型表示\n    root.val = 0n;\n    while (stack.length) {\n        const len = stack.length;\n        const left = stack[0].val;\n        const right = stack[len - 1].val;\n        if (right - left + 1n > res) {\n            res = right - left + 1n;\n        }\n        for (let i = 0; i < len; i++) {\n            const tmp = stack.shift();\n            if (tmp.left) {\n                stack.push(tmp.left)\n                tmp.left.val = 2n * tmp.val\n            }\n            if (tmp.right) {\n                stack.push(tmp.right)\n                tmp.right.val = 2n * tmp.val + 1n\n            }\n        }\n    }\n    return number(res);\n};\n\n\n\n# 前序中序构造二叉树\n\n * leetcode105\n\n> 根据一棵树的前序遍历与中序遍历构造二叉树。\n> \n> 注意: 你可以假设树中没有重复的元素。\n> \n> 例如，给出\n> \n> 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：\n> \n> 3\n> \n> /\n> 9 20 /\n> 15 7\n\nvar buildtree = function(preorder, inorder) {\n    if (!preorder.length) return null;\n    const root = new treenode(preorder[0]);\n    const mid = inorder.indexof(preorder[0]);\n    root.left = buildtree(preorder.slice(1, 1 + mid), inorder.slice(0, mid));\n    root.right = buildtree(preorder.slice(1 + mid), inorder.slice(mid + 1));\n    return root;\n};\n\n\n\n# 二叉树的右视图\n\n * leetcode199\n\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n\n\n * 层次遍历记录每层最后一个就好\n\nvar rightsideview = function(root) {\n    if (!root) {\n        return [];\n    }\n    const queue = [root];\n    const res = [];\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const tmp = queue.shift();\n            if (i === len - 1) {\n                res.push(tmp.val);\n            }\n            if (tmp.left) {\n                queue.push(tmp.left);\n            } \n            if (tmp.right) {\n                queue.push(tmp.right);\n            } \n        }\n    }\n    return res;\n};\n\n\n\n# 二叉树展开为链表\n\n * leetcode114\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n展开后的单链表应该同样使用 treenode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n\n * 先序遍历后构造链表（一定要手写一下，构造链表很容易出错）\n\nvar flatten = function(root) {\n    const stack = []\n    const arr = []\n    if (root !== null) stack.push(root)\n    while (stack.length) {\n        let tmp = stack.pop()\n        arr.push(tmp)\n        if (tmp.right !== null) stack.push(tmp.right)\n        if (tmp.left !== null) stack.push(tmp.left)\n    }\n    for (let i = 1; i < arr.length; i++) {\n        const prev = arr[i - 1], curr = arr[i]\n        prev.left = null\n        prev.right = curr\n    }\n};\n\n\n\n# 最近公共祖先\n\n * leetcode236\n * 视频讲解\n\nvar lowestcommonancestor = function(root, p, q) {\n    if (root === null || root === p || root === q) {\n        return root;\n    }\n    const left = lowestcommonancestor(root.left, p, q);\n    const right = lowestcommonancestor(root.right, p, q);\n    // 左右子树都找到，说明左子树和右子树各有一个寻找的节点，此时 root 就是最近公共祖先\n    if (left && right) {\n        return root;\n    }\n    // 只有左子树找到, 返回递归左子树的结果\n    else if (left) {\n        return left;\n    }\n    // 只有右子树找到, 返回递归右子树的结果\n    else if (right) {\n        return right;\n    }\n};\n\n\n\n# 根据边构造二叉树\n\n[[1, 2], [1, 3], [3, 4], [3, 5], [1, 6]]\n\n{  \n    value: 1,\n    children: [\n   \t\t{ value:2, children: []},\n     \t{ \n          value: 3,\n       \t  children: [{ value: 4, children:[]}, { value: 5, children:[]}]\n        },\n   \t\t{ value:6, children: []},\n\t]\n}\n\n\n// o(2n)\nfunction build(sides) {\n    const map = {};\n    // 找到根节点\n    const pids = sides.map(s => s[0]);\n    const ids = sides.map(s => s[1]);\n    const root = pids.find(p => !ids.includes(p));\n    // 初始化 map\n    for (const side of sides) {\n        for (const id of side) {\n            map[id] = {val: id, children: []};\n        }\n    }\n    // 根据边构造\n    for (const side of sides) {\n        const pid = side[0];\n        const id = side[1];\n        const node = map[id];\n        map[pid].children.push(node);\n    }\n    return map[root];\n}\n\n// o(n): 边遍历边初始化 map\nfunction builds(sides) {\n    const map = {};\n    // 找到根节点\n    const pids = sides.map(s => s[0]);\n    const ids = sides.map(s => s[1]);\n    const root = pids.find(p => !ids.includes(p));\n    for (const side of sides) {\n        const pid = side[0];\n        const id = side[1];\n        if (!map[id]) {\n            map[id] = {val: id, children: []};\n        }\n        const node = map[id];\n        if (!map[pid]) {\n            map[pid] = {val: pid, children: []};\n        }\n        map[pid].children.push(node);\n    }\n    return map[root];\n}\n\n\n\n# 扁平数据结构转tree\n\n// 输入\n[\n    {id: 1, name: \'部门1\', pid: 0},\n    {id: 2, name: \'部门2\', pid: 1},\n    {id: 3, name: \'部门3\', pid: 1},\n    {id: 4, name: \'部门4\', pid: 3},\n    {id: 5, name: \'部门5\', pid: 4},\n]\n// 输出\n[\n    {\n        "id": 1,\n        "name": "部门1",\n        "pid": 0,\n        "children": [\n            {\n                "id": 2,\n                "name": "部门2",\n                "pid": 1,\n                "children": []\n            },\n            {\n                "id": 3,\n                "name": "部门3",\n                "pid": 1,\n                "children": [\n                    // 结果 ,,,\n                ]\n            }\n        ]\n    }\n]\n\n\n// 递归\nconst fn = function(arr, id) {\n    const nodes = arr.filter(item => item.pid === id);\n    const res = [];\n    nodes.foreach(n => {\n        res.push({\n            ...n,\n            children: this.fn(arr, n.id),\n        })\n    })\n    return res;\n}\nfn(arr, 0);\n\n// 非递归 o(2n)\nfn(arr) {\n    const result = [];\n    const map = {};\n    // 初始化 map\n    for (const item of arr) {\n        map[item.id] = {\n            ...item,\n            children: [],\n        };\n    }\n    for(const item of arr) {\n        const node = map[item.id];\n        if (item.pid === 0) {\n            result.push(node);\n        }\n        else {\n            map[item.pid].children.push(node);\n        }\n    }\n    return result;\n}\nfn(arr);\n\n// 非递归 o(n): 边遍历边初始化 map\nfn(arr) {\n    const result = [];\n    const map = {};\n    for(const item of arr) {\n        if (!map[item.id]) {\n            map[item.id] = {\n                ...item,\n                children: [],\n            };\n        }\n        const node = map[item.id];\n        if (item.pid === 0) {\n            result.push(node);\n        }\n        else {\n            if (!map[item.pid]) {\n                map[item.pid] = {\n                    ...item,\n                    children: [],\n                };\n            }\n            map[item.pid].children.push(node);\n        }\n    }\n    return result;\n}\n',charsets:{cjk:!0}},{title:"信息整理",frontmatter:{},regularPath:"/blockchain/info.html",relativePath:"blockchain/info.md",key:"v-4d369e5f",path:"/blockchain/info.html",lastUpdated:"6/26/2023, 7:15:43 PM",lastUpdatedTimestamp:1687778143e3,headersStr:null,content:"# 信息整理\n\n * https://abetterweb3.notion.site/\n * SmartDeer\n * bingx\n * bitget\n * debank\n * onekey",normalizedContent:"# 信息整理\n\n * https://abetterweb3.notion.site/\n * smartdeer\n * bingx\n * bitget\n * debank\n * onekey",charsets:{cjk:!0}},{title:"web3.js和ethers.js",frontmatter:{},regularPath:"/blockchain/js.html",relativePath:"blockchain/js.md",key:"v-97a9a082",path:"/blockchain/js.html",headers:[{level:2,title:"核心功能",slug:"核心功能",normalizedTitle:"核心功能",charIndex:878},{level:2,title:"主要区别详解",slug:"主要区别详解",normalizedTitle:"主要区别详解",charIndex:1042},{level:3,title:"设计哲学",slug:"设计哲学",normalizedTitle:"设计哲学",charIndex:1053},{level:3,title:"钱包与私钥管理",slug:"钱包与私钥管理",normalizedTitle:"钱包与私钥管理",charIndex:1257},{level:3,title:"Provider 配置",slug:"provider-配置",normalizedTitle:"provider 配置",charIndex:1517},{level:3,title:"合约交互示例",slug:"合约交互示例",normalizedTitle:"合约交互示例",charIndex:1767},{level:3,title:"交易发送",slug:"交易发送",normalizedTitle:"交易发送",charIndex:2070},{level:2,title:"如何选择？",slug:"如何选择",normalizedTitle:"如何选择？",charIndex:2374},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2596}],lastUpdated:"5/23/2025, 5:16:31 PM",lastUpdatedTimestamp:1747991791e3,headersStr:"核心功能 主要区别详解 设计哲学 钱包与私钥管理 Provider 配置 合约交互示例 交易发送 如何选择？ 总结",content:'# web3.js和ethers.js\n\n对比维度               WEB3.JS                         ETHERS.JS\n开发者/维护者            以太坊基金会                          社区驱动（Richard Moore 创建）\n设计理念               早期官方库，功能全面                      轻量、模块化、安全性优先\n代码体积               较大（约 1MB）                       更小（约 500KB）\nAPI 友好性            传统回调风格，支持 Promise               原生 Promise + 更简洁的链式调用\n钱包与私钥处理            需要依赖外部钱包（如 MetaMask）            内置安全钱包类，可独立管理私钥\nProvider 支持        需自行配置 HTTP/WebSocket Provider   内置默认 Provider（如 Infura、Alchemy）\nTypeScript 支持      支持，但类型定义较旧                      原生 TypeScript 开发，类型定义完善\n树摇（Tree-shaking）   部分支持                            模块化设计，支持按需加载\n合约交互语法             基于web3.eth.Contract的较复杂 API     更简洁的Contract方法（如contract.functionName()）\n错误处理               错误信息较基础                         详细的错误分类与描述\n社区活跃度              较高（但更新放缓）                       高（持续更新，适配新协议如 EIP-1559）\n\n\n# 核心功能\n\n两者均为以太坊区块链开发的 JavaScript 库，支持以下操作：\n\n 1. 连接以太坊节点（通过 JSON-RPC、Infura、Alchemy 等）。\n 2. 创建和管理钱包（生成地址、签名交易）。\n 3. 与智能合约交互（读取数据、发送交易）。\n 4. 查询区块链数据（余额、交易记录、区块信息）。\n\n\n# 主要区别详解\n\n\n# 设计哲学\n\n * web3.js：\n   \n   * 作为以太坊官方早期库，覆盖全面功能，但架构较为臃肿。\n   * 适合需要直接使用以太坊原生 API 的传统项目。\n\n * ethers.js：\n   \n   * 强调轻量化和开发者体验，模块化拆分（如ethers.Wallet、ethers.Contract）。\n   * 适合现代 Web 应用（如 React DApp）及对体积敏感的场景。\n\n\n# 钱包与私钥管理\n\n * web3.js：\n   \n   * 依赖外部钱包（如 MetaMask）注入的window.ethereum对象。\n   * 私钥通常由用户钱包管理，开发者不直接处理。\n\n * ethers.js：\n   \n   * 内置Wallet类，可直接安全创建和管理私钥：\n   \n   const wallet = ethers.Wallet.createRandom(); // 离线生成钱包\n   console.log(wallet.privateKey); // 安全存储私钥\n   \n\n\n# Provider 配置\n\n * web3.js：\n   \n   * 需手动指定 Provider：\n   \n   const web3 = new Web3("https://mainnet.infura.io/v3/YOUR_KEY");\n   \n\n * ethers.js：\n   \n   * 内置默认 Provider（自动连接公开节点，但建议生产环境替换为专用节点）：\n   \n   const provider = ethers.getDefaultProvider();\n   \n\n\n# 合约交互示例\n\n * web3.js：\n\nconst contract = new web3.eth.Contract(abi, address);\ncontract.methods.balanceOf(userAddress).call()\n  .then(balance => console.log(balance));\n\n\n * ethers.js：\n\nconst contract = new ethers.Contract(address, abi, provider);\nconst balance = await contract.balanceOf(userAddress);\n\n\n\n# 交易发送\n\n * web3.js：\n\nweb3.eth.sendTransaction({\n  from: senderAddress,\n  to: receiverAddress,\n  value: web3.utils.toWei("1", "ether")\n});\n\n\n * ethers.js：\n\nconst wallet = new ethers.Wallet(privateKey, provider);\nawait wallet.sendTransaction({\n  to: receiverAddress,\n  value: ethers.parseEther("1")\n});\n\n\n\n# 如何选择？\n\n * 使用 web3.js 的场景：\n   \n   * 维护旧项目或依赖 MetaMask 深度集成。\n   * 需要直接使用以太坊原生 RPC 方法（如web3.eth.subscribe）。\n\n * 使用 ethers.js 的场景：\n   \n   * 新建项目，尤其是前端 DApp（React/Vue）。\n   * 注重代码简洁性、安全性和轻量化。\n   * 需要 TypeScript 支持或树摇优化打包体积。\n\n\n# 总结\n\n * web3.js：老牌工具，功能全但稍显笨重，适合传统项目。\n * ethers.js：现代轻量库，开发体验更佳，推荐新项目首选。两者均能完成以太坊开发核心需求，根据项目需求及团队偏好选择即可。',normalizedContent:'# web3.js和ethers.js\n\n对比维度               web3.js                         ethers.js\n开发者/维护者            以太坊基金会                          社区驱动（richard moore 创建）\n设计理念               早期官方库，功能全面                      轻量、模块化、安全性优先\n代码体积               较大（约 1mb）                       更小（约 500kb）\napi 友好性            传统回调风格，支持 promise               原生 promise + 更简洁的链式调用\n钱包与私钥处理            需要依赖外部钱包（如 metamask）            内置安全钱包类，可独立管理私钥\nprovider 支持        需自行配置 http/websocket provider   内置默认 provider（如 infura、alchemy）\ntypescript 支持      支持，但类型定义较旧                      原生 typescript 开发，类型定义完善\n树摇（tree-shaking）   部分支持                            模块化设计，支持按需加载\n合约交互语法             基于web3.eth.contract的较复杂 api     更简洁的contract方法（如contract.functionname()）\n错误处理               错误信息较基础                         详细的错误分类与描述\n社区活跃度              较高（但更新放缓）                       高（持续更新，适配新协议如 eip-1559）\n\n\n# 核心功能\n\n两者均为以太坊区块链开发的 javascript 库，支持以下操作：\n\n 1. 连接以太坊节点（通过 json-rpc、infura、alchemy 等）。\n 2. 创建和管理钱包（生成地址、签名交易）。\n 3. 与智能合约交互（读取数据、发送交易）。\n 4. 查询区块链数据（余额、交易记录、区块信息）。\n\n\n# 主要区别详解\n\n\n# 设计哲学\n\n * web3.js：\n   \n   * 作为以太坊官方早期库，覆盖全面功能，但架构较为臃肿。\n   * 适合需要直接使用以太坊原生 api 的传统项目。\n\n * ethers.js：\n   \n   * 强调轻量化和开发者体验，模块化拆分（如ethers.wallet、ethers.contract）。\n   * 适合现代 web 应用（如 react dapp）及对体积敏感的场景。\n\n\n# 钱包与私钥管理\n\n * web3.js：\n   \n   * 依赖外部钱包（如 metamask）注入的window.ethereum对象。\n   * 私钥通常由用户钱包管理，开发者不直接处理。\n\n * ethers.js：\n   \n   * 内置wallet类，可直接安全创建和管理私钥：\n   \n   const wallet = ethers.wallet.createrandom(); // 离线生成钱包\n   console.log(wallet.privatekey); // 安全存储私钥\n   \n\n\n# provider 配置\n\n * web3.js：\n   \n   * 需手动指定 provider：\n   \n   const web3 = new web3("https://mainnet.infura.io/v3/your_key");\n   \n\n * ethers.js：\n   \n   * 内置默认 provider（自动连接公开节点，但建议生产环境替换为专用节点）：\n   \n   const provider = ethers.getdefaultprovider();\n   \n\n\n# 合约交互示例\n\n * web3.js：\n\nconst contract = new web3.eth.contract(abi, address);\ncontract.methods.balanceof(useraddress).call()\n  .then(balance => console.log(balance));\n\n\n * ethers.js：\n\nconst contract = new ethers.contract(address, abi, provider);\nconst balance = await contract.balanceof(useraddress);\n\n\n\n# 交易发送\n\n * web3.js：\n\nweb3.eth.sendtransaction({\n  from: senderaddress,\n  to: receiveraddress,\n  value: web3.utils.towei("1", "ether")\n});\n\n\n * ethers.js：\n\nconst wallet = new ethers.wallet(privatekey, provider);\nawait wallet.sendtransaction({\n  to: receiveraddress,\n  value: ethers.parseether("1")\n});\n\n\n\n# 如何选择？\n\n * 使用 web3.js 的场景：\n   \n   * 维护旧项目或依赖 metamask 深度集成。\n   * 需要直接使用以太坊原生 rpc 方法（如web3.eth.subscribe）。\n\n * 使用 ethers.js 的场景：\n   \n   * 新建项目，尤其是前端 dapp（react/vue）。\n   * 注重代码简洁性、安全性和轻量化。\n   * 需要 typescript 支持或树摇优化打包体积。\n\n\n# 总结\n\n * web3.js：老牌工具，功能全但稍显笨重，适合传统项目。\n * ethers.js：现代轻量库，开发体验更佳，推荐新项目首选。两者均能完成以太坊开发核心需求，根据项目需求及团队偏好选择即可。',charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 1",frontmatter:{},regularPath:"/blockchain/learn1.html",relativePath:"blockchain/learn1.md",key:"v-0aa58e3f",path:"/blockchain/learn1.html",headers:[{level:2,title:"区块链",slug:"区块链",normalizedTitle:"区块链",charIndex:9},{level:2,title:"密码学原理",slug:"密码学原理",normalizedTitle:"密码学原理",charIndex:580},{level:2,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:2003},{level:3,title:"Hash Pointer（哈希指针）",slug:"hash-pointer-哈希指针",normalizedTitle:"hash pointer（哈希指针）",charIndex:2012},{level:3,title:"Merkle Tree（默克尔树）",slug:"merkle-tree-默克尔树",normalizedTitle:"merkle tree（默克尔树）",charIndex:2460},{level:3,title:"轻节点与全节点(light node and full node)",slug:"轻节点与全节点-light-node-and-full-node",normalizedTitle:"轻节点与全节点(light node and full node)",charIndex:2920},{level:2,title:"协议",slug:"协议",normalizedTitle:"协议",charIndex:3548},{level:3,title:"数字货币的问题",slug:"数字货币的问题",normalizedTitle:"数字货币的问题",charIndex:3555},{level:3,title:"中心化",slug:"中心化",normalizedTitle:"中心化",charIndex:267},{level:3,title:"去中心化",slug:"去中心化",normalizedTitle:"去中心化",charIndex:331},{level:3,title:"区块结构",slug:"区块结构",normalizedTitle:"区块结构",charIndex:4874},{level:3,title:"共识协议",slug:"共识协议",normalizedTitle:"共识协议",charIndex:5279},{level:3,title:"比特币共识协议",slug:"比特币共识协议",normalizedTitle:"比特币共识协议",charIndex:5741},{level:3,title:"比特币的激励机制",slug:"比特币的激励机制",normalizedTitle:"比特币的激励机制",charIndex:6912}],lastUpdated:"5/23/2023, 11:30:04 AM",lastUpdatedTimestamp:1684812604e3,headersStr:"区块链 密码学原理 数据结构 Hash Pointer（哈希指针） Merkle Tree（默克尔树） 轻节点与全节点(light node and full node) 协议 数字货币的问题 中心化 去中心化 区块结构 共识协议 比特币共识协议 比特币的激励机制",content:"# 北大肖臻老师《区块链技术与应用》公开课学习 1\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n * 参考文章：\n   * https://blog.nowcoder.net/n/30cbdb37108b4d93b3a5a93b8226ae31\n   * https://blog.csdn.net/weixin_47692652/category_11702107.html\n\n\n# 区块链\n\n20 世纪经济学家 哈耶克 认为：欧美通货膨胀的根源在于货币是政府发行的，是中心化的，注定会为了铸币税而滥发。比特币是一种虚拟货币，它是为了解决哈耶克提出来的中心化货币必然会超发贬值的问题，而被创造出来的去中心化货币。\n\n货币交易的过程中怎么确保记账不出错，不被篡改？\n\n> 古代文明使用实体物质特别是贵金属。（无法凭空创造物质，元宝给了你我就没了） 近代国家进入纸币时代。（特殊印版、纸张、油墨，使得复制纸币变为不可能） 移动互联网时代使用的是网上支付。（第三方中介银行进行信用担保、密码系统）\n\n那么比特币是怎么记账的呢？\n\n> 牺牲隐私，每个账户的出账和入账都广播出来，整个记账过程让全网的人都看到，组成一条区块链。\n\n那么怎么保证区块链上的之前的信息没有被篡改呢？\n\n> 这就利用到了下面讲到的密码学原理。\n\n\n# 密码学原理\n\n比特币被称为加密货币 cryptocurrency。但其实区块链上内容都是公开的，包括区块的地址，转账的金额。 比特币主要用到了密码学中的两个功能: 1.哈希 2.签名\n\n密码学中用到的哈希函数被称为 cryptographic hash function, 它有两个重要的性质:\n\n * collision resistance(抗碰撞性): 例如 x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。哈希碰撞中，给出x，很难找到y，除非蛮力求解(brute-force)。难以发现碰撞的性质称为collision resistance\n   * 作用：检测上传到云端的文件是否被更改，上传文件前先求该文件的hash值，过段时间下载该文件后，再求一次hash值，比较两值是否相等即可知道文件是否被篡改。\n   * 人工制造碰撞：我国著名密码学家王小云教授在 2004 年就找到算法，人工制造了哈希函数 MD5 的哈希碰撞，使得 MD5函数 安全性收到了冲击。如果无法人工制造哈希碰撞，那么坏人就只能用 brute-force 蛮力穷举，这种工作量就巨大到不可能了。\n * hiding: 哈希函数的计算过程是单向的，不可逆的。例如从 H(x) 无法推导出 x, hiding 性质前提是输入空间足够大(不然很容易遍历完)，分布比较均匀(hash 结果不能只是某几个值)。如果输入不是足够大，一般在 x 后面拼接一个随机数，如 x123213124，整体取哈希值。\n   * 作用：和 collision resistance 结合在一起，用来实现 digital commitment (又称为 digital equivalent of a sealed envelope)。把预测结果作为输入 x，算出一个哈希值，将哈希值公布，hiding 让人们知道哈希值而不知道预测值，最后再将 x 公布，因为有 collision resistance 的性质，预测结果是不可篡改的。\n * puzzle friendly: 所谓 puzzle friendly，意思是对于哈希函数，他的输出是无法预测的，要找到特定区间内的哈希值的输入x，没有捷径。 比如，我要找到SHA256函数（比特币中用的 hash 函数: Secure Hash algorithm）的哈希值，前60位都是零，我除了一个一个试验以外，没有其他的方法。 （挖矿很难，验证很容易）\n\n关于签名，首先要介绍比特币中的账户管理，开户方式: 只需要创建一对公私钥即可（非对称加密），公钥是公开的，私钥是私密的。\n\n> 那么每个人都有公私钥，可不可以不断生成公私钥，与区块链上已存在的公钥进行对比，如果相同，则用对应的私钥去攻击他。答案是不可能，因为概率微乎其微，但是前提是生成公私钥的时候要有好的随机源。\n\n比特币的本质就是数字签名，对于一笔交易，要用发起人的私钥进行签名，大家可以用发起人的公钥对这笔交易进行验证。\n\n> 关于非对称加密算法，比较常见的是椭圆曲线加密算法。简单可以理解为经过一条椭圆曲线，可以生成两个值 K 和 Q，对一个数 123 用 K 进行加密会生成毫无规律的数，再对其用 Q 进行解密，就又恢复成了 123。K 可以作为私钥，Q 可以作为公钥。\n\n\n# 数据结构\n\n\n# Hash Pointer（哈希指针）\n\n> 在比特币中，其最基本的数据结构便是一个个区块形成的区块链。区块链与链表的区别就是用哈希指针代替了普通指针。 一般的链表我们都可以改造为使用哈希指针的链表，但当链表中存在环时，哈希指针便不能再使用。\n\n对于链表中的节点，对链表中的内容做一次哈希运算，记 H() 为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。\n\n\n\n> 如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。 在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。\n\n\n# Merkle Tree（默克尔树）\n\n> Merkle Tree 与 Binary Tree 的区别就是用哈希指针代替了普通指针。\n\n\n\n> 上图即为一个简单的Merkle Tree，其中Tx0、Tx1、Tx2、Tx3为数据块，代表每一次交易。Tx0、Tx1各有一个哈希值，将其合并放在一个节点中，Tx2、Tx3同样操作，而后，针对得到的两个节点Hash01、Hash23分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头中存储的是根节点的哈希值（对其再取一次哈希）\n\n该数据结构的优点在于：只需要记住 Root Hash（根哈希值），便可以检测出对树中任何部位的修改。不论在哪里篡改了，都会通过哈希值向上反应，最终反馈到 Root Hash 值上。\n\n> 在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过 Merkle Tree 的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信息），块身中存在交易列表。\n\n\n# 轻节点与全节点(light node and full node)\n\n> 全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。 为什么要分轻节点和全节点？ 因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容。\n\n当需要向轻节点证明某条交易是否被写入区块链，便需要用到 Merkle proof。我们将交易到根节点这一条路径称为 Merkle proof，全节点将整个 Merkle tree 的信息发送给轻节点，轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，计算出来的根哈希值正确，说明内容没有被修改过。\n\n\n\n那么全节点是否可以修改 Hash 值，向轻节点发送修改后的 Hash 值使得向上一层计算的 Hash 值仍然正确呢？\n\n> 实际上，这种情况为人为制造哈希碰撞。由于哈希函数的 collision resistance 性质，这种情况是不会发生的，保证了系统的不可篡改性。同时，这样一个 Merkle Proof 的事件复杂度为 O(log n), 非常高效【证明交易存在】。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。在比特币系统中，没有相应的需求，所以在比特币系统中并没有对 Merkle Tree 进行排序。\n\n\n# 协议\n\n\n# 数字货币的问题\n\n假设权威机构——中央银行发行数字货币，发行了数字货币，用央行的私钥签名，然后使用的时候，用户直接拿央行的公钥验证签名（假设大家都知道公钥）。\n\n\n\n虽然签名保证了没办法篡改其中的内容，但是数字货币本质上还是一个文件，这样的数字货币可复制，就会造成双花攻击（double spending attack）。不像是纸质货币，花出去手上就没有。\n\n\n# 中心化\n\n为解决这个问题，央行还要维护一个数据库，即记录每个编号的数字货币是归哪个用户所有。\n\n\n\n在支付时，不仅要用公钥验证签名是央行签署的，还要通过央行验证该货币是归自己所有，央行再将货币所有者改成支付给的那个用户。不仅数字货币的发行是由央行统一控制，而且每次交易都要由央行确认其合法性，这种方案是一个中心化的方案。\n\n\n# 去中心化\n\n将央行的职能改成由广大的用户来共同承担，也就是去中心化的方案，这是BTC等数字货币系统要解决的问题，即：\n\n> 1️⃣ 怎么决定数字货币的发行及发行量 2️⃣ 怎么验证交易的合法性，防止双花攻击 第一个问题在 BTC 系统中是挖矿决定的 第二个问题的解决，要维护一个数据结构，由所有用户来共同维护，这个数据结构就是区块链。\n\n假设用户 A 获得了铸币权，他发行了 10 个 BTC。然后他将这 10 个 BTC 转给 B 和 C，每个人分 5 个 BTC。接下来 B 给 C 2 个货币，给 D 3 个货币。最后 C 将所得的 7 个货币全部给 E。\n\n\n\n> 红色箭头会说明【币的来源】，这也就防止了双花攻击，如过 B 已经将自己的 5个BTC 花掉了，假设 B 尝试再花一次，将 5个BTC 转给F。这时顺着区块链去检查这个区块到来源交易之间的区块，发现 B 已经花了来源区块的BTC，说明这新个交易是不合法的，也就不会接受这个转给F的区块进入区块链。\n\n以 A 向 B 转账为例：\n\n * B的公钥: A 向 B 转账，A 需要知道 B 的地址。因为 BTC 系统中的收款地址就是收款人的公钥取哈希再经过一些转换得到的。BTC系统也没有提供查询某用户的公钥或账户地址的功能，要向 B 转账，就需要 B 提供公钥或账户地址。这种情况 B 可以把公钥公布在网站上。（虽然公钥可以公开，但实际中更多公开的是公钥的哈希）\n * A的公钥: A 向 B 转账，B 也需要知道 A 的公钥。因为一方面 A 的公钥代表 A 的身份，B 要知道转账的是谁，另一方面是为了验证 BTC 交易中 A 的签名（私钥签名公钥验证），也就是说所有结点都需要知道 A 的公钥才行，每个结点都需要独立验证，即使是一个和交易无关的旁观者也要验证这笔交易的合法性。\n * 如何知道 A 的公钥: A 的公钥是 A 自己写在这笔交易的输入部分里，即在交易中付款方自己宣称的。实际中 A 转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造 A 的公钥来“偷”走 A 的比特币。\n * 在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。\n\n\n# 区块结构\n\n\n\n> 全结点（fully validating node）是有块身的，需要验证所有交易的合法性；轻结点（light node）是没有块身的，没有办法独立验证交易的合法性。轻结点没有参与区块链的构造和维护，只是利用了区块链中的部分信息。系统中大部分结点是轻结点，全结点不是很多。下面主要是对全结点进行说明。\n\n * 块头（block header）: 块头里保存的是区块的宏观的信息。\n   * version: 用的是BTC的哪个版本的协议\n   * 指向前一个区块块头的哈希指针\n   * Merkle root hash: 整棵 Merkle Tree 的根哈希值\n   * target: 挖矿的难度目标阈值target\n   * nonce: 挖矿用的随机数nonce，要使得H(blockheader) ≤ target\n * 块身（block body）\n   * 交易列表\n\n\n# 共识协议\n\n每个账户都可以发布交易，区块链可以看做去中心化的账本，那么发布的交易应该写在哪个区块里呢？交易广播给每个区块，每个人都在自己本地的区块链上写入交易，如何保证写入后的一致性？也就是说账本的内容要取得分布式的共识（distributed consensus）。\n\n * FLP impossibility result: 讲的是在一个异步的系统（asynchronous system）中，网络传输的时延没有上限，即使只有一个成员是有问题（faulty）的，也不可能取得共识。\n * CAP Theorem: CAP 是分布式系统想要的三个性质，Consistency 一致性、Availability 可用性、Partition tolerance 分区容忍性。而 CAP Theorem 是说任何一个分布式系统中，CAP 三个性质最多只能满足其中两个，不可能三个全满足。\n * 分布式共识中协议 Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。\n\n\n# 比特币共识协议\n\n> 背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。 想法1：直接投票 某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。 存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。 存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。 存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。 更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击 sybil attack）。所以，这种简单的投票方案也是不可行的。\n\n比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。 在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种 nonce 值（4 bytes），这就是挖矿。H(block header)<=target。当某个节点找到符合要求的 nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。\n\n> 验证合法性如检查 target 的编码 nBits 域设置的是不是符合 BTC 协议规定的难度要求、检查带 nonce 的块头哈希值是不是小于target、检查块身中的每个交易是否都有合法的签名、检查每个交易都没有双花等\n\n候选区块合法了就要去接收吗？\n\n分叉攻击：A用户对上面的A转账给B的记录回滚，从而非法获取利益。但是在两条链上，发现交易都合法，但是转账给A'不应当被接受。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。 在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。\n\n> 此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”）\n\n\n# 比特币的激励机制\n\n让大家去竞争记账权的动力是什么？需要提供算力和电力成本，节点为什么要去做？获得记账权的结点本身有一定的权力，如可以决定哪些交易被写入下一个区块中，但这不应当成为竞争记账权的主要动力，因为 BTC 系统设计来希望所有交易都能被公平写入账本。出块奖励机制解决了这个问题。\n\nBTC协议中规定，获得记账权的结点，在发布的区块里可以有一个特殊的交易——铸币交易，在这个交易中可以发布一定数量的BTC，这是发行BTC（产生新的BTC）的唯一方法，不必指定币的来源。这也就解决了前面谈及的去中心化系统中的第一个问题——谁来发行 BTC 和发行多少 BTC。\n\n> BTC刚出现时，出块奖励是 50 个BTC，BTC协议规定每 21万个 区块之后，出块奖励就要减半，也就变成 25个BTC。如今的情况是每个区块中能产生12.5个BTC。\n\n为什么形容取得记账权的过程为挖矿（mining）？\n\n> 矿的数量有限，BTC总量有限。 挖矿的过程很难，挖到矿的回报很大，BTC取得记账权来获得出块奖励也是一样。 争夺记账权的结点称为矿工。",normalizedContent:"# 北大肖臻老师《区块链技术与应用》公开课学习 1\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n * 参考文章：\n   * https://blog.nowcoder.net/n/30cbdb37108b4d93b3a5a93b8226ae31\n   * https://blog.csdn.net/weixin_47692652/category_11702107.html\n\n\n# 区块链\n\n20 世纪经济学家 哈耶克 认为：欧美通货膨胀的根源在于货币是政府发行的，是中心化的，注定会为了铸币税而滥发。比特币是一种虚拟货币，它是为了解决哈耶克提出来的中心化货币必然会超发贬值的问题，而被创造出来的去中心化货币。\n\n货币交易的过程中怎么确保记账不出错，不被篡改？\n\n> 古代文明使用实体物质特别是贵金属。（无法凭空创造物质，元宝给了你我就没了） 近代国家进入纸币时代。（特殊印版、纸张、油墨，使得复制纸币变为不可能） 移动互联网时代使用的是网上支付。（第三方中介银行进行信用担保、密码系统）\n\n那么比特币是怎么记账的呢？\n\n> 牺牲隐私，每个账户的出账和入账都广播出来，整个记账过程让全网的人都看到，组成一条区块链。\n\n那么怎么保证区块链上的之前的信息没有被篡改呢？\n\n> 这就利用到了下面讲到的密码学原理。\n\n\n# 密码学原理\n\n比特币被称为加密货币 cryptocurrency。但其实区块链上内容都是公开的，包括区块的地址，转账的金额。 比特币主要用到了密码学中的两个功能: 1.哈希 2.签名\n\n密码学中用到的哈希函数被称为 cryptographic hash function, 它有两个重要的性质:\n\n * collision resistance(抗碰撞性): 例如 x=y h(x)=h(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。哈希碰撞中，给出x，很难找到y，除非蛮力求解(brute-force)。难以发现碰撞的性质称为collision resistance\n   * 作用：检测上传到云端的文件是否被更改，上传文件前先求该文件的hash值，过段时间下载该文件后，再求一次hash值，比较两值是否相等即可知道文件是否被篡改。\n   * 人工制造碰撞：我国著名密码学家王小云教授在 2004 年就找到算法，人工制造了哈希函数 md5 的哈希碰撞，使得 md5函数 安全性收到了冲击。如果无法人工制造哈希碰撞，那么坏人就只能用 brute-force 蛮力穷举，这种工作量就巨大到不可能了。\n * hiding: 哈希函数的计算过程是单向的，不可逆的。例如从 h(x) 无法推导出 x, hiding 性质前提是输入空间足够大(不然很容易遍历完)，分布比较均匀(hash 结果不能只是某几个值)。如果输入不是足够大，一般在 x 后面拼接一个随机数，如 x123213124，整体取哈希值。\n   * 作用：和 collision resistance 结合在一起，用来实现 digital commitment (又称为 digital equivalent of a sealed envelope)。把预测结果作为输入 x，算出一个哈希值，将哈希值公布，hiding 让人们知道哈希值而不知道预测值，最后再将 x 公布，因为有 collision resistance 的性质，预测结果是不可篡改的。\n * puzzle friendly: 所谓 puzzle friendly，意思是对于哈希函数，他的输出是无法预测的，要找到特定区间内的哈希值的输入x，没有捷径。 比如，我要找到sha256函数（比特币中用的 hash 函数: secure hash algorithm）的哈希值，前60位都是零，我除了一个一个试验以外，没有其他的方法。 （挖矿很难，验证很容易）\n\n关于签名，首先要介绍比特币中的账户管理，开户方式: 只需要创建一对公私钥即可（非对称加密），公钥是公开的，私钥是私密的。\n\n> 那么每个人都有公私钥，可不可以不断生成公私钥，与区块链上已存在的公钥进行对比，如果相同，则用对应的私钥去攻击他。答案是不可能，因为概率微乎其微，但是前提是生成公私钥的时候要有好的随机源。\n\n比特币的本质就是数字签名，对于一笔交易，要用发起人的私钥进行签名，大家可以用发起人的公钥对这笔交易进行验证。\n\n> 关于非对称加密算法，比较常见的是椭圆曲线加密算法。简单可以理解为经过一条椭圆曲线，可以生成两个值 k 和 q，对一个数 123 用 k 进行加密会生成毫无规律的数，再对其用 q 进行解密，就又恢复成了 123。k 可以作为私钥，q 可以作为公钥。\n\n\n# 数据结构\n\n\n# hash pointer（哈希指针）\n\n> 在比特币中，其最基本的数据结构便是一个个区块形成的区块链。区块链与链表的区别就是用哈希指针代替了普通指针。 一般的链表我们都可以改造为使用哈希指针的链表，但当链表中存在环时，哈希指针便不能再使用。\n\n对于链表中的节点，对链表中的内容做一次哈希运算，记 h() 为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。\n\n\n\n> 如图中所示，如果我们想要破坏区块链完整性。篡改b的内容，而c中保存有b的哈希值，所以c也得进行修改。而同样c后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。 在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。\n\n\n# merkle tree（默克尔树）\n\n> merkle tree 与 binary tree 的区别就是用哈希指针代替了普通指针。\n\n\n\n> 上图即为一个简单的merkle tree，其中tx0、tx1、tx2、tx3为数据块，代表每一次交易。tx0、tx1各有一个哈希值，将其合并放在一个节点中，tx2、tx3同样操作，而后，针对得到的两个节点hash01、hash23分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头中存储的是根节点的哈希值（对其再取一次哈希）\n\n该数据结构的优点在于：只需要记住 root hash（根哈希值），便可以检测出对树中任何部位的修改。不论在哪里篡改了，都会通过哈希值向上反应，最终反馈到 root hash 值上。\n\n> 在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过 merkle tree 的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信息），块身中存在交易列表。\n\n\n# 轻节点与全节点(light node and full node)\n\n> 全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。 为什么要分轻节点和全节点？ 因为硬件的局限。一个区块大小为1mb，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容。\n\n当需要向轻节点证明某条交易是否被写入区块链，便需要用到 merkle proof。我们将交易到根节点这一条路径称为 merkle proof，全节点将整个 merkle tree 的信息发送给轻节点，轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，计算出来的根哈希值正确，说明内容没有被修改过。\n\n\n\n那么全节点是否可以修改 hash 值，向轻节点发送修改后的 hash 值使得向上一层计算的 hash 值仍然正确呢？\n\n> 实际上，这种情况为人为制造哈希碰撞。由于哈希函数的 collision resistance 性质，这种情况是不会发生的，保证了系统的不可篡改性。同时，这样一个 merkle proof 的事件复杂度为 o(log n), 非常高效【证明交易存在】。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。在比特币系统中，没有相应的需求，所以在比特币系统中并没有对 merkle tree 进行排序。\n\n\n# 协议\n\n\n# 数字货币的问题\n\n假设权威机构——中央银行发行数字货币，发行了数字货币，用央行的私钥签名，然后使用的时候，用户直接拿央行的公钥验证签名（假设大家都知道公钥）。\n\n\n\n虽然签名保证了没办法篡改其中的内容，但是数字货币本质上还是一个文件，这样的数字货币可复制，就会造成双花攻击（double spending attack）。不像是纸质货币，花出去手上就没有。\n\n\n# 中心化\n\n为解决这个问题，央行还要维护一个数据库，即记录每个编号的数字货币是归哪个用户所有。\n\n\n\n在支付时，不仅要用公钥验证签名是央行签署的，还要通过央行验证该货币是归自己所有，央行再将货币所有者改成支付给的那个用户。不仅数字货币的发行是由央行统一控制，而且每次交易都要由央行确认其合法性，这种方案是一个中心化的方案。\n\n\n# 去中心化\n\n将央行的职能改成由广大的用户来共同承担，也就是去中心化的方案，这是btc等数字货币系统要解决的问题，即：\n\n> 1️⃣ 怎么决定数字货币的发行及发行量 2️⃣ 怎么验证交易的合法性，防止双花攻击 第一个问题在 btc 系统中是挖矿决定的 第二个问题的解决，要维护一个数据结构，由所有用户来共同维护，这个数据结构就是区块链。\n\n假设用户 a 获得了铸币权，他发行了 10 个 btc。然后他将这 10 个 btc 转给 b 和 c，每个人分 5 个 btc。接下来 b 给 c 2 个货币，给 d 3 个货币。最后 c 将所得的 7 个货币全部给 e。\n\n\n\n> 红色箭头会说明【币的来源】，这也就防止了双花攻击，如过 b 已经将自己的 5个btc 花掉了，假设 b 尝试再花一次，将 5个btc 转给f。这时顺着区块链去检查这个区块到来源交易之间的区块，发现 b 已经花了来源区块的btc，说明这新个交易是不合法的，也就不会接受这个转给f的区块进入区块链。\n\n以 a 向 b 转账为例：\n\n * b的公钥: a 向 b 转账，a 需要知道 b 的地址。因为 btc 系统中的收款地址就是收款人的公钥取哈希再经过一些转换得到的。btc系统也没有提供查询某用户的公钥或账户地址的功能，要向 b 转账，就需要 b 提供公钥或账户地址。这种情况 b 可以把公钥公布在网站上。（虽然公钥可以公开，但实际中更多公开的是公钥的哈希）\n * a的公钥: a 向 b 转账，b 也需要知道 a 的公钥。因为一方面 a 的公钥代表 a 的身份，b 要知道转账的是谁，另一方面是为了验证 btc 交易中 a 的签名（私钥签名公钥验证），也就是说所有结点都需要知道 a 的公钥才行，每个结点都需要独立验证，即使是一个和交易无关的旁观者也要验证这笔交易的合法性。\n * 如何知道 a 的公钥: a 的公钥是 a 自己写在这笔交易的输入部分里，即在交易中付款方自己宣称的。实际中 a 转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造 a 的公钥来“偷”走 a 的比特币。\n * 在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。\n\n\n# 区块结构\n\n\n\n> 全结点（fully validating node）是有块身的，需要验证所有交易的合法性；轻结点（light node）是没有块身的，没有办法独立验证交易的合法性。轻结点没有参与区块链的构造和维护，只是利用了区块链中的部分信息。系统中大部分结点是轻结点，全结点不是很多。下面主要是对全结点进行说明。\n\n * 块头（block header）: 块头里保存的是区块的宏观的信息。\n   * version: 用的是btc的哪个版本的协议\n   * 指向前一个区块块头的哈希指针\n   * merkle root hash: 整棵 merkle tree 的根哈希值\n   * target: 挖矿的难度目标阈值target\n   * nonce: 挖矿用的随机数nonce，要使得h(blockheader) ≤ target\n * 块身（block body）\n   * 交易列表\n\n\n# 共识协议\n\n每个账户都可以发布交易，区块链可以看做去中心化的账本，那么发布的交易应该写在哪个区块里呢？交易广播给每个区块，每个人都在自己本地的区块链上写入交易，如何保证写入后的一致性？也就是说账本的内容要取得分布式的共识（distributed consensus）。\n\n * flp impossibility result: 讲的是在一个异步的系统（asynchronous system）中，网络传输的时延没有上限，即使只有一个成员是有问题（faulty）的，也不可能取得共识。\n * cap theorem: cap 是分布式系统想要的三个性质，consistency 一致性、availability 可用性、partition tolerance 分区容忍性。而 cap theorem 是说任何一个分布式系统中，cap 三个性质最多只能满足其中两个，不可能三个全满足。\n * 分布式共识中协议 paxos 可以保证consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。\n\n\n# 比特币共识协议\n\n> 背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。 想法1：直接投票 某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。 存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。 存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。 存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。 更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击 sybil attack）。所以，这种简单的投票方案也是不可行的。\n\n比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。 在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种 nonce 值（4 bytes），这就是挖矿。h(block header)<=target。当某个节点找到符合要求的 nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。\n\n> 验证合法性如检查 target 的编码 nbits 域设置的是不是符合 btc 协议规定的难度要求、检查带 nonce 的块头哈希值是不是小于target、检查块身中的每个交易是否都有合法的签名、检查每个交易都没有双花等\n\n候选区块合法了就要去接收吗？\n\n分叉攻击：a用户对上面的a转账给b的记录回滚，从而非法获取利益。但是在两条链上，发现交易都合法，但是转账给a'不应当被接受。这是一个典型的双花攻击。a给b转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。 在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而a这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。\n\n> 此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”）\n\n\n# 比特币的激励机制\n\n让大家去竞争记账权的动力是什么？需要提供算力和电力成本，节点为什么要去做？获得记账权的结点本身有一定的权力，如可以决定哪些交易被写入下一个区块中，但这不应当成为竞争记账权的主要动力，因为 btc 系统设计来希望所有交易都能被公平写入账本。出块奖励机制解决了这个问题。\n\nbtc协议中规定，获得记账权的结点，在发布的区块里可以有一个特殊的交易——铸币交易，在这个交易中可以发布一定数量的btc，这是发行btc（产生新的btc）的唯一方法，不必指定币的来源。这也就解决了前面谈及的去中心化系统中的第一个问题——谁来发行 btc 和发行多少 btc。\n\n> btc刚出现时，出块奖励是 50 个btc，btc协议规定每 21万个 区块之后，出块奖励就要减半，也就变成 25个btc。如今的情况是每个区块中能产生12.5个btc。\n\n为什么形容取得记账权的过程为挖矿（mining）？\n\n> 矿的数量有限，btc总量有限。 挖矿的过程很难，挖到矿的回报很大，btc取得记账权来获得出块奖励也是一样。 争夺记账权的结点称为矿工。",charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 4",frontmatter:{},regularPath:"/blockchain/learn4.html",relativePath:"blockchain/learn4.md",key:"v-88916b42",path:"/blockchain/learn4.html",headers:[{level:2,title:"BTC 分叉",slug:"btc-分叉",normalizedTitle:"btc 分叉",charIndex:83},{level:3,title:"state fork",slug:"state-fork",normalizedTitle:"state fork",charIndex:94},{level:3,title:"protocol fork",slug:"protocol-fork",normalizedTitle:"protocol fork",charIndex:304},{level:2,title:"BTC 问答",slug:"btc-问答",normalizedTitle:"btc 问答",charIndex:2484},{level:2,title:"BTC 匿名性",slug:"btc-匿名性",normalizedTitle:"btc 匿名性",charIndex:3817},{level:3,title:"BTC 什么情况会破坏其匿名性",slug:"btc-什么情况会破坏其匿名性",normalizedTitle:"btc 什么情况会破坏其匿名性",charIndex:4028},{level:3,title:"如何提高匿名性",slug:"如何提高匿名性",normalizedTitle:"如何提高匿名性",charIndex:4886},{level:3,title:"零知识证明",slug:"零知识证明",normalizedTitle:"零知识证明",charIndex:5059},{level:3,title:"同态隐藏",slug:"同态隐藏",normalizedTitle:"同态隐藏",charIndex:5205},{level:3,title:"盲签方法",slug:"盲签方法",normalizedTitle:"盲签方法",charIndex:5291},{level:3,title:"零币和零钞",slug:"零币和零钞",normalizedTitle:"零币和零钞",charIndex:5397},{level:2,title:"BTC 思考",slug:"btc-思考",normalizedTitle:"btc 思考",charIndex:5529},{level:3,title:"哈希指针",slug:"哈希指针",normalizedTitle:"哈希指针",charIndex:5540},{level:3,title:"区块『恋』",slug:"区块『恋』",normalizedTitle:"区块『恋』",charIndex:5946},{level:3,title:"分布式共识",slug:"分布式共识",normalizedTitle:"分布式共识",charIndex:6269},{level:3,title:"BTC 稀缺性",slug:"btc-稀缺性",normalizedTitle:"btc 稀缺性",charIndex:6486},{level:3,title:"量子计算",slug:"量子计算",normalizedTitle:"量子计算",charIndex:6834}],lastUpdated:"6/6/2025, 6:14:05 PM",lastUpdatedTimestamp:1749204845e3,headersStr:"BTC 分叉 state fork protocol fork BTC 问答 BTC 匿名性 BTC 什么情况会破坏其匿名性 如何提高匿名性 零知识证明 同态隐藏 盲签方法 零币和零钞 BTC 思考 哈希指针 区块『恋』 分布式共识 BTC 稀缺性 量子计算",content:"# 北大肖臻老师《区块链技术与应用》公开课学习 4\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n\n\n# BTC 分叉\n\n\n# state fork\n\n如果两个节点差不多同时挖到一个区块，这两个区块都是挂在当前的区块上的，不同节点先收到的区块不同，就会各自沿着先收到的区块往下扩展，这种时候就会出现临时性的分叉，称为state fork，即由于对区块链当前的状态有意见分歧而产生的分叉。\n\n分叉攻击（forking attack）也属于state fork，只不过这种意见分歧是人为造成的，这种情况也称为 deliberate fork。\n\n\n# protocol fork\n\n要修改比特币协议需要软件升级，在去中心化的系统中，没办法要求所有的结点都升级软件\n\n假设大部分节点升级了软件，少部分节点没有升级（可能是没来得及升级，也可能是不同意协议的修改），这种分叉称为protocol fork，即对比特币协议产生了分歧，使用不同版本的协议而产生的分叉。\n\n在 protocol fork 中，根据对协议修改的内容的不同，又可以分为硬分叉和软分叉。\n\n# 硬分叉\n\n如果区块链软件的共识规则被改变，并且这种规则改变无法向前兼容，旧节点无法认可新节点产生的区块，即为硬分叉。\n\n 1. 比特币分叉\n\n一些人开始觉得比特币的区块容量太小，总出现拥堵，于是这些人要求对比特币的区块大小进行升级扩容。有人支持就有人反对，这种对比特币发展的分歧导致了比特币首次硬分叉，旧链上的币仍然是比特币 BTC(区块容量达到了8M)，新链上的币是 BCH（Bitcoin Cash，比特币现金。区块容量达到了8M）。\n\nBCH 和 BTC 最大的区别只是在于区块容量的参数不同，两者分叉前的交易都是一样的，只是交易的币种不一样。可以理解为 BCH 那条链把分叉前的区块里的交易按照原来的方式重新运行了一遍，只是把币种由原来的 BTC 换成了 BCH。\n\n 2. 以太坊分叉\n\nThe DAO 项目是区块链物联网公司 Slock.it 发起的一个众筹项目，于2016年5月正式发布，截止到当年6月，The DAO 项目募集资金超过 1.6 亿美元。没过多久，The DAO 项目就被黑客盯上了，因为智能合约上的巨大漏洞，导致 The DAO 项目被转移了市值五千万美元的以太币。\n\n为了挽回众多投资者的资产并停止恐慌，以太坊创始人V神（Vitalik Buterin）最后提出硬分叉的设想，并最终通过社区的多数投票表决在以太坊第 1920000 区块完成了硬分叉，回滚了包括被黑客占有的所有以太币。即使以太坊硬分叉成了两条链，依然有部分信仰着区块链不可篡改特性的人留在以太经典这条原链上。\n\n目前的以太坊 ETH 就是硬分叉之后的，原来的链是 ETC。分叉之初，由于两个链分叉造成了互相影响，产生了很多麻烦。比如：在 ETH 链上有一笔转账 B->C，有人便在 ETC 链上回放，将 ETC 链上的货币页转给了 C(C收到两笔钱)。后来，对两条链各添加了一个 chainID，将两个链区分开，才使得这两条链真正分开。\n\n# 软分叉\n\n如果区块链的共识规则改变后，这种改变是向前兼容的，旧节点可以兼容新节点产生的区块，即为软分叉。\n\n实际上，软分叉通常刚开始并不会产生两条区块链，因为新规则下产生的块会被旧节点接受，旧节点只是无法识别新规则的真实意义。所以新旧节点仍然处于同一条区块链上，对整个系统的影响也就较小。\n\n 1. coinbase 域\n\n铸币交易中 CoinBase 域。在 CoinBase 域中写入任何内容都可以，挖矿本质是调整 block header 中的 nonce ，但其本身只有 4 个字节，搜索空间太小。所以实际使用中，将 CoinBase 域前 8 个自己作为另一个 extra nonce，此时搜索空间从原本2^32 增长到 2^96，对于目前挖矿难度来说已经足够。但 CoinBase 中并不是只有8个字节，还剩下很多空间。\n\nCoinbase 交易的输入中有一个字段 coinbase data 内容可以任意定制。BIP-34 就是要求在 coinbase data 中必须包含块高度（Block Height）信息且将块版本（Block version）从 1 修改为 2。\n\n显然在旧规则下，节点并不关心 coinbase data 是什么内容，完全可以兼容包含块高度信息的区块，所以不会就此产生分叉。\n\nBIP-34 的升级过程如下：\n\n * 刚开始矿工将块版本号变为2以表示准备好进行升级，此时并不要求 coinbase data 必须包含块高度信息。\n * 当最近 1000 个区块中超过 75% 的版本号为 2时，整个系统开始强制要求版本号为 2 的区块 coinbase data 中必须包含块高度信息。但版本号为 1 的区块仍然被所有节点接受。\n * 当最近 1000 个区块中超过 95% 的版本号为 2 时，版本号为 1 的区块开始被认为无效，节点会拒绝版本号为 1 的区块，于是会逼迫最后一小部分节点进行升级。（否则完成挖矿获得的奖励将失去价值）。\n\n 2. P2SH：Pay to Script Hash\n\nP2SH（Pay to Script Hash） 形式的交易脚本，最开始的比特币系统中是没有的，是后来通过软分叉的方式加进去的。P2SH 会把 redeem script 的内容在第二阶段执行，这个过程旧节点认为是合法的，因为旧节点只会验证第一阶段。\n\n软分叉提供了一种逐步升级比特币的方式，除了 BIP-34，还有 BIP-65、BIP-66、BIP-9 等特性进行了软分叉升级。\n\n> soft fork: 只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉。 hard fork: 必须系统中所有节点更新软件，系统才不会产生永久性分叉。\n\n\n# BTC 问答\n\n 1. 转账交易时候，如果接收者不在线(没有连在比特币网络上)怎么办？\n\n> 转账交易只需要在区块链上记录，将某账户比特币转到另一账户，而接收方是否在线并无影响。\n\n 2. 假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过。\n\n> 可能，因为比特币账户只需要本地产生即可。只有该账户第一次收到钱时，其他节点才能知道该节点的存在。\n\n 3. 如果账户私钥丢失怎么办？\n\n> 没有办法。因为比特币是去中心化货币，没有第三方中心机构可以重置密码，所以账户上的钱也就变成了死钱。 通过加密货币交易所(中心化机构)，一般需要提供身份证明，如果忘记私钥可以找交易所申请追回私钥。但目前这类货币的交易所，尚且处于缺少监管的状态，并不一定具有可信力。而且，其本身仅起到“中介”作用，与该提问的回答“私钥丢失无法追回里面的比特币”并不冲突。 在历史上，有很多次交易所被黑客攻击偷走大量加密货币的事情，其中最著名的为 Mt. GOX（中文译为：门头沟）事件。该交易所曾经为全球最大比特币交易所，交易量占到全球比特币交易量的 70% 左右，设于日本。后来由于被攻击丢失大量比特币，导致交易所破产，其 CEO 被判刑入狱。\n\n 4. 私钥泄露怎么办？\n\n> 尽快将剩余BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。BTC系统中账户便是公私钥对，密码就是私钥，无法更改。\n\n 5. 转账写错地址怎么办？\n\n> 没有办法，只能自认倒霉，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。当然，比特币系统中 UTXO 会永久保存该交易，记录该并不存在的地址。因此对全节点来说这是不友好的。\n\n 6. 之前在 BTC 脚本中介绍了 OP_RETURN 指令，我们提到，这种方法为普通用户提供了一个向比特币网络中写入想要一直保存的内容。但OP_RETURN 执行结果是无条件返回错误，而交易返回错误，区块又怎么会包含它？区块链又如何会接收这个区块？\n\n> 实际上要想清楚，OP_RETURN 是写在哪里的。OP_RETURN 实际写在当前交易的输出脚本中，而验证交易合法性时，使用的当前交易的输入脚本和前一个交易(币来源的交易)的输出脚本进行验证。也就是说，验证当前交易合法性时，并不会执行该语句。只有在有人想花这笔钱时候，才会执行该语句。\n\n 7. BTC系统挖矿，会不会有矿工“偷”答案？例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。\n\n> 实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款地址，而地址改变，铸币交易内容也发生改变，从而引发 Merkle Tree 根哈希值改变。从而导致原本的 nonce 作废。\n\n 8. 交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？\n\n> 事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费。\n\n\n# BTC 匿名性\n\n一般来说,匿名性多与隐私保护相关。但实际上，比特币中的匿名并非真正的匿名。实际上比特币与纸币相比，纸币的匿名性更好，因为其并没有对个人信息的标记。也正是因为其匿名性，很多非法交易采用现金交易。\n\n实际上，比特币中的数据是完全公开的，而网上的交易是要与实体世界进行交易的，所以大大破坏了其匿名性。假如银行允许用假名(以前的存折时代)，由于银行数据并非公开，所以银行系统的匿名性是要比比特币更好的。\n\n\n# BTC 什么情况会破坏其匿名性\n\n 1. 用户可以生成多个地址账户，但这些地址账户可以被关联起来\n\n例如如下这个交易：\n\n> 在图中可以看到该交易有 2 个输入和 2 个输出，所以 addr1 和 addr2 很可能是同一个人所持有的账户，因为该人同时拥有这两个私钥的地址。(一个账户中的钱可能不够)而在输出中，很有可能有一个地址是属于找零钱的地址，即花掉之后剩余的钱。在某些情况下，也是可以分析出来的。addr4 很明显是找零钱的地址，而非addr3(支付6个比特币，单个账户不够用，所以用两个账户)。\n\n 2. 地址账户与个人在真实社会中的身份也可能会产生关联\n\n任何使得BTC和实体世界中关联的操作都有可能泄露用户真实身份，其中最明显的就是资金的转入转出。要得到 BTC，如果用钱买，就会与实体世界进行交互。想要将 BTC 转为现实中的货币，也同样需要与实体世界交互。\n\n如何防范不法分子采用 BTC 进行洗钱呢？其实只需要盯住资金转入转出链即可。对于大额资金转入 BTC 或将大量 BTC 转为现实货币，很难逃避司法金融机构的监管。\n\n 3. BTC 支付\n\n> 例如某些商家接受用 BTC 进行支付，例如可以用 BTC 购买咖啡、蛋糕等。(但是用 BTC 交易延迟高，交易费贵，并非一个好的idea)在进行支付时候，便和个人账户建立了联系，从而会泄露掉个人信息。\n\n也就是说，BTC 并不是具有很好的匿名信。实际中很多人保持有较好的匿名性。保持最好的便是其开发者中本聪，其参与 BTC 时间最长，全世界都想知道他是谁。但实际上，中本聪的比特币并非有花出去，这也使得我们难以发现他具体是谁。\n\n以前美国有一个 skil road 网站，主要用于匿名支付，采用各类可以躲避监管的方法(因为售卖的都是违禁品)。但运行没有几年就被查封，其老板当时赚取了许多比特币，但由于其担心被发现，这些钱实际中一个都不敢花，仍然过的是非常简朴的生活。最终据说由于在同一电脑上登录现实社会账户和非法网站上账户，从而被抓。\n\n\n# 如何提高匿名性\n\n> 从应用层看，可以将各个不同用户的 BTC 混合在一起，使得追查变得混乱(Coin mixing) 从网络层看，从节点上 ip 地址可以推算出真实身份，所以可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)。\n\n实际上正因为 BTC 的公开性和不可篡改性，才导致隐私性会有一定的问题。\n\n\n# 零知识证明\n\n零知识证明是指一方（证明者）项另一方（验证者）证明一个陈述是正确的，而无需透露该陈述是正确的外的任何信息。\n\n> 例如证明某个比特币账户是我的（不能泄露私钥），那么就用私钥产生一个签名，大家用我的公钥来验证。但是因为告诉别人了公钥，所以有争议这种方式是不是零知识证明。\n\n\n# 同态隐藏\n\n\n\n> 例如：Alice 想要向 Bob 证明她知道一组数 x 和 y 使得 x + y = 7，同时不像让 Bob，知道 x 和 y 的具体数值\n\n\n\n\n# 盲签方法\n\n在前面的课程中说到，央行会维护一个中心化的数据库来记录每一笔钱是否花出去，来防止双花，那么你的每一笔交易央行都会知道。那么有没有一种办法既然央行做中心化的记账，又不让它知道交易的信息呢。\n\n\n\n\n# 零币和零钞\n\n\n\n不常用的原因：\n\n 1. btc 的匿名性已经够用了，大家不愿意为了匿名性而去用一种新的币。\n 2. 零币和零钞运用了密码学和数学的知识来增强匿名性，实现和使用起来比较复杂。\n 3. 当与现实交互的时候零币和零钞也无法保证100%匿名。\n\n\n# BTC 思考\n\n\n# 哈希指针\n\nBTC 系统中很多地方使用到了哈希指针。指针保存的本地内存地址，只有在本地计算机上才具有意义，如果发送给其他计算机就没有意义了。那么在区块发布时候，哈希指针如何通过网络进行传播？\n\n> 所谓哈希指针，只是系统中一种形象化的方法。实际应用时候，只有哈希而没有指针。回顾之前提过的Block header数据结构，有一个字段前一个区块的哈希值。 因此可见，在 block header 中只有 hash 值，没有指针。那么如何查找到前一个区块的内容？ 全节点一般将区块存储于一个 key-value 数据库中，key 为哈希，value 为区块内容。常用的 key-value 数据库为 levelDB，只要掌握到最后一个区块的哈希值即可依据哈希值一直往前找到区块链所有内容。有些节点只保存区块链部分信息，如果需要用到前面的区块，可以问其他节点要。哈希指针性质保证了整个区块链内容是不可篡改的。\n\n\n# 区块『恋』\n\n有情侣一起买 BTC，将私钥从中截断，每人保留其中一部分。如果未来两人依旧感情很好，就可以将钱取出；如果分手，这部分钱就会永久锁死，谁也无法取出，通过区块链的不可篡改性作为两人的爱情见证。这样做有什么问题？ 如此下来，N 个人怎么办？ 如果按照这种方法，将私钥分为 N 份。但这样会有一系列问题。\n\n 1. 如果N个人中任意一个人忘记私钥，则无法将钱取出。\n 2. 截断私钥长度，会降低安全性，因为私钥长度会直接影响破解难度(2^256远远大于2^128)，之间难度差距远远不止一倍。(可见，对于多个人账户，应该使用多重签名，而非截断私钥的方法。)\n 3. 如果分手，该钱变成死钱，一直保存在UTXO集合中，对矿工不友好。\n\n\n# 分布式共识\n\n之前有提及，理论上来说，分布式系统不可能达成共识。但实际中为何变成可能了？严格来说，BTC系统的共识随时可能被推翻，例如分叉攻击导致系统回滚。此外，理论和实际存在差异。不可能结论针对特定模型，实际中对模型稍微修改或添加线下方法即可将不可能变为可能。\n\n知识改变命运，这句话本身没有错，但是对知识的一知半解可能让你的命运变得更差，搞科研是很有意义的，但是不要给学术界的思维限制头脑，不要为程序员的思维限制想象力。\n\n\n# BTC 稀缺性\n\n为什么要挖矿？因为有收益，且收益大于开销。早期 BTC 难度低且出块奖励高，从而吸引矿工。 之前有提到，BTC 总量固定，有人认为其是一个精妙的设计。但实际上，总量固定的东西并不适合作为货币，这也就决定了 BTC 并不能在未来完全颠覆现有货币体系。以太坊中便没有 BTC 中出块奖励定期减半的做法，此外，某些新型货币会自带通货膨胀的功能。 对个人来说，通货膨胀并非好事，因为钱不值钱了。但人类每年创造的价值，如果用总量固定的东西作为货币，则其只会越来越值钱，而这会导致拥有者不断看着其升值，其他没有的人无论如何奋斗都赶不上（房价也是如此，炒房使一部分人靠房租便可大赚特赚，个人奋斗却很难买房。这也是我国目前存在的较大的问题，社会财富的分配不公，最终引发各种社会矛盾）。\n\n\n# 量子计算\n\n会不会 BTC 这种建立在密码学上的加密货币，在量子计算出来后会不会变得不安全。\n\n 1. 量子计算距离使用仍然有很长距离。\n 2. 量子计算若真正使用到破坏现有加密算法，对传统金融业的破坏才是最大的，网上银行网上转账都不安全了。\n 3. BTC 实际中使用的并非公钥，而是用公钥哈希。而哈希函数一般都是不可逆的，就算量子计算可以从公钥推出私钥，但是即使知道了公钥哈希量子计算也无法反推公钥。加密和哈希不是一回事，加密过程要保证信息不丢失去，但是取哈希会丢失一些信息。BTC 中用的 SHA-256，无论输入多大，最终结果都为 256 位，必然会导致信息丢失，无法反推原本数据。如果能反推数据，那么这将成为前所未有的压缩算法（把整个图书馆的数据作为输入压缩为 256 位，再从 256 位反推出图书馆信息这是不可能的）。",normalizedContent:"# 北大肖臻老师《区块链技术与应用》公开课学习 4\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n\n\n# btc 分叉\n\n\n# state fork\n\n如果两个节点差不多同时挖到一个区块，这两个区块都是挂在当前的区块上的，不同节点先收到的区块不同，就会各自沿着先收到的区块往下扩展，这种时候就会出现临时性的分叉，称为state fork，即由于对区块链当前的状态有意见分歧而产生的分叉。\n\n分叉攻击（forking attack）也属于state fork，只不过这种意见分歧是人为造成的，这种情况也称为 deliberate fork。\n\n\n# protocol fork\n\n要修改比特币协议需要软件升级，在去中心化的系统中，没办法要求所有的结点都升级软件\n\n假设大部分节点升级了软件，少部分节点没有升级（可能是没来得及升级，也可能是不同意协议的修改），这种分叉称为protocol fork，即对比特币协议产生了分歧，使用不同版本的协议而产生的分叉。\n\n在 protocol fork 中，根据对协议修改的内容的不同，又可以分为硬分叉和软分叉。\n\n# 硬分叉\n\n如果区块链软件的共识规则被改变，并且这种规则改变无法向前兼容，旧节点无法认可新节点产生的区块，即为硬分叉。\n\n 1. 比特币分叉\n\n一些人开始觉得比特币的区块容量太小，总出现拥堵，于是这些人要求对比特币的区块大小进行升级扩容。有人支持就有人反对，这种对比特币发展的分歧导致了比特币首次硬分叉，旧链上的币仍然是比特币 btc(区块容量达到了8m)，新链上的币是 bch（bitcoin cash，比特币现金。区块容量达到了8m）。\n\nbch 和 btc 最大的区别只是在于区块容量的参数不同，两者分叉前的交易都是一样的，只是交易的币种不一样。可以理解为 bch 那条链把分叉前的区块里的交易按照原来的方式重新运行了一遍，只是把币种由原来的 btc 换成了 bch。\n\n 2. 以太坊分叉\n\nthe dao 项目是区块链物联网公司 slock.it 发起的一个众筹项目，于2016年5月正式发布，截止到当年6月，the dao 项目募集资金超过 1.6 亿美元。没过多久，the dao 项目就被黑客盯上了，因为智能合约上的巨大漏洞，导致 the dao 项目被转移了市值五千万美元的以太币。\n\n为了挽回众多投资者的资产并停止恐慌，以太坊创始人v神（vitalik buterin）最后提出硬分叉的设想，并最终通过社区的多数投票表决在以太坊第 1920000 区块完成了硬分叉，回滚了包括被黑客占有的所有以太币。即使以太坊硬分叉成了两条链，依然有部分信仰着区块链不可篡改特性的人留在以太经典这条原链上。\n\n目前的以太坊 eth 就是硬分叉之后的，原来的链是 etc。分叉之初，由于两个链分叉造成了互相影响，产生了很多麻烦。比如：在 eth 链上有一笔转账 b->c，有人便在 etc 链上回放，将 etc 链上的货币页转给了 c(c收到两笔钱)。后来，对两条链各添加了一个 chainid，将两个链区分开，才使得这两条链真正分开。\n\n# 软分叉\n\n如果区块链的共识规则改变后，这种改变是向前兼容的，旧节点可以兼容新节点产生的区块，即为软分叉。\n\n实际上，软分叉通常刚开始并不会产生两条区块链，因为新规则下产生的块会被旧节点接受，旧节点只是无法识别新规则的真实意义。所以新旧节点仍然处于同一条区块链上，对整个系统的影响也就较小。\n\n 1. coinbase 域\n\n铸币交易中 coinbase 域。在 coinbase 域中写入任何内容都可以，挖矿本质是调整 block header 中的 nonce ，但其本身只有 4 个字节，搜索空间太小。所以实际使用中，将 coinbase 域前 8 个自己作为另一个 extra nonce，此时搜索空间从原本2^32 增长到 2^96，对于目前挖矿难度来说已经足够。但 coinbase 中并不是只有8个字节，还剩下很多空间。\n\ncoinbase 交易的输入中有一个字段 coinbase data 内容可以任意定制。bip-34 就是要求在 coinbase data 中必须包含块高度（block height）信息且将块版本（block version）从 1 修改为 2。\n\n显然在旧规则下，节点并不关心 coinbase data 是什么内容，完全可以兼容包含块高度信息的区块，所以不会就此产生分叉。\n\nbip-34 的升级过程如下：\n\n * 刚开始矿工将块版本号变为2以表示准备好进行升级，此时并不要求 coinbase data 必须包含块高度信息。\n * 当最近 1000 个区块中超过 75% 的版本号为 2时，整个系统开始强制要求版本号为 2 的区块 coinbase data 中必须包含块高度信息。但版本号为 1 的区块仍然被所有节点接受。\n * 当最近 1000 个区块中超过 95% 的版本号为 2 时，版本号为 1 的区块开始被认为无效，节点会拒绝版本号为 1 的区块，于是会逼迫最后一小部分节点进行升级。（否则完成挖矿获得的奖励将失去价值）。\n\n 2. p2sh：pay to script hash\n\np2sh（pay to script hash） 形式的交易脚本，最开始的比特币系统中是没有的，是后来通过软分叉的方式加进去的。p2sh 会把 redeem script 的内容在第二阶段执行，这个过程旧节点认为是合法的，因为旧节点只会验证第一阶段。\n\n软分叉提供了一种逐步升级比特币的方式，除了 bip-34，还有 bip-65、bip-66、bip-9 等特性进行了软分叉升级。\n\n> soft fork: 只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉。 hard fork: 必须系统中所有节点更新软件，系统才不会产生永久性分叉。\n\n\n# btc 问答\n\n 1. 转账交易时候，如果接收者不在线(没有连在比特币网络上)怎么办？\n\n> 转账交易只需要在区块链上记录，将某账户比特币转到另一账户，而接收方是否在线并无影响。\n\n 2. 假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过。\n\n> 可能，因为比特币账户只需要本地产生即可。只有该账户第一次收到钱时，其他节点才能知道该节点的存在。\n\n 3. 如果账户私钥丢失怎么办？\n\n> 没有办法。因为比特币是去中心化货币，没有第三方中心机构可以重置密码，所以账户上的钱也就变成了死钱。 通过加密货币交易所(中心化机构)，一般需要提供身份证明，如果忘记私钥可以找交易所申请追回私钥。但目前这类货币的交易所，尚且处于缺少监管的状态，并不一定具有可信力。而且，其本身仅起到“中介”作用，与该提问的回答“私钥丢失无法追回里面的比特币”并不冲突。 在历史上，有很多次交易所被黑客攻击偷走大量加密货币的事情，其中最著名的为 mt. gox（中文译为：门头沟）事件。该交易所曾经为全球最大比特币交易所，交易量占到全球比特币交易量的 70% 左右，设于日本。后来由于被攻击丢失大量比特币，导致交易所破产，其 ceo 被判刑入狱。\n\n 4. 私钥泄露怎么办？\n\n> 尽快将剩余btc转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。btc系统中账户便是公私钥对，密码就是私钥，无法更改。\n\n 5. 转账写错地址怎么办？\n\n> 没有办法，只能自认倒霉，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。当然，比特币系统中 utxo 会永久保存该交易，记录该并不存在的地址。因此对全节点来说这是不友好的。\n\n 6. 之前在 btc 脚本中介绍了 op_return 指令，我们提到，这种方法为普通用户提供了一个向比特币网络中写入想要一直保存的内容。但op_return 执行结果是无条件返回错误，而交易返回错误，区块又怎么会包含它？区块链又如何会接收这个区块？\n\n> 实际上要想清楚，op_return 是写在哪里的。op_return 实际写在当前交易的输出脚本中，而验证交易合法性时，使用的当前交易的输入脚本和前一个交易(币来源的交易)的输出脚本进行验证。也就是说，验证当前交易合法性时，并不会执行该语句。只有在有人想花这笔钱时候，才会执行该语句。\n\n 7. btc系统挖矿，会不会有矿工“偷”答案？例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。\n\n> 实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款地址，而地址改变，铸币交易内容也发生改变，从而引发 merkle tree 根哈希值改变。从而导致原本的 nonce 作废。\n\n 8. 交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？\n\n> 事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费。\n\n\n# btc 匿名性\n\n一般来说,匿名性多与隐私保护相关。但实际上，比特币中的匿名并非真正的匿名。实际上比特币与纸币相比，纸币的匿名性更好，因为其并没有对个人信息的标记。也正是因为其匿名性，很多非法交易采用现金交易。\n\n实际上，比特币中的数据是完全公开的，而网上的交易是要与实体世界进行交易的，所以大大破坏了其匿名性。假如银行允许用假名(以前的存折时代)，由于银行数据并非公开，所以银行系统的匿名性是要比比特币更好的。\n\n\n# btc 什么情况会破坏其匿名性\n\n 1. 用户可以生成多个地址账户，但这些地址账户可以被关联起来\n\n例如如下这个交易：\n\n> 在图中可以看到该交易有 2 个输入和 2 个输出，所以 addr1 和 addr2 很可能是同一个人所持有的账户，因为该人同时拥有这两个私钥的地址。(一个账户中的钱可能不够)而在输出中，很有可能有一个地址是属于找零钱的地址，即花掉之后剩余的钱。在某些情况下，也是可以分析出来的。addr4 很明显是找零钱的地址，而非addr3(支付6个比特币，单个账户不够用，所以用两个账户)。\n\n 2. 地址账户与个人在真实社会中的身份也可能会产生关联\n\n任何使得btc和实体世界中关联的操作都有可能泄露用户真实身份，其中最明显的就是资金的转入转出。要得到 btc，如果用钱买，就会与实体世界进行交互。想要将 btc 转为现实中的货币，也同样需要与实体世界交互。\n\n如何防范不法分子采用 btc 进行洗钱呢？其实只需要盯住资金转入转出链即可。对于大额资金转入 btc 或将大量 btc 转为现实货币，很难逃避司法金融机构的监管。\n\n 3. btc 支付\n\n> 例如某些商家接受用 btc 进行支付，例如可以用 btc 购买咖啡、蛋糕等。(但是用 btc 交易延迟高，交易费贵，并非一个好的idea)在进行支付时候，便和个人账户建立了联系，从而会泄露掉个人信息。\n\n也就是说，btc 并不是具有很好的匿名信。实际中很多人保持有较好的匿名性。保持最好的便是其开发者中本聪，其参与 btc 时间最长，全世界都想知道他是谁。但实际上，中本聪的比特币并非有花出去，这也使得我们难以发现他具体是谁。\n\n以前美国有一个 skil road 网站，主要用于匿名支付，采用各类可以躲避监管的方法(因为售卖的都是违禁品)。但运行没有几年就被查封，其老板当时赚取了许多比特币，但由于其担心被发现，这些钱实际中一个都不敢花，仍然过的是非常简朴的生活。最终据说由于在同一电脑上登录现实社会账户和非法网站上账户，从而被抓。\n\n\n# 如何提高匿名性\n\n> 从应用层看，可以将各个不同用户的 btc 混合在一起，使得追查变得混乱(coin mixing) 从网络层看，从节点上 ip 地址可以推算出真实身份，所以可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)。\n\n实际上正因为 btc 的公开性和不可篡改性，才导致隐私性会有一定的问题。\n\n\n# 零知识证明\n\n零知识证明是指一方（证明者）项另一方（验证者）证明一个陈述是正确的，而无需透露该陈述是正确的外的任何信息。\n\n> 例如证明某个比特币账户是我的（不能泄露私钥），那么就用私钥产生一个签名，大家用我的公钥来验证。但是因为告诉别人了公钥，所以有争议这种方式是不是零知识证明。\n\n\n# 同态隐藏\n\n\n\n> 例如：alice 想要向 bob 证明她知道一组数 x 和 y 使得 x + y = 7，同时不像让 bob，知道 x 和 y 的具体数值\n\n\n\n\n# 盲签方法\n\n在前面的课程中说到，央行会维护一个中心化的数据库来记录每一笔钱是否花出去，来防止双花，那么你的每一笔交易央行都会知道。那么有没有一种办法既然央行做中心化的记账，又不让它知道交易的信息呢。\n\n\n\n\n# 零币和零钞\n\n\n\n不常用的原因：\n\n 1. btc 的匿名性已经够用了，大家不愿意为了匿名性而去用一种新的币。\n 2. 零币和零钞运用了密码学和数学的知识来增强匿名性，实现和使用起来比较复杂。\n 3. 当与现实交互的时候零币和零钞也无法保证100%匿名。\n\n\n# btc 思考\n\n\n# 哈希指针\n\nbtc 系统中很多地方使用到了哈希指针。指针保存的本地内存地址，只有在本地计算机上才具有意义，如果发送给其他计算机就没有意义了。那么在区块发布时候，哈希指针如何通过网络进行传播？\n\n> 所谓哈希指针，只是系统中一种形象化的方法。实际应用时候，只有哈希而没有指针。回顾之前提过的block header数据结构，有一个字段前一个区块的哈希值。 因此可见，在 block header 中只有 hash 值，没有指针。那么如何查找到前一个区块的内容？ 全节点一般将区块存储于一个 key-value 数据库中，key 为哈希，value 为区块内容。常用的 key-value 数据库为 leveldb，只要掌握到最后一个区块的哈希值即可依据哈希值一直往前找到区块链所有内容。有些节点只保存区块链部分信息，如果需要用到前面的区块，可以问其他节点要。哈希指针性质保证了整个区块链内容是不可篡改的。\n\n\n# 区块『恋』\n\n有情侣一起买 btc，将私钥从中截断，每人保留其中一部分。如果未来两人依旧感情很好，就可以将钱取出；如果分手，这部分钱就会永久锁死，谁也无法取出，通过区块链的不可篡改性作为两人的爱情见证。这样做有什么问题？ 如此下来，n 个人怎么办？ 如果按照这种方法，将私钥分为 n 份。但这样会有一系列问题。\n\n 1. 如果n个人中任意一个人忘记私钥，则无法将钱取出。\n 2. 截断私钥长度，会降低安全性，因为私钥长度会直接影响破解难度(2^256远远大于2^128)，之间难度差距远远不止一倍。(可见，对于多个人账户，应该使用多重签名，而非截断私钥的方法。)\n 3. 如果分手，该钱变成死钱，一直保存在utxo集合中，对矿工不友好。\n\n\n# 分布式共识\n\n之前有提及，理论上来说，分布式系统不可能达成共识。但实际中为何变成可能了？严格来说，btc系统的共识随时可能被推翻，例如分叉攻击导致系统回滚。此外，理论和实际存在差异。不可能结论针对特定模型，实际中对模型稍微修改或添加线下方法即可将不可能变为可能。\n\n知识改变命运，这句话本身没有错，但是对知识的一知半解可能让你的命运变得更差，搞科研是很有意义的，但是不要给学术界的思维限制头脑，不要为程序员的思维限制想象力。\n\n\n# btc 稀缺性\n\n为什么要挖矿？因为有收益，且收益大于开销。早期 btc 难度低且出块奖励高，从而吸引矿工。 之前有提到，btc 总量固定，有人认为其是一个精妙的设计。但实际上，总量固定的东西并不适合作为货币，这也就决定了 btc 并不能在未来完全颠覆现有货币体系。以太坊中便没有 btc 中出块奖励定期减半的做法，此外，某些新型货币会自带通货膨胀的功能。 对个人来说，通货膨胀并非好事，因为钱不值钱了。但人类每年创造的价值，如果用总量固定的东西作为货币，则其只会越来越值钱，而这会导致拥有者不断看着其升值，其他没有的人无论如何奋斗都赶不上（房价也是如此，炒房使一部分人靠房租便可大赚特赚，个人奋斗却很难买房。这也是我国目前存在的较大的问题，社会财富的分配不公，最终引发各种社会矛盾）。\n\n\n# 量子计算\n\n会不会 btc 这种建立在密码学上的加密货币，在量子计算出来后会不会变得不安全。\n\n 1. 量子计算距离使用仍然有很长距离。\n 2. 量子计算若真正使用到破坏现有加密算法，对传统金融业的破坏才是最大的，网上银行网上转账都不安全了。\n 3. btc 实际中使用的并非公钥，而是用公钥哈希。而哈希函数一般都是不可逆的，就算量子计算可以从公钥推出私钥，但是即使知道了公钥哈希量子计算也无法反推公钥。加密和哈希不是一回事，加密过程要保证信息不丢失去，但是取哈希会丢失一些信息。btc 中用的 sha-256，无论输入多大，最终结果都为 256 位，必然会导致信息丢失，无法反推原本数据。如果能反推数据，那么这将成为前所未有的压缩算法（把整个图书馆的数据作为输入压缩为 256 位，再从 256 位反推出图书馆信息这是不可能的）。",charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 2",frontmatter:{},regularPath:"/blockchain/learn2.html",relativePath:"blockchain/learn2.md",key:"v-45ab779f",path:"/blockchain/learn2.html",headers:[{level:2,title:"BTC 系统实现",slug:"btc-系统实现",normalizedTitle:"btc 系统实现",charIndex:83},{level:3,title:"UTXO",slug:"utxo",normalizedTitle:"utxo",charIndex:404},{level:3,title:"交易费",slug:"交易费",normalizedTitle:"交易费",charIndex:711},{level:3,title:"区块举例",slug:"区块举例",normalizedTitle:"区块举例",charIndex:871},{level:3,title:"交易举例",slug:"交易举例",normalizedTitle:"交易举例",charIndex:1699},{level:3,title:"概率分析",slug:"概率分析",normalizedTitle:"概率分析",charIndex:1841},{level:3,title:"BTC 总量",slug:"btc-总量",normalizedTitle:"btc 总量",charIndex:2537},{level:3,title:"安全性分析",slug:"安全性分析",normalizedTitle:"安全性分析",charIndex:2650},{level:2,title:"BTC 网络工作原理",slug:"btc-网络工作原理",normalizedTitle:"btc 网络工作原理",charIndex:3080},{level:2,title:"挖矿难度",slug:"挖矿难度",normalizedTitle:"挖矿难度",charIndex:3997},{level:3,title:"BTC 如何调整挖矿难度",slug:"btc-如何调整挖矿难度",normalizedTitle:"btc 如何调整挖矿难度",charIndex:4775}],lastUpdated:"5/18/2023, 3:43:33 PM",lastUpdatedTimestamp:1684395813e3,headersStr:"BTC 系统实现 UTXO 交易费 区块举例 交易举例 概率分析 BTC 总量 安全性分析 BTC 网络工作原理 挖矿难度 BTC 如何调整挖矿难度",content:"# 北大肖臻老师《区块链技术与应用》公开课学习 2\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n\n\n# BTC 系统实现\n\n区块链是去中心化的账本，BTC采用的是基于交易的账本模式（transaction-based ledger），只记录了转账交易和铸币交易，并没有直接记录每个账户上有多少钱。如果想知道某个BTC账户上有多少钱，要通过交易记录来推算。\n\n除了BTC系统这样基于交易的账本模式（transaction-based ledger），还有一些系统是基于账户的模式（account-based ledger），比如后面要学的以太坊。在这种模式中系统要显式的记录每个账户中有多少个币。\n\nBTC系统的这种模式，隐私保护性比较好，但会带来一些代价，如转账交易要说明币的来源（币是从之前的哪个交易的哪个输出中来的）以防止双花攻击。\n\n\n# UTXO\n\nBTC 中的全结点要维护一个叫 UTXO（Unspent Transaction Output） 的数据结构，即还没有被花出去的交易的输出。一个交易可能有多个输出，被花掉的就不在 UTXO 里了。如果拥有不花就一直放在 UTXO 中\n\n\n\nUTXO 集合中的每个元素要给出产生这个输出的交易的哈希值，以及它在这个交易中是第几个输出。用这两个信息就可以定位到一个确定的交易中确定的输出。\n\n使用 UTXO 可以用来快速检测双花攻击，想知道新发布的交易是不是合法的，要查一下全结点存在内存中的 UTXO。要花掉的币只有在这个UTXO 这个集合里才是合法的，否则要么是不存在的，要么是已经花过了的。\n\n\n# 交易费\n\n有些交易的总输入可能略微大于总输出，如可能总输出是1个BTC，总输出是0.99个BTC，这之中的差额就作为记账费给了获得记账权的那个结点。\n\n> 这是因为仅有出块奖励是不够的，给予交易费可以给别人记账的动机。0.01BTC 的费用已经很高了，有些简单的交易是没有费用的。目前的激励机制主要还是出块奖励\n\n\n# 区块举例\n\n\n\n// block header 数据结构\nclass CBlockHeader {\n\tpublic:\n  \tint32_t nVersion; // BTC版本号，没法改\n    uint256 hashPrevBlock; // 前一个区块块头哈希值（32字节）不能改\n    uint256 hashMerkleRoot; // 通过修改Merkle Tree中铸币交易的CoinBase域来调整其根哈希值\n  \tuint32_t nTime; // 区块产生时间，有一定的调整余地，BTC系统并不要求非常精确的时间，这个域可以在一定范围内调整\n  \tuint32_t nBits; // 挖矿目标阈值编码后的版本，只能按照协议中的要求定期进行调整，不能改\n  \tunit32_t nNonce\n}\n\n\n区块中的 nonce 是4字节即32位整数，也就只 2^32 种取值。因为BTC近些年太火爆了，挖矿的人数很多，所以挖矿的难度被调整的很高，单纯靠调整 nonce 是很可能得不到符合难度要求的解的（搜索空间不够大）。\n\n\n\n铸币交易是没有交易来源的，所以可以在其 CoinBase 域里随便写入内容，铸币交易的变化会使该交易的哈希发生变化，变化沿着 Merkle Tree 一路向上传递，最终使整棵 Merkle Tree 的根哈希值发生变化，间接地调整块头的哈希值。所以可以把这个字段当做一个 extra nonce，块头的 nonce 字段不够用，就再拿着这个域的一部分字节一起调整，就增大了搜索空间。例如，拿出这个域的前 8 个字节当做extra nonce，则搜索空间一下子就增大到了 2^96\n\n\n\n实际挖矿时，一般也是为此设计了两层循环，外层循环调整铸币交易的 CoinBase 域的 extra nonce，然后算出 Merkle Tree 的根哈希值；内层循环调整块头的 nonce，计算整个块头的哈希值。\n\n\n# 交易举例\n\n\n\nBTC系统中交易的输入和输出都是用脚本来指定的，验证交易输入输出的过程就是把输入脚本和输出脚本配对执行（不是把同一个交易的输入输出脚本配对执行，而是把这个交易的输入脚本和提供币的来源的那个交易的输出脚本配对执行）。只要配对后都能成功执行，交易验证就是通过的。\n\n\n# 概率分析\n\n挖矿的过程就是不断尝试 nonce 去求解 puzzle，每次尝试可以看做一个伯努利试验 Bernoulli trial：a random experiment with binary outcome。掷硬币就是一个最简单的伯努利试验，要么正面朝上要么反面朝上，这两个概率不必一样大，对于挖矿而言，成功和失败的概率相差非常悬殊，成功的概率很小。\n\n当进行了大量的伯努利试验，这些伯努利试验就构成了伯努利过程 Bernoulli process：a sequence of independent Bernoulli trails。伯努利过程的一个性质是无记忆性（memoryless），即做大量的试验，前面的试验结果对后面没有影响，例如掷硬币很多次都是反面朝上，下一次掷硬币正面朝上的概率也不会增加。\n\n对于挖矿来说，可以采用泊松分布进行近似，由此通过概率论可以推断出，系统出块时间服从指数分布。(需要注意的是，出块时间指的是整个系统出块时间，并非挖矿的个人)\n\n\n\n出块时间服从的指数分布也是无记忆性的，也就是说从任何一个位置将其截断，剩下的部分仍然是服从指数分布的。将来还要挖多少时间 和 过去已经挖了多少时间 是没有关系的。不管已经挖了多长时间，接下来系统中要出块的平均时间仍然还是10分钟左右。\n\nprogress free ——过去做了多少工作不会让后续成功的概率变化。这个性质是必要的。假设一个加密货币系统不满足 progress free，即过去做的工作越多，后面成功的概率就越大，那么就会造成算力强的矿工会有不成比例的优势，而不能按照算力的比例计算优势。\n\n\n# BTC 总量\n\n出块奖励是系统中产生新的 BTC 的唯一途径，而出块奖励每隔 21万个 区块（大约每隔4年）要减半。\n\n> 21万 * 50 * (1 + 1/2 + 1/4 + 1/8 + ...) = 2100万\n\n\n# 安全性分析\n\n * 偷币: 假设一个有恶意的结点 M 获得了记账权，它想把结点 A 的钱转走，但因为没法伪造 A 的签名（没有A的私钥），这样的攻击是无效的。\n * 分叉攻击: M把BTC转给A，然后就紧接着挖矿挖到了一个区块，在这里填写了M把BTC转给自己的交易，以希望沿着这个区块成为最长合法链，这样就能将转给A的挤掉，从而将花出去的BTC回滚。这也是双花攻击的一种。如果大部分结点掌握在诚实结点手里，这样攻击的难度非常大，有恶意的结点要连续获得好多次记账权才可能改变最长合法链。所以一种最简单的防范方法就是多等几个区块，也叫多等几个确认（confirmation）。缺省的是要等 6个confirmation（大约一小时）\n * selfish mining: 提前挖到但不发布，继续挖下去，等到想要攻击的交易等了6次确认认为安全之后将整条链发布出去，试图回滚原来记录。这种情况，需要恶意节点掌握系统中半数以上算力才行，否则无法成为最长合法链。\n\n\n# BTC 网络工作原理\n\n用户将交易发布到比特币网络上，节点收到交易后打包到区块中，然后将区块发布到比特币网络上，那么新发布的交易和区块在比特币网络上是如何传播的呢？\n\n比特币工作于网络应用层，其底层（网络层）是一个 P2P Overlay network（P2P覆盖网络）。比特币系统中所有节点完全平等，不像一些其他网络存在超级节点(super node)。要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了 TCP协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。\n\n比特币网络设计原则：简单、鲁棒（最坏情况下能达到最优状况，即健壮性）而非高效。 每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。\n\n比特币系统中，每个节点要维护一个等待上链的交易集合。第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发（避免网络上交易无线传输）。假如网络中存在两个冲突交易，如交易1：A->B,交易2：A->C（假设花费的同一笔钱）。具体接收哪个取决于节点先接收到哪个交易，之后收到另一个交易会将其放弃。\n\n> 假如某个节点先听到 A->B，但又听到 A->C 已经上链，则此时 A->B 为非法交易，所以要再等待上链交易集合中删除 A->B\n\n新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块内容是否合法，还要检查是否位于最长合法链上。区块越大，则网络上传输越慢。BTC协议对于区块大小限制为不大于1M大小。\n\n> 区块大小越大，网络上传播时延越长；区块大小越小，则可以包含的交易数目越少。\n\n此外，比特币网络传播属于 Best effort（尽力而为），不能保证一定传输成功。以一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。\n\n\n# 挖矿难度\n\n挖矿本质上就是不断调整 block header 中的 nonce 值，使整个 block header 的哈希值小于等于给定的目标阈值。即：H(block header)<=target.（target便是目标阈值，target越小，目标难度就越大）对于挖矿难度的调整，可以视为调整目标空间在整个输出空间中所占比例大小。\n\n> 比特币系统采用的哈希算法为 SHA-256，所以整个输出空间大小为 2^256，调整目标空间所占比例，简单的说需要目标值前需要多少个0。\n\n 1. 如果不调整挖矿难度会怎么样？ 系统总算力越来越强，若挖矿难度保持不变，则出块时间会越来越短。\n 2. 出块时间越来越短是好事吗？ 出块时间缩短，那么交易可以很快便被写入区块链，并且提高了系统响应时间，增加了区块链系统效率。但是，出块时间并不是越短越好。出块时间太短，也会造成一定的问题。首先，区块在网络上传播具有时延，假如出块时间为1秒，但网络传播需要10秒，则会使得系统中节点经常性处于不一致的状态，增加了系统不稳定性，且系统经常性位于分叉状态（不仅二分叉，乃至多分叉）。分叉过多，则不利于系统达成共识，且会造成算力分散，使得黑客攻击成本大大降低(不再需要整个系统51%的算力)。\n 3. 10min的出块间隔是最优吗？ 当然不是，但可以确定的是，系统出块时间需要维持在一个定值附近。后续文章中会介绍以太坊，以太坊中平均出块时间仅为15秒左右，但同样在以太坊中也有相应难度调整算法维持其平均出块时间(后续会写文介绍)，当然15s的时间明显会产生经常性的分叉，所以以太坊设计了新的共识协议Ghost（后续文章中会介绍）。 当然，对于一个交易系统来说，10min这样一个交易时间是比较长的。但对于跨国交易来说，这个时间反而大大缩短了交易时间，减少了相应成本。\n\n\n# BTC 如何调整挖矿难度\n\n在BTC协议中规定，每隔2016个区块需要调整一次难度，因为平均 10min 产生一个新区块，大概需要14天的时间调整一次难度。具体调整公式如下：\n\n> target = target × (expectual time / actual time)\n\nexpected time 就是预期的两次调整的间隔时间，即 2016乘以10分钟；而 actual time 是系统中产生最近的2016个区块实际花费的时间。实际的时间越大，就越需要降低难度，即提高 target；实际的时间越小，就越需要提高难度，即降低 target。\n\n为了避免系统中出现某些意外情况，导致系统出现非常大的波动，每次对目标阈值 target 的调整最大不能超过 4 倍，最小不能小于 1/4。 恶意节点可不可以不调整 target？如果不调整 target，那么发布的区块块头里的4字节 nBits域（32字节的target压缩编码后的版本）就不是正确的，诚实的结点不会接收这样的区块。",normalizedContent:"# 北大肖臻老师《区块链技术与应用》公开课学习 2\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n\n\n# btc 系统实现\n\n区块链是去中心化的账本，btc采用的是基于交易的账本模式（transaction-based ledger），只记录了转账交易和铸币交易，并没有直接记录每个账户上有多少钱。如果想知道某个btc账户上有多少钱，要通过交易记录来推算。\n\n除了btc系统这样基于交易的账本模式（transaction-based ledger），还有一些系统是基于账户的模式（account-based ledger），比如后面要学的以太坊。在这种模式中系统要显式的记录每个账户中有多少个币。\n\nbtc系统的这种模式，隐私保护性比较好，但会带来一些代价，如转账交易要说明币的来源（币是从之前的哪个交易的哪个输出中来的）以防止双花攻击。\n\n\n# utxo\n\nbtc 中的全结点要维护一个叫 utxo（unspent transaction output） 的数据结构，即还没有被花出去的交易的输出。一个交易可能有多个输出，被花掉的就不在 utxo 里了。如果拥有不花就一直放在 utxo 中\n\n\n\nutxo 集合中的每个元素要给出产生这个输出的交易的哈希值，以及它在这个交易中是第几个输出。用这两个信息就可以定位到一个确定的交易中确定的输出。\n\n使用 utxo 可以用来快速检测双花攻击，想知道新发布的交易是不是合法的，要查一下全结点存在内存中的 utxo。要花掉的币只有在这个utxo 这个集合里才是合法的，否则要么是不存在的，要么是已经花过了的。\n\n\n# 交易费\n\n有些交易的总输入可能略微大于总输出，如可能总输出是1个btc，总输出是0.99个btc，这之中的差额就作为记账费给了获得记账权的那个结点。\n\n> 这是因为仅有出块奖励是不够的，给予交易费可以给别人记账的动机。0.01btc 的费用已经很高了，有些简单的交易是没有费用的。目前的激励机制主要还是出块奖励\n\n\n# 区块举例\n\n\n\n// block header 数据结构\nclass cblockheader {\n\tpublic:\n  \tint32_t nversion; // btc版本号，没法改\n    uint256 hashprevblock; // 前一个区块块头哈希值（32字节）不能改\n    uint256 hashmerkleroot; // 通过修改merkle tree中铸币交易的coinbase域来调整其根哈希值\n  \tuint32_t ntime; // 区块产生时间，有一定的调整余地，btc系统并不要求非常精确的时间，这个域可以在一定范围内调整\n  \tuint32_t nbits; // 挖矿目标阈值编码后的版本，只能按照协议中的要求定期进行调整，不能改\n  \tunit32_t nnonce\n}\n\n\n区块中的 nonce 是4字节即32位整数，也就只 2^32 种取值。因为btc近些年太火爆了，挖矿的人数很多，所以挖矿的难度被调整的很高，单纯靠调整 nonce 是很可能得不到符合难度要求的解的（搜索空间不够大）。\n\n\n\n铸币交易是没有交易来源的，所以可以在其 coinbase 域里随便写入内容，铸币交易的变化会使该交易的哈希发生变化，变化沿着 merkle tree 一路向上传递，最终使整棵 merkle tree 的根哈希值发生变化，间接地调整块头的哈希值。所以可以把这个字段当做一个 extra nonce，块头的 nonce 字段不够用，就再拿着这个域的一部分字节一起调整，就增大了搜索空间。例如，拿出这个域的前 8 个字节当做extra nonce，则搜索空间一下子就增大到了 2^96\n\n\n\n实际挖矿时，一般也是为此设计了两层循环，外层循环调整铸币交易的 coinbase 域的 extra nonce，然后算出 merkle tree 的根哈希值；内层循环调整块头的 nonce，计算整个块头的哈希值。\n\n\n# 交易举例\n\n\n\nbtc系统中交易的输入和输出都是用脚本来指定的，验证交易输入输出的过程就是把输入脚本和输出脚本配对执行（不是把同一个交易的输入输出脚本配对执行，而是把这个交易的输入脚本和提供币的来源的那个交易的输出脚本配对执行）。只要配对后都能成功执行，交易验证就是通过的。\n\n\n# 概率分析\n\n挖矿的过程就是不断尝试 nonce 去求解 puzzle，每次尝试可以看做一个伯努利试验 bernoulli trial：a random experiment with binary outcome。掷硬币就是一个最简单的伯努利试验，要么正面朝上要么反面朝上，这两个概率不必一样大，对于挖矿而言，成功和失败的概率相差非常悬殊，成功的概率很小。\n\n当进行了大量的伯努利试验，这些伯努利试验就构成了伯努利过程 bernoulli process：a sequence of independent bernoulli trails。伯努利过程的一个性质是无记忆性（memoryless），即做大量的试验，前面的试验结果对后面没有影响，例如掷硬币很多次都是反面朝上，下一次掷硬币正面朝上的概率也不会增加。\n\n对于挖矿来说，可以采用泊松分布进行近似，由此通过概率论可以推断出，系统出块时间服从指数分布。(需要注意的是，出块时间指的是整个系统出块时间，并非挖矿的个人)\n\n\n\n出块时间服从的指数分布也是无记忆性的，也就是说从任何一个位置将其截断，剩下的部分仍然是服从指数分布的。将来还要挖多少时间 和 过去已经挖了多少时间 是没有关系的。不管已经挖了多长时间，接下来系统中要出块的平均时间仍然还是10分钟左右。\n\nprogress free ——过去做了多少工作不会让后续成功的概率变化。这个性质是必要的。假设一个加密货币系统不满足 progress free，即过去做的工作越多，后面成功的概率就越大，那么就会造成算力强的矿工会有不成比例的优势，而不能按照算力的比例计算优势。\n\n\n# btc 总量\n\n出块奖励是系统中产生新的 btc 的唯一途径，而出块奖励每隔 21万个 区块（大约每隔4年）要减半。\n\n> 21万 * 50 * (1 + 1/2 + 1/4 + 1/8 + ...) = 2100万\n\n\n# 安全性分析\n\n * 偷币: 假设一个有恶意的结点 m 获得了记账权，它想把结点 a 的钱转走，但因为没法伪造 a 的签名（没有a的私钥），这样的攻击是无效的。\n * 分叉攻击: m把btc转给a，然后就紧接着挖矿挖到了一个区块，在这里填写了m把btc转给自己的交易，以希望沿着这个区块成为最长合法链，这样就能将转给a的挤掉，从而将花出去的btc回滚。这也是双花攻击的一种。如果大部分结点掌握在诚实结点手里，这样攻击的难度非常大，有恶意的结点要连续获得好多次记账权才可能改变最长合法链。所以一种最简单的防范方法就是多等几个区块，也叫多等几个确认（confirmation）。缺省的是要等 6个confirmation（大约一小时）\n * selfish mining: 提前挖到但不发布，继续挖下去，等到想要攻击的交易等了6次确认认为安全之后将整条链发布出去，试图回滚原来记录。这种情况，需要恶意节点掌握系统中半数以上算力才行，否则无法成为最长合法链。\n\n\n# btc 网络工作原理\n\n用户将交易发布到比特币网络上，节点收到交易后打包到区块中，然后将区块发布到比特币网络上，那么新发布的交易和区块在比特币网络上是如何传播的呢？\n\n比特币工作于网络应用层，其底层（网络层）是一个 p2p overlay network（p2p覆盖网络）。比特币系统中所有节点完全平等，不像一些其他网络存在超级节点(super node)。要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了 tcp协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。\n\n比特币网络设计原则：简单、鲁棒（最坏情况下能达到最优状况，即健壮性）而非高效。 每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。\n\n比特币系统中，每个节点要维护一个等待上链的交易集合。第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发（避免网络上交易无线传输）。假如网络中存在两个冲突交易，如交易1：a->b,交易2：a->c（假设花费的同一笔钱）。具体接收哪个取决于节点先接收到哪个交易，之后收到另一个交易会将其放弃。\n\n> 假如某个节点先听到 a->b，但又听到 a->c 已经上链，则此时 a->b 为非法交易，所以要再等待上链交易集合中删除 a->b\n\n新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块内容是否合法，还要检查是否位于最长合法链上。区块越大，则网络上传输越慢。btc协议对于区块大小限制为不大于1m大小。\n\n> 区块大小越大，网络上传播时延越长；区块大小越小，则可以包含的交易数目越少。\n\n此外，比特币网络传播属于 best effort（尽力而为），不能保证一定传输成功。以一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。\n\n\n# 挖矿难度\n\n挖矿本质上就是不断调整 block header 中的 nonce 值，使整个 block header 的哈希值小于等于给定的目标阈值。即：h(block header)<=target.（target便是目标阈值，target越小，目标难度就越大）对于挖矿难度的调整，可以视为调整目标空间在整个输出空间中所占比例大小。\n\n> 比特币系统采用的哈希算法为 sha-256，所以整个输出空间大小为 2^256，调整目标空间所占比例，简单的说需要目标值前需要多少个0。\n\n 1. 如果不调整挖矿难度会怎么样？ 系统总算力越来越强，若挖矿难度保持不变，则出块时间会越来越短。\n 2. 出块时间越来越短是好事吗？ 出块时间缩短，那么交易可以很快便被写入区块链，并且提高了系统响应时间，增加了区块链系统效率。但是，出块时间并不是越短越好。出块时间太短，也会造成一定的问题。首先，区块在网络上传播具有时延，假如出块时间为1秒，但网络传播需要10秒，则会使得系统中节点经常性处于不一致的状态，增加了系统不稳定性，且系统经常性位于分叉状态（不仅二分叉，乃至多分叉）。分叉过多，则不利于系统达成共识，且会造成算力分散，使得黑客攻击成本大大降低(不再需要整个系统51%的算力)。\n 3. 10min的出块间隔是最优吗？ 当然不是，但可以确定的是，系统出块时间需要维持在一个定值附近。后续文章中会介绍以太坊，以太坊中平均出块时间仅为15秒左右，但同样在以太坊中也有相应难度调整算法维持其平均出块时间(后续会写文介绍)，当然15s的时间明显会产生经常性的分叉，所以以太坊设计了新的共识协议ghost（后续文章中会介绍）。 当然，对于一个交易系统来说，10min这样一个交易时间是比较长的。但对于跨国交易来说，这个时间反而大大缩短了交易时间，减少了相应成本。\n\n\n# btc 如何调整挖矿难度\n\n在btc协议中规定，每隔2016个区块需要调整一次难度，因为平均 10min 产生一个新区块，大概需要14天的时间调整一次难度。具体调整公式如下：\n\n> target = target × (expectual time / actual time)\n\nexpected time 就是预期的两次调整的间隔时间，即 2016乘以10分钟；而 actual time 是系统中产生最近的2016个区块实际花费的时间。实际的时间越大，就越需要降低难度，即提高 target；实际的时间越小，就越需要提高难度，即降低 target。\n\n为了避免系统中出现某些意外情况，导致系统出现非常大的波动，每次对目标阈值 target 的调整最大不能超过 4 倍，最小不能小于 1/4。 恶意节点可不可以不调整 target？如果不调整 target，那么发布的区块块头里的4字节 nbits域（32字节的target压缩编码后的版本）就不是正确的，诚实的结点不会接收这样的区块。",charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 5",frontmatter:{},regularPath:"/blockchain/learn5.html",relativePath:"blockchain/learn5.md",key:"v-12859882",path:"/blockchain/learn5.html",headers:[{level:2,title:"ETH 概述",slug:"eth-概述",normalizedTitle:"eth 概述",charIndex:125},{level:3,title:"为什么智能合约",slug:"为什么智能合约",normalizedTitle:"为什么智能合约",charIndex:452},{level:2,title:"ETH 账户",slug:"eth-账户",normalizedTitle:"eth 账户",charIndex:929},{level:3,title:"为什么以太坊要基于账户的模型",slug:"为什么以太坊要基于账户的模型",normalizedTitle:"为什么以太坊要基于账户的模型",charIndex:1784},{level:2,title:"ETH 状态树",slug:"eth-状态树",normalizedTitle:"eth 状态树",charIndex:1885},{level:3,title:"MPT",slug:"mpt",normalizedTitle:"mpt",charIndex:2937},{level:2,title:"ETH 交易树和收据树",slug:"eth-交易树和收据树",normalizedTitle:"eth 交易树和收据树",charIndex:4829},{level:3,title:"布隆过滤器(Bloom filter)",slug:"布隆过滤器-bloom-filter",normalizedTitle:"布隆过滤器(bloom filter)",charIndex:5097},{level:3,title:"补充",slug:"补充",normalizedTitle:"补充",charIndex:5745},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:6118}],lastUpdated:"6/2/2023, 3:07:42 PM",lastUpdatedTimestamp:1685689662e3,headersStr:"ETH 概述 为什么智能合约 ETH 账户 为什么以太坊要基于账户的模型 ETH 状态树 MPT ETH 交易树和收据树 布隆过滤器(Bloom filter) 补充 代码实现",content:'# 北大肖臻老师《区块链技术与应用》公开课学习 5\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n * 参考文章：北京大学肖臻老师《区块链技术与应用》公开课笔记15——ETH概述篇\n\n\n# ETH 概述\n\nBTC 和 ETH 为最主要的两种加密货币，BTC 称为区块链 1.0，以太坊称为区块链 2.0。因为了比特币设计中存在某些不足，以太坊便对其进行了改进。例如：\n\n * 出块时间: 以太坊出块时间降低到十几秒，以及设计了一套共识协议\n * mining puzzle: BTC 挖矿属于计算密集型，挖矿设备专业化（ASIC），以太坊设计的 mining puzzle 对内存要求高，限制了 ASIC 的使用（ASIC resistance）\n * 未来，以太坊还将会用权益证明(proof of stake)替代工作量证明(proof of work)\n * 此外，以太坊增加了对智能合约（smart contract）的支持。\n\n\n# 为什么智能合约\n\nBTC 本身是一个去中心化的货币，在比特币取得成功之后，很多人就开始思考：除了货币可以去中心化，还有什么可以去中心化？以太坊的一个特性就是增加了对去中心化的合约的支持。\n\n * BitCoin: decenralized currency, BTC, 最小单位一聪\n * Ethereum: decenralized contract, ETH, 最小单位一wei\n\n货币本身由政府发行，政府公信力为其背书，BTC 通过技术手段取代了政府的职能。 现实生活中，我们经常提到 契约 或 合约。合约的有效性也是需要政府进行维护的，如果产生纠纷需要针对合法性合同进行判决（打官司）。ETH 的设计目的就是，通过技术手段来实现取代政府对于合约的职能（区块链的不可篡改性）。并不是所有的合同都可以实现，比较简单的可以使用智能合约。\n\n智能合约有什么好处？\n\n> 去中心化的货币的好处是跨国转账，比法币快很多。 智能合约: 若合同签署方并非一个国家，没有统一的司法部门。如果可以编写无法修改的合约，所有人只能按照相关参与方执行，无法违约。\n\n\n# ETH 账户\n\nBTC 系统是基于交易的账本，系统中并未显示记录账户有多少钱，只能通过 UTXO 进行推算。这种隐私保护比较好，但是使用起来比较别扭。比如 A 转给 B 比特币的时候，A 需要说明币的来源。但是我们实际中存钱说明来源，花钱则不用。此外，BTC 账户中的钱在花的时候，必须一次性全部花出去。\n\n> A => B(10BTC) B => C(3BTC) 如果 B 只转给 C 3个 BTC，那么剩下的 7个 BTC 将作为交易费给矿工，所以还要将剩下的钱转给自己：B => B\'(7 BTC) 比特币系统中没有显式的基于账户的模型 而以太坊系统则采用了基于账户的模型，与现实中银行账户相似。\n\n优点：转账是否合法只需要查看转账者账户中以太币是否足够即可，同时也不需要每次全部转账，这也天然地防范了双花攻击。（你要是花两次我就从你账户扣两次钱） 缺点：重放攻击：A 向 B 转账，过一段时间，B 将 A 的交易重新发布，从而导致 A账户被扣钱两次。\n\n> 为了防范重放攻击，给账户交易添加计数器记录该账户交易过多少次，转账时候将转账次数计入交易的内容中。 系统中全节点维护账户余额和该计数器的交易数，从而防止本地篡改余额或进行重放攻击。 交易内容：A => B(10ETH)、nonce = 21(这是第21次交易)、Signed by A 如果重放上述交易内容，会发现 nonce = 21 的交易已经被发布了，就不会执行了。\n\n以太坊系统中存在两类账户：外部账户和合约账户。\n\n * 外部账户：类似于 BTC 系统中公私钥对。存在账户余额 balance 和计数器 nonce\n * 合约账户：并非通过公私钥对控制。合约账户不能主动发起交易，只能接收到外部账户调用后才能发起交易或调用其他合约账户。其除了balance 和 nonce 之外还有 code (代码)、storage (相关状态-存储)\n\n创建合约时候会返回一个地址，就可以对其调用。调用过程中，代码不变但状态会发生改变。\n\n\n# 为什么以太坊要基于账户的模型\n\n比特币隐私保护比较好，支持每次交易都更换账户。但以太坊是为了支持智能合约，而合约签订双方是比较稳定的身份且较少变化的。尤其是对于合约账户来说，需要保持稳定状态。\n\n\n# ETH 状态树\n\n首先，我们要实现从账户地址到账户状态的映射。在以太坊中，账户地址为 160字节 ，表示为 40个16进制。状态包含了余额(balance)、交易次数(nonce)，合约账户中还包含了代码(code)、存储(stroge)。\n\n直观地来看，其本质上为 key-value 键值对，所以直观想法便用哈希表实现。若不考虑哈希碰撞，查询直接为常数级别的查询效率。但采用哈希表，难以提供 Merkle proof\n\n 1. 我们能否像 BTC，将哈希表的内容组织为 Merkle Tree ？\n\n> 当新区块发布，哈希表内容会改变，再次将其组织为新的 Merkle Tree。如果这样，每当产生新区块(ETH 中新区块产生时间为10s左右)，都要重新组织 Merkle Tree，很明显这是不现实的。 需要注意的是，比特币系统中没有账户概念，交易由区块管理，而区块包含上限为 4000 个交易左右，所以 Merkle Tree 不是无限增大的。而 ETH 中，Merkle Tree 来组织账户信息，很明显其会越来越庞大。 实际中，发生变化的仅仅为很少一部分数据，我们每次重新构建 Merkle Tree 代价很大\n\n 2. 那我们不要哈希表了，直接使用 Merkle Tree 把所有的账户都放进去，每次修改只需要修改其中一部分即可，这个可以吗？\n\n> 实际中，Merkle Tree 并未提供一个高效的查找和更新的方案。此外，将所有账户构建为一个大的 Merkle Tree，为了保证所有节点的一致性和查找速度，必须进行排序。\n\n 3. 不排序有什么问题?\n\n> Merkle Tree 的叶子节点是账户信息，如果不排序，系统中有很多全节点会按照自己的排序方式进行构造账户信息，导致 Merkle Tree 均不相同，根哈希值也不同。\n\n 4. 比特币的 Merkle Tree 不也没排序吗？\n\n> 比特币每个全节点收到的交易顺序也是不一致的，Merkle Tree 根哈希值也不一样。但是比特币是每个节点在本地组装一个候选区块，它自己决定收集哪些交易，然后去挖矿争夺记账权，只有挖到矿的人才能决定发布区块，这个顺序是唯一的。\n\n 5. 那么经过排序，使用 Sorted Merkle Tree 可以吗？\n\n> 新增账户，由于其地址随机，插入 Merkle Tree 时候很大可能在 Tree 中间，必须进行重构。所以 Sorted Merkle Tree 插入、删除的代价太大。\n\n\n# MPT\n\n以太坊采取的数据结构：MPT，首先介绍一下 trie 前缀树（字典树）\n\n 1. trie 中每个节点的分支数目取决于每个元素的取值范围(图例中最多26个英文字母分叉+ 1个结束标志位)。以太坊中是16进制表示（0 ~ f）加上一个结束标识符为 17 个分叉。\n 2. trie 查找效率取决于 key 的长度。实际应用中（以太坊地址长度为160字节）。\n 3. trie 上面不会发生哈希碰撞，两个账户的地址不一样，映射到 trie 一定是不同的分支。\n 4. 给定输入，无论如何顺序插入，构造的 trie 都是一样的。\n 5. 更新的局部性比较好：每次发布一个区块，系统中绝大多数账户的状态是不变的，只有个别才会变，所以更新操作的局部性很重要。trie 上只需要遍历某一个分支，并不需要遍历整棵树。\n 6. 缺点：存储上会有浪费，很多节点只有一个子节点。因此引入了 Patricia tree/trie（经过路径压缩后的前缀树）。\n\n\n\n需要注意的是，如果新插入单词，原本压缩的路径可能需要扩展开来。什么情况下路径压缩效果较好？树中插入的键值分布较为稀疏的情况下，路径压缩效果较好。看以下例子：\n\n\n\n\n\n在以太坊系统中，160 位的地址存在 2^160 种，以太坊全世界的账户数加一起也远不足这个数，为什么地址搞的这么稀疏呢？\n\n> 就是因为地址分布稀疏，所以路径压缩效果较好。 以太坊创建账户在本地创建即可，类似于比特币，那么会不会两个创建的账户地址一样呢？有可能，但是比地球爆炸的可能性还要低，就是因为地址足够长，足够稀疏。 实际上，在以太坊种使用的并非简单的 Patricia tree，而是 MPT(Merkle Patricia tree)\n\nMPT 就是将所有账户组织为一个经过路径压缩和排序的 Merkle Tree (指针为哈希指针)，其根哈希值存储于 block header 中。根哈希值的用处：\n\n 1. 防止篡改。\n 2. 提供 Merkle proof ，可以证明账户余额，轻节点可以进行验证。\n 3. 给一个账户转账之前，证明某个发生了交易的账户是否存在。\n\n以太坊中针对 MPT 进行了修改，我们称其为 Modified MPT。\n\n\n\n * shared nibble(s)：十六进制\n * extension node：扩展节点，经过路径压缩的节点\n * leaf node：叶子节点\n * branch node：分支节点\n\n每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。如下图中，仅仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。\n\n\n\n所以，系统中全节点并非维护一棵MPT，而是每次发布新区块都要新建MPT。只不过大部分节点共享。\n\n> 为什么要保存原本状态？为何不直接修改？ 为了便于回滚。如产生分叉后上面节点胜出，那么下面节点中状态的修改便需要进行回滚。因此，需要维护这些历史记录。\n\nblock header 中的数据结构\n\n\n\n * Parenthash: 父区块的哈希（前一个区块的哈希）\n * Unclehash: 叔父区块的哈希\n * Coinbase: 矿工地址\n * Root: 状态树的根哈希值\n * Txhash: 交易树的根哈希值\n * Receipthash: 收据树的根哈希值\n * Bloom: 整个区块块头的 Bloom filter\n * Difficulty: 挖矿难度\n * GasLimit: 汽油费（类似于比特币中的交易费）相关\n * GasUsed: 汽油费（类似于比特币中的交易费）相关\n * Time: 区块产生时间\n * Mixdigest: 挖矿过程随机数算出来的哈希值\n * Nonce: 挖矿时随机数\n\n区块结构\n\n\n\n * header: 指向 block header 的指针\n * uncles: 指向叔父区块的指针\n * transactions: 交易列表\n\n区块在网上真正发布时的信息\n\ntype extblock struct {\n    Header *Header\n    Txs    []*Transactions\n    uncles []*Header\n}\n\n\n> 状态树中保存 Key-value 对，key 就是地址，而 value 状态通过 RLP(Recursive Length Prefix，一种进行序列化的方法) 编码序列号之后再进行存储。\n\n\n# ETH 交易树和收据树\n\n每次发布一个区块时，区块中的交易会形成一颗 Merkle Tree，即交易树。此外以太坊还添加了一个收据树，每个交易执行完之后形成一个收据，记录交易相关信息。交易树和收据树上的节点是一一对应的，且都是 MPT。MPT 的好处是支持查找操作，通过键值沿着树进行查找即可。\n\n * 对于状态树，查找键值为账户地址。\n * 对于交易树和收据树，查找键值为交易在发布的区块中的序号。\n\n收据树作用：在以太坊中最重要的功能是加入了智能合约，而智能合约的执行过程比较复杂，收据树的作用是利于系统快速查询执行结果。\n\n\n# 布隆过滤器(Bloom filter)\n\n作用：布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n\n> 给定一个数据集，其中含义元素 a、b、c，通过一个哈希函数 H() 对其进行计算，将其映射到一个其初始全为 0 的 128 位的向量的某个位置，将该位置置为 1。将所有元素处理完，就可以得到一个向量，则称该向量为原集合的 摘要。该 摘要 比原集合是要小很多的。 假定想要查询一个元素 d 是否在集合中，假设 H(d) 映射到向量中的位置处为 0，说明 d一定不在集合中；假设 H(d)映射到向量中的位置处为 1，可能集合中确实有 d，也有可能因为哈希碰撞产生误报。 个人理解就是：他会告诉你某样东西一定不存在或者可能存在。\n\n# Bloom filter 在以太坊中的应用\n\n每个交易完成后会产生一个收据，收据包含一个 Bloom filter 记录交易类型、地址等信息。在区块 block header 中也包含一个Bloom filter，其为该区块中所有交易的 Bloom filter 的一个并集。 所以，查找时候先查找块头中的 Bloom filter，如果块头中包含。再查看区块中包含的交易的 Bloom filter，如果存在，再查看交易进行确认；如果不存在，则说明发生了 碰撞。 好处就是通过 Bloom filter 这样一个结构，快速大量过滤掉大量无关区块，从而提高了查找效率。\n\n\n# 补充\n\n以太坊对于给定的当前状态和给定一组交易可以确定性的转移到下一状态，这一运行过程可以视为交易驱动的状态机，通过执行当前区块中包含的交易，驱动系统从当前状态转移到下一状态。当然，BTC 我们也可以视为交易驱动的状态机，其状态为 UTXO。\n\n问题1：A转账到B，有没有可能收款账户不包含再状态树中？\n\n> 可能。因为以太坊中账户可以节点自己产生，只有在产生交易时才会被系统知道。 问题2：可否将每个区块中状态树更改为只包含和区块中交易相关的账户状态？(大幅削减状态树大小，且和交易树、收据树保持一致) 不能。首先，这样设计要查找账户状态很不方便，因为不存在某个区块包含所有状态。其次，如果要向一个新创建账户转账，因为需要知道收款账户的状态，才能给其添加金额，但由于其是新创建的账户，所有需要一直找到创世纪块才能知道该账户为新建账户。\n\n\n# 代码实现\n\nfunc NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt, hasher TrieHasher) *Block {\n\tb := &Block{header: CopyHeader(header)}\n\n\t// 交易列表是否为空\n\tif len(txs) == 0 {\n        // 块头里的交易树的根哈希值为空哈希值\n\t\tb.header.TxHash = EmptyTxsHash\n\t} else {\n        // 调用 DeriveSha 获得根哈希值\n\t\tb.header.TxHash = DeriveSha(Transactions(txs), hasher)\n        // 创建交易列表\n\t\tb.transactions = make(Transactions, len(txs))\n\t\tcopy(b.transactions, txs)\n\t}\n\n    // 收据列表是否为空\n\tif len(receipts) == 0 {\n        // 块头里的收据树的根哈希值为空哈希值\n\t\tb.header.ReceiptHash = EmptyReceiptsHash\n\t} else {\n        // 调用 DeriveSha 获得根哈希值\n\t\tb.header.ReceiptHash = DeriveSha(Receipts(receipts), hasher)\n        // 创建 Bloom Filter\n        // CreateBloom 函数用来创建 Block Header 中的 Bloom 域,\n        // 这个 Bloom Filter 由这个块中所有 receiptes 的 Bloom Filter 组合得到\n\t\tb.header.Bloom = CreateBloom(receipts)\n\t}\n\n    // 叔父列表是否为空\n\tif len(uncles) == 0 {\n        // 块头里的叔父区块的哈希值为空哈希值\n\t\tb.header.UncleHash = EmptyUncleHash\n\t} else {\n        // 通过 CalcUncleHash 计算出哈希值\n\t\tb.header.UncleHash = CalcUncleHash(uncles)\n        // 通过循环构造出叔父数组\n\t\tb.uncles = make([]*Header, len(uncles))\n\t\tfor i := range uncles {\n\t\t\tb.uncles[i] = CopyHeader(uncles[i])\n\t\t}\n\t}\n\n\treturn b\n}\n\n// DeriveSha 函数\nfunc DeriveSha(list DerivableList) common.Hash {\n\tkeybuf := new(bytes.Buffer)\n\ttrie := new(trie.Trie)\n\tfor i := 0; i < list.Len(); i++ {\n\t\tkeybuf.Reset()\n\t\trlp.Encode(keybuf, uint(i))\n\t\ttrie.Update(keybuf.Bytes(), list.GetRlp(i))\n\t}\n\treturn trie.Hash()\n}\n\n// 收据数据结构\ntype Receipt struct {\n\tPostState         []byte `json:"root"`\n\tStatus            uint64 `json:"status"`\n\tCumulativeGasUsed uint64 `json:"cumulativeGasUsed" gencodec:"required"`\n\tBloom             Bloom  `json:"logsBloom"         gencodec:"required"`\n\tLogs              []*Log `json:"logs"              gencodec:"required"`\n\n\tTxHash          common.Hash    `json:"transactionHash" gencodec:"required"`\n\tContractAddress common.Address `json:"contractAddress"`\n\tGasUsed         uint64         `json:"gasUsed" gencodec:"required"`\n}\n',normalizedContent:'# 北大肖臻老师《区块链技术与应用》公开课学习 5\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n * 参考文章：北京大学肖臻老师《区块链技术与应用》公开课笔记15——eth概述篇\n\n\n# eth 概述\n\nbtc 和 eth 为最主要的两种加密货币，btc 称为区块链 1.0，以太坊称为区块链 2.0。因为了比特币设计中存在某些不足，以太坊便对其进行了改进。例如：\n\n * 出块时间: 以太坊出块时间降低到十几秒，以及设计了一套共识协议\n * mining puzzle: btc 挖矿属于计算密集型，挖矿设备专业化（asic），以太坊设计的 mining puzzle 对内存要求高，限制了 asic 的使用（asic resistance）\n * 未来，以太坊还将会用权益证明(proof of stake)替代工作量证明(proof of work)\n * 此外，以太坊增加了对智能合约（smart contract）的支持。\n\n\n# 为什么智能合约\n\nbtc 本身是一个去中心化的货币，在比特币取得成功之后，很多人就开始思考：除了货币可以去中心化，还有什么可以去中心化？以太坊的一个特性就是增加了对去中心化的合约的支持。\n\n * bitcoin: decenralized currency, btc, 最小单位一聪\n * ethereum: decenralized contract, eth, 最小单位一wei\n\n货币本身由政府发行，政府公信力为其背书，btc 通过技术手段取代了政府的职能。 现实生活中，我们经常提到 契约 或 合约。合约的有效性也是需要政府进行维护的，如果产生纠纷需要针对合法性合同进行判决（打官司）。eth 的设计目的就是，通过技术手段来实现取代政府对于合约的职能（区块链的不可篡改性）。并不是所有的合同都可以实现，比较简单的可以使用智能合约。\n\n智能合约有什么好处？\n\n> 去中心化的货币的好处是跨国转账，比法币快很多。 智能合约: 若合同签署方并非一个国家，没有统一的司法部门。如果可以编写无法修改的合约，所有人只能按照相关参与方执行，无法违约。\n\n\n# eth 账户\n\nbtc 系统是基于交易的账本，系统中并未显示记录账户有多少钱，只能通过 utxo 进行推算。这种隐私保护比较好，但是使用起来比较别扭。比如 a 转给 b 比特币的时候，a 需要说明币的来源。但是我们实际中存钱说明来源，花钱则不用。此外，btc 账户中的钱在花的时候，必须一次性全部花出去。\n\n> a => b(10btc) b => c(3btc) 如果 b 只转给 c 3个 btc，那么剩下的 7个 btc 将作为交易费给矿工，所以还要将剩下的钱转给自己：b => b\'(7 btc) 比特币系统中没有显式的基于账户的模型 而以太坊系统则采用了基于账户的模型，与现实中银行账户相似。\n\n优点：转账是否合法只需要查看转账者账户中以太币是否足够即可，同时也不需要每次全部转账，这也天然地防范了双花攻击。（你要是花两次我就从你账户扣两次钱） 缺点：重放攻击：a 向 b 转账，过一段时间，b 将 a 的交易重新发布，从而导致 a账户被扣钱两次。\n\n> 为了防范重放攻击，给账户交易添加计数器记录该账户交易过多少次，转账时候将转账次数计入交易的内容中。 系统中全节点维护账户余额和该计数器的交易数，从而防止本地篡改余额或进行重放攻击。 交易内容：a => b(10eth)、nonce = 21(这是第21次交易)、signed by a 如果重放上述交易内容，会发现 nonce = 21 的交易已经被发布了，就不会执行了。\n\n以太坊系统中存在两类账户：外部账户和合约账户。\n\n * 外部账户：类似于 btc 系统中公私钥对。存在账户余额 balance 和计数器 nonce\n * 合约账户：并非通过公私钥对控制。合约账户不能主动发起交易，只能接收到外部账户调用后才能发起交易或调用其他合约账户。其除了balance 和 nonce 之外还有 code (代码)、storage (相关状态-存储)\n\n创建合约时候会返回一个地址，就可以对其调用。调用过程中，代码不变但状态会发生改变。\n\n\n# 为什么以太坊要基于账户的模型\n\n比特币隐私保护比较好，支持每次交易都更换账户。但以太坊是为了支持智能合约，而合约签订双方是比较稳定的身份且较少变化的。尤其是对于合约账户来说，需要保持稳定状态。\n\n\n# eth 状态树\n\n首先，我们要实现从账户地址到账户状态的映射。在以太坊中，账户地址为 160字节 ，表示为 40个16进制。状态包含了余额(balance)、交易次数(nonce)，合约账户中还包含了代码(code)、存储(stroge)。\n\n直观地来看，其本质上为 key-value 键值对，所以直观想法便用哈希表实现。若不考虑哈希碰撞，查询直接为常数级别的查询效率。但采用哈希表，难以提供 merkle proof\n\n 1. 我们能否像 btc，将哈希表的内容组织为 merkle tree ？\n\n> 当新区块发布，哈希表内容会改变，再次将其组织为新的 merkle tree。如果这样，每当产生新区块(eth 中新区块产生时间为10s左右)，都要重新组织 merkle tree，很明显这是不现实的。 需要注意的是，比特币系统中没有账户概念，交易由区块管理，而区块包含上限为 4000 个交易左右，所以 merkle tree 不是无限增大的。而 eth 中，merkle tree 来组织账户信息，很明显其会越来越庞大。 实际中，发生变化的仅仅为很少一部分数据，我们每次重新构建 merkle tree 代价很大\n\n 2. 那我们不要哈希表了，直接使用 merkle tree 把所有的账户都放进去，每次修改只需要修改其中一部分即可，这个可以吗？\n\n> 实际中，merkle tree 并未提供一个高效的查找和更新的方案。此外，将所有账户构建为一个大的 merkle tree，为了保证所有节点的一致性和查找速度，必须进行排序。\n\n 3. 不排序有什么问题?\n\n> merkle tree 的叶子节点是账户信息，如果不排序，系统中有很多全节点会按照自己的排序方式进行构造账户信息，导致 merkle tree 均不相同，根哈希值也不同。\n\n 4. 比特币的 merkle tree 不也没排序吗？\n\n> 比特币每个全节点收到的交易顺序也是不一致的，merkle tree 根哈希值也不一样。但是比特币是每个节点在本地组装一个候选区块，它自己决定收集哪些交易，然后去挖矿争夺记账权，只有挖到矿的人才能决定发布区块，这个顺序是唯一的。\n\n 5. 那么经过排序，使用 sorted merkle tree 可以吗？\n\n> 新增账户，由于其地址随机，插入 merkle tree 时候很大可能在 tree 中间，必须进行重构。所以 sorted merkle tree 插入、删除的代价太大。\n\n\n# mpt\n\n以太坊采取的数据结构：mpt，首先介绍一下 trie 前缀树（字典树）\n\n 1. trie 中每个节点的分支数目取决于每个元素的取值范围(图例中最多26个英文字母分叉+ 1个结束标志位)。以太坊中是16进制表示（0 ~ f）加上一个结束标识符为 17 个分叉。\n 2. trie 查找效率取决于 key 的长度。实际应用中（以太坊地址长度为160字节）。\n 3. trie 上面不会发生哈希碰撞，两个账户的地址不一样，映射到 trie 一定是不同的分支。\n 4. 给定输入，无论如何顺序插入，构造的 trie 都是一样的。\n 5. 更新的局部性比较好：每次发布一个区块，系统中绝大多数账户的状态是不变的，只有个别才会变，所以更新操作的局部性很重要。trie 上只需要遍历某一个分支，并不需要遍历整棵树。\n 6. 缺点：存储上会有浪费，很多节点只有一个子节点。因此引入了 patricia tree/trie（经过路径压缩后的前缀树）。\n\n\n\n需要注意的是，如果新插入单词，原本压缩的路径可能需要扩展开来。什么情况下路径压缩效果较好？树中插入的键值分布较为稀疏的情况下，路径压缩效果较好。看以下例子：\n\n\n\n\n\n在以太坊系统中，160 位的地址存在 2^160 种，以太坊全世界的账户数加一起也远不足这个数，为什么地址搞的这么稀疏呢？\n\n> 就是因为地址分布稀疏，所以路径压缩效果较好。 以太坊创建账户在本地创建即可，类似于比特币，那么会不会两个创建的账户地址一样呢？有可能，但是比地球爆炸的可能性还要低，就是因为地址足够长，足够稀疏。 实际上，在以太坊种使用的并非简单的 patricia tree，而是 mpt(merkle patricia tree)\n\nmpt 就是将所有账户组织为一个经过路径压缩和排序的 merkle tree (指针为哈希指针)，其根哈希值存储于 block header 中。根哈希值的用处：\n\n 1. 防止篡改。\n 2. 提供 merkle proof ，可以证明账户余额，轻节点可以进行验证。\n 3. 给一个账户转账之前，证明某个发生了交易的账户是否存在。\n\n以太坊中针对 mpt 进行了修改，我们称其为 modified mpt。\n\n\n\n * shared nibble(s)：十六进制\n * extension node：扩展节点，经过路径压缩的节点\n * leaf node：叶子节点\n * branch node：分支节点\n\n每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。如下图中，仅仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。\n\n\n\n所以，系统中全节点并非维护一棵mpt，而是每次发布新区块都要新建mpt。只不过大部分节点共享。\n\n> 为什么要保存原本状态？为何不直接修改？ 为了便于回滚。如产生分叉后上面节点胜出，那么下面节点中状态的修改便需要进行回滚。因此，需要维护这些历史记录。\n\nblock header 中的数据结构\n\n\n\n * parenthash: 父区块的哈希（前一个区块的哈希）\n * unclehash: 叔父区块的哈希\n * coinbase: 矿工地址\n * root: 状态树的根哈希值\n * txhash: 交易树的根哈希值\n * receipthash: 收据树的根哈希值\n * bloom: 整个区块块头的 bloom filter\n * difficulty: 挖矿难度\n * gaslimit: 汽油费（类似于比特币中的交易费）相关\n * gasused: 汽油费（类似于比特币中的交易费）相关\n * time: 区块产生时间\n * mixdigest: 挖矿过程随机数算出来的哈希值\n * nonce: 挖矿时随机数\n\n区块结构\n\n\n\n * header: 指向 block header 的指针\n * uncles: 指向叔父区块的指针\n * transactions: 交易列表\n\n区块在网上真正发布时的信息\n\ntype extblock struct {\n    header *header\n    txs    []*transactions\n    uncles []*header\n}\n\n\n> 状态树中保存 key-value 对，key 就是地址，而 value 状态通过 rlp(recursive length prefix，一种进行序列化的方法) 编码序列号之后再进行存储。\n\n\n# eth 交易树和收据树\n\n每次发布一个区块时，区块中的交易会形成一颗 merkle tree，即交易树。此外以太坊还添加了一个收据树，每个交易执行完之后形成一个收据，记录交易相关信息。交易树和收据树上的节点是一一对应的，且都是 mpt。mpt 的好处是支持查找操作，通过键值沿着树进行查找即可。\n\n * 对于状态树，查找键值为账户地址。\n * 对于交易树和收据树，查找键值为交易在发布的区块中的序号。\n\n收据树作用：在以太坊中最重要的功能是加入了智能合约，而智能合约的执行过程比较复杂，收据树的作用是利于系统快速查询执行结果。\n\n\n# 布隆过滤器(bloom filter)\n\n作用：布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n\n> 给定一个数据集，其中含义元素 a、b、c，通过一个哈希函数 h() 对其进行计算，将其映射到一个其初始全为 0 的 128 位的向量的某个位置，将该位置置为 1。将所有元素处理完，就可以得到一个向量，则称该向量为原集合的 摘要。该 摘要 比原集合是要小很多的。 假定想要查询一个元素 d 是否在集合中，假设 h(d) 映射到向量中的位置处为 0，说明 d一定不在集合中；假设 h(d)映射到向量中的位置处为 1，可能集合中确实有 d，也有可能因为哈希碰撞产生误报。 个人理解就是：他会告诉你某样东西一定不存在或者可能存在。\n\n# bloom filter 在以太坊中的应用\n\n每个交易完成后会产生一个收据，收据包含一个 bloom filter 记录交易类型、地址等信息。在区块 block header 中也包含一个bloom filter，其为该区块中所有交易的 bloom filter 的一个并集。 所以，查找时候先查找块头中的 bloom filter，如果块头中包含。再查看区块中包含的交易的 bloom filter，如果存在，再查看交易进行确认；如果不存在，则说明发生了 碰撞。 好处就是通过 bloom filter 这样一个结构，快速大量过滤掉大量无关区块，从而提高了查找效率。\n\n\n# 补充\n\n以太坊对于给定的当前状态和给定一组交易可以确定性的转移到下一状态，这一运行过程可以视为交易驱动的状态机，通过执行当前区块中包含的交易，驱动系统从当前状态转移到下一状态。当然，btc 我们也可以视为交易驱动的状态机，其状态为 utxo。\n\n问题1：a转账到b，有没有可能收款账户不包含再状态树中？\n\n> 可能。因为以太坊中账户可以节点自己产生，只有在产生交易时才会被系统知道。 问题2：可否将每个区块中状态树更改为只包含和区块中交易相关的账户状态？(大幅削减状态树大小，且和交易树、收据树保持一致) 不能。首先，这样设计要查找账户状态很不方便，因为不存在某个区块包含所有状态。其次，如果要向一个新创建账户转账，因为需要知道收款账户的状态，才能给其添加金额，但由于其是新创建的账户，所有需要一直找到创世纪块才能知道该账户为新建账户。\n\n\n# 代码实现\n\nfunc newblock(header *header, txs []*transaction, uncles []*header, receipts []*receipt, hasher triehasher) *block {\n\tb := &block{header: copyheader(header)}\n\n\t// 交易列表是否为空\n\tif len(txs) == 0 {\n        // 块头里的交易树的根哈希值为空哈希值\n\t\tb.header.txhash = emptytxshash\n\t} else {\n        // 调用 derivesha 获得根哈希值\n\t\tb.header.txhash = derivesha(transactions(txs), hasher)\n        // 创建交易列表\n\t\tb.transactions = make(transactions, len(txs))\n\t\tcopy(b.transactions, txs)\n\t}\n\n    // 收据列表是否为空\n\tif len(receipts) == 0 {\n        // 块头里的收据树的根哈希值为空哈希值\n\t\tb.header.receipthash = emptyreceiptshash\n\t} else {\n        // 调用 derivesha 获得根哈希值\n\t\tb.header.receipthash = derivesha(receipts(receipts), hasher)\n        // 创建 bloom filter\n        // createbloom 函数用来创建 block header 中的 bloom 域,\n        // 这个 bloom filter 由这个块中所有 receiptes 的 bloom filter 组合得到\n\t\tb.header.bloom = createbloom(receipts)\n\t}\n\n    // 叔父列表是否为空\n\tif len(uncles) == 0 {\n        // 块头里的叔父区块的哈希值为空哈希值\n\t\tb.header.unclehash = emptyunclehash\n\t} else {\n        // 通过 calcunclehash 计算出哈希值\n\t\tb.header.unclehash = calcunclehash(uncles)\n        // 通过循环构造出叔父数组\n\t\tb.uncles = make([]*header, len(uncles))\n\t\tfor i := range uncles {\n\t\t\tb.uncles[i] = copyheader(uncles[i])\n\t\t}\n\t}\n\n\treturn b\n}\n\n// derivesha 函数\nfunc derivesha(list derivablelist) common.hash {\n\tkeybuf := new(bytes.buffer)\n\ttrie := new(trie.trie)\n\tfor i := 0; i < list.len(); i++ {\n\t\tkeybuf.reset()\n\t\trlp.encode(keybuf, uint(i))\n\t\ttrie.update(keybuf.bytes(), list.getrlp(i))\n\t}\n\treturn trie.hash()\n}\n\n// 收据数据结构\ntype receipt struct {\n\tpoststate         []byte `json:"root"`\n\tstatus            uint64 `json:"status"`\n\tcumulativegasused uint64 `json:"cumulativegasused" gencodec:"required"`\n\tbloom             bloom  `json:"logsbloom"         gencodec:"required"`\n\tlogs              []*log `json:"logs"              gencodec:"required"`\n\n\ttxhash          common.hash    `json:"transactionhash" gencodec:"required"`\n\tcontractaddress common.address `json:"contractaddress"`\n\tgasused         uint64         `json:"gasused" gencodec:"required"`\n}\n',charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 3",frontmatter:{},regularPath:"/blockchain/learn3.html",relativePath:"blockchain/learn3.md",key:"v-fe9d3e02",path:"/blockchain/learn3.html",headers:[{level:2,title:"BTC 中的节点",slug:"btc-中的节点",normalizedTitle:"btc 中的节点",charIndex:83},{level:3,title:"全节点",slug:"全节点",normalizedTitle:"全节点",charIndex:96},{level:3,title:"轻节点",slug:"轻节点",normalizedTitle:"轻节点",charIndex:349},{level:2,title:"挖矿设备演化",slug:"挖矿设备演化",normalizedTitle:"挖矿设备演化",charIndex:806},{level:2,title:"矿池",slug:"矿池",normalizedTitle:"矿池",charIndex:1351},{level:3,title:"矿工利益分配",slug:"矿工利益分配",normalizedTitle:"矿工利益分配",charIndex:1637},{level:3,title:"可能出现的问题",slug:"可能出现的问题",normalizedTitle:"可能出现的问题",charIndex:2057},{level:3,title:"矿池的数据",slug:"矿池的数据",normalizedTitle:"矿池的数据",charIndex:2419},{level:3,title:"矿池可以发动哪些攻击",slug:"矿池可以发动哪些攻击",normalizedTitle:"矿池可以发动哪些攻击",charIndex:2807},{level:2,title:"BTC 脚本篇",slug:"btc-脚本篇",normalizedTitle:"btc 脚本篇",charIndex:3194},{level:3,title:"交易结构",slug:"交易结构",normalizedTitle:"交易结构",charIndex:3208},{level:3,title:"脚本举例说明",slug:"脚本举例说明",normalizedTitle:"脚本举例说明",charIndex:4515},{level:3,title:"P2PK（Pay to Public Key）",slug:"p2pk-pay-to-public-key",normalizedTitle:"p2pk（pay to public key）",charIndex:4736},{level:3,title:"P2PKH（Pay to public key hash）——最常用",slug:"p2pkh-pay-to-public-key-hash-最常用",normalizedTitle:"p2pkh（pay to public key hash）——最常用",charIndex:5041},{level:3,title:"P2SH（Pay to Script Hash）",slug:"p2sh-pay-to-script-hash",normalizedTitle:"p2sh（pay to script hash）",charIndex:5554},{level:3,title:"多重签名",slug:"多重签名",normalizedTitle:"多重签名",charIndex:4133},{level:3,title:"用P2SH实现多重签名",slug:"用p2sh实现多重签名",normalizedTitle:"用p2sh实现多重签名",charIndex:7072},{level:3,title:"Proof of Burn：销毁BTC",slug:"proof-of-burn-销毁btc",normalizedTitle:"proof of burn：销毁btc",charIndex:7756}],lastUpdated:"6/2/2023, 5:37:21 PM",lastUpdatedTimestamp:1685698641e3,headersStr:"BTC 中的节点 全节点 轻节点 挖矿设备演化 矿池 矿工利益分配 可能出现的问题 矿池的数据 矿池可以发动哪些攻击 BTC 脚本篇 交易结构 脚本举例说明 P2PK（Pay to Public Key） P2PKH（Pay to public key hash）——最常用 P2SH（Pay to Script Hash） 多重签名 用P2SH实现多重签名 Proof of Burn：销毁BTC",content:'# 北大肖臻老师《区块链技术与应用》公开课学习 3\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n\n\n# BTC 中的节点\n\n\n# 全节点\n\n * 一直在线\n * 在本地硬盘上维护完整区块链信息\n * 在内存中维护UTXO集合，以便于快速检验交易合法性\n * 监听比特币网络中交易内容，验证每个交易合法性\n * 决定哪些交易会打包到区块中\n * 监听其他矿工挖出的区块，验证其合法性\n   * 区块中的每个交易都要合法\n   * 发布的区块是不是符合难度要求、难度目标阈值的设置是否正确、每两周调整的挖矿难度\n   * 区块是在延伸最长合法链\n * 挖矿\n   * 决定沿着哪条链挖下去\n   * 当出现等长分叉，选择哪一个分叉\n\n\n# 轻节点\n\n * 不是一直在线\n * 不保存整个区块链，只需要保存每隔区块块头\n * 不保存全部交易，只保存和自己有关的交易\n * 无法验证大多数交易合法性，只能检验和自己相关的交易合法性\n * 无法检测网上发布的区块正确性\n * 可以验证挖矿难度\n * 只能检测哪个是最长链，不知道哪个是最长合法链\n\n在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最后这个新合法区块的候选区块，重新开始挖矿。\n\n这样是不是有些可惜？之前花费好多资源，全部白挖了。\n\n> 实际上并不可惜。之前文章中提及，挖矿本身具有无记忆性，前面无论挖多久，对后续继续挖矿没有影响。 比特币系统如何安全性？ 一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账户上BTC转走。（前提：系统中大多数算力掌握在好人手中） 二是共识机制：保证了恶意交易不被系统承认。\n\n\n# 挖矿设备演化\n\n目前，挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。 普通CPU -> GPU -> ASIC芯片（挖矿专用矿机）\n\n> 实际上，挖矿本身就是计算，对于普通计算机来说，挖矿过程中大多数内存、硬盘、CPU中大多数部件（用到指令较少）等都是闲置的，如果用普通计算机专门用于挖矿是根本不划算的。随着挖矿难度提高，用通用计算机挖矿很快变得无利可图。 所以，挖矿设备转入第二代——GPU(主要用于大规模并行计算，如：深度学习)。但是，用GPU挖矿，仍然有一定浪费(GPU为通用并行计算设计，挖矿仍然有很多部件闲置。例如：浮点数运算部件，挖矿过程只使用整数操作，该部分部件根本不会用到)。 GPU价格上涨，仅仅是深度学习火热导致的吗？实际上，很多GPU被用于了挖矿。 当然，目前GPU挖矿也已经不划算了（目前一些新开发货币仍然用GPU挖矿）。所以，开始进入第三代设备：ASIC芯片（专门为挖矿设计的芯片），这种芯片专门为挖矿设计，只能用于特定币种的挖矿。 但ASIC芯片设计、流片流程很长，假如BTC价格剧烈变化，前期投入很可能会血本无归。所以，ASIC芯片需要提前预订。假如BTC系统中，算力突然很猛烈增加，一般是一个大的厂商生产出新的ASIC矿机。\n\n\n# 矿池\n\n单个矿工挖矿的收益是很不稳定的，平均出块时间10分钟是对于比特币系统中的所有矿工而言的。一个矿工用一个矿机挖出矿的时间可能要很久，并且除了挖矿之外还要承担全结点的其它责任。\n\n矿池将很多矿工组织起来，一般的架构就是一个矿主（pool manager）全结点去驱动很多矿机，下属矿工只负责计算哈希值，全结点的其它职能只由矿主来承担。有了收益以后再大家一起分配。\n\n\n\n如果矿机来自不同机构，这时候矿工很可能分布在世界各地，只是都加入了这个矿池。矿工和矿主联系，矿主将要计算的哈希值的任务分配给他，矿工计算好后将结果发给矿主，最终得到出块奖励后一起参与分红。\n\n\n# 矿工利益分配\n\n 1. 平均分配，所有人平分出块奖励。\n\n> 大家一起"吃大锅饭"，会导致某些矿工懈怠，不干活（挖矿要费电，需要成本）。反正又不影响最后平均分配。 所以，这里也需要进行按劳分配，需要一个工作量证明的方案。如何证明每个矿工所作的工作量呢？\n\n 2. 降低挖矿难度\n\n> 假设原本挖矿难度要求，计算所得 126位 的哈希值前 70位 都必须为0，现在降低要求，只需要前 60位 为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其称为一个 share，或 almost valid share。矿工每挖到一个 share，将其提交给矿主，矿主对其进行记录，作为矿工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的 share 数量进行分配。因为每个矿工尝试的 nonce 越多，挖到矿的可能性越大，所能得到的 share 也会越多，所以这种方案作为工作量证明方案是可行的。\n\n\n# 可能出现的问题\n\n 1. 矿工会不会平时正常提交 share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去\n\n> 不可能。因为矿主已经组装好了区块，交给矿工计算，区块中铸币交易的收款人地址是矿主。\n\n 2. 那么矿工可以可以把铸币交易的收款人改成自己呢？\n\n> 如果自己把铸币交易的地址改成自己的，然后去挖矿，这样提交上去的 share 矿主是不认可的，挖出来的矿虽然是自己的，但是整体看来就是自己单干，根本没必要加入矿池。\n\n 3. 有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？\n\n> 可能是有，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。 但是，矿池之间存在竞争关系。有可能为了打击竞争对手，从而起到搞破坏的作用。\n\n\n# 矿池的数据\n\n\n\n如果存在一个矿池(GHash.IO)算力比例占据全部算力一半以上，当时引起了恐慌(一个矿池就可以发动51攻击)。之后，该矿池主动降低了矿池算力，避免动摇人们对比特币信心。\n\n有可能表面看上去是安全的，但实际实上某个机构如果有超过50%算力，其必然不会将其放入一个矿池中。而是将其分散隐藏，真正需要发动攻击时候再集中起来发动攻击\n\n> 由这些数据可以得知，矿池本身对 BTC 系统带来了较大威胁。某个恶意用户如果想发动攻击，以前需要自己达到 51% 算力，现在自己只需要作为矿主，只需要很少一部分算力就可以了。只要能够吸引到足够多的不明真相的矿工，便可以用较低成本实现攻击。 当然，矿主经验管理矿池，也需要收取一定比例(出块奖励、交易费)作为管理费用。如果恶意者想要攻击系统，会将管理费降低甚至赔本吸引足够多矿工加入。这便使得发动攻击变得容易了起来。\n\n\n# 矿池可以发动哪些攻击\n\n 1. 分叉攻击: 对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。\n\n> 矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么，所以容易被利用。 此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。\n\n 2. 封锁交易\n\n> 假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为最长合法链。这样，便实现了对A账户的封锁。其他矿工因为害怕，可能也不会将A的交易记录下来。\n\n 3. 偷币\n\n> 这个是不可能的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。\n\n\n# BTC 脚本篇\n\n\n\n\n# 交易结构\n\n"result": {\n  "txid": "921a.dd24", // 交易id\n  "hash": "921a.dd24", // 交易的哈希值\n  "version": 1, // 使用的比特币协议版本号\n  "size": 226, // 交易的大小\n  "locktime": 0, // 交易的生效时间，0代表立即生效，非0代表经过几个区块后才允许上链\n  "vin": [...], // 交易的输入\n          "vout": [...], // 交易的输出\n  "blockhash": "0000000000000000002c510d..5c0b", // 交易所在区块的哈希值\n  "confirmations": 23, // 目前已经有几个确认，包括自己及其后面有多少区块上链\n  "time": 1530846727, // 交易产生的时间戳\n  "blocktime": 1530846727 // 该交易所在的区块的产生时间\n}\n\n// 交易的输入，是一个数组，可以有多个输入，每个输入都要指明来源，并给出签名。\n"vin": [{\n  "txid": "c0cb...c57b",// 该输入的来源交易的哈希值\n  "vout": 0, // 该输入对应『来源交易』的第几个输出。是一个索引值\n  "scriptsig": { // 输入脚本，这里是最简单的形式，只有签名    \n    "asm": "3045...0018",\n    "hex": "4830...0018"\n  }\t\n}],\n\n// 交易的输出\n"vout":[{\n  "va1ue": 0.22684000, // 金额，即转过去多少BTC\n  "n": 0, // 序号，表示这个输出在这个交易中的索引\n  "scriptPubKey": { // 输出脚本\n    "asm": "DUP HASH160 628e...d/43 EQUALVERTFY CHECKSTG",\n    "hex": "76a9.88ac",\n    "regsigs": 1, // 这个输出需要多少个签名才能兑现，有的输出需要多重签名\n    "type": "pubkeyhash", // 输出的类型，此处 pubkeyhash 是公钥的哈希\n    "addresses": ["19z8LJkNXLrTv2QK5jgTncJCGUEEfpQvSr"] // 输出的地址\n  }\n},{\n  "va1ue": 0.53756644,\n  "n": 1,\n  "scriptPubKey": {\n    "asm": "DUP HASH160 da7d...2cd2 EQUALVERIFY CHECKSIG",\n    "hex": "76a9.88ac",\n    "regsigs": 1,\n    "type": "pubkeyhash",\n    "addresses": ["1LVGTpdyeVLCLCDK2m9f7Pbh7zwhs7NYhX"]\n  }\n}]\n\n\n\n# 脚本举例说明\n\n\n\n> 在早期的比特币系统中，B->C 这个交易的输入脚本和 A->B 这个交易的输出脚本拼在一起执行。 后来，出于安全因素的考虑，这两个脚本改为分别执行，首先执行输入脚本，如果没有出错，那么再执行输出脚本，如果能顺利执行，并且最后得到非零值（true），那么这个交易就是合法的。 如果一个交易有多个输入，每个输入脚本都要去找到前面特定区块中所对应的输出脚本，匹配之后来进行验证。全部验证通过后，这个交易才是合法的。\n\n\n# P2PK（Pay to Public Key）\n\ninput script:\n\tPUSHDATA(Sig) # 输入脚本中直接给出签名（收款人用自己的私钥对输入脚本所在的整个交易的签名）\noutput script:\n\tPUSHDATA(PubKey) # 输出脚本中直接给出收款人的公钥\n\tCHECKSIG # 最后的 CHECKSIG 是检查签名\n\n\n入栈执行过程：\n\n 1. 第一条语句，将输入脚本中的签名压入栈\n 2. 第二条语句，将输出脚本中的公钥压入栈\n 3. 第三条语句，弹出栈顶的两个元素，用公钥 PubKey 检查一下签名 Sig 是否正确。如果正确，返回True，说明验证通过\n\n\n\n\n# P2PKH（Pay to public key hash）——最常用\n\ninput script:\n\tPUSHDATA(Sig) # 给出私钥签名\n\tPUSHDATA(PubKey) # 给出公钥\noutput script:\n\tDUP\n\tHASH160\n\tPUSHDATA(PubKeyHash) # 输出脚本中没有给出收款人的公钥，给出的是公钥的哈希值。\n\tEQUALVERIEY\n\tCHECKSIG\n\n\n入栈执行过程：\n\n 1. 第一条语句，将输入脚本中的签名压入栈\n 2. 第二条语句，将输入脚本中的公钥压入栈\n 3. 第三条语句，将栈顶元素复制一遍（所以又压入了一次公钥）\n 4. 第四条语句，将栈顶元素取出来取哈希，再将得到的哈希值压入栈（也就是将栈顶的公钥变成了其哈希值）\n 5. 第五条语句，将输出脚本中提供的公钥的哈希值压入栈\n 6. 第六条语句，弹出栈顶的两个元素（都是公钥的哈希值），比较它们是否相等——防止有人用自己的公钥冒充币的来源的交易的收款人的公钥\n 7. 第七条语句，弹出栈顶的两个元素（公钥和签名），用公钥PubKey检查一下签名Sig是否正确。如果正确，返回True，说明验证通过\n\n\n# P2SH（Pay to Script Hash）\n\n这种形式下输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的赎回脚本（Redeem Script）的哈希。我们举个例子就明白了。\n\nredeemScript: # 赎回脚本(收款人会公开)\n\tPUSHDATA(PubKey)\n\tCHECKSIG\ninput script:\n\tPUSHDATA(Sig) # 给出私钥签名\n\tPUSHDATA(serialized redeemScript) # 给出序列化的赎回脚本\noutput script:\n\tHASH160\n\tPUSHDATA(redeemscriptHash)\n\tEQUAL\n\n\n入栈执行过程\n\n * 第一阶段\n   * 第一步，将输入脚本中的交易签名压入栈\n   * 第二步，将输入脚本中给出的赎回脚本压入栈\n   * 第三步，弹出栈顶元素取哈希再压栈，也就得到了赎回脚本的哈希（Redeem Script Hash）\n   * 第四步，将输出脚本中给出的赎回脚本的哈希值压入栈\n   * 第五步，比较栈顶两个元素是否相等，相当于用之前的输出脚本给出的赎回脚本哈希，验证了输入脚本提供的赎回脚本是否是正确的\n * 第二阶段（反序列化并执行redeemScript，验证input script中给出的签名是否正确）\n   * 第一步，将脚本中写死的公钥压入栈\n   * 第二步，验证输入脚本中给出的交易签名的正确性。验证通过就会返回 True\n\n\n# 多重签名\n\nP2SH常见的应用场景就是对多重签名的支持\n\n比特币系统中一个交易输出可能要求使用它的交易输入提供多个签名，才能把BTC取出来。比如某个公司可能要求5个合伙人中的任意三个提供签名，才能把公司的钱转走。这样设计不但为私钥的泄露提供了一定安全性保护，也为私钥的丢失提供了一定的容错性。\n\ninputScript:\n\tX # 在输入脚本里往栈中添加一个没用的元素，抵消掉BTC其中的一个bug。\n\tPUSHDATA(Sig 1)\n\tPUSHDATA(Sig 2)\n\tPUSHDATA(Sig M)\noutputScript:\n\tM\n\tPUSHDATA(pubkey_1)\n\tPUSHDATA(pubkey_2)\n\t...\n\tPUSHDATA(pubkey N)\n\tN\n\tCHECKMULTISIG\n\n\n> 为什么不把这个 bug 修复了呢？去中心化的系统和中心化的系统不一样。中心化的系统可以发布很多版本，去中心化的系统修改版本后会产生硬分叉。\n\n入栈执行过程\n\n 1. 第一步，将输入脚本中的多余元素（前述的X）压栈\n 2. 第二步，将输入脚本里的 M 个签名依次压入栈中（这里 M=2）\n 3. 第三步，将输出脚本中给定的阈值 M 压栈\n 4. 第四步，将输出脚本中给定的 N 个公钥压栈\n 5. 第五步，将输出脚本中给定的公钥数 N 压栈\n 6. 第六步，执行 CEHCKMULTISIG，以检查堆栈中是否按顺序包含了 N 个签名中的 M 个\n\n> 这是最早的多重签名，并没有用到 P2SH，就是用比特币脚本中原生的 CEHCKMULTISIG 实现的。 这样在实际使用时有些不方便的地方，例如电商网站开通了比特币支付渠道，但要求要有5个合伙人中3个人的签名才能把 BTC 转走。但这样做之后，用户在 BTC 支付的时候，生成的转账交易里也给出 5 个合伙人的公钥，同时还要给出N和M的值。 而这些公钥，以及 N 和 M 的值就要电商网站公布给用户，而且不同的电商网站规则也不一样，这就让用户生成转账交易变得不方便。因为这些复杂性都暴露给用户了\n\n\n# 用P2SH实现多重签名\n\n相比前面的实现，这样的本质是将复杂性从输出脚本转移到了赎回脚本中，输出脚本只需要给出赎回脚本的哈希值就行了。N个公钥以及N、M的值都在赎回脚本中给出来，而赎回脚本由输入脚本提供，这样也就和支付给它的用户们隔离开了。\n\n> 从用户的角度来看，采用这种P2SH的支付方式，和P2PKH支付方式没有多大区别，只不过输出脚本中的是赎回脚本的哈希值而不是公钥的哈希值 输入脚本就是电商网站要把这笔BTC转出去时候用的，这种方式下输入脚本要包含M个签名，以及赎回脚本的序列化版本。 如果电商将来改变了采用的多重签名规则，就只需要改变一下赎回脚本的内容和输入脚本中的内容，然后把新的赎回脚本的哈希值公布出去就可以了。对用户而言也只是付款时候输出脚本中要包含的哈希值发生了变化。\n\n入栈执行过程：\n\n * 第一阶段\n   * 第一步，将占位元素 X 压栈\n   * 第二步，将输入脚本中的M个签名压栈\n   * 第三步，将输入脚本中保存的序列化的赎回脚本压栈\n   * 第四步，弹出栈顶元素取哈希再压栈，即将栈顶的赎回脚本取哈希\n   * 第五步，将输出脚本中给出的赎回脚本哈希值（RSH）压栈\n   * 第六步，判断栈顶两个元素是否相等，即判断一下计算出的赎回脚本哈希和给定的赎回脚本哈希是否相等\n * 第二阶段（执行 redeem script）\n   * 第一步，将签名数 M 压栈\n   * 第二步，将 N 个公钥压栈\n   * 第三步，将给定的公钥数 N 压栈\n   * 第四步，使用CEHCKMULTISIG操作检查多重签名的正确性\n\n\n\n\n# Proof of Burn：销毁BTC\n\n一个特殊的脚本, 以 RETURN 开始，后面可以跟任何内容。RETURN 操作，无条件返回错误，所以该脚本永远不可能通过验证。执行到RETURN，后续操作不会再执行。该方法是销毁比特币的一种方法。 为什么要销毁比特币？现在比特币价值极高，销毁是不是很可惜？\n\n 1. 部分小币种(AltCoin)要求销毁部分比特币才能得到该种小币种。\n 2. 往区块链中写入内容。我们经常说，区块链是不可篡改的账本，有人便利用该特性往其中添加想要永久保存的内容。例如：知识产权保护——知识产权的哈希值。\n\n> 铸币交易的 CoinBase 域也可以随便写什么内容，为什么不在那里写呢？因为这种方法很难，必须要获得记账权。然而发布交易不需要有记账权。 任何用户都可以用 Proof of Burn 的方法，销毁极少量的比特币，换取向比特币系统的区块链中写入一些内容的机会。没有销毁比特币，仅仅支付了交易费，也可以向区块链中写入内容。\n\n例如下图为一个铸币交易，其中包含两个交易，第二个交易便是仅仅想要往其中写入内容。\n\n下图为一个普通的转账交易，其就是仅仅为了向区块链写入内容。该交易并未销毁 BTC，只是将输入的费用作为交易费给了挖到矿的矿工。这种交易永远不会兑现，所以矿工不会将其保存在 UTXO 中，对全节点比较友好。\n\n\n\n> BTC系统中使用的脚本语言很简单，它也不是图灵完备的语言，甚至不支持循环，这样设计也有其用意，不支持循环也就不会有死循环。后面学的以太坊的脚本语言就是图灵完备的，这样就靠其它机制来防止进入死循环等。\n\nBTC的脚本语言针对BTC应用场景做了很好的优化，如检查多重签名时的 CHECKMULTISIG 操作一条就能实现，这是其强大之处。',normalizedContent:'# 北大肖臻老师《区块链技术与应用》公开课学习 3\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n\n\n# btc 中的节点\n\n\n# 全节点\n\n * 一直在线\n * 在本地硬盘上维护完整区块链信息\n * 在内存中维护utxo集合，以便于快速检验交易合法性\n * 监听比特币网络中交易内容，验证每个交易合法性\n * 决定哪些交易会打包到区块中\n * 监听其他矿工挖出的区块，验证其合法性\n   * 区块中的每个交易都要合法\n   * 发布的区块是不是符合难度要求、难度目标阈值的设置是否正确、每两周调整的挖矿难度\n   * 区块是在延伸最长合法链\n * 挖矿\n   * 决定沿着哪条链挖下去\n   * 当出现等长分叉，选择哪一个分叉\n\n\n# 轻节点\n\n * 不是一直在线\n * 不保存整个区块链，只需要保存每隔区块块头\n * 不保存全部交易，只保存和自己有关的交易\n * 无法验证大多数交易合法性，只能检验和自己相关的交易合法性\n * 无法检测网上发布的区块正确性\n * 可以验证挖矿难度\n * 只能检测哪个是最长链，不知道哪个是最长合法链\n\n在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最后这个新合法区块的候选区块，重新开始挖矿。\n\n这样是不是有些可惜？之前花费好多资源，全部白挖了。\n\n> 实际上并不可惜。之前文章中提及，挖矿本身具有无记忆性，前面无论挖多久，对后续继续挖矿没有影响。 比特币系统如何安全性？ 一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账户上btc转走。（前提：系统中大多数算力掌握在好人手中） 二是共识机制：保证了恶意交易不被系统承认。\n\n\n# 挖矿设备演化\n\n目前，挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。 普通cpu -> gpu -> asic芯片（挖矿专用矿机）\n\n> 实际上，挖矿本身就是计算，对于普通计算机来说，挖矿过程中大多数内存、硬盘、cpu中大多数部件（用到指令较少）等都是闲置的，如果用普通计算机专门用于挖矿是根本不划算的。随着挖矿难度提高，用通用计算机挖矿很快变得无利可图。 所以，挖矿设备转入第二代——gpu(主要用于大规模并行计算，如：深度学习)。但是，用gpu挖矿，仍然有一定浪费(gpu为通用并行计算设计，挖矿仍然有很多部件闲置。例如：浮点数运算部件，挖矿过程只使用整数操作，该部分部件根本不会用到)。 gpu价格上涨，仅仅是深度学习火热导致的吗？实际上，很多gpu被用于了挖矿。 当然，目前gpu挖矿也已经不划算了（目前一些新开发货币仍然用gpu挖矿）。所以，开始进入第三代设备：asic芯片（专门为挖矿设计的芯片），这种芯片专门为挖矿设计，只能用于特定币种的挖矿。 但asic芯片设计、流片流程很长，假如btc价格剧烈变化，前期投入很可能会血本无归。所以，asic芯片需要提前预订。假如btc系统中，算力突然很猛烈增加，一般是一个大的厂商生产出新的asic矿机。\n\n\n# 矿池\n\n单个矿工挖矿的收益是很不稳定的，平均出块时间10分钟是对于比特币系统中的所有矿工而言的。一个矿工用一个矿机挖出矿的时间可能要很久，并且除了挖矿之外还要承担全结点的其它责任。\n\n矿池将很多矿工组织起来，一般的架构就是一个矿主（pool manager）全结点去驱动很多矿机，下属矿工只负责计算哈希值，全结点的其它职能只由矿主来承担。有了收益以后再大家一起分配。\n\n\n\n如果矿机来自不同机构，这时候矿工很可能分布在世界各地，只是都加入了这个矿池。矿工和矿主联系，矿主将要计算的哈希值的任务分配给他，矿工计算好后将结果发给矿主，最终得到出块奖励后一起参与分红。\n\n\n# 矿工利益分配\n\n 1. 平均分配，所有人平分出块奖励。\n\n> 大家一起"吃大锅饭"，会导致某些矿工懈怠，不干活（挖矿要费电，需要成本）。反正又不影响最后平均分配。 所以，这里也需要进行按劳分配，需要一个工作量证明的方案。如何证明每个矿工所作的工作量呢？\n\n 2. 降低挖矿难度\n\n> 假设原本挖矿难度要求，计算所得 126位 的哈希值前 70位 都必须为0，现在降低要求，只需要前 60位 为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其称为一个 share，或 almost valid share。矿工每挖到一个 share，将其提交给矿主，矿主对其进行记录，作为矿工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的 share 数量进行分配。因为每个矿工尝试的 nonce 越多，挖到矿的可能性越大，所能得到的 share 也会越多，所以这种方案作为工作量证明方案是可行的。\n\n\n# 可能出现的问题\n\n 1. 矿工会不会平时正常提交 share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去\n\n> 不可能。因为矿主已经组装好了区块，交给矿工计算，区块中铸币交易的收款人地址是矿主。\n\n 2. 那么矿工可以可以把铸币交易的收款人改成自己呢？\n\n> 如果自己把铸币交易的地址改成自己的，然后去挖矿，这样提交上去的 share 矿主是不认可的，挖出来的矿虽然是自己的，但是整体看来就是自己单干，根本没必要加入矿池。\n\n 3. 有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？\n\n> 可能是有，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。 但是，矿池之间存在竞争关系。有可能为了打击竞争对手，从而起到搞破坏的作用。\n\n\n# 矿池的数据\n\n\n\n如果存在一个矿池(ghash.io)算力比例占据全部算力一半以上，当时引起了恐慌(一个矿池就可以发动51攻击)。之后，该矿池主动降低了矿池算力，避免动摇人们对比特币信心。\n\n有可能表面看上去是安全的，但实际实上某个机构如果有超过50%算力，其必然不会将其放入一个矿池中。而是将其分散隐藏，真正需要发动攻击时候再集中起来发动攻击\n\n> 由这些数据可以得知，矿池本身对 btc 系统带来了较大威胁。某个恶意用户如果想发动攻击，以前需要自己达到 51% 算力，现在自己只需要作为矿主，只需要很少一部分算力就可以了。只要能够吸引到足够多的不明真相的矿工，便可以用较低成本实现攻击。 当然，矿主经验管理矿池，也需要收取一定比例(出块奖励、交易费)作为管理费用。如果恶意者想要攻击系统，会将管理费降低甚至赔本吸引足够多矿工加入。这便使得发动攻击变得容易了起来。\n\n\n# 矿池可以发动哪些攻击\n\n 1. 分叉攻击: 对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。\n\n> 矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么，所以容易被利用。 此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。\n\n 2. 封锁交易\n\n> 假如攻击者不喜欢某个账户a，不想让a的交易上区块链，在监听到有其他人将a的交易发布到区块链上时，立刻发动分叉攻击，使a所在链无法成为最长合法链。这样，便实现了对a账户的封锁。其他矿工因为害怕，可能也不会将a的交易记录下来。\n\n 3. 偷币\n\n> 这个是不可能的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。\n\n\n# btc 脚本篇\n\n\n\n\n# 交易结构\n\n"result": {\n  "txid": "921a.dd24", // 交易id\n  "hash": "921a.dd24", // 交易的哈希值\n  "version": 1, // 使用的比特币协议版本号\n  "size": 226, // 交易的大小\n  "locktime": 0, // 交易的生效时间，0代表立即生效，非0代表经过几个区块后才允许上链\n  "vin": [...], // 交易的输入\n          "vout": [...], // 交易的输出\n  "blockhash": "0000000000000000002c510d..5c0b", // 交易所在区块的哈希值\n  "confirmations": 23, // 目前已经有几个确认，包括自己及其后面有多少区块上链\n  "time": 1530846727, // 交易产生的时间戳\n  "blocktime": 1530846727 // 该交易所在的区块的产生时间\n}\n\n// 交易的输入，是一个数组，可以有多个输入，每个输入都要指明来源，并给出签名。\n"vin": [{\n  "txid": "c0cb...c57b",// 该输入的来源交易的哈希值\n  "vout": 0, // 该输入对应『来源交易』的第几个输出。是一个索引值\n  "scriptsig": { // 输入脚本，这里是最简单的形式，只有签名    \n    "asm": "3045...0018",\n    "hex": "4830...0018"\n  }\t\n}],\n\n// 交易的输出\n"vout":[{\n  "va1ue": 0.22684000, // 金额，即转过去多少btc\n  "n": 0, // 序号，表示这个输出在这个交易中的索引\n  "scriptpubkey": { // 输出脚本\n    "asm": "dup hash160 628e...d/43 equalvertfy checkstg",\n    "hex": "76a9.88ac",\n    "regsigs": 1, // 这个输出需要多少个签名才能兑现，有的输出需要多重签名\n    "type": "pubkeyhash", // 输出的类型，此处 pubkeyhash 是公钥的哈希\n    "addresses": ["19z8ljknxlrtv2qk5jgtncjcgueefpqvsr"] // 输出的地址\n  }\n},{\n  "va1ue": 0.53756644,\n  "n": 1,\n  "scriptpubkey": {\n    "asm": "dup hash160 da7d...2cd2 equalverify checksig",\n    "hex": "76a9.88ac",\n    "regsigs": 1,\n    "type": "pubkeyhash",\n    "addresses": ["1lvgtpdyevlclcdk2m9f7pbh7zwhs7nyhx"]\n  }\n}]\n\n\n\n# 脚本举例说明\n\n\n\n> 在早期的比特币系统中，b->c 这个交易的输入脚本和 a->b 这个交易的输出脚本拼在一起执行。 后来，出于安全因素的考虑，这两个脚本改为分别执行，首先执行输入脚本，如果没有出错，那么再执行输出脚本，如果能顺利执行，并且最后得到非零值（true），那么这个交易就是合法的。 如果一个交易有多个输入，每个输入脚本都要去找到前面特定区块中所对应的输出脚本，匹配之后来进行验证。全部验证通过后，这个交易才是合法的。\n\n\n# p2pk（pay to public key）\n\ninput script:\n\tpushdata(sig) # 输入脚本中直接给出签名（收款人用自己的私钥对输入脚本所在的整个交易的签名）\noutput script:\n\tpushdata(pubkey) # 输出脚本中直接给出收款人的公钥\n\tchecksig # 最后的 checksig 是检查签名\n\n\n入栈执行过程：\n\n 1. 第一条语句，将输入脚本中的签名压入栈\n 2. 第二条语句，将输出脚本中的公钥压入栈\n 3. 第三条语句，弹出栈顶的两个元素，用公钥 pubkey 检查一下签名 sig 是否正确。如果正确，返回true，说明验证通过\n\n\n\n\n# p2pkh（pay to public key hash）——最常用\n\ninput script:\n\tpushdata(sig) # 给出私钥签名\n\tpushdata(pubkey) # 给出公钥\noutput script:\n\tdup\n\thash160\n\tpushdata(pubkeyhash) # 输出脚本中没有给出收款人的公钥，给出的是公钥的哈希值。\n\tequalveriey\n\tchecksig\n\n\n入栈执行过程：\n\n 1. 第一条语句，将输入脚本中的签名压入栈\n 2. 第二条语句，将输入脚本中的公钥压入栈\n 3. 第三条语句，将栈顶元素复制一遍（所以又压入了一次公钥）\n 4. 第四条语句，将栈顶元素取出来取哈希，再将得到的哈希值压入栈（也就是将栈顶的公钥变成了其哈希值）\n 5. 第五条语句，将输出脚本中提供的公钥的哈希值压入栈\n 6. 第六条语句，弹出栈顶的两个元素（都是公钥的哈希值），比较它们是否相等——防止有人用自己的公钥冒充币的来源的交易的收款人的公钥\n 7. 第七条语句，弹出栈顶的两个元素（公钥和签名），用公钥pubkey检查一下签名sig是否正确。如果正确，返回true，说明验证通过\n\n\n# p2sh（pay to script hash）\n\n这种形式下输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的赎回脚本（redeem script）的哈希。我们举个例子就明白了。\n\nredeemscript: # 赎回脚本(收款人会公开)\n\tpushdata(pubkey)\n\tchecksig\ninput script:\n\tpushdata(sig) # 给出私钥签名\n\tpushdata(serialized redeemscript) # 给出序列化的赎回脚本\noutput script:\n\thash160\n\tpushdata(redeemscripthash)\n\tequal\n\n\n入栈执行过程\n\n * 第一阶段\n   * 第一步，将输入脚本中的交易签名压入栈\n   * 第二步，将输入脚本中给出的赎回脚本压入栈\n   * 第三步，弹出栈顶元素取哈希再压栈，也就得到了赎回脚本的哈希（redeem script hash）\n   * 第四步，将输出脚本中给出的赎回脚本的哈希值压入栈\n   * 第五步，比较栈顶两个元素是否相等，相当于用之前的输出脚本给出的赎回脚本哈希，验证了输入脚本提供的赎回脚本是否是正确的\n * 第二阶段（反序列化并执行redeemscript，验证input script中给出的签名是否正确）\n   * 第一步，将脚本中写死的公钥压入栈\n   * 第二步，验证输入脚本中给出的交易签名的正确性。验证通过就会返回 true\n\n\n# 多重签名\n\np2sh常见的应用场景就是对多重签名的支持\n\n比特币系统中一个交易输出可能要求使用它的交易输入提供多个签名，才能把btc取出来。比如某个公司可能要求5个合伙人中的任意三个提供签名，才能把公司的钱转走。这样设计不但为私钥的泄露提供了一定安全性保护，也为私钥的丢失提供了一定的容错性。\n\ninputscript:\n\tx # 在输入脚本里往栈中添加一个没用的元素，抵消掉btc其中的一个bug。\n\tpushdata(sig 1)\n\tpushdata(sig 2)\n\tpushdata(sig m)\noutputscript:\n\tm\n\tpushdata(pubkey_1)\n\tpushdata(pubkey_2)\n\t...\n\tpushdata(pubkey n)\n\tn\n\tcheckmultisig\n\n\n> 为什么不把这个 bug 修复了呢？去中心化的系统和中心化的系统不一样。中心化的系统可以发布很多版本，去中心化的系统修改版本后会产生硬分叉。\n\n入栈执行过程\n\n 1. 第一步，将输入脚本中的多余元素（前述的x）压栈\n 2. 第二步，将输入脚本里的 m 个签名依次压入栈中（这里 m=2）\n 3. 第三步，将输出脚本中给定的阈值 m 压栈\n 4. 第四步，将输出脚本中给定的 n 个公钥压栈\n 5. 第五步，将输出脚本中给定的公钥数 n 压栈\n 6. 第六步，执行 cehckmultisig，以检查堆栈中是否按顺序包含了 n 个签名中的 m 个\n\n> 这是最早的多重签名，并没有用到 p2sh，就是用比特币脚本中原生的 cehckmultisig 实现的。 这样在实际使用时有些不方便的地方，例如电商网站开通了比特币支付渠道，但要求要有5个合伙人中3个人的签名才能把 btc 转走。但这样做之后，用户在 btc 支付的时候，生成的转账交易里也给出 5 个合伙人的公钥，同时还要给出n和m的值。 而这些公钥，以及 n 和 m 的值就要电商网站公布给用户，而且不同的电商网站规则也不一样，这就让用户生成转账交易变得不方便。因为这些复杂性都暴露给用户了\n\n\n# 用p2sh实现多重签名\n\n相比前面的实现，这样的本质是将复杂性从输出脚本转移到了赎回脚本中，输出脚本只需要给出赎回脚本的哈希值就行了。n个公钥以及n、m的值都在赎回脚本中给出来，而赎回脚本由输入脚本提供，这样也就和支付给它的用户们隔离开了。\n\n> 从用户的角度来看，采用这种p2sh的支付方式，和p2pkh支付方式没有多大区别，只不过输出脚本中的是赎回脚本的哈希值而不是公钥的哈希值 输入脚本就是电商网站要把这笔btc转出去时候用的，这种方式下输入脚本要包含m个签名，以及赎回脚本的序列化版本。 如果电商将来改变了采用的多重签名规则，就只需要改变一下赎回脚本的内容和输入脚本中的内容，然后把新的赎回脚本的哈希值公布出去就可以了。对用户而言也只是付款时候输出脚本中要包含的哈希值发生了变化。\n\n入栈执行过程：\n\n * 第一阶段\n   * 第一步，将占位元素 x 压栈\n   * 第二步，将输入脚本中的m个签名压栈\n   * 第三步，将输入脚本中保存的序列化的赎回脚本压栈\n   * 第四步，弹出栈顶元素取哈希再压栈，即将栈顶的赎回脚本取哈希\n   * 第五步，将输出脚本中给出的赎回脚本哈希值（rsh）压栈\n   * 第六步，判断栈顶两个元素是否相等，即判断一下计算出的赎回脚本哈希和给定的赎回脚本哈希是否相等\n * 第二阶段（执行 redeem script）\n   * 第一步，将签名数 m 压栈\n   * 第二步，将 n 个公钥压栈\n   * 第三步，将给定的公钥数 n 压栈\n   * 第四步，使用cehckmultisig操作检查多重签名的正确性\n\n\n\n\n# proof of burn：销毁btc\n\n一个特殊的脚本, 以 return 开始，后面可以跟任何内容。return 操作，无条件返回错误，所以该脚本永远不可能通过验证。执行到return，后续操作不会再执行。该方法是销毁比特币的一种方法。 为什么要销毁比特币？现在比特币价值极高，销毁是不是很可惜？\n\n 1. 部分小币种(altcoin)要求销毁部分比特币才能得到该种小币种。\n 2. 往区块链中写入内容。我们经常说，区块链是不可篡改的账本，有人便利用该特性往其中添加想要永久保存的内容。例如：知识产权保护——知识产权的哈希值。\n\n> 铸币交易的 coinbase 域也可以随便写什么内容，为什么不在那里写呢？因为这种方法很难，必须要获得记账权。然而发布交易不需要有记账权。 任何用户都可以用 proof of burn 的方法，销毁极少量的比特币，换取向比特币系统的区块链中写入一些内容的机会。没有销毁比特币，仅仅支付了交易费，也可以向区块链中写入内容。\n\n例如下图为一个铸币交易，其中包含两个交易，第二个交易便是仅仅想要往其中写入内容。\n\n下图为一个普通的转账交易，其就是仅仅为了向区块链写入内容。该交易并未销毁 btc，只是将输入的费用作为交易费给了挖到矿的矿工。这种交易永远不会兑现，所以矿工不会将其保存在 utxo 中，对全节点比较友好。\n\n\n\n> btc系统中使用的脚本语言很简单，它也不是图灵完备的语言，甚至不支持循环，这样设计也有其用意，不支持循环也就不会有死循环。后面学的以太坊的脚本语言就是图灵完备的，这样就靠其它机制来防止进入死循环等。\n\nbtc的脚本语言针对btc应用场景做了很好的优化，如检查多重签名时的 checkmultisig 操作一条就能实现，这是其强大之处。',charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 8",frontmatter:{},regularPath:"/blockchain/learn8.html",relativePath:"blockchain/learn8.md",key:"v-b0622042",path:"/blockchain/learn8.html",headers:[{level:2,title:"DAO",slug:"dao",normalizedTitle:"dao",charIndex:138},{level:3,title:"The DAO",slug:"the-dao",normalizedTitle:"the dao",charIndex:273},{level:2,title:"重入攻击",slug:"重入攻击",normalizedTitle:"重入攻击",charIndex:1407},{level:2,title:"The Dao 补救措施",slug:"the-dao-补救措施",normalizedTitle:"the dao 补救措施",charIndex:2301},{level:2,title:"反思",slug:"反思",normalizedTitle:"反思",charIndex:3186},{level:2,title:"美链 Beauty Chain",slug:"美链-beauty-chain",normalizedTitle:"美链 beauty chain",charIndex:4822},{level:2,title:"区块链的滥用",slug:"区块链的滥用",normalizedTitle:"区块链的滥用",charIndex:6028},{level:2,title:"法律监管和支付方式",slug:"法律监管和支付方式",normalizedTitle:"法律监管和支付方式",charIndex:6399},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6533}],lastUpdated:"6/25/2023, 4:30:00 PM",lastUpdatedTimestamp:16876818e5,headersStr:"DAO The DAO 重入攻击 The Dao 补救措施 反思 美链 Beauty Chain 区块链的滥用 法律监管和支付方式 总结",content:'# 北大肖臻老师《区块链技术与应用》公开课学习 8\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n * 参考文章：https://sinocifeng.github.io/downloadPage.html\n\n\n# DAO\n\n为何不将一切都去中心化呢 Decentralize everything. DAO(Decentralize Autonomous Organization)-去中心化自治组织就出现了。组织一般都会有自己的规章制度，DAO 的规章制度是写在代码里的。\n\n\n# The DAO\n\n2016年5月，出现一个致力于众筹投资的 Dao——The DAO（名字有点歧义）。类似于众筹的基金组织，本质上就是一个运行在以太坊上的智能合约。如果想要参与其众筹，可以将自己的以太币发送到该智能合约换回The DAO 的代币。当需要决定投资哪一个项目时，由代币持有者进行投票表决，每位参与者投票的权重由代笔多少决定。 当投资获得收益，也根据参与者代币数进行分成。\n\n传统的投资都是由几个决策者决定投资方向的，但 The DAO 的方式使得所有人都可以参与决策。2016年5月开始众筹，仅一个月时间就已经众筹得到价值极多的以太币。有人认为 3-5 年后的影响力会超过以太坊本身。但是它仅仅存在了 3 个月。\n\n考虑到投资者在投资过程中可能需要用钱，需要用代币换回以太币。在 The DAO 的设计中采用了 拆分(split DAO) 实现这一功能。其并非单纯取回收益，而是采用生成 child DAO 的方法。如果投资过程中某个小众项目不被看好，那么它可以独立出来成立为子基金，极端情况就是单个的投资人成立了 child DAO，这个人将钱投资给自己从而取回自己的投资与收益。\n\n拆分前有7天的辩论期，大家可以讨论拆分是否好并决定是否加入拆分。拆分之后，有28天锁定期，28天后才能取出这些以太币。也正是这28天的锁定期，给了以太坊补救时间（惊变28天）。这一理念是民主制度的进一步体现，不仅倡议少数服从多数，也保障了对少数人的权利尊重。但问题出现在了对 split DAO 的实现上，这导致了 The DAO 最终走向末路。下为 split DAO 的实现代码：\n\nfunction splitDAO(\n    uint _proposalID,\n    address _newCurator\n) noEther onlyTokenholders returns (bool _success) {\n    // ......\n    // Burn DAO Tokens\n    Transfer(msg.sender, 0, balances[msg.sender]);\n    withdrawRewardFor(msg.sender); // (1) 还钱给调用该函数的人\n    totalSupply -= balances[msg.sender]; // (2) 减小 The Dao 中的总金额\n    balances[msg.sender] = 0; // (3) 将调用者的账户清零\n    paidOut[msg.sender] = 0;\n    return true;\n}\n\n\n正确的做法应该是先清零再还钱，否则会造成重入攻击。\n\n\n# 重入攻击\n\n计算机程序或子程序在执行过程中中断，然后在它前一次调用完成执行之前再次进行调用，那么该程序或子程序称为重入程序。中断可能是由内部操作（如jump或call）或外部操作（如interrupt 或signal）引起的。重入调用完成后，以前的调用将恢复正常执行。使用某些代码段执行此操作将导致重入攻击。\n\n在上面的示例中，注释（1）部分进行资金转移之后，才对注释（3）账户余额状态进行修改。这时候，会让黑客可以在状态修改之前利用fallback() 函数多次调用该函数，直至取走合约账户内的全部余额。\n\n而黑客通过这一 bug 转走了价值近 5000万 的以太币。这在以太坊社区引发了巨大恐慌，从而也引发以太币价格的跳水。对此，以太坊内部进行了大讨论，主流意见分为两派:\n\n 1. 一派认为，需要对以太坊进行交易回滚（由于28天锁定期存在，黑客暂时无法取走钱），从而进行及时补救。通过交易回滚，保障投资者正当利益。\n 2. 另一派则认为，code is law，不需要采取补救措施。因为黑客行为并未违法，既然 code is law，那么代码中的bug也是规则中一部分。据说网上流传一封黑客写给以太坊社区的公开信，信中说："我并未做错任何事，我仅仅利用了代码中的 feature。既然代码中允许我可以重复、多次取钱，我仅仅是利用了这一特性而已"。这一派人认为不应该采取补救措施，更不应该进行交易的回滚。因为区块链最重要的特性便是不可篡改性，如果产生问题就进行回滚这无疑违背了这一特性。此外，此次出现问题的仅仅是以太坊之上运行的一个应用，以太坊本身并没有问题，且以太坊上存在着无数的应用，如果下一个智能合约出现问题，我们还要进行回滚吗？\n\n以太坊开发团队支持前者，主要原因的 The DAO 募集的以太币已经超过当时总流通以太币量 10%，这件事对以太坊有着巨大影响，而如果放任不管，大概其中的 1/3 将落入黑客手中，The DAO已经是以太坊生态中一个 "too big to fail" 的应用了（企业已经大而不能到了，如果倒了会对社会造成影响）。\n\n\n# The Dao 补救措施\n\n补救措施，从发生攻击的区块前一个区块处进行分叉，使得新分支最终超越原有分支可行吗？\n\n> 我们假设大家都同意该方案，不再沿着原来链继续挖下去，而是从黑客攻击区块的前一个处进行重新挖矿。然而如果这样做，上面那条链上黑客攻击的交易和其他合法交易都被回滚了，因此该方案不可行。因为 The DAO 只是以太坊上的一个智能合约，还有其他智能合约和交易呢。\n\n以太坊团队设定了两步走的方案：1.锁定黑客账户 2.设法从黑客账户退回以太币\n\n 1. 以太坊团队发布一个升级，要求凡是与 The DAO 基金账户相关的账户均不被允许进行任何交易。发布后大多数矿工都升级了这一软件，接受了这一措施。(这是一个软分叉, 旧矿工认为新区块合法, 新矿工认为旧区块不合法)。然而升级后的软件存在一个与汽油费相关的 bug：在收到一个区块发现其中包含与 The DAO 账户相关交易，那么还需要收取汽油费吗？直觉告诉我们似乎不应该要，以太坊社区这一升级也遵循了这一直觉，没有收取汽油费。这导致攻击者可以以极低的成本，发起大量的这类 非法交易 请求，导致矿工打包的区块频繁不被认可。于是软分叉的方案就失败了。\n 2. 以太坊发布了新的升级，将 The DAO 账户的资金强行转入到一个新的智能合约中，而该智能合约只有退钱（将代币退回成以太币）这一功能。这是硬分叉，软件本质是以软件升级方式强行重新记账。原本应该有账户的签名才行，但现在非常时期，凡是 The DAO 账户上的资金无论本人同意与否都强行转入到新的合约中去。升级软件规定挖到第192w个区块时，自动执行这一转账交易。旧矿工必然不认可这一规则，因为没有合法签名属于非法交易。因此最终产生硬分叉。\n\n支持者与反对者进行了激烈争论。为此开发团队开发了一个智能合约对此进行投票。最终结果是，大多数人支持进行硬分叉，大多数矿工也接受了这一升级，大家便开始等待挖出第192w个区块这一历史性时刻。这一次硬分叉成功了。从此两条链之后逐步通过 chainId 进行了区分，并共同存活了下去: ETH 和 ETC。\n\n\n# 反思\n\nIs smart contract really smart？\n\n> 智能合约与人工智能无关，其实可以称其为 自动合约 ——以事先写好代码自动执行相应规则。因此智能合约并不智能，写好之后就不可以再进行修改，实际上就相当于一个 代码合同。\n\nsmart contract is anything but smart.\n\n> 区块链的不可篡改性其实是一个双刃剑。一方面增加了合约的公信力，另一方面也意味着规则中有漏洞很难修复。中心化的软件只需要发布一个 patch （补丁）就行了，但是区块链软件更新需要硬分叉。设想你发现银行卡信息被盗，第一反应是通知银行将账户进行冻结。但如果在区块链上，你就只能看着账户中的钱被转移走。(除非比特币发布一个新版本，与你相关的交易都不接受)。 智能合约一旦发布到区块链上，就不能阻止其被调用。那么你又必须将智能合约中的钱转走。而智能合约并没有提供转走钱的方法，那就只能通过黑客的方法将剩余资金转移到新账户中。\n\nNothing is irrevocability.\n\n> 区块链真的不可篡改吗？其实是可以改的。代码是死的，人是活的，宪法都可以修宪呢。真正遇到类似 The DAO 这类重大事件，真正想要修改还是可以实现的。\n\nIs solidity the right programming language?\n\n> 一般意义上，A 给 B 转账，B 不可能会反过来调用 A。然而 solidity 语言中，A 给 B转账等于隐性调用了B的 fallback() 函数，而 B 可以通过 fallback() 来反过来调用 A。由于这与我们的常识不符，便容易忽视掉这一漏洞。有人呼吁用更安全的函数式的编程语言，且长远来看，要实现对智能合约理论上正确性的证明。 比特币脚本语言简单、表达能力差，很多功能无法表达出现。而以太坊的编程语言是图灵完备的，凡是计算机程序可以完成的，solidity 都可以将其实现。然而，图灵完备的表达能力是一种好事吗？有人认为应该选择一种适中的语言，既不要比特币脚本语言那么简单，又不要 solidity 语言那样图灵完备，希望既可以实现智能合约想要实现的功能，但又不容易出现安全漏洞。然而，找到这样一种语言是困难的，因为设计之初我们无法预料到未来的所有应用场景和所有的安全攻击。现实生活中合同也会出现纠纷，我们并未提供一种专门用于合同编写的专用语言，而是通过提供【模板】来解决。这可能是智能合约未来的发展方向，常用的智能合约可能会出现模板，也可能会出现专门编写智能合约的机构。\n\n开源软件比非开源软件安全。\n\n> 有人认为开源代码被众人所审视，其中出现安全漏洞的可能不大。虽然理论上大家都可以去看，然而实际上真正有时间和精力查看的人很少，即使看，也不一定大多数人都又足够的专业知识看出其中隐藏的漏洞。有可能我们都认为世界上这么多人，别人肯定看过了，但实际上大家可能都这么想，没有几个人真正看过开源代码。many eyeball fallacy\n\nWhat does decentrtilization mean？\n\n> 去中心化不意味着完全拒绝人的干预，不意味着完全不能修改，而是要用去中心化的方法来完成修改。以太坊团队发布升级为什么最终能够成功？因为绝大多数矿工接受了升级软件，以行动支持了分叉方案。即使如此，以太坊团队仍然不能强迫一部分人从旧链转到新链。所以以太坊团队并不能强迫大家去转换，矿工们认为以太坊的决定是符合大家利益的。\n\n分叉是坏事吗？\n\n> 在中心化的系统里，你可以选择放弃但是不能分叉。分叉导致原有一条链变成了两条。然而分叉恰恰是去中心化的体现，存在分叉，恰恰是民主精神的体现。(用户不满意，就有选择分叉的权利)\n\ndecentralized 不等于 detributed\n\n> 一个去中心化系统必然是分布式的，但分布式未必是去中心化。比特币、以太坊都属于交易驱动的状态机。\n\n\n# 美链 Beauty Chain\n\n\n\nERC 指的是 Ethereum Request for Comments.\n\n * IPO: Inital public offering, 指企业首次将自己的股份向公众出售，是中小企业融资的一种方式，通过这种方式成长型企业能够快速募集资金，吸引投资者，增强其股份在市场上的流通性，完成从私人制企业向股份制企业的转变。\n * ICO: Inital coin offering, 是区块链行业的一种融资方式，指通过发行代币（Token）的方式进行融资。每个区块链项目会根据投资者投资金额比例，发行相应的代币给投资者，这些代币往往也可以在一些数据货币交易平台（如Counterparty等）进行交易。\n * 加密货币指的是任何拥有独立区块链的加密货币（比特币、以太坊）\n * 代币是没有自己的区块链，而是依附于其他区块链的加密货币。 代币会从自己依附的区块链技术中获益。\n\n// 两个参数 接收地址，转账金额\nfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value; // 计算总金额\n    require(cnt > 0 && cnt <= 20); // 接收者最多20个\n    require(_value > 0 && balances[msg.sender] >= amount); // 检查发起调用的账户是否用足够多的代币\n\n    balances[msg.sender] = balances[msg.sender].sub(amount); // 发起调用的账户减去 amount\n    for (uint i = 0; i < cnt; i++) { // 通过循环给接收者价值 value 的代币\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n\n\n> 问题出现在计算总金额上面： uint256 amount = uint256(cnt) * _value。假如计算时，value 的值很大，这个乘法结果可能会产生溢出。溢出后算得的 amount 可能是一个很小的数。换言之在调用者账户做减法时，减掉的是一个很小的数字，但转账时，转走的仍然是一笔很大的代币。从而导致系统中凭空产生大量代币。\n\n\n# 区块链的滥用\n\n有人说保险理赔可以上链，因为现有理赔很慢。因为区块链上转账只需要确认后就完成了，与现实中数星期相比具有很大的进步。\n\n> 保险理赔速度慢，并非转账这一过程，而是审核理赔内容。而理赔确认和审核，是区块链所无法完成的。\n\n有人说用区块链做防伪溯源，将有机蔬菜生产全过程上链，在区块链上可以查到蔬菜生产销售的全过程。\n\n> 区块只能保证区块链的数据内容是不可篡改的，而无法检测数据是否真实。写入的时候本身写的就是假的内容。\n\n中心化与去中心化的界限并非是分明的。\n\n> 一个商业模式既可以存在中心化成分，也可以存在去中心化成分。比特币仅仅是一种支付方式，而采用比特币作为支付方式的商业模式本身并不是必须是去中心化的。比如亚马逊如果在未来接受比特币支付。不要因为区块链是去中心化的，而认为所有用到区块链的技术都是去中心化的。\n\n\n# 法律监管和支付方式\n\n区块链的支付方式目前不受法律监管和保护。现实中信用卡被盗刷可以申请法律监管的保护，但是区块链则不能。 有人认为区块链的交易方式与现有方式相比，支付效率低、能耗大，是不划算的。但是在跨国贸易这一背景下，比特币方式是比现有银行体系更高效的。\n\n\n# 总结\n\n不要认为去中心化、智能合约等可以解决一切问题，这就迈向了另一个极端。The DAO 即使没有黑客攻击的问题，其商业模式是否就没有问题存在？The DAO 的投资方向完全民主，由大家一起说了算，但民主就一定是好事吗？大多数人就是对的吗？\n\nDemocracy is the worst form of Government except for those other forms that have been tried from time to time',normalizedContent:'# 北大肖臻老师《区块链技术与应用》公开课学习 8\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n * 参考文章：https://sinocifeng.github.io/downloadpage.html\n\n\n# dao\n\n为何不将一切都去中心化呢 decentralize everything. dao(decentralize autonomous organization)-去中心化自治组织就出现了。组织一般都会有自己的规章制度，dao 的规章制度是写在代码里的。\n\n\n# the dao\n\n2016年5月，出现一个致力于众筹投资的 dao——the dao（名字有点歧义）。类似于众筹的基金组织，本质上就是一个运行在以太坊上的智能合约。如果想要参与其众筹，可以将自己的以太币发送到该智能合约换回the dao 的代币。当需要决定投资哪一个项目时，由代币持有者进行投票表决，每位参与者投票的权重由代笔多少决定。 当投资获得收益，也根据参与者代币数进行分成。\n\n传统的投资都是由几个决策者决定投资方向的，但 the dao 的方式使得所有人都可以参与决策。2016年5月开始众筹，仅一个月时间就已经众筹得到价值极多的以太币。有人认为 3-5 年后的影响力会超过以太坊本身。但是它仅仅存在了 3 个月。\n\n考虑到投资者在投资过程中可能需要用钱，需要用代币换回以太币。在 the dao 的设计中采用了 拆分(split dao) 实现这一功能。其并非单纯取回收益，而是采用生成 child dao 的方法。如果投资过程中某个小众项目不被看好，那么它可以独立出来成立为子基金，极端情况就是单个的投资人成立了 child dao，这个人将钱投资给自己从而取回自己的投资与收益。\n\n拆分前有7天的辩论期，大家可以讨论拆分是否好并决定是否加入拆分。拆分之后，有28天锁定期，28天后才能取出这些以太币。也正是这28天的锁定期，给了以太坊补救时间（惊变28天）。这一理念是民主制度的进一步体现，不仅倡议少数服从多数，也保障了对少数人的权利尊重。但问题出现在了对 split dao 的实现上，这导致了 the dao 最终走向末路。下为 split dao 的实现代码：\n\nfunction splitdao(\n    uint _proposalid,\n    address _newcurator\n) noether onlytokenholders returns (bool _success) {\n    // ......\n    // burn dao tokens\n    transfer(msg.sender, 0, balances[msg.sender]);\n    withdrawrewardfor(msg.sender); // (1) 还钱给调用该函数的人\n    totalsupply -= balances[msg.sender]; // (2) 减小 the dao 中的总金额\n    balances[msg.sender] = 0; // (3) 将调用者的账户清零\n    paidout[msg.sender] = 0;\n    return true;\n}\n\n\n正确的做法应该是先清零再还钱，否则会造成重入攻击。\n\n\n# 重入攻击\n\n计算机程序或子程序在执行过程中中断，然后在它前一次调用完成执行之前再次进行调用，那么该程序或子程序称为重入程序。中断可能是由内部操作（如jump或call）或外部操作（如interrupt 或signal）引起的。重入调用完成后，以前的调用将恢复正常执行。使用某些代码段执行此操作将导致重入攻击。\n\n在上面的示例中，注释（1）部分进行资金转移之后，才对注释（3）账户余额状态进行修改。这时候，会让黑客可以在状态修改之前利用fallback() 函数多次调用该函数，直至取走合约账户内的全部余额。\n\n而黑客通过这一 bug 转走了价值近 5000万 的以太币。这在以太坊社区引发了巨大恐慌，从而也引发以太币价格的跳水。对此，以太坊内部进行了大讨论，主流意见分为两派:\n\n 1. 一派认为，需要对以太坊进行交易回滚（由于28天锁定期存在，黑客暂时无法取走钱），从而进行及时补救。通过交易回滚，保障投资者正当利益。\n 2. 另一派则认为，code is law，不需要采取补救措施。因为黑客行为并未违法，既然 code is law，那么代码中的bug也是规则中一部分。据说网上流传一封黑客写给以太坊社区的公开信，信中说："我并未做错任何事，我仅仅利用了代码中的 feature。既然代码中允许我可以重复、多次取钱，我仅仅是利用了这一特性而已"。这一派人认为不应该采取补救措施，更不应该进行交易的回滚。因为区块链最重要的特性便是不可篡改性，如果产生问题就进行回滚这无疑违背了这一特性。此外，此次出现问题的仅仅是以太坊之上运行的一个应用，以太坊本身并没有问题，且以太坊上存在着无数的应用，如果下一个智能合约出现问题，我们还要进行回滚吗？\n\n以太坊开发团队支持前者，主要原因的 the dao 募集的以太币已经超过当时总流通以太币量 10%，这件事对以太坊有着巨大影响，而如果放任不管，大概其中的 1/3 将落入黑客手中，the dao已经是以太坊生态中一个 "too big to fail" 的应用了（企业已经大而不能到了，如果倒了会对社会造成影响）。\n\n\n# the dao 补救措施\n\n补救措施，从发生攻击的区块前一个区块处进行分叉，使得新分支最终超越原有分支可行吗？\n\n> 我们假设大家都同意该方案，不再沿着原来链继续挖下去，而是从黑客攻击区块的前一个处进行重新挖矿。然而如果这样做，上面那条链上黑客攻击的交易和其他合法交易都被回滚了，因此该方案不可行。因为 the dao 只是以太坊上的一个智能合约，还有其他智能合约和交易呢。\n\n以太坊团队设定了两步走的方案：1.锁定黑客账户 2.设法从黑客账户退回以太币\n\n 1. 以太坊团队发布一个升级，要求凡是与 the dao 基金账户相关的账户均不被允许进行任何交易。发布后大多数矿工都升级了这一软件，接受了这一措施。(这是一个软分叉, 旧矿工认为新区块合法, 新矿工认为旧区块不合法)。然而升级后的软件存在一个与汽油费相关的 bug：在收到一个区块发现其中包含与 the dao 账户相关交易，那么还需要收取汽油费吗？直觉告诉我们似乎不应该要，以太坊社区这一升级也遵循了这一直觉，没有收取汽油费。这导致攻击者可以以极低的成本，发起大量的这类 非法交易 请求，导致矿工打包的区块频繁不被认可。于是软分叉的方案就失败了。\n 2. 以太坊发布了新的升级，将 the dao 账户的资金强行转入到一个新的智能合约中，而该智能合约只有退钱（将代币退回成以太币）这一功能。这是硬分叉，软件本质是以软件升级方式强行重新记账。原本应该有账户的签名才行，但现在非常时期，凡是 the dao 账户上的资金无论本人同意与否都强行转入到新的合约中去。升级软件规定挖到第192w个区块时，自动执行这一转账交易。旧矿工必然不认可这一规则，因为没有合法签名属于非法交易。因此最终产生硬分叉。\n\n支持者与反对者进行了激烈争论。为此开发团队开发了一个智能合约对此进行投票。最终结果是，大多数人支持进行硬分叉，大多数矿工也接受了这一升级，大家便开始等待挖出第192w个区块这一历史性时刻。这一次硬分叉成功了。从此两条链之后逐步通过 chainid 进行了区分，并共同存活了下去: eth 和 etc。\n\n\n# 反思\n\nis smart contract really smart？\n\n> 智能合约与人工智能无关，其实可以称其为 自动合约 ——以事先写好代码自动执行相应规则。因此智能合约并不智能，写好之后就不可以再进行修改，实际上就相当于一个 代码合同。\n\nsmart contract is anything but smart.\n\n> 区块链的不可篡改性其实是一个双刃剑。一方面增加了合约的公信力，另一方面也意味着规则中有漏洞很难修复。中心化的软件只需要发布一个 patch （补丁）就行了，但是区块链软件更新需要硬分叉。设想你发现银行卡信息被盗，第一反应是通知银行将账户进行冻结。但如果在区块链上，你就只能看着账户中的钱被转移走。(除非比特币发布一个新版本，与你相关的交易都不接受)。 智能合约一旦发布到区块链上，就不能阻止其被调用。那么你又必须将智能合约中的钱转走。而智能合约并没有提供转走钱的方法，那就只能通过黑客的方法将剩余资金转移到新账户中。\n\nnothing is irrevocability.\n\n> 区块链真的不可篡改吗？其实是可以改的。代码是死的，人是活的，宪法都可以修宪呢。真正遇到类似 the dao 这类重大事件，真正想要修改还是可以实现的。\n\nis solidity the right programming language?\n\n> 一般意义上，a 给 b 转账，b 不可能会反过来调用 a。然而 solidity 语言中，a 给 b转账等于隐性调用了b的 fallback() 函数，而 b 可以通过 fallback() 来反过来调用 a。由于这与我们的常识不符，便容易忽视掉这一漏洞。有人呼吁用更安全的函数式的编程语言，且长远来看，要实现对智能合约理论上正确性的证明。 比特币脚本语言简单、表达能力差，很多功能无法表达出现。而以太坊的编程语言是图灵完备的，凡是计算机程序可以完成的，solidity 都可以将其实现。然而，图灵完备的表达能力是一种好事吗？有人认为应该选择一种适中的语言，既不要比特币脚本语言那么简单，又不要 solidity 语言那样图灵完备，希望既可以实现智能合约想要实现的功能，但又不容易出现安全漏洞。然而，找到这样一种语言是困难的，因为设计之初我们无法预料到未来的所有应用场景和所有的安全攻击。现实生活中合同也会出现纠纷，我们并未提供一种专门用于合同编写的专用语言，而是通过提供【模板】来解决。这可能是智能合约未来的发展方向，常用的智能合约可能会出现模板，也可能会出现专门编写智能合约的机构。\n\n开源软件比非开源软件安全。\n\n> 有人认为开源代码被众人所审视，其中出现安全漏洞的可能不大。虽然理论上大家都可以去看，然而实际上真正有时间和精力查看的人很少，即使看，也不一定大多数人都又足够的专业知识看出其中隐藏的漏洞。有可能我们都认为世界上这么多人，别人肯定看过了，但实际上大家可能都这么想，没有几个人真正看过开源代码。many eyeball fallacy\n\nwhat does decentrtilization mean？\n\n> 去中心化不意味着完全拒绝人的干预，不意味着完全不能修改，而是要用去中心化的方法来完成修改。以太坊团队发布升级为什么最终能够成功？因为绝大多数矿工接受了升级软件，以行动支持了分叉方案。即使如此，以太坊团队仍然不能强迫一部分人从旧链转到新链。所以以太坊团队并不能强迫大家去转换，矿工们认为以太坊的决定是符合大家利益的。\n\n分叉是坏事吗？\n\n> 在中心化的系统里，你可以选择放弃但是不能分叉。分叉导致原有一条链变成了两条。然而分叉恰恰是去中心化的体现，存在分叉，恰恰是民主精神的体现。(用户不满意，就有选择分叉的权利)\n\ndecentralized 不等于 detributed\n\n> 一个去中心化系统必然是分布式的，但分布式未必是去中心化。比特币、以太坊都属于交易驱动的状态机。\n\n\n# 美链 beauty chain\n\n\n\nerc 指的是 ethereum request for comments.\n\n * ipo: inital public offering, 指企业首次将自己的股份向公众出售，是中小企业融资的一种方式，通过这种方式成长型企业能够快速募集资金，吸引投资者，增强其股份在市场上的流通性，完成从私人制企业向股份制企业的转变。\n * ico: inital coin offering, 是区块链行业的一种融资方式，指通过发行代币（token）的方式进行融资。每个区块链项目会根据投资者投资金额比例，发行相应的代币给投资者，这些代币往往也可以在一些数据货币交易平台（如counterparty等）进行交易。\n * 加密货币指的是任何拥有独立区块链的加密货币（比特币、以太坊）\n * 代币是没有自己的区块链，而是依附于其他区块链的加密货币。 代币会从自己依附的区块链技术中获益。\n\n// 两个参数 接收地址，转账金额\nfunction batchtransfer(address[] _receivers, uint256 _value) public whennotpaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value; // 计算总金额\n    require(cnt > 0 && cnt <= 20); // 接收者最多20个\n    require(_value > 0 && balances[msg.sender] >= amount); // 检查发起调用的账户是否用足够多的代币\n\n    balances[msg.sender] = balances[msg.sender].sub(amount); // 发起调用的账户减去 amount\n    for (uint i = 0; i < cnt; i++) { // 通过循环给接收者价值 value 的代币\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n\n\n> 问题出现在计算总金额上面： uint256 amount = uint256(cnt) * _value。假如计算时，value 的值很大，这个乘法结果可能会产生溢出。溢出后算得的 amount 可能是一个很小的数。换言之在调用者账户做减法时，减掉的是一个很小的数字，但转账时，转走的仍然是一笔很大的代币。从而导致系统中凭空产生大量代币。\n\n\n# 区块链的滥用\n\n有人说保险理赔可以上链，因为现有理赔很慢。因为区块链上转账只需要确认后就完成了，与现实中数星期相比具有很大的进步。\n\n> 保险理赔速度慢，并非转账这一过程，而是审核理赔内容。而理赔确认和审核，是区块链所无法完成的。\n\n有人说用区块链做防伪溯源，将有机蔬菜生产全过程上链，在区块链上可以查到蔬菜生产销售的全过程。\n\n> 区块只能保证区块链的数据内容是不可篡改的，而无法检测数据是否真实。写入的时候本身写的就是假的内容。\n\n中心化与去中心化的界限并非是分明的。\n\n> 一个商业模式既可以存在中心化成分，也可以存在去中心化成分。比特币仅仅是一种支付方式，而采用比特币作为支付方式的商业模式本身并不是必须是去中心化的。比如亚马逊如果在未来接受比特币支付。不要因为区块链是去中心化的，而认为所有用到区块链的技术都是去中心化的。\n\n\n# 法律监管和支付方式\n\n区块链的支付方式目前不受法律监管和保护。现实中信用卡被盗刷可以申请法律监管的保护，但是区块链则不能。 有人认为区块链的交易方式与现有方式相比，支付效率低、能耗大，是不划算的。但是在跨国贸易这一背景下，比特币方式是比现有银行体系更高效的。\n\n\n# 总结\n\n不要认为去中心化、智能合约等可以解决一切问题，这就迈向了另一个极端。the dao 即使没有黑客攻击的问题，其商业模式是否就没有问题存在？the dao 的投资方向完全民主，由大家一起说了算，但民主就一定是好事吗？大多数人就是对的吗？\n\ndemocracy is the worst form of government except for those other forms that have been tried from time to time',charsets:{cjk:!0}},{title:"图解HTTP",frontmatter:{},regularPath:"/book/http.html",relativePath:"book/http.md",key:"v-723ecb02",path:"/book/http.html",headers:[{level:2,title:"第四章 状态码",slug:"第四章-状态码",normalizedTitle:"第四章 状态码",charIndex:13}],lastUpdated:"7/14/2022, 8:08:21 PM",lastUpdatedTimestamp:1657800501e3,headersStr:"第四章 状态码",content:"# 图解HTTP\n\n\n# 第四章 状态码",normalizedContent:"# 图解http\n\n\n# 第四章 状态码",charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 6",frontmatter:{},regularPath:"/blockchain/learn6.html",relativePath:"blockchain/learn6.md",key:"v-31c31d1f",path:"/blockchain/learn6.html",headers:[{level:2,title:"Ghost 协议",slug:"ghost-协议",normalizedTitle:"ghost 协议",charIndex:131},{level:3,title:"具体例子",slug:"具体例子",normalizedTitle:"具体例子",charIndex:2090},{level:2,title:"ETH 挖矿算法",slug:"eth-挖矿算法",normalizedTitle:"eth 挖矿算法",charIndex:2491},{level:3,title:"预挖矿(pre mining)",slug:"预挖矿-pre-mining",normalizedTitle:"预挖矿(pre mining)",charIndex:5598},{level:2,title:"以太坊挖矿难度调整",slug:"以太坊挖矿难度调整",normalizedTitle:"以太坊挖矿难度调整",charIndex:6037},{level:3,title:"难度炸弹",slug:"难度炸弹",normalizedTitle:"难度炸弹",charIndex:6057},{level:3,title:"以太坊发展的四个阶段",slug:"以太坊发展的四个阶段",normalizedTitle:"以太坊发展的四个阶段",charIndex:6468},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:6536}],lastUpdated:"6/5/2023, 5:21:42 PM",lastUpdatedTimestamp:1685956902e3,headersStr:"Ghost 协议 具体例子 ETH 挖矿算法 预挖矿(pre mining) 以太坊挖矿难度调整 难度炸弹 以太坊发展的四个阶段 代码实现",content:'# 北大肖臻老师《区块链技术与应用》公开课学习 6\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n * 参考文章：北京大学肖臻老师《区块链技术与应用》公开课笔记20——ETH中GHOST协议篇\n\n\n# Ghost 协议\n\nBTC 系统中出块时间为 10min，而以太坊中出块时间被降低到 15s左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。在 BTC 系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。 对此，以太坊设计了新的共识协议—— GHOST协议 (该协议并非原创，而是对原本就有的Ghost协议进行了改进)。\n\n\n\n> 如图，假定以太坊系统存在以下情况，A、B、C、D 在四个分支上，最后，随着时间推移 B 所在链成为最长合法链，因此 A、C、D 区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些 补偿，并称其为 Uncle Block（叔父区块）。 规定 E 区块在发布时可以将 A、C、D 叔父区块包含进来，A、C、D 叔父区块可以得到出块奖励的 7/8，而为了激励 E 包含叔父区块，规定 E 每包含一个叔父区块可以额外得到 1/32 的出块奖励。为了防止 E 大量包含叔父区块，规定一个区块只能最多包含 2 个叔父区块，因此 E 在 A、C、D 中最多只能包含 2 个区块作为自己的出块奖励。 E 把 A 作为叔父区块的前提是：在挖 E 这个区块的时候就知道 A 的存在了，把 A 写在自己的块头里修改后继续挖，因为挖矿是无记忆性的所以这并不影响什么。\n\n问题：\n\n 1. 因为叔父区块最多只能包含 2 个，如果出现 3 个怎么办？\n 2. 矿工自私，故意不包含叔父区块，导致叔父区块 7/8 出块奖励没了，而自己仅仅损失 1/32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。\n\n\n\n> 如图1为对上面例子的补充，F 为 E 后面一个新的区块。因为规定 E 最多只能包含 2 个叔父区块，所以假定 E 包含了 C 和 D。此时，F 也可以将 A 认为自己的的叔父区块(实际上并非叔父辈的，而是爷爷辈的)。如果继续往下挖，F 后的新区块仍然可以包含 B 同辈的区块。这样，就有效地解决了上面的问题。 就算自己挖的区块成为了叔父区块，自己也可以在最长合法链上挖，然后把自己包含进去。\n\n问题：叔父 最多可以隔多少代？\n\n\n\n> 以太坊中规定，如果 M 包含 F 区块，则 F 获得 7/8 出块奖励；如果 M 包含 E 区块，则 F 获得 6/8 出块奖励，以此类推向前。直到包含 A 区块，A获得 2/8 出块奖励，再往前的叔父区块，对于 M 来说就不再认可其为 M 的叔父了(合法的叔父只有 6 辈)。对于 M 来说，无论包含哪个辈分的叔父，得到的出块奖励都是 1/32 出块奖励。 这样，就方便了全节点进行记录（有效叔父区块不会无限增加），此外，也从协议上鼓励一旦出现分叉马上进行合并。\n\n以上这些都是为了解决临时性分叉的问题，那么为什么比特币和以太坊要设计最长合法链呢，是为了防止数据被篡改。\n\n * BTC 奖励：block reward（静态奖励）+ tx fee（动态奖励）\n * ETH 奖励：block reward（静态奖励）+ gas fee（动态奖励，叔父区块是得不到的）\n * BTC 中为了人为制造稀缺性，比特币每隔一段时间出块奖励会降低，最终当出块奖励趋于 0 后会主要依赖于交易费运作。而以太坊中并没有人为规定每隔一段时间降低出块奖励。\n\n> 如果区块里包含智能合约，执行智能合约的时候会获得汽油费。但是所占的比例很小，跟比特币类似交易费占比很小。\n\n把叔父区块包含进来的时候，叔父区块里的交易要不要执行？\n\n> 不应该，叔父区块和同辈的主链上区块有可能包含有冲突的交易。执行完父区块的交易再去执行叔父区块的交易可能就变成非法的了。因此，一个节点在收到一个叔父区块的时候，只检查区块合法性而不检查其中交易的合法性。\n\n分叉后的区块后面还跟着其他区块怎么处理？\n\n> A->F 该链并非一个最长合法链，所以 B->F 这些区块怎么办？可不可以规定将下面整条链作为一个整体，给予出块奖励？ 不行，这一定程度上鼓励了分叉攻击(如果 A 转给 B 一大笔钱，B 等了很多区块后觉得没什么问题了，此时 A 发动分叉攻击将钱转给 A\'，这需要挖出更多的区块代价是很大的，但是，后面的区块都给奖励，这就降低了分叉攻击的成本，因为即使攻击失败也有奖励)。因此，ETH 系统中规定，只认可 A 区块为叔父区块，给予其补偿，而其后的区块全部作废。\n\n\n# 具体例子\n\nhttps://etherscan.io/\n\n\n\n * Block Height 为当前区块的序号，UncleNumber 为叔父区块的序号\n * 如果相差为 1，说明是刚刚相差一辈，获得 7/8 的奖励，以此类推\n\n\n\n * Block Reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（1个, 0.09375 = 3 * 1 / 32）\n * Uncles Reward: 叔父区块获得的奖励，通过计算可知隔两代，2.25 = 3 * 6 / 8\n\n\n\n * Block Reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（2个, 0.1875 = 3 * 2 * 1 / 32）\n * Uncles Reward: 叔父区块获得的奖励，通过计算可知分别隔两代和隔一代，4.875 = 2.25 (3 * 6 / 8) + 2.625 (3 * 7 / 8)\n\n\n# ETH 挖矿算法\n\nBlock chain is secured by mining. 比特币是天然的 bug bounty，只要你能找到挖矿的 bug，就能获得赏金。然而比特币的缺点在于专业矿机的出现，不是很符合去中心化的概念。中本聪写到 one cpu, one vote，希望每个人都能参与进去。所以后来的加密货币在设计挖矿算法的时候，希望 ASIC resistance，怎么解决呢？\n\n * memory hard mining puzzle: 增加对内存的访问, 因为 ASIC 主要是算力强，但是内存访问能力弱。一个例子就是 LiteCoin，它是基于 scrypt 对于内存要求较高，在内存中创建了一个比较大的数组进行运算。\n\n好的 puzzle 的准则是 diffculty to solve, but easy to verify，但是上述算法在验证的时候也需要同样大小的数组，对于轻节点不友好，如果是手机上的 APP 则很难实现，所以实际上莱特币设计的数组大小为 128K。但是这种理念对于莱特币的 冷启动 很有意义。\n\nETH 中设计了两个数据集：16M cache 和 1G dataset (DAG)。\n\n> 16M cache 生成方式：通过 Seed (种子数)进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。 1G DAG 生成方式：从小数组中按照伪随机顺序读取一些元素，如第一次读取 A 位置数据，对当前哈希值更新迭代算出下一次读取位置 B，再进行哈希值更新迭代计算出 C 位置元素。如此来回迭代读取 256 次，最终算出一个数作为 DAG 中第一个元素。 考虑到计算机内存不断增大，因此该两个数组需要定期增大。 轻节点只保存小的 cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过 Cache 计算 DAG 上面，因此，其必须保存大的数组 DAG 以便于更快挖矿。\n\n以太坊挖矿过程：\n\n> 根据区块 block header 和其中的 Nonce 值计算一个初始哈希，在 DAG 上根据其映射到某个初始位置 A1，读取 A1 位置的数及其相邻的后一个位置 A2 上的数，根据该两个数进行运算，算得下一个位置 B1，读取 B1 和 B2 位置上的数，依次类推，迭代读取 64 次，共读取 128 个数。最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就更换 Nonce，重复以上操作直到最终计算哈希值符合难度要求。\n\n每隔 30000 个块会重新生成 seed （对原来的 seed 求哈希），并且利用新的 seed 生成新的 cache，cache 的初始大小为 16M，每隔 30000 个块重新生成时增大初始大小的 1/128 - 128K，通过 seed 计算 cache 的伪代码：\n\ndef mkcache(cache_size, seed):\n  o = [hash(seed)]\n  for i in range (1, cache_size):\n    o.append(hash(o[-1]))\n  return o;\n\n\nDAG 初始大小是 1G，也是每隔 30000 个块更新，同时增大初始大小的 1/128 - 8M，通过 cache 来生成 dataset 中第 i 个元素的伪代码\n\ndef calc_dataset_item(cache, i):\n  cache_size = cache.size\n  # 通过 cache 中第 i 个元素生成 mix\n  mix = hash(cache[i % cache_size] ^ i)\n  # 循环 256 次\n  for j in range(256):\n    # 每次通过 get_int_from_item 根据当前的 mix 求得下一个 cache 元素的下标\n    cache_index = get_int_from_item(mix)\n    mix = make_item(mix, cache[cache_index % cache_size])\n   # 最终返回 mix 的哈希值，得到第 i 个 dataset 中的元素\n   return hash(mix)\n\n\n挖矿过程与轻节点验证过程，先通过 header 和 nonce 求出一个初始的 mix，然后进行 64 次循环，根据 mix 求出要访问的 dataset 的元素下标，然后根据这个下标访问 dataset 中两个连续的值。\n\ndef hashimoto_full(header, nonce, full_size, dataset):\n  mix = hash(header, nonce)\n  for i in range(64):\n    dataset_index = get_int_from_item(mix) % full_size\n    mix = make_item(mix, dataset[dataset_index])\n    mix = make_item(mix, dataset[dataset_index + 1])\n  return hash(mix)\n\n# 轻节点是临时计算出用到的 dataset 元素，而矿工是直接访存\ndef hashimoto_light(header, nonce, full_size, dataset):\n  mix = hash(header, nonce)\n  for i in range(64):\n    dataset_index = get_int_from_item(mix) % full_size\n    mix = make_item(mix, calc_dataset_item[cache, dataset_index])\n    mix = make_item(mix, calc_dataset_item[cache, dataset_index + 1])\n  return hash(mix)\n\n\n挖矿伪代码，随机初始化 nonce，再一个个重试 nonce\n\ndef mine(full_size, dataset, header, target):\n  nonce = random.randint(0, 2**64)\n  while hashimoto_full(header, nonce, full_size, dataset) > target:\n    nonce = (nonce + 1) % 2**64\n  return nonce\n\n\n> 目前以太坊挖矿以 GPU 为主，可见其设计较为成功，这与以太坊设计的挖矿算法 (Ethash) 所需要的大内存具有很大关系。 1G的大数组与128k相比，差距8000多倍，即使是16MB与128K相比，也大了一百多倍，可见对内存需求的差距很大，况且两个数组大小是会不断增长的。\n> \n> 当然，以太坊实现 ASIC Resistance 除了挖矿算法设计之外，还存在另外一个原因，即其预期从工作量证明(proof of work)转向权益证明(proof of stake)\n> \n> 而这对于 ASIC 厂商来说有威胁。因为 ASIC 芯片研发周期很长，成本很高，如果以太坊转入权益证明，这些投入的研发费用将全部白费，但截至目前，以太坊仍然基于 POW 共识机制。\n\n\n# 预挖矿(pre mining)\n\n以太坊中采用的预挖矿的机制。这里 预挖矿 并不挖矿，而是在开发以太坊时，给开发者预留了一部分货币，其实这部分预留了很多(在 Genesis 创世纪块)。 和 Pre-Mining 对应，还有 Pre-Sale，Pre-Sale 指的是将预留的货币出售掉用于后续开发工作（众筹）\n\n> 挖矿算法设计一直趋向于让大众参与，这才是公平的。但也有人认为让普通计算机参与挖矿是不安全的，像比特币那样，让中心化矿池参与挖矿才是安全的。为什么呢？ 因为要攻击系统，需要购入大量矿机通过算力进行 51% 攻击，而且这种矿机不能用于其他币种。而且攻击成功后，证明安全性不够必然导致该币的价值跳水，攻击者投入的硬件成本将会全部打水漂。相反让通用计算机也参与挖矿，发动攻击成本便大幅度降低，目前的大型互联网公司，将其服务器聚集起来进行攻击即可，而攻击完成后这些服务器仍然可以转而运行日常业务。因此有人认为在挖矿上面，ASIC 矿机一统天下才是最安全的方式。\n\n\n# 以太坊挖矿难度调整\n\n\n\n\n\n\n\n\n# 难度炸弹\n\n以太坊在设计之初就计划要逐步从 POW（工作量证明）转向 POS（权益证明），而权益证明不需要挖矿。从旁观者角度来看，挖矿消耗了大量电力、资金等，如果转入放弃挖矿必然是一件好事。但从矿工的角度，花费了很大精力投入成本购买设备，突然被告知不挖矿了，这必然是一件很难接受的事情。因此，以太坊在设计之初便添加了难度炸弹，迫使矿工转入 POS。\n\n\n\n> 难度炸弹属于指数级别，在以太坊早期时，区块号较小难度炸弹计算所得值较小，难度调整级别基本上通过难度调整中的自适应难度调整部分决定，而随着越来越多区块被挖出，难度炸弹的威力开始显露出来，这也就使得挖矿变得越来越难，从而迫使矿工愿意转入 POS。 但是目前以太坊共识机制仍然是 POW，依然需要矿工参与挖矿维护以太坊系统的稳定。所以以太坊决定将区块号减去 300w 个（就是上面图中的公示）\n\n\n\n> 上图中展示了回退 300w 个区块前后的难度炸弹的为例\n\n\n# 以太坊发展的四个阶段\n\n以太坊发展存在四个阶段，我们目前处于第三个阶段中的拜占庭阶段，难度炸弹回调就是在拜占庭阶段进行的。\n\n\n\n\n# 代码实现\n\nfunc calcDifficultyByzantium(curVersion string, time uint64, parent *types.Header) *big.Int {\n\t// https://github.com/MatrixAINetwork/EIPs/issues/100.\n\t// algorithm:\n\t// diff = (parent_diff +\n\t//         (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))\n\t//        ) + 2^(periodCount - 2)\n\n\tbigTime := new(big.Int).SetUint64(time) // 当前区块时间戳\n\tbigParentTime := new(big.Int).Set(parent.Time) // 父区块时间戳\n\n\t// holds intermediate values to make the algo easier to read & audit\n\tx := new(big.Int)\n\ty := new(big.Int)\n\tlogger := log.New("CalcDifficulty diff", parent.Difficulty)\n\t// (2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9\n\tx.Sub(bigTime, bigParentTime) // 当前区块时间戳 - 父区块时间戳 = 出块时间\n\tvar durationLimit *big.Int\n\tif manversion.VersionCmp(curVersion, manversion.VersionGamma) >= 0 {\n\t\tdurationLimit = params.VersionGammaDurationLimit\n\t} else {\n\t\tdurationLimit = params.DurationLimit\n\t}\n\tlogger.Info("CalcDifficulty diff", "duration", durationLimit.String())\n\tx.Div(x, durationLimit)\n\tif parent.UncleHash == types.EmptyUncleHash {\n\t\tx.Sub(big1, x)\n\t} else {\n\t\tx.Sub(big2, x)\n\t}\n\t// max((2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9, -99)\n\tif x.Cmp(bigMinus99) < 0 {\n\t\tx.Set(bigMinus99)\n\t}\n\t// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))\n\ty.Div(parent.Difficulty, params.DifficultyBoundDivisor)\n\tif y.Sign() == 0 {\n\t\ty = big1\n\t}\n\tx.Mul(y, x)\n\tx.Add(parent.Difficulty, x)\n  logger.Info("cal Diff", "x", x, "y", y, "minDiff", params.MinimumDifficulty)\n\t// minimum difficulty can ever be (before exponential factor)\n\tif x.Cmp(params.MinimumDifficulty) < 0 {\n\t\tx.Set(params.MinimumDifficulty) // MinimumDifficulty 是难度下限 D0\n\t}\n\t// calculate a fake block number for the ice-age delay:\n\t//   https://github.com/MatrixAINetwork/EIPs/pull/669\n\t//   fake_block_number = min(0, block.number - 3_000_000\n\tfakeBlockNumber := new(big.Int)\n\tif parent.Number.Cmp(big2999999) >= 0 {\n\t\tfakeBlockNumber = fakeBlockNumber.Sub(parent.Number, big2999999) // Note, parent is 1 less than the actual block number\n\t}\n\t// for the exponential factor\n\tperiodCount := fakeBlockNumber\n\tperiodCount.Div(periodCount, expDiffPeriod)\n\n\t// the exponential factor, commonly referred to as "the bomb"\n\t// diff = diff + 2^(periodCount - 2)\n\tif periodCount.Cmp(big1) > 0 {\n\t\ty.Sub(periodCount, big2)\n\t\ty.Exp(big2, y, nil)\n\t\tx.Add(x, y)\n\t}\n\treturn x\n}\n',normalizedContent:'# 北大肖臻老师《区块链技术与应用》公开课学习 6\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n * 参考文章：北京大学肖臻老师《区块链技术与应用》公开课笔记20——eth中ghost协议篇\n\n\n# ghost 协议\n\nbtc 系统中出块时间为 10min，而以太坊中出块时间被降低到 15s左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。在 btc 系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。 对此，以太坊设计了新的共识协议—— ghost协议 (该协议并非原创，而是对原本就有的ghost协议进行了改进)。\n\n\n\n> 如图，假定以太坊系统存在以下情况，a、b、c、d 在四个分支上，最后，随着时间推移 b 所在链成为最长合法链，因此 a、c、d 区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些 补偿，并称其为 uncle block（叔父区块）。 规定 e 区块在发布时可以将 a、c、d 叔父区块包含进来，a、c、d 叔父区块可以得到出块奖励的 7/8，而为了激励 e 包含叔父区块，规定 e 每包含一个叔父区块可以额外得到 1/32 的出块奖励。为了防止 e 大量包含叔父区块，规定一个区块只能最多包含 2 个叔父区块，因此 e 在 a、c、d 中最多只能包含 2 个区块作为自己的出块奖励。 e 把 a 作为叔父区块的前提是：在挖 e 这个区块的时候就知道 a 的存在了，把 a 写在自己的块头里修改后继续挖，因为挖矿是无记忆性的所以这并不影响什么。\n\n问题：\n\n 1. 因为叔父区块最多只能包含 2 个，如果出现 3 个怎么办？\n 2. 矿工自私，故意不包含叔父区块，导致叔父区块 7/8 出块奖励没了，而自己仅仅损失 1/32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。\n\n\n\n> 如图1为对上面例子的补充，f 为 e 后面一个新的区块。因为规定 e 最多只能包含 2 个叔父区块，所以假定 e 包含了 c 和 d。此时，f 也可以将 a 认为自己的的叔父区块(实际上并非叔父辈的，而是爷爷辈的)。如果继续往下挖，f 后的新区块仍然可以包含 b 同辈的区块。这样，就有效地解决了上面的问题。 就算自己挖的区块成为了叔父区块，自己也可以在最长合法链上挖，然后把自己包含进去。\n\n问题：叔父 最多可以隔多少代？\n\n\n\n> 以太坊中规定，如果 m 包含 f 区块，则 f 获得 7/8 出块奖励；如果 m 包含 e 区块，则 f 获得 6/8 出块奖励，以此类推向前。直到包含 a 区块，a获得 2/8 出块奖励，再往前的叔父区块，对于 m 来说就不再认可其为 m 的叔父了(合法的叔父只有 6 辈)。对于 m 来说，无论包含哪个辈分的叔父，得到的出块奖励都是 1/32 出块奖励。 这样，就方便了全节点进行记录（有效叔父区块不会无限增加），此外，也从协议上鼓励一旦出现分叉马上进行合并。\n\n以上这些都是为了解决临时性分叉的问题，那么为什么比特币和以太坊要设计最长合法链呢，是为了防止数据被篡改。\n\n * btc 奖励：block reward（静态奖励）+ tx fee（动态奖励）\n * eth 奖励：block reward（静态奖励）+ gas fee（动态奖励，叔父区块是得不到的）\n * btc 中为了人为制造稀缺性，比特币每隔一段时间出块奖励会降低，最终当出块奖励趋于 0 后会主要依赖于交易费运作。而以太坊中并没有人为规定每隔一段时间降低出块奖励。\n\n> 如果区块里包含智能合约，执行智能合约的时候会获得汽油费。但是所占的比例很小，跟比特币类似交易费占比很小。\n\n把叔父区块包含进来的时候，叔父区块里的交易要不要执行？\n\n> 不应该，叔父区块和同辈的主链上区块有可能包含有冲突的交易。执行完父区块的交易再去执行叔父区块的交易可能就变成非法的了。因此，一个节点在收到一个叔父区块的时候，只检查区块合法性而不检查其中交易的合法性。\n\n分叉后的区块后面还跟着其他区块怎么处理？\n\n> a->f 该链并非一个最长合法链，所以 b->f 这些区块怎么办？可不可以规定将下面整条链作为一个整体，给予出块奖励？ 不行，这一定程度上鼓励了分叉攻击(如果 a 转给 b 一大笔钱，b 等了很多区块后觉得没什么问题了，此时 a 发动分叉攻击将钱转给 a\'，这需要挖出更多的区块代价是很大的，但是，后面的区块都给奖励，这就降低了分叉攻击的成本，因为即使攻击失败也有奖励)。因此，eth 系统中规定，只认可 a 区块为叔父区块，给予其补偿，而其后的区块全部作废。\n\n\n# 具体例子\n\nhttps://etherscan.io/\n\n\n\n * block height 为当前区块的序号，unclenumber 为叔父区块的序号\n * 如果相差为 1，说明是刚刚相差一辈，获得 7/8 的奖励，以此类推\n\n\n\n * block reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（1个, 0.09375 = 3 * 1 / 32）\n * uncles reward: 叔父区块获得的奖励，通过计算可知隔两代，2.25 = 3 * 6 / 8\n\n\n\n * block reward: 出块奖励 + 汽油费 + 包含叔父区块奖励（2个, 0.1875 = 3 * 2 * 1 / 32）\n * uncles reward: 叔父区块获得的奖励，通过计算可知分别隔两代和隔一代，4.875 = 2.25 (3 * 6 / 8) + 2.625 (3 * 7 / 8)\n\n\n# eth 挖矿算法\n\nblock chain is secured by mining. 比特币是天然的 bug bounty，只要你能找到挖矿的 bug，就能获得赏金。然而比特币的缺点在于专业矿机的出现，不是很符合去中心化的概念。中本聪写到 one cpu, one vote，希望每个人都能参与进去。所以后来的加密货币在设计挖矿算法的时候，希望 asic resistance，怎么解决呢？\n\n * memory hard mining puzzle: 增加对内存的访问, 因为 asic 主要是算力强，但是内存访问能力弱。一个例子就是 litecoin，它是基于 scrypt 对于内存要求较高，在内存中创建了一个比较大的数组进行运算。\n\n好的 puzzle 的准则是 diffculty to solve, but easy to verify，但是上述算法在验证的时候也需要同样大小的数组，对于轻节点不友好，如果是手机上的 app 则很难实现，所以实际上莱特币设计的数组大小为 128k。但是这种理念对于莱特币的 冷启动 很有意义。\n\neth 中设计了两个数据集：16m cache 和 1g dataset (dag)。\n\n> 16m cache 生成方式：通过 seed (种子数)进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。 1g dag 生成方式：从小数组中按照伪随机顺序读取一些元素，如第一次读取 a 位置数据，对当前哈希值更新迭代算出下一次读取位置 b，再进行哈希值更新迭代计算出 c 位置元素。如此来回迭代读取 256 次，最终算出一个数作为 dag 中第一个元素。 考虑到计算机内存不断增大，因此该两个数组需要定期增大。 轻节点只保存小的 cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过 cache 计算 dag 上面，因此，其必须保存大的数组 dag 以便于更快挖矿。\n\n以太坊挖矿过程：\n\n> 根据区块 block header 和其中的 nonce 值计算一个初始哈希，在 dag 上根据其映射到某个初始位置 a1，读取 a1 位置的数及其相邻的后一个位置 a2 上的数，根据该两个数进行运算，算得下一个位置 b1，读取 b1 和 b2 位置上的数，依次类推，迭代读取 64 次，共读取 128 个数。最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就更换 nonce，重复以上操作直到最终计算哈希值符合难度要求。\n\n每隔 30000 个块会重新生成 seed （对原来的 seed 求哈希），并且利用新的 seed 生成新的 cache，cache 的初始大小为 16m，每隔 30000 个块重新生成时增大初始大小的 1/128 - 128k，通过 seed 计算 cache 的伪代码：\n\ndef mkcache(cache_size, seed):\n  o = [hash(seed)]\n  for i in range (1, cache_size):\n    o.append(hash(o[-1]))\n  return o;\n\n\ndag 初始大小是 1g，也是每隔 30000 个块更新，同时增大初始大小的 1/128 - 8m，通过 cache 来生成 dataset 中第 i 个元素的伪代码\n\ndef calc_dataset_item(cache, i):\n  cache_size = cache.size\n  # 通过 cache 中第 i 个元素生成 mix\n  mix = hash(cache[i % cache_size] ^ i)\n  # 循环 256 次\n  for j in range(256):\n    # 每次通过 get_int_from_item 根据当前的 mix 求得下一个 cache 元素的下标\n    cache_index = get_int_from_item(mix)\n    mix = make_item(mix, cache[cache_index % cache_size])\n   # 最终返回 mix 的哈希值，得到第 i 个 dataset 中的元素\n   return hash(mix)\n\n\n挖矿过程与轻节点验证过程，先通过 header 和 nonce 求出一个初始的 mix，然后进行 64 次循环，根据 mix 求出要访问的 dataset 的元素下标，然后根据这个下标访问 dataset 中两个连续的值。\n\ndef hashimoto_full(header, nonce, full_size, dataset):\n  mix = hash(header, nonce)\n  for i in range(64):\n    dataset_index = get_int_from_item(mix) % full_size\n    mix = make_item(mix, dataset[dataset_index])\n    mix = make_item(mix, dataset[dataset_index + 1])\n  return hash(mix)\n\n# 轻节点是临时计算出用到的 dataset 元素，而矿工是直接访存\ndef hashimoto_light(header, nonce, full_size, dataset):\n  mix = hash(header, nonce)\n  for i in range(64):\n    dataset_index = get_int_from_item(mix) % full_size\n    mix = make_item(mix, calc_dataset_item[cache, dataset_index])\n    mix = make_item(mix, calc_dataset_item[cache, dataset_index + 1])\n  return hash(mix)\n\n\n挖矿伪代码，随机初始化 nonce，再一个个重试 nonce\n\ndef mine(full_size, dataset, header, target):\n  nonce = random.randint(0, 2**64)\n  while hashimoto_full(header, nonce, full_size, dataset) > target:\n    nonce = (nonce + 1) % 2**64\n  return nonce\n\n\n> 目前以太坊挖矿以 gpu 为主，可见其设计较为成功，这与以太坊设计的挖矿算法 (ethash) 所需要的大内存具有很大关系。 1g的大数组与128k相比，差距8000多倍，即使是16mb与128k相比，也大了一百多倍，可见对内存需求的差距很大，况且两个数组大小是会不断增长的。\n> \n> 当然，以太坊实现 asic resistance 除了挖矿算法设计之外，还存在另外一个原因，即其预期从工作量证明(proof of work)转向权益证明(proof of stake)\n> \n> 而这对于 asic 厂商来说有威胁。因为 asic 芯片研发周期很长，成本很高，如果以太坊转入权益证明，这些投入的研发费用将全部白费，但截至目前，以太坊仍然基于 pow 共识机制。\n\n\n# 预挖矿(pre mining)\n\n以太坊中采用的预挖矿的机制。这里 预挖矿 并不挖矿，而是在开发以太坊时，给开发者预留了一部分货币，其实这部分预留了很多(在 genesis 创世纪块)。 和 pre-mining 对应，还有 pre-sale，pre-sale 指的是将预留的货币出售掉用于后续开发工作（众筹）\n\n> 挖矿算法设计一直趋向于让大众参与，这才是公平的。但也有人认为让普通计算机参与挖矿是不安全的，像比特币那样，让中心化矿池参与挖矿才是安全的。为什么呢？ 因为要攻击系统，需要购入大量矿机通过算力进行 51% 攻击，而且这种矿机不能用于其他币种。而且攻击成功后，证明安全性不够必然导致该币的价值跳水，攻击者投入的硬件成本将会全部打水漂。相反让通用计算机也参与挖矿，发动攻击成本便大幅度降低，目前的大型互联网公司，将其服务器聚集起来进行攻击即可，而攻击完成后这些服务器仍然可以转而运行日常业务。因此有人认为在挖矿上面，asic 矿机一统天下才是最安全的方式。\n\n\n# 以太坊挖矿难度调整\n\n\n\n\n\n\n\n\n# 难度炸弹\n\n以太坊在设计之初就计划要逐步从 pow（工作量证明）转向 pos（权益证明），而权益证明不需要挖矿。从旁观者角度来看，挖矿消耗了大量电力、资金等，如果转入放弃挖矿必然是一件好事。但从矿工的角度，花费了很大精力投入成本购买设备，突然被告知不挖矿了，这必然是一件很难接受的事情。因此，以太坊在设计之初便添加了难度炸弹，迫使矿工转入 pos。\n\n\n\n> 难度炸弹属于指数级别，在以太坊早期时，区块号较小难度炸弹计算所得值较小，难度调整级别基本上通过难度调整中的自适应难度调整部分决定，而随着越来越多区块被挖出，难度炸弹的威力开始显露出来，这也就使得挖矿变得越来越难，从而迫使矿工愿意转入 pos。 但是目前以太坊共识机制仍然是 pow，依然需要矿工参与挖矿维护以太坊系统的稳定。所以以太坊决定将区块号减去 300w 个（就是上面图中的公示）\n\n\n\n> 上图中展示了回退 300w 个区块前后的难度炸弹的为例\n\n\n# 以太坊发展的四个阶段\n\n以太坊发展存在四个阶段，我们目前处于第三个阶段中的拜占庭阶段，难度炸弹回调就是在拜占庭阶段进行的。\n\n\n\n\n# 代码实现\n\nfunc calcdifficultybyzantium(curversion string, time uint64, parent *types.header) *big.int {\n\t// https://github.com/matrixainetwork/eips/issues/100.\n\t// algorithm:\n\t// diff = (parent_diff +\n\t//         (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))\n\t//        ) + 2^(periodcount - 2)\n\n\tbigtime := new(big.int).setuint64(time) // 当前区块时间戳\n\tbigparenttime := new(big.int).set(parent.time) // 父区块时间戳\n\n\t// holds intermediate values to make the algo easier to read & audit\n\tx := new(big.int)\n\ty := new(big.int)\n\tlogger := log.new("calcdifficulty diff", parent.difficulty)\n\t// (2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9\n\tx.sub(bigtime, bigparenttime) // 当前区块时间戳 - 父区块时间戳 = 出块时间\n\tvar durationlimit *big.int\n\tif manversion.versioncmp(curversion, manversion.versiongamma) >= 0 {\n\t\tdurationlimit = params.versiongammadurationlimit\n\t} else {\n\t\tdurationlimit = params.durationlimit\n\t}\n\tlogger.info("calcdifficulty diff", "duration", durationlimit.string())\n\tx.div(x, durationlimit)\n\tif parent.unclehash == types.emptyunclehash {\n\t\tx.sub(big1, x)\n\t} else {\n\t\tx.sub(big2, x)\n\t}\n\t// max((2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9, -99)\n\tif x.cmp(bigminus99) < 0 {\n\t\tx.set(bigminus99)\n\t}\n\t// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))\n\ty.div(parent.difficulty, params.difficultybounddivisor)\n\tif y.sign() == 0 {\n\t\ty = big1\n\t}\n\tx.mul(y, x)\n\tx.add(parent.difficulty, x)\n  logger.info("cal diff", "x", x, "y", y, "mindiff", params.minimumdifficulty)\n\t// minimum difficulty can ever be (before exponential factor)\n\tif x.cmp(params.minimumdifficulty) < 0 {\n\t\tx.set(params.minimumdifficulty) // minimumdifficulty 是难度下限 d0\n\t}\n\t// calculate a fake block number for the ice-age delay:\n\t//   https://github.com/matrixainetwork/eips/pull/669\n\t//   fake_block_number = min(0, block.number - 3_000_000\n\tfakeblocknumber := new(big.int)\n\tif parent.number.cmp(big2999999) >= 0 {\n\t\tfakeblocknumber = fakeblocknumber.sub(parent.number, big2999999) // note, parent is 1 less than the actual block number\n\t}\n\t// for the exponential factor\n\tperiodcount := fakeblocknumber\n\tperiodcount.div(periodcount, expdiffperiod)\n\n\t// the exponential factor, commonly referred to as "the bomb"\n\t// diff = diff + 2^(periodcount - 2)\n\tif periodcount.cmp(big1) > 0 {\n\t\ty.sub(periodcount, big2)\n\t\ty.exp(big2, y, nil)\n\t\tx.add(x, y)\n\t}\n\treturn x\n}\n',charsets:{cjk:!0}},{title:"北大肖臻老师《区块链技术与应用》公开课学习 7",frontmatter:{},regularPath:"/blockchain/learn7.html",relativePath:"blockchain/learn7.md",key:"v-6cc9067f",path:"/blockchain/learn7.html",headers:[{level:2,title:"权益证明",slug:"权益证明",normalizedTitle:"权益证明",charIndex:118},{level:3,title:"两边下注",slug:"两边下注",normalizedTitle:"两边下注",charIndex:781},{level:3,title:"以太坊权益证明",slug:"以太坊权益证明",normalizedTitle:"以太坊权益证明",charIndex:868},{level:2,title:"智能合约",slug:"智能合约",normalizedTitle:"智能合约",charIndex:216},{level:3,title:"智能合约的优点",slug:"智能合约的优点",normalizedTitle:"智能合约的优点",charIndex:2132},{level:3,title:"智能合约的应用",slug:"智能合约的应用",normalizedTitle:"智能合约的应用",charIndex:2345},{level:3,title:"智能合约的调用",slug:"智能合约的调用",normalizedTitle:"智能合约的调用",charIndex:2600},{level:3,title:"智能合约的创建与运行",slug:"智能合约的创建与运行",normalizedTitle:"智能合约的创建与运行",charIndex:2769},{level:3,title:"汽油费",slug:"汽油费",normalizedTitle:"汽油费",charIndex:2868},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:3961},{level:3,title:"嵌套调用",slug:"嵌套调用",normalizedTitle:"嵌套调用",charIndex:4076},{level:3,title:"挖矿与智能合约执行",slug:"挖矿与智能合约执行",normalizedTitle:"挖矿与智能合约执行",charIndex:4087},{level:3,title:"地址类型",slug:"地址类型",normalizedTitle:"地址类型",charIndex:5063},{level:3,title:"code is law",slug:"code-is-law",normalizedTitle:"code is law",charIndex:5190},{level:3,title:"锁仓",slug:"锁仓",normalizedTitle:"锁仓",charIndex:5332}],lastUpdated:"6/25/2023, 4:30:00 PM",lastUpdatedTimestamp:16876818e5,headersStr:"权益证明 两边下注 以太坊权益证明 智能合约 智能合约的优点 智能合约的应用 智能合约的调用 智能合约的创建与运行 汽油费 错误处理 嵌套调用 挖矿与智能合约执行 地址类型 code is law 锁仓",content:"# 北大肖臻老师《区块链技术与应用》公开课学习 7\n\n * 学习地址：https://www.bilibili.com/video/BV1Vt411X7JF\n * 参考文章：[北京大学肖臻老师《区块链技术与应用》公开课笔记24——ETH权益证明篇](https://blog.nowcoder.net/n/a509ac93c75242438e71cb47fe59229c、北京大学肖臻老师《区块链技术与应用》公开课笔记25——ETH智能合约篇1\n\n\n# 权益证明\n\n比特币的挖矿过程，消耗了巨大的电力，并且能耗随时间不断增长，平均每一个交易消耗 1000 度电。同样地以太坊平均每一个交易消耗 67 度电。\n\n> 矿工为什么要挖矿？因为要获得出块奖励。为什么要给矿工奖励？因为激励矿工参与区块链的维护。 挖矿的收益是由『拼钱』（买矿机）决定的，那么既然是拼钱，我们直接把钱拿出来比一比行不行？与其买矿机挖矿，我们不如把钱投入到区块链的维护当中，由投入资金的比例来决定最终的收益。这就是 proof of stake 权益证明的思想。\n\n优点：\n\n * 省去了挖矿的过程，减少了能耗，减少了温室气体的排放。\n * 维护区块链安全的资源形成闭环，而 POW 中维护其安全的资源需要通过现实中流通的货币购买矿机等设备，这也就导致只要有人想要攻击，只需要外部聚集足够资金达到 51% 算力就可以攻击成功。主流的货币抗攻击能力还比较强，刚刚发行的小币种，遇到这种攻击是致命的。Altcoin Infanticide。\n\n权益证明是基于拥有的币，如果想发动攻击必须获取一半以上的币，无论你在外部有多少的资金，都不会对加密货币系统造成直接的影响，你只能花钱买到足够多的币才可以（内部闭环），如果一旦有人花钱大量买币，会导致价格大涨，这对开发者是有好处的可以大赚一笔。\n\n\n# 两边下注\n\n假如一个区块链出现了分叉，如果挖矿会沿着最长合法链去挖，虽然另一条也有可能成为最长合法链，但是你只会沿着一条去挖。但是如果是权益证明，你可以两边都下注。\n\n\n# 以太坊权益证明\n\nCasper the Friendly Finality Gadget(FFG)\n\nCasper 协议引入一个概念 validator 验证者，想成为 validator 必须投入一定的保证金，保证金会被系统锁定。他的职责是推动系统达成共识，投票决定哪条链成为最长合法链，投票的权重为保证金的数目。第一轮投票是 prepare message，第二轮投票是 commit message，每一轮投票都要得到 2/3 以上的验证者同意。实际上 100 个区块的 epoch 分成两个 50 个区块，每 50 个区块结束后就进行一轮投票。\n\n> 矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然某个验证者行政不作为，不参与投票导致系统迟迟无法达成共识，这时扣掉部分保证金；如果某个验证者乱作为，给两边都进行投票，被发现后没收全部保证金。没收后的保证金直接销毁掉。 每个验证者有一定时间的任期，在任期结束后，进入等待期，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定奖励。\n\n通过验证者投票达成的 Finality，有没有可能被推翻？\n\n> 假如某个恶意的组织要发生攻击，假如他们是矿工的话，没有验证者作为同伙则无法推翻 Finality。矿工无论算力多么强，最终投票权都不在其手中。 必须在系统中，存在大量验证者进行了两边投票，也就是说，至少 1/3（该协议规定超过2/3才有效）的验证者两侧都投票，才会导致系统被篡改。而这一旦被发现，这 1/3 验证者的保证金将会被没收。\n\n以太坊系统设想，随着时间推移，挖矿奖励逐渐减少而权益证明奖励逐渐增多，从而实现POW到POS的过渡，最终实现完全放弃挖矿。\n\n既然权益证明这么好，那么为什么没有推广开来？\n\n> 比特币和以太坊的机制都经过了 bug bounty，工作量证明已经得到了事实检验，该机制较为成熟。 例如 EOS 柚子加密货币，它用的就是权益证明的思想，用的是 DPOS：Delegated Proof of Stake 协议，通过投票选 21 个超级节点，再由超级节点产生区块。基于权益证明的机制仍然处于探索阶段。\n\n有人认为挖矿消耗的电并不是很多，而且其对于环境的影响是有限的。很多人对工作量证明其实是反感做的是无用功。挖矿提供了将电能转换为钱的手段，而电能本身难以传输和存储。挖矿为将多余的电能转换为有价值的货币提供了很好的解决手段。也就是说挖矿消耗电能可以有效消耗过剩产能，带动当地经济发展。\n\n\n# 智能合约\n\n智能合约的概念最早是由 Nick Szabo 在 1994 年提出的。智能合约是一个计算机层面的交易协议，用于执行一系列的合约项。合约旨在满足一些常见的合约条件。\n\n很多区块链网络使用的智能合约功能类似于自动售货机或者说是一个电子合同。智能合约与自动售货机类比：如果你向自动售货机（类比分类账本）转入比特币或其他加密货币，一旦输入满足智能合约代码要求，它会自动执行双方约定的义务。\n\n\n# 智能合约的优点\n\n * 自治 智能合约独立运行在遍布世界各地的计算机上，不依赖于任何中心化的系统。\n * 可信 智能合约可信的特点是基于分布式账本的，这些账本可以执行并验证合约。\n * 鲁棒性 智能合约存在于分布式的网络中，单点缺失或破坏并不会有影响。\n * 速度 智能合约的去中心化的处理过程可以在短时间内完成对业务逻辑的处理。\n * 经济 智能合约消除了对律师、见证人以及其他中间机构所构成的庞大的中介链的需求。\n\n\n# 智能合约的应用\n\n> 知识产权保护：智能合约可以帮助创作者保护他们的知识产权，由于对 NFT 等数字商品的担忧，这一点变得越来越重要。创作者可以使用智能合约，在交易过程中转移或保留他们对某一内容的所有权。例如，NFT 创造者可能希望保留对其艺术作品的所有权，同时将代币的所有权转让给买方。在 NFT 的智能合约中，他们可以概述明确的所有权和支付条款，以保护他们的权利。 艺术家也可以使用智能合约获得版税。任何时候，只要他们的艺术作品的 NFT 或副本售出，智能合约就可以触发分销商向艺术家的自动付款。\n\n\n# 智能合约的调用\n\n以太坊中智能合约编写代码为 Solidity，其语法与 JavaScript 很接近。 调用智能合约其实和转账类似，比如 A 发起一个交易转账给 B，如果 B 是一个普通的账户这就是一次普通转账，但是 B 如果是一个合约账户，这就是发起了对 B 合约的调用。外部账户可以调用合约账户，合约账户也可以调用合约账户\n\n\n# 智能合约的创建与运行\n\nEVM 设计思想类似于 JAVA 中的 JVM ，便于跨平台增强可移植性。EVM 中寻址空间 256位，而目前个人机主流位 32位和 64位，与之存在较大差距。\n\n\n\n\n# 汽油费\n\n比特币相比于以太坊很简单，脚本语言都不支持循环。而以太坊提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致一些问题，例如当一个全节点收到一个对智能合约调用怎么知晓其是否会导致死循环。\n\n事实上无法预知其是否会导致死循环，实际上该问题是一个停机问题，而停机问题不可解。因此，以太坊引入汽油费机制将该问题扔给了发起交易的账户。以太坊规定执行合约中指令需要收取汽油费，并且由发起交易的人进行支付。\n\n\n\n * Price: 单位汽油价格\n * GasLimit: 愿意支付最大汽油量\n * Recipient: 收款人地址\n * Amount: 转账金额\n * Payload: data 域\n\n当一个全节点收到一个对智能合约的调用，先按照最大汽油费收取从其账户一次性扣除，再根据实际执行情况多退少补(汽油费不够会引发回滚，而非简单的补齐)。一般计算量较大、存储量较大的复杂指令的汽油费比较贵。\n\n> 以太坊中存在 gaslimit，通过收取汽油费保障系统中不会存在对资源消耗特别大的调用。但与比特币不同，比特币直接通过限制区块大小 1MB 保障对网络资源压力不会过大，这 1MB 大小是固定的无法修改。而以太坊中每个矿工都可以以前一个区块中 gaslimt 为基数，进行上调或下调 1/1024，从而通过绝大多数区块不断上下调整，保证得到一个较为理想化的 gaslimt 值。最终整个系统的 gaslimt 就是所有矿工希望的平均值。\n\n> 在比特币系统中，交易是比较简单的，仅仅是转账操作，也就是说可以通过交易的字节数衡量出交易所需要消耗的资源多少。但以太坊中引入了智能合约，而智能合约逻辑很复杂，其字节数与消耗资源数并无关联。存在某些交易，从字节数来看很小，但其实际消耗资源很大(例如调用其他合约等)，因此要根据交易的具体操作收费，所有引入了汽油费这一概念。 在 block header 中包含了 gaslimit，其并非将所有交易的消耗汽油费相加，而是该区块中所有交易能够消耗的资源的上限。\n\n汽油费是怎么扣除的？\n\n> 首先，之前在以太坊数据结构中介绍了以太坊中三棵树——状态树、交易树、收据树。这三棵树都位于全节点中，是全节点在本地维护的数据结构，记录了每个账户的状态等数据，所以该节点收到调用时，是在本地对该账户的余额减掉即可。所以多个全节点每人扣一次，仅仅是每个全节点各自在本地扣一次。 也就是说，智能合约在执行过程中，修改的都是本地的数据结构，只有在该智能合约被发布到区块链上，所有节点才需要同步状态，各自在本地执行该智能合约。\n\n\n# 错误处理\n\n以太坊中交易具有原子性，要么全执行，要么全不执行，不会只执行一部分(包含普通转账交易和智能合约)。在执行过程中产生错误导致回滚，已经消耗掉的汽油费是不会退回的。从而有效防止了恶意节点对全节点进行恶意调用。\n\n\n\n\n# 嵌套调用\n\n\n\n\n# 挖矿与智能合约执行\n\n假设全节点要打包一些交易到区块中，其中存在某些交易是对智能合约的调用。全节点应该先执行智能合约再挖矿，还是先挖矿获得记账权后执行智能合约？\n\n如果先挖矿后执行智能合约会如何？\n\n> 智能合约会导致数据结构发生改变，从而修改掉区块中的内容，那么之前挖矿时挖到的 nonce 是不适用于此时修改过后的 block的，也就是说执行智能合约后的区块并非之前的区块，之前的 nonce 不能适用于当前区块，从而无法被加入到区块链中。挖矿导致三棵树数据结构改变，之前挖到的矿就无效了。所以，在以太坊系统中，必然是先执行智能合约，后挖矿。\n\n假如某个矿工执行智能合约消耗了很多资源，但是记账权被别人拿到了，矿工会得到什么补偿？\n\n> 汽油费是没有的，只给获得记账权发布区块的那个矿工进行补偿。以太坊中没有任何补偿，不仅如此还要把发布区块中的交易执行一次更新三棵树的内容算出根哈希值，和别人发布的进行比较。这种情况下挖矿慢的矿工特别吃亏。\n\n会不会有的矿工想不开，你不给我汽油费，那我就不验证你发布区块的正确性？\n\n> 这种情况如果发生最直接的后果是危害区块链的安全。如果他跳过验证过程，本地三棵树的内容没有更新，算出的根哈希值就不对了，以后发布的区块就没人会认了。\n\n发布到区块链上的交易，是不是都是成功执行的？智能合约发生错误，要不要也发不到区块链上去？\n\n> 不一定，执行发生错误的交易也要发布到区块链上去，这样才能成功扣除汽油费。如果交易不被发布到区块链上，是无法收取汽油费的。\n\n智能合约支持多线程吗？\n\n> 多核处理器很常见，计算机可以有很多核，那么智能合约支不支持多核并行处理呢。Solidity 不支持多线程，因为以太坊本质为一个交易驱动的状态机，给定一个智能合约，面对同一组输入，必须转移到一个确定的状态，因为所有的全节点都要执行同一组操作来验证。但对于多线程来说，同一组输入的输入顺序不同，最终的结果可能不一致。 此外，其他可能导致执行结果不确定的操作也不支持，例如：产生随机数。因此，以太坊中的随机数是伪随机数，不能产生真正意义的随机数。 也正是因为其不支持多线程，所以无法通过系统调用获得系统信息，因为每个全节点环境并非完全一样。因此只能通过固定的结构获取。下图分别为为其可以获得的区块链信息和调用信息。\n\n\n\n\n\n\n# 地址类型\n\n\n\n在以太坊中，转账有以下三种方法。\n\n * transfer: 在转账失败后会导致连锁性回滚，抛出异常；\n * send: 转账失败会返回false，不会导致连锁性回滚\n * call: 本意是用于发动函数调用，但是也可以进行转账\n\n\n# code is law\n\nCode is law！智能合约规则是代码逻辑决定的，而发布到区块链上后就再也无法修改。这样的好处是，没有人可以篡改规则；这一的坏处是，规则如果有漏洞，也无法进行修改和补救。智能合约如果设计的不够好，就有可能将收到的以太币永久性锁死，谁也取不出来。\n\n\n# 锁仓\n\n> 通过智能合约进行锁仓。例如某个团队决定一起开发某个新型加密货币，开发中进行“pre mining”，给开发者预留一部分币。将这些预留币打入到一个合约账户，锁仓三年。三年后，这些币才可以参与交易，从而便于开发者可以集中精力进行这种加密货币开发工作。 但是万一在写入时候多写一个0，从3年变成30年，那这些币就会被锁仓30年，没有任何办法取出这些币。这有些类似于【不可撤销的信托(irrevocable trust)】，有些有钱人会采用这种方式来达到财产保护和减税的目的。如果在制定这种不可撤销的信托时，法律条款设置存在漏洞，也可能会导致存入的钱无法取出。 因此，在发布一个智能合约之前，需要进行大量、严格的测试。可以去专门的 testnet 网站上，采用虚假的以太币进行测试，确认完全没有问题后再发布。\n\n是否可以在智能合约中留一个后门，用于修复bug？例如给合约创建者超级用户的权力 例如前文例子，记录owner，记录owner的地址，当出现这种问题后其可以及时进行修复。这样做，会存在owner卷款跑路的风险。这样做前提是所有人都要相信这个超级管理员，而这于去中心化的理念背道而驰，是绝大多数区块链用户所不能接受的。",normalizedContent:"# 北大肖臻老师《区块链技术与应用》公开课学习 7\n\n * 学习地址：https://www.bilibili.com/video/bv1vt411x7jf\n * 参考文章：[北京大学肖臻老师《区块链技术与应用》公开课笔记24——eth权益证明篇](https://blog.nowcoder.net/n/a509ac93c75242438e71cb47fe59229c、北京大学肖臻老师《区块链技术与应用》公开课笔记25——eth智能合约篇1\n\n\n# 权益证明\n\n比特币的挖矿过程，消耗了巨大的电力，并且能耗随时间不断增长，平均每一个交易消耗 1000 度电。同样地以太坊平均每一个交易消耗 67 度电。\n\n> 矿工为什么要挖矿？因为要获得出块奖励。为什么要给矿工奖励？因为激励矿工参与区块链的维护。 挖矿的收益是由『拼钱』（买矿机）决定的，那么既然是拼钱，我们直接把钱拿出来比一比行不行？与其买矿机挖矿，我们不如把钱投入到区块链的维护当中，由投入资金的比例来决定最终的收益。这就是 proof of stake 权益证明的思想。\n\n优点：\n\n * 省去了挖矿的过程，减少了能耗，减少了温室气体的排放。\n * 维护区块链安全的资源形成闭环，而 pow 中维护其安全的资源需要通过现实中流通的货币购买矿机等设备，这也就导致只要有人想要攻击，只需要外部聚集足够资金达到 51% 算力就可以攻击成功。主流的货币抗攻击能力还比较强，刚刚发行的小币种，遇到这种攻击是致命的。altcoin infanticide。\n\n权益证明是基于拥有的币，如果想发动攻击必须获取一半以上的币，无论你在外部有多少的资金，都不会对加密货币系统造成直接的影响，你只能花钱买到足够多的币才可以（内部闭环），如果一旦有人花钱大量买币，会导致价格大涨，这对开发者是有好处的可以大赚一笔。\n\n\n# 两边下注\n\n假如一个区块链出现了分叉，如果挖矿会沿着最长合法链去挖，虽然另一条也有可能成为最长合法链，但是你只会沿着一条去挖。但是如果是权益证明，你可以两边都下注。\n\n\n# 以太坊权益证明\n\ncasper the friendly finality gadget(ffg)\n\ncasper 协议引入一个概念 validator 验证者，想成为 validator 必须投入一定的保证金，保证金会被系统锁定。他的职责是推动系统达成共识，投票决定哪条链成为最长合法链，投票的权重为保证金的数目。第一轮投票是 prepare message，第二轮投票是 commit message，每一轮投票都要得到 2/3 以上的验证者同意。实际上 100 个区块的 epoch 分成两个 50 个区块，每 50 个区块结束后就进行一轮投票。\n\n> 矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然某个验证者行政不作为，不参与投票导致系统迟迟无法达成共识，这时扣掉部分保证金；如果某个验证者乱作为，给两边都进行投票，被发现后没收全部保证金。没收后的保证金直接销毁掉。 每个验证者有一定时间的任期，在任期结束后，进入等待期，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定奖励。\n\n通过验证者投票达成的 finality，有没有可能被推翻？\n\n> 假如某个恶意的组织要发生攻击，假如他们是矿工的话，没有验证者作为同伙则无法推翻 finality。矿工无论算力多么强，最终投票权都不在其手中。 必须在系统中，存在大量验证者进行了两边投票，也就是说，至少 1/3（该协议规定超过2/3才有效）的验证者两侧都投票，才会导致系统被篡改。而这一旦被发现，这 1/3 验证者的保证金将会被没收。\n\n以太坊系统设想，随着时间推移，挖矿奖励逐渐减少而权益证明奖励逐渐增多，从而实现pow到pos的过渡，最终实现完全放弃挖矿。\n\n既然权益证明这么好，那么为什么没有推广开来？\n\n> 比特币和以太坊的机制都经过了 bug bounty，工作量证明已经得到了事实检验，该机制较为成熟。 例如 eos 柚子加密货币，它用的就是权益证明的思想，用的是 dpos：delegated proof of stake 协议，通过投票选 21 个超级节点，再由超级节点产生区块。基于权益证明的机制仍然处于探索阶段。\n\n有人认为挖矿消耗的电并不是很多，而且其对于环境的影响是有限的。很多人对工作量证明其实是反感做的是无用功。挖矿提供了将电能转换为钱的手段，而电能本身难以传输和存储。挖矿为将多余的电能转换为有价值的货币提供了很好的解决手段。也就是说挖矿消耗电能可以有效消耗过剩产能，带动当地经济发展。\n\n\n# 智能合约\n\n智能合约的概念最早是由 nick szabo 在 1994 年提出的。智能合约是一个计算机层面的交易协议，用于执行一系列的合约项。合约旨在满足一些常见的合约条件。\n\n很多区块链网络使用的智能合约功能类似于自动售货机或者说是一个电子合同。智能合约与自动售货机类比：如果你向自动售货机（类比分类账本）转入比特币或其他加密货币，一旦输入满足智能合约代码要求，它会自动执行双方约定的义务。\n\n\n# 智能合约的优点\n\n * 自治 智能合约独立运行在遍布世界各地的计算机上，不依赖于任何中心化的系统。\n * 可信 智能合约可信的特点是基于分布式账本的，这些账本可以执行并验证合约。\n * 鲁棒性 智能合约存在于分布式的网络中，单点缺失或破坏并不会有影响。\n * 速度 智能合约的去中心化的处理过程可以在短时间内完成对业务逻辑的处理。\n * 经济 智能合约消除了对律师、见证人以及其他中间机构所构成的庞大的中介链的需求。\n\n\n# 智能合约的应用\n\n> 知识产权保护：智能合约可以帮助创作者保护他们的知识产权，由于对 nft 等数字商品的担忧，这一点变得越来越重要。创作者可以使用智能合约，在交易过程中转移或保留他们对某一内容的所有权。例如，nft 创造者可能希望保留对其艺术作品的所有权，同时将代币的所有权转让给买方。在 nft 的智能合约中，他们可以概述明确的所有权和支付条款，以保护他们的权利。 艺术家也可以使用智能合约获得版税。任何时候，只要他们的艺术作品的 nft 或副本售出，智能合约就可以触发分销商向艺术家的自动付款。\n\n\n# 智能合约的调用\n\n以太坊中智能合约编写代码为 solidity，其语法与 javascript 很接近。 调用智能合约其实和转账类似，比如 a 发起一个交易转账给 b，如果 b 是一个普通的账户这就是一次普通转账，但是 b 如果是一个合约账户，这就是发起了对 b 合约的调用。外部账户可以调用合约账户，合约账户也可以调用合约账户\n\n\n# 智能合约的创建与运行\n\nevm 设计思想类似于 java 中的 jvm ，便于跨平台增强可移植性。evm 中寻址空间 256位，而目前个人机主流位 32位和 64位，与之存在较大差距。\n\n\n\n\n# 汽油费\n\n比特币相比于以太坊很简单，脚本语言都不支持循环。而以太坊提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致一些问题，例如当一个全节点收到一个对智能合约调用怎么知晓其是否会导致死循环。\n\n事实上无法预知其是否会导致死循环，实际上该问题是一个停机问题，而停机问题不可解。因此，以太坊引入汽油费机制将该问题扔给了发起交易的账户。以太坊规定执行合约中指令需要收取汽油费，并且由发起交易的人进行支付。\n\n\n\n * price: 单位汽油价格\n * gaslimit: 愿意支付最大汽油量\n * recipient: 收款人地址\n * amount: 转账金额\n * payload: data 域\n\n当一个全节点收到一个对智能合约的调用，先按照最大汽油费收取从其账户一次性扣除，再根据实际执行情况多退少补(汽油费不够会引发回滚，而非简单的补齐)。一般计算量较大、存储量较大的复杂指令的汽油费比较贵。\n\n> 以太坊中存在 gaslimit，通过收取汽油费保障系统中不会存在对资源消耗特别大的调用。但与比特币不同，比特币直接通过限制区块大小 1mb 保障对网络资源压力不会过大，这 1mb 大小是固定的无法修改。而以太坊中每个矿工都可以以前一个区块中 gaslimt 为基数，进行上调或下调 1/1024，从而通过绝大多数区块不断上下调整，保证得到一个较为理想化的 gaslimt 值。最终整个系统的 gaslimt 就是所有矿工希望的平均值。\n\n> 在比特币系统中，交易是比较简单的，仅仅是转账操作，也就是说可以通过交易的字节数衡量出交易所需要消耗的资源多少。但以太坊中引入了智能合约，而智能合约逻辑很复杂，其字节数与消耗资源数并无关联。存在某些交易，从字节数来看很小，但其实际消耗资源很大(例如调用其他合约等)，因此要根据交易的具体操作收费，所有引入了汽油费这一概念。 在 block header 中包含了 gaslimit，其并非将所有交易的消耗汽油费相加，而是该区块中所有交易能够消耗的资源的上限。\n\n汽油费是怎么扣除的？\n\n> 首先，之前在以太坊数据结构中介绍了以太坊中三棵树——状态树、交易树、收据树。这三棵树都位于全节点中，是全节点在本地维护的数据结构，记录了每个账户的状态等数据，所以该节点收到调用时，是在本地对该账户的余额减掉即可。所以多个全节点每人扣一次，仅仅是每个全节点各自在本地扣一次。 也就是说，智能合约在执行过程中，修改的都是本地的数据结构，只有在该智能合约被发布到区块链上，所有节点才需要同步状态，各自在本地执行该智能合约。\n\n\n# 错误处理\n\n以太坊中交易具有原子性，要么全执行，要么全不执行，不会只执行一部分(包含普通转账交易和智能合约)。在执行过程中产生错误导致回滚，已经消耗掉的汽油费是不会退回的。从而有效防止了恶意节点对全节点进行恶意调用。\n\n\n\n\n# 嵌套调用\n\n\n\n\n# 挖矿与智能合约执行\n\n假设全节点要打包一些交易到区块中，其中存在某些交易是对智能合约的调用。全节点应该先执行智能合约再挖矿，还是先挖矿获得记账权后执行智能合约？\n\n如果先挖矿后执行智能合约会如何？\n\n> 智能合约会导致数据结构发生改变，从而修改掉区块中的内容，那么之前挖矿时挖到的 nonce 是不适用于此时修改过后的 block的，也就是说执行智能合约后的区块并非之前的区块，之前的 nonce 不能适用于当前区块，从而无法被加入到区块链中。挖矿导致三棵树数据结构改变，之前挖到的矿就无效了。所以，在以太坊系统中，必然是先执行智能合约，后挖矿。\n\n假如某个矿工执行智能合约消耗了很多资源，但是记账权被别人拿到了，矿工会得到什么补偿？\n\n> 汽油费是没有的，只给获得记账权发布区块的那个矿工进行补偿。以太坊中没有任何补偿，不仅如此还要把发布区块中的交易执行一次更新三棵树的内容算出根哈希值，和别人发布的进行比较。这种情况下挖矿慢的矿工特别吃亏。\n\n会不会有的矿工想不开，你不给我汽油费，那我就不验证你发布区块的正确性？\n\n> 这种情况如果发生最直接的后果是危害区块链的安全。如果他跳过验证过程，本地三棵树的内容没有更新，算出的根哈希值就不对了，以后发布的区块就没人会认了。\n\n发布到区块链上的交易，是不是都是成功执行的？智能合约发生错误，要不要也发不到区块链上去？\n\n> 不一定，执行发生错误的交易也要发布到区块链上去，这样才能成功扣除汽油费。如果交易不被发布到区块链上，是无法收取汽油费的。\n\n智能合约支持多线程吗？\n\n> 多核处理器很常见，计算机可以有很多核，那么智能合约支不支持多核并行处理呢。solidity 不支持多线程，因为以太坊本质为一个交易驱动的状态机，给定一个智能合约，面对同一组输入，必须转移到一个确定的状态，因为所有的全节点都要执行同一组操作来验证。但对于多线程来说，同一组输入的输入顺序不同，最终的结果可能不一致。 此外，其他可能导致执行结果不确定的操作也不支持，例如：产生随机数。因此，以太坊中的随机数是伪随机数，不能产生真正意义的随机数。 也正是因为其不支持多线程，所以无法通过系统调用获得系统信息，因为每个全节点环境并非完全一样。因此只能通过固定的结构获取。下图分别为为其可以获得的区块链信息和调用信息。\n\n\n\n\n\n\n# 地址类型\n\n\n\n在以太坊中，转账有以下三种方法。\n\n * transfer: 在转账失败后会导致连锁性回滚，抛出异常；\n * send: 转账失败会返回false，不会导致连锁性回滚\n * call: 本意是用于发动函数调用，但是也可以进行转账\n\n\n# code is law\n\ncode is law！智能合约规则是代码逻辑决定的，而发布到区块链上后就再也无法修改。这样的好处是，没有人可以篡改规则；这一的坏处是，规则如果有漏洞，也无法进行修改和补救。智能合约如果设计的不够好，就有可能将收到的以太币永久性锁死，谁也取不出来。\n\n\n# 锁仓\n\n> 通过智能合约进行锁仓。例如某个团队决定一起开发某个新型加密货币，开发中进行“pre mining”，给开发者预留一部分币。将这些预留币打入到一个合约账户，锁仓三年。三年后，这些币才可以参与交易，从而便于开发者可以集中精力进行这种加密货币开发工作。 但是万一在写入时候多写一个0，从3年变成30年，那这些币就会被锁仓30年，没有任何办法取出这些币。这有些类似于【不可撤销的信托(irrevocable trust)】，有些有钱人会采用这种方式来达到财产保护和减税的目的。如果在制定这种不可撤销的信托时，法律条款设置存在漏洞，也可能会导致存入的钱无法取出。 因此，在发布一个智能合约之前，需要进行大量、严格的测试。可以去专门的 testnet 网站上，采用虚假的以太币进行测试，确认完全没有问题后再发布。\n\n是否可以在智能合约中留一个后门，用于修复bug？例如给合约创建者超级用户的权力 例如前文例子，记录owner，记录owner的地址，当出现这种问题后其可以及时进行修复。这样做，会存在owner卷款跑路的风险。这样做前提是所有人都要相信这个超级管理员，而这于去中心化的理念背道而驰，是绝大多数区块链用户所不能接受的。",charsets:{cjk:!0}},{title:"跨域相关",frontmatter:{},regularPath:"/chrome/cross.html",relativePath:"chrome/cross.md",key:"v-9a739656",path:"/chrome/cross.html",headers:[{level:2,title:"Access-Control-Allow-Origin",slug:"access-control-allow-origin",normalizedTitle:"access-control-allow-origin",charIndex:66},{level:2,title:"proxy 代理",slug:"proxy-代理",normalizedTitle:"proxy 代理",charIndex:720},{level:2,title:"Allow CORS 插件",slug:"allow-cors-插件",normalizedTitle:"allow cors 插件",charIndex:2028},{level:2,title:"接口的形式",slug:"接口的形式",normalizedTitle:"接口的形式",charIndex:2235},{level:2,title:"预检请求",slug:"预检请求",normalizedTitle:"预检请求",charIndex:153},{level:2,title:"预检请求与重定向",slug:"预检请求与重定向",normalizedTitle:"预检请求与重定向",charIndex:2673},{level:2,title:"常见跨域错误",slug:"常见跨域错误",normalizedTitle:"常见跨域错误",charIndex:3864},{level:2,title:"axios 请求的三种错误",slug:"axios-请求的三种错误",normalizedTitle:"axios 请求的三种错误",charIndex:4169}],lastUpdated:"4/26/2023, 3:48:58 PM",lastUpdatedTimestamp:1682495338e3,headersStr:"Access-Control-Allow-Origin proxy 代理 Allow CORS 插件 接口的形式 预检请求 预检请求与重定向 常见跨域错误 axios 请求的三种错误",content:"# 跨域相关\n\n本文不是八股文知识点，不会介绍 jsonp、iframe 等跨域方式，只介绍在开发中最常见的几种跨域方式。\n\n\n# Access-Control-Allow-Origin\n\n最简单的方式：服务端配置 Access-Control-Allow-Origin: *，借此复习一下几种响应头。\n\n预检请求 (opens new window)相关响应头\n\n * Access-Control-Allow-Origin：响应头指定了该响应的资源是否被允许与给定的origin (opens new window)共享。\n * Access-Control-Allow-Methods: 响应首部 Access-Control-Allow-Methods 在对 preflight request (opens new window).（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。\n * Access-Control-Allow-Headers: 响应首部 Access-Control-Allow-Headers 用于 preflight request (opens new window)（预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers (opens new window)字段中出现的首部信息。\n * Access-Control-Allow-Credentials: 当请求要求携带证书信息（例如cookie,授权信息等）验证，服务器端是否允许携带\n * Access-Control-Max-Age: 本次预检请求的有效期，单位为秒\n\n\n# proxy 代理\n\n由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n\n那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。\n\n可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。\n\n那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。\n\nwebpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。\n\n比如我们假定 GitHub 的 API 就是我们应用的后端服务，那我们的目标就是将 GitHub API 代理到本地开发服务器中，我们可以先在浏览器中尝试访问其中的一个接口： https://api.github.com/users\n\ndevServer: {\n    contentBase: './public',\n    proxy: {\n      '/api': {\n        // http://localhost:8080/api/users -> https://api.github.com/api/users\n        target: 'https://api.github.com',\n        // http://localhost:8080/api/users -> https://api.github.com/users\n        pathRewrite: {\n          '^/api': ''\n        },\n        // 不能使用 localhost:8080 作为请求 GitHub 的主机名\n        changeOrigin: true\n      }\n    }\n  },\n\n\n\n\n那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/users\n\n// 此时再写跨域请求，就可正常访问\n// 虽然 GitHub 支持 CORS，但是不是每个服务端都应该支持。\n// fetch('https://api.github.com/users')\nfetch('/api/users')\n  .then(res => res.json())\n// 实际请求到http://localhost:8080/api/users\n\n\n\n# Allow CORS 插件\n\nchrome网上应用商店地址\n\n开发时只需开启插件即可，原理也是添加响应头 Access-Control-Allow-Origin\n\n> Easily add (Access-Control-Allow-Origin: *) rule to the response header.\n\n但是注意这种方式不一定完全适用，且不用的时候注意关掉，因为访问正常网站的时候可能会报错。\n\n\n# 接口的形式\n\n项目中的接口一般分为两种写法，第一种是区分测试环境和线上环境：\n\n测试环境地址：api.github-test.com/api/users\n正式环境地址：api.github.com/api/users\n\n\n另一种是使用相对路径的方式，只写 /api/users，不用区分测试和线上环境，这种方式一般使用上述的 devserver 开发的，测试环境可以直接跑在开发机上，线上部署后由于相对路径请求起来也没问题。\n\n\n# 预检请求\n\n只有跨域的时候才可能会发送预检请求，此时还需要判断请求是否为简单请求\n\n简单请求：同时满足以下两大条件，\n\n * 条件1：使用下列方法之一：GET，HEAD，POST\n * 条件2：Content-Type 的值仅限于下列三者之一：\n * text/plain\n * multipart/form-data\n * application/x-www-form-urlencoded\n\n除了以上条件之外，则会发起预检请求。\n\n\n# 预检请求与重定向\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\n\n并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误（chrome 有问题，safari 没问题）：\n\n> Access to XMLHttpRequest at 'http://xxx' (redirected from 'http://yyy') from origin 'http://zzz' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: Redirect is not allowed for a preflight request.\n\nCORS 最初要求浏览器具有该行为，不过在后续的修订中废弃了这一要求。但并非所有浏览器都实现了这一变更，而仍然表现出最初要求的行为。\n\n在浏览器的实现跟上规范之前，有两种方式规避上述报错行为：\n\n * 在服务端去掉对预检请求的重定向；\n * 将实际请求变成一个简单请求。\n\n> 情景1：用户登录页面 http://aaa.com 后，请求 http://aaa.com/getuser 接口，后端判断未登录，于是 302 重定向到单点登录网站 http://login.com，但是此时却报错：\n> \n> Access to XMLHttpRequest at 'http://login.com' (redirected from 'http://aaa.com/getuser') from origin 'http://aaa.com' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n> \n> 问题：http://aaa.com/getuser 接口的请求头中加了 Content-Type：application/json，使得发送了预检请求，然后在 chrome 中预检请求直接重定向有问题从而报错，把 application/json 删掉即可。\n\n\n# 常见跨域错误\n\n> Access to XMLHttpRequest at 'xxxx' from origin 'yyyy' has been blocked by CORS policy: Request header field zzz is not allowed by Access-Control-Allow-Headers in preflight response.\n\n这种问题的是因为后端配置的 access-control-allow-header 里面不允许 zzz，要么后端配置下，要么删一下请求头。表现形式一般是 options 请求可以请求成功，但是正式请求会报跨域错误。\n\n\n# axios 请求的三种错误\n\n * 网络异常错误：当网络出现异常（比如网络不通）的时候，再比如上述所说的预检请求不允许重定向\n * 超时错误\n * 状态码错误：比如 http状态码为 500\n\ninstance.interceptors.response.use(\n    response => {},\n    error => {\n        if (error.response && error.response.data) {\n            return Promise.reject(error);\n        }\n\n        let {message} = error;\n        if (message === 'Network Error') {\n            message = '后端接口连接异常!';\n        }\n        if (message.includes('timeout')) {\n            message = '后端接口请求超时';\n        }\n        if (message.includes('Request failed with status code')) {\n            const code = message.substr(message.length - 3);\n            message = '后端接口' + code + '异常';\n        }\n        Message.error(message);\n        return Promise.reject(error);\n    }\n);\n",normalizedContent:"# 跨域相关\n\n本文不是八股文知识点，不会介绍 jsonp、iframe 等跨域方式，只介绍在开发中最常见的几种跨域方式。\n\n\n# access-control-allow-origin\n\n最简单的方式：服务端配置 access-control-allow-origin: *，借此复习一下几种响应头。\n\n预检请求 (opens new window)相关响应头\n\n * access-control-allow-origin：响应头指定了该响应的资源是否被允许与给定的origin (opens new window)共享。\n * access-control-allow-methods: 响应首部 access-control-allow-methods 在对 preflight request (opens new window).（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。\n * access-control-allow-headers: 响应首部 access-control-allow-headers 用于 preflight request (opens new window)（预检请求）中，列出了将会在正式请求的 access-control-request-headers (opens new window)字段中出现的首部信息。\n * access-control-allow-credentials: 当请求要求携带证书信息（例如cookie,授权信息等）验证，服务器端是否允许携带\n * access-control-max-age: 本次预检请求的有效期，单位为秒\n\n\n# proxy 代理\n\n由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n\n那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 api，回到我们的开发环境后，再次访问这些 api 就会产生跨域请求问题。\n\n可能有人会说，我们可以用跨域资源共享（cors）解决这个问题。确实如此，如果我们请求的后端 api 支持 cors，那这个问题就不成立了。但是并不是每种情况下服务端的 api 都支持 cors。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 cors，所以跨域请求的问题仍然是不可避免的。\n\n那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 api 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。\n\nwebpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。\n\n比如我们假定 github 的 api 就是我们应用的后端服务，那我们的目标就是将 github api 代理到本地开发服务器中，我们可以先在浏览器中尝试访问其中的一个接口： https://api.github.com/users\n\ndevserver: {\n    contentbase: './public',\n    proxy: {\n      '/api': {\n        // http://localhost:8080/api/users -> https://api.github.com/api/users\n        target: 'https://api.github.com',\n        // http://localhost:8080/api/users -> https://api.github.com/users\n        pathrewrite: {\n          '^/api': ''\n        },\n        // 不能使用 localhost:8080 作为请求 github 的主机名\n        changeorigin: true\n      }\n    }\n  },\n\n\n\n\n那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/users\n\n// 此时再写跨域请求，就可正常访问\n// 虽然 github 支持 cors，但是不是每个服务端都应该支持。\n// fetch('https://api.github.com/users')\nfetch('/api/users')\n  .then(res => res.json())\n// 实际请求到http://localhost:8080/api/users\n\n\n\n# allow cors 插件\n\nchrome网上应用商店地址\n\n开发时只需开启插件即可，原理也是添加响应头 access-control-allow-origin\n\n> easily add (access-control-allow-origin: *) rule to the response header.\n\n但是注意这种方式不一定完全适用，且不用的时候注意关掉，因为访问正常网站的时候可能会报错。\n\n\n# 接口的形式\n\n项目中的接口一般分为两种写法，第一种是区分测试环境和线上环境：\n\n测试环境地址：api.github-test.com/api/users\n正式环境地址：api.github.com/api/users\n\n\n另一种是使用相对路径的方式，只写 /api/users，不用区分测试和线上环境，这种方式一般使用上述的 devserver 开发的，测试环境可以直接跑在开发机上，线上部署后由于相对路径请求起来也没问题。\n\n\n# 预检请求\n\n只有跨域的时候才可能会发送预检请求，此时还需要判断请求是否为简单请求\n\n简单请求：同时满足以下两大条件，\n\n * 条件1：使用下列方法之一：get，head，post\n * 条件2：content-type 的值仅限于下列三者之一：\n * text/plain\n * multipart/form-data\n * application/x-www-form-urlencoded\n\n除了以上条件之外，则会发起预检请求。\n\n\n# 预检请求与重定向\n\nhttps://developer.mozilla.org/zh-cn/docs/web/http/cors\n\n并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误（chrome 有问题，safari 没问题）：\n\n> access to xmlhttprequest at 'http://xxx' (redirected from 'http://yyy') from origin 'http://zzz' has been blocked by cors policy: response to preflight request doesn't pass access control check: redirect is not allowed for a preflight request.\n\ncors 最初要求浏览器具有该行为，不过在后续的修订中废弃了这一要求。但并非所有浏览器都实现了这一变更，而仍然表现出最初要求的行为。\n\n在浏览器的实现跟上规范之前，有两种方式规避上述报错行为：\n\n * 在服务端去掉对预检请求的重定向；\n * 将实际请求变成一个简单请求。\n\n> 情景1：用户登录页面 http://aaa.com 后，请求 http://aaa.com/getuser 接口，后端判断未登录，于是 302 重定向到单点登录网站 http://login.com，但是此时却报错：\n> \n> access to xmlhttprequest at 'http://login.com' (redirected from 'http://aaa.com/getuser') from origin 'http://aaa.com' has been blocked by cors policy: response to preflight request doesn't pass access control check: no 'access-control-allow-origin' header is present on the requested resource. if an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with cors disabled.\n> \n> 问题：http://aaa.com/getuser 接口的请求头中加了 content-type：application/json，使得发送了预检请求，然后在 chrome 中预检请求直接重定向有问题从而报错，把 application/json 删掉即可。\n\n\n# 常见跨域错误\n\n> access to xmlhttprequest at 'xxxx' from origin 'yyyy' has been blocked by cors policy: request header field zzz is not allowed by access-control-allow-headers in preflight response.\n\n这种问题的是因为后端配置的 access-control-allow-header 里面不允许 zzz，要么后端配置下，要么删一下请求头。表现形式一般是 options 请求可以请求成功，但是正式请求会报跨域错误。\n\n\n# axios 请求的三种错误\n\n * 网络异常错误：当网络出现异常（比如网络不通）的时候，再比如上述所说的预检请求不允许重定向\n * 超时错误\n * 状态码错误：比如 http状态码为 500\n\ninstance.interceptors.response.use(\n    response => {},\n    error => {\n        if (error.response && error.response.data) {\n            return promise.reject(error);\n        }\n\n        let {message} = error;\n        if (message === 'network error') {\n            message = '后端接口连接异常!';\n        }\n        if (message.includes('timeout')) {\n            message = '后端接口请求超时';\n        }\n        if (message.includes('request failed with status code')) {\n            const code = message.substr(message.length - 3);\n            message = '后端接口' + code + '异常';\n        }\n        message.error(message);\n        return promise.reject(error);\n    }\n);\n",charsets:{cjk:!0}},{title:"Chrome性能分析&性能监视器",frontmatter:{},regularPath:"/chrome/performance.html",relativePath:"chrome/performance.md",key:"v-0ea86735",path:"/chrome/performance.html",headers:[{level:2,title:"Performance Monitor 性能监视器",slug:"performance-monitor-性能监视器",normalizedTitle:"performance monitor 性能监视器",charIndex:332},{level:2,title:"Performance 性能分析",slug:"performance-性能分析",normalizedTitle:"performance 性能分析",charIndex:792}],lastUpdated:"4/14/2023, 5:31:58 PM",lastUpdatedTimestamp:1681464718e3,headersStr:"Performance Monitor 性能监视器 Performance 性能分析",content:"# Chrome性能分析&性能监视器\n\n有一天在启动项目的时候，突然电脑发烫，风扇开始转，此时我打开了 mac 的活动监视器发现：\n\n\n\n然后我又运行了一下 top 命令（top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器）\n\n\n\n然后我又打开了 chrome 的任务管理器，发现确实是这个项目对应的 tab 进程把 cpu 占满了。\n\n\n\n然后开始分析项目，发现只有在进入某一个页面的时候才会这样，最后对代码进行分析，发现是 ui 组件库中的一个组件里面有死循环代码，最后升级了版本解决了。其实除了以上几种查看 cpu 的方式，chrome 浏览器还有自带的性能分析&性能监视器功能。\n\n\n# Performance Monitor 性能监视器\n\n打开需要监测的页面，F12打开控制台后，command + p 打开命令输入，可输入?查看以下命令：\n\n\n\n * open file：打开文件\n * run command：运行命令\n * run snippet：运行代码片段\n * go to symbol\n * go to line：跳转到指定行\n\n我们输入> Show Performance Monitor，打开性能监视器，这个过程是实时监测的，比如修复问题后可以看到曲线降了下来。\n\n\n\n可以看到左侧的性能指标主要有，可以勾选想要看的指标：\n\n * CPU usage：CPU占用率\n * JS head size：JS内存使用大小\n * DOM Nodes：内存中挂载的DOM节点个数\n * JS event listeners：事件监听数\n * Document\n * Document Frames\n * Layouts / sec：重排\n * Style recalcs / sec：重绘\n\n\n# Performance 性能分析\n\n\n\n * record button：录制按钮，点击后开启录制然后点击停止按钮。\n * reload button：页面会重新加载，记录页面加载过程中的性能分析，会自动停止。\n\n功能面板介绍：Chrome DevTools Performance 功能详解",normalizedContent:"# chrome性能分析&性能监视器\n\n有一天在启动项目的时候，突然电脑发烫，风扇开始转，此时我打开了 mac 的活动监视器发现：\n\n\n\n然后我又运行了一下 top 命令（top命令是linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于windows的任务管理器）\n\n\n\n然后我又打开了 chrome 的任务管理器，发现确实是这个项目对应的 tab 进程把 cpu 占满了。\n\n\n\n然后开始分析项目，发现只有在进入某一个页面的时候才会这样，最后对代码进行分析，发现是 ui 组件库中的一个组件里面有死循环代码，最后升级了版本解决了。其实除了以上几种查看 cpu 的方式，chrome 浏览器还有自带的性能分析&性能监视器功能。\n\n\n# performance monitor 性能监视器\n\n打开需要监测的页面，f12打开控制台后，command + p 打开命令输入，可输入?查看以下命令：\n\n\n\n * open file：打开文件\n * run command：运行命令\n * run snippet：运行代码片段\n * go to symbol\n * go to line：跳转到指定行\n\n我们输入> show performance monitor，打开性能监视器，这个过程是实时监测的，比如修复问题后可以看到曲线降了下来。\n\n\n\n可以看到左侧的性能指标主要有，可以勾选想要看的指标：\n\n * cpu usage：cpu占用率\n * js head size：js内存使用大小\n * dom nodes：内存中挂载的dom节点个数\n * js event listeners：事件监听数\n * document\n * document frames\n * layouts / sec：重排\n * style recalcs / sec：重绘\n\n\n# performance 性能分析\n\n\n\n * record button：录制按钮，点击后开启录制然后点击停止按钮。\n * reload button：页面会重新加载，记录页面加载过程中的性能分析，会自动停止。\n\n功能面板介绍：chrome devtools performance 功能详解",charsets:{cjk:!0}},{title:"GC算法，V8引擎",frontmatter:{title:"GC算法，V8引擎",date:"2020-08-26T10:37:54.000Z",categories:"浏览器"},regularPath:"/chrome/gc.html",relativePath:"chrome/gc.md",key:"v-aee874c2",path:"/chrome/gc.html",headers:[{level:2,title:"GC算法",slug:"gc算法",normalizedTitle:"gc算法",charIndex:2},{level:2,title:"什么情况会引起内存泄漏？",slug:"什么情况会引起内存泄漏",normalizedTitle:"什么情况会引起内存泄漏？",charIndex:733},{level:2,title:"内存溢出",slug:"内存溢出",normalizedTitle:"内存溢出",charIndex:32},{level:2,title:"V8引擎与垃圾回收策略",slug:"v8引擎与垃圾回收策略",normalizedTitle:"v8引擎与垃圾回收策略",charIndex:1236},{level:3,title:"V8内存分配与垃圾回收",slug:"v8内存分配与垃圾回收",normalizedTitle:"v8内存分配与垃圾回收",charIndex:1338},{level:2,title:"performance",slug:"performance",normalizedTitle:"performance",charIndex:48}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"GC算法 什么情况会引起内存泄漏？ 内存溢出 V8引擎与垃圾回收策略 V8内存分配与垃圾回收 performance",content:"# GC算法，V8引擎\n\n * GC算法\n * 内存泄露\n * 内存溢出\n * V8引擎\n * performance\n\n\n# GC算法\n\n# 1. 标记清除\n\n垃圾回收器会在运行时给存储在内存中的所有变量加一个标记，然后去除环境中的变量以及被环境中的变量所引用的变量（闭包）在这些完成后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了。缺点是清除的对象可能地址不连续，造成内存碎片化。\n\n优缺点：1. 可处理循环引用 2. 产生碎片化 3. 不会立即回收\n\n> 你可以想象整个内存是一个大海，每个对象都是一个岛屿，相互之间用大桥连接，现在要找出与大陆相连的岛屿，那么就从大陆出发，依次标记所能达到的每个岛屿，最后没有被标记到的岛屿就是孤岛，可以当垃圾清除掉。即使两个孤岛之间相互有桥连接也没用，因为与大陆不通啊。\n\n# 2. 引用计数\n\n引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，这个值得引用次数就加一，如果该变量的值变成了另一个，则这个值得引用次数就减一，当这个值的引用次数为0的时候，说明没有变量在使用，这个值无法访问。由此可以将其占用的空间回收，这些垃圾回收器就会在运行时清理掉引用次数为0的值占用的空间，但这种方法容易引起内存泄漏，因为这种方式没有解决循环引用的问题，所以不建议使用！例如：\n\nvar obj = { a:1,b:2,c:3 };\nobj.o = obj;//循环引用\n\n\n优缺点：1.即时回收 2. 减少程序卡顿 3.无法解决循环引用 4. 资源消耗大：维护引用计数器\n\n# 3. 标记整理\n\n标记清除的升级版，清除之前先整理空间，再清除，防止内存碎片化\n\n\n# 什么情况会引起内存泄漏？\n\n虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。\n\n * 意外的全局变量引起的内存泄漏。\n\n原因：全局变量，不会被回收。\n\n解决：使用严格模式避免。\n\n * 闭包引起的内存泄漏\n\n原因：闭包可以维持函数内局部变量，使其得不到释放。\n\n解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。\n\n * 没有清理的DOM元素引用\n\n原因：虽然别的地方删除了，但是对象中还存在对dom的引用\n\n解决：手动删除。\n\n * 被遗忘的定时器或者回调\n\n原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。\n\n解决：手动删除定时器和dom。\n\n * 子元素存在引用引起的内存泄漏\n\n原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。\n\n解决：手动删除清空。\n\n\n# 内存溢出\n\n * 内存溢出，申请不到足够的内存；\n\n * 内存泄露，无法释放已申请的内存；\n\n\n# V8引擎与垃圾回收策略\n\n * V8采用即时编译\n\n * V8内存设限（64操作系统不超过1.5G）\n\n * 采用分代回收的思想\n\n * 内存分为新生代，老生代\n\n * 不同对象采用不同GC算法\n\n\n# V8内存分配与垃圾回收\n\n> V8内存空间一分为二\n> \n> 小空间用于存储新生代对象（32M | 16M）\n> \n> 新生代指的是存活时间较短的对象\n> \n> 新生代内存区分为两个相等空间\n> \n> 使用空间为From，空闲空间为To\n> \n> 活动对象存储于From空间\n> \n> 进行回收时，标记整理将From活动对象拷贝至To，释放From区域\n> \n> 最后From和To交换空间\n> \n> 空间换时间\n\n回收过程中可能出现晋升：\n\n * 一轮GC还存活的新生代需要晋升到老年代\n * To空间使用率超过25%的需要晋升，因为From和To互换后需要保证新活动对象的空间充足\n\n> 老生代（1.4G | 700M）\n> \n> 老生代对象就是指存活时间较长的对象\n> \n> 采用标记清除，标记整理，增量标记\n> \n> 首先使用标记清除完成垃圾回收\n> \n> 采用标记整理进行空间优化\n> \n> 采用增量标记进行效率优化，将标记过程分段，与程序执行交替执行，提高效率（垃圾回收会阻塞程序）\n\n\n# performance\n\n打开F12中的performance工具，点击录制，输入网址并做一些操作，点击停止就可以看到最后一个图的蓝色线条即是内存变换情况。\n\n监控内存的方式\n\n * 浏览器任务管理器：shift+esc，最后一列可看到JavaScript使用的内存\n * Timeline时序图：蓝色线条，在其上面可定位\n * 堆快照查找分离DOM：F12中的Memory选项，Take snapshot\n * 判断是否存在频繁的垃圾回收：Timeline和任务管理器去查看",normalizedContent:"# gc算法，v8引擎\n\n * gc算法\n * 内存泄露\n * 内存溢出\n * v8引擎\n * performance\n\n\n# gc算法\n\n# 1. 标记清除\n\n垃圾回收器会在运行时给存储在内存中的所有变量加一个标记，然后去除环境中的变量以及被环境中的变量所引用的变量（闭包）在这些完成后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了。缺点是清除的对象可能地址不连续，造成内存碎片化。\n\n优缺点：1. 可处理循环引用 2. 产生碎片化 3. 不会立即回收\n\n> 你可以想象整个内存是一个大海，每个对象都是一个岛屿，相互之间用大桥连接，现在要找出与大陆相连的岛屿，那么就从大陆出发，依次标记所能达到的每个岛屿，最后没有被标记到的岛屿就是孤岛，可以当垃圾清除掉。即使两个孤岛之间相互有桥连接也没用，因为与大陆不通啊。\n\n# 2. 引用计数\n\n引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，这个值得引用次数就加一，如果该变量的值变成了另一个，则这个值得引用次数就减一，当这个值的引用次数为0的时候，说明没有变量在使用，这个值无法访问。由此可以将其占用的空间回收，这些垃圾回收器就会在运行时清理掉引用次数为0的值占用的空间，但这种方法容易引起内存泄漏，因为这种方式没有解决循环引用的问题，所以不建议使用！例如：\n\nvar obj = { a:1,b:2,c:3 };\nobj.o = obj;//循环引用\n\n\n优缺点：1.即时回收 2. 减少程序卡顿 3.无法解决循环引用 4. 资源消耗大：维护引用计数器\n\n# 3. 标记整理\n\n标记清除的升级版，清除之前先整理空间，再清除，防止内存碎片化\n\n\n# 什么情况会引起内存泄漏？\n\n虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。\n\n * 意外的全局变量引起的内存泄漏。\n\n原因：全局变量，不会被回收。\n\n解决：使用严格模式避免。\n\n * 闭包引起的内存泄漏\n\n原因：闭包可以维持函数内局部变量，使其得不到释放。\n\n解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。\n\n * 没有清理的dom元素引用\n\n原因：虽然别的地方删除了，但是对象中还存在对dom的引用\n\n解决：手动删除。\n\n * 被遗忘的定时器或者回调\n\n原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。\n\n解决：手动删除定时器和dom。\n\n * 子元素存在引用引起的内存泄漏\n\n原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。\n\n解决：手动删除清空。\n\n\n# 内存溢出\n\n * 内存溢出，申请不到足够的内存；\n\n * 内存泄露，无法释放已申请的内存；\n\n\n# v8引擎与垃圾回收策略\n\n * v8采用即时编译\n\n * v8内存设限（64操作系统不超过1.5g）\n\n * 采用分代回收的思想\n\n * 内存分为新生代，老生代\n\n * 不同对象采用不同gc算法\n\n\n# v8内存分配与垃圾回收\n\n> v8内存空间一分为二\n> \n> 小空间用于存储新生代对象（32m | 16m）\n> \n> 新生代指的是存活时间较短的对象\n> \n> 新生代内存区分为两个相等空间\n> \n> 使用空间为from，空闲空间为to\n> \n> 活动对象存储于from空间\n> \n> 进行回收时，标记整理将from活动对象拷贝至to，释放from区域\n> \n> 最后from和to交换空间\n> \n> 空间换时间\n\n回收过程中可能出现晋升：\n\n * 一轮gc还存活的新生代需要晋升到老年代\n * to空间使用率超过25%的需要晋升，因为from和to互换后需要保证新活动对象的空间充足\n\n> 老生代（1.4g | 700m）\n> \n> 老生代对象就是指存活时间较长的对象\n> \n> 采用标记清除，标记整理，增量标记\n> \n> 首先使用标记清除完成垃圾回收\n> \n> 采用标记整理进行空间优化\n> \n> 采用增量标记进行效率优化，将标记过程分段，与程序执行交替执行，提高效率（垃圾回收会阻塞程序）\n\n\n# performance\n\n打开f12中的performance工具，点击录制，输入网址并做一些操作，点击停止就可以看到最后一个图的蓝色线条即是内存变换情况。\n\n监控内存的方式\n\n * 浏览器任务管理器：shift+esc，最后一列可看到javascript使用的内存\n * timeline时序图：蓝色线条，在其上面可定位\n * 堆快照查找分离dom：f12中的memory选项，take snapshot\n * 判断是否存在频繁的垃圾回收：timeline和任务管理器去查看",charsets:{cjk:!0}},{title:"浏览器渲染相关",frontmatter:{title:"浏览器渲染相关",date:"2021-01-28T11:27:54.000Z",categories:"浏览器"},regularPath:"/chrome/render.html",relativePath:"chrome/render.md",key:"v-0ba510df",path:"/chrome/render.html",headers:[{level:2,title:"浏览器多进程架构",slug:"浏览器多进程架构",normalizedTitle:"浏览器多进程架构",charIndex:14},{level:3,title:"单进程缺点",slug:"单进程缺点",normalizedTitle:"单进程缺点",charIndex:426},{level:3,title:"多进程特点",slug:"多进程特点",normalizedTitle:"多进程特点",charIndex:516},{level:2,title:"浏览器渲染过程",slug:"浏览器渲染过程",normalizedTitle:"浏览器渲染过程",charIndex:594},{level:3,title:"导航流程",slug:"导航流程",normalizedTitle:"导航流程",charIndex:606},{level:3,title:"解析流程",slug:"解析流程",normalizedTitle:"解析流程",charIndex:617},{level:2,title:"回流与重绘",slug:"回流与重绘",normalizedTitle:"回流与重绘",charIndex:2566},{level:3,title:"reflow（回流）",slug:"reflow-回流",normalizedTitle:"reflow（回流）",charIndex:2576},{level:3,title:"repaint（重绘）",slug:"repaint-重绘",normalizedTitle:"repaint（重绘）",charIndex:2880},{level:2,title:"CSS 硬件加速",slug:"css-硬件加速",normalizedTitle:"css 硬件加速",charIndex:3330},{level:2,title:"js 会阻塞 dom",slug:"js-会阻塞-dom",normalizedTitle:"js 会阻塞 dom",charIndex:3802},{level:2,title:"css 不会阻塞 dom 解析但会阻塞渲染",slug:"css-不会阻塞-dom-解析但会阻塞渲染",normalizedTitle:"css 不会阻塞 dom 解析但会阻塞渲染",charIndex:4065},{level:2,title:"script标签中的async，defer",slug:"script标签中的async-defer",normalizedTitle:"script标签中的async，defer",charIndex:4249}],lastUpdated:"2/15/2023, 7:28:18 PM",lastUpdatedTimestamp:1676460498e3,headersStr:"浏览器多进程架构 单进程缺点 多进程特点 浏览器渲染过程 导航流程 解析流程 回流与重绘 reflow（回流） repaint（重绘） CSS 硬件加速 js 会阻塞 dom css 不会阻塞 dom 解析但会阻塞渲染 script标签中的async，defer",content:"# 浏览器渲染相关\n\n\n# 浏览器多进程架构\n\n一文看懂Chrome浏览器运行机制，如何查看进程：浏览器中右上角更多工具 => 任务管理器\n\n * Browers主进程：负责界面显示，用户交互，子进程管理，同时提供存储等功能\n * 渲染进程：一个tab窗口对应一个(不一定，网站隔离)，核心任务是将 html 转换为用户可以与之交互的网页\n * GPU进程：只有一个，实现网页，UI界面的硬件绘制\n * 插件进程：主要负责插件的运行，每一个插件对应一个进程\n * 网络进程：主要负责页面的网络资源加载\n\n> 浏览器主进程有很多负责不同工作的线程（worker thread）其中包括绘制浏览器顶部按钮和导航栏输入框等组件的UI线程（UI thread）、管理网络请求的网络线程（network thread）、以及控制文件读写的存储线程（storage thread）等。当你在导航栏里面输入一个URL的时候，其实就是UI线程在处理你的输入。\n\n\n# 单进程缺点\n\n * 不稳定：同一进程中，任何线程或模块的崩溃将导致整个进程的崩溃\n * 不流畅：任务排斥，内存泄露\n * 不安全：用C或C++写的插件可以获取操作系统资源\n\n\n# 多进程特点\n\n * 解决了稳定性，流畅性，安全性的问题\n * 带来了更多的资源占用\n * 带来了更复杂的体系架构（模块直接耦合度高，可扩展性降低）\n\n\n# 浏览器渲染过程\n\n\n# 导航流程\n\n\n\n\n# 解析流程\n\n\n\n> 解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树\n\n * DOM Tree：浏览器将HTML解析成树形的数据结构。\n\n * CSS Rule Tree：浏览器将CSS解析成树形的数据结构。\n\n * Render Tree: DOM和CSS合并后生成Render Tree。\n\n * layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置\n\n * painting: 主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。类似于canvas。\n\n * 合成与光栅化：一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后将图块发送给一系列光栅线程（raster threads）。光栅线程会栅格化每个图块并且把它们存储在GPU的内存中。\n   \n   当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。\n   \n   合成帧构建完成之后，合成线程就会通过IPC向浏览器进程提交（commit）一个渲染帧，合成帧会被发送给GPU从而展示在屏幕上。\n   \n   > 将绘制信息转化为显示器的像素的过程叫做光栅化（rasterizing）。\n   > \n   > 可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。Chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。\n   > \n   > 合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。\n\n综上所述，渲染进程共有三个线程参与工作，解析 html 到 painting 以上过程都是在主线程执行的，而合成和光栅化分别有合成线程和光栅化线程处理。\n\n\n\n * Compositor Thread\n   \n   首先将页面分成若干层，然后切分为一块又一块的小图块，然后将图块发送给光栅线程。当图层上面的图块都被栅格化后，合成线程会收集绘画四边形的信息来构建一个合成帧。合成帧构建完成之后，合成线程就会向浏览器进程提交一个渲染帧，合成帧会被发送给GPU从而展示在屏幕上。\n\n * Main Thread\n   \n   \n   \n   这里大家就很熟悉了，chrome devtools的Timeline里Main那一栏显示的内容就是Main Thread完成的相关任务：某段JS的执行、Recalculate Style、Update Layer Tree、Paint、Composite Layers等等。\n\n * Compositor Tile Worker(s) 可能有一个或多个线程，比如PC端的chrome是2个或4个，安卓和safari为1个或2个不等。是由Compositor Thread创建的，专门用来处理tile（小图块） 的Rasterization（前文说过的光栅化）。\n\n可以看到Compositor Thread是一个很核心的东西，后面的俩线程都是由他主要进行控制的。 同时，用户输入是直接进入Compositor Thread的，一方面在那些不需要执行JS或者没有CSS动画、不重绘等的场景时，可以直接对用户输入进行处理和响应，而Main Thread是有很复杂的任务流程的。这使得浏览器可以快速响应用户的滚动、打字等等输入，完全不用进主线程。就比如说js动画要走主线程，css动画有的不会走主线程，直接在 Compositor Thread 中完成\n\n> 所以说 css 动画会不会被 js 阻塞呢，答案是有时会有时不会，比如 transform，opacity，filter。transform在GPU直接创建一个新的层\n\n\n# 回流与重绘\n\n\n# reflow（回流）\n\n当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。\n\n\n# repaint（重绘）\n\n改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。\n\n哪些属性会触发回流与重绘\n\n(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。\n\n(2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。\n\n(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。\n\n\n\n# CSS 硬件加速\n\nCSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform3d 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。\n\n在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层 ，一旦独立出来，就不会影响其它 DOM 的布局（主线程），所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了。\n\n如下几个css属性可以触发硬件加速：\n\n * transform（ translate3d、translateZ(0)等）\n * opacity\n * filter（滤镜：drop-shadow()、opacity()，函数与已有的box-shadow、opacity属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速）\n * will-change：哪一个属性即将发生变化，进而进行优化。\n\n\n# js 会阻塞 dom\n\n * 现代浏览器会并行加载js文件，但是按照书写顺序执行代码\n * 加载或者执行js时会阻塞对标签的解析，也就是阻塞了dom树的形成，只有等到js执行完毕，浏览器才会继续解析标签。没有dom树，浏览器就无法渲染，所以当加载很大的js文件时，可以看到页面很长时间是一片空白\n * 之所以会阻塞对标签的解析是因为加载的js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，然后生成dom树，性能比较差\n\n\n# css 不会阻塞 dom 解析但会阻塞渲染\n\n * 因为需要具有 DOM 以及 CSSOM 才会构建渲染树，加载 css 的时候肯定无法继续渲染\n\n> 为什么把 js 放在底部，css 放在顶部\n\nJs 放在顶部会阻塞 dom 的渲染，浏览器可能一直转圈圈，而 css 不会阻塞 dom 解析。\n\n我们会将 js 放在后面，以减少First Paint的时间\n\n\n# script标签中的async，defer\n\n * script标签中的async，defer\n\n",normalizedContent:"# 浏览器渲染相关\n\n\n# 浏览器多进程架构\n\n一文看懂chrome浏览器运行机制，如何查看进程：浏览器中右上角更多工具 => 任务管理器\n\n * browers主进程：负责界面显示，用户交互，子进程管理，同时提供存储等功能\n * 渲染进程：一个tab窗口对应一个(不一定，网站隔离)，核心任务是将 html 转换为用户可以与之交互的网页\n * gpu进程：只有一个，实现网页，ui界面的硬件绘制\n * 插件进程：主要负责插件的运行，每一个插件对应一个进程\n * 网络进程：主要负责页面的网络资源加载\n\n> 浏览器主进程有很多负责不同工作的线程（worker thread）其中包括绘制浏览器顶部按钮和导航栏输入框等组件的ui线程（ui thread）、管理网络请求的网络线程（network thread）、以及控制文件读写的存储线程（storage thread）等。当你在导航栏里面输入一个url的时候，其实就是ui线程在处理你的输入。\n\n\n# 单进程缺点\n\n * 不稳定：同一进程中，任何线程或模块的崩溃将导致整个进程的崩溃\n * 不流畅：任务排斥，内存泄露\n * 不安全：用c或c++写的插件可以获取操作系统资源\n\n\n# 多进程特点\n\n * 解决了稳定性，流畅性，安全性的问题\n * 带来了更多的资源占用\n * 带来了更复杂的体系架构（模块直接耦合度高，可扩展性降低）\n\n\n# 浏览器渲染过程\n\n\n# 导航流程\n\n\n\n\n# 解析流程\n\n\n\n> 解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树\n\n * dom tree：浏览器将html解析成树形的数据结构。\n\n * css rule tree：浏览器将css解析成树形的数据结构。\n\n * render tree: dom和css合并后生成render tree。\n\n * layout: 有了render tree，浏览器已经能知道网页中有哪些节点、各个节点的css定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置\n\n * painting: 主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。类似于canvas。\n\n * 合成与光栅化：一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后将图块发送给一系列光栅线程（raster threads）。光栅线程会栅格化每个图块并且把它们存储在gpu的内存中。\n   \n   当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。\n   \n   合成帧构建完成之后，合成线程就会通过ipc向浏览器进程提交（commit）一个渲染帧，合成帧会被发送给gpu从而展示在屏幕上。\n   \n   > 将绘制信息转化为显示器的像素的过程叫做光栅化（rasterizing）。\n   > \n   > 可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。\n   > \n   > 合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。\n\n综上所述，渲染进程共有三个线程参与工作，解析 html 到 painting 以上过程都是在主线程执行的，而合成和光栅化分别有合成线程和光栅化线程处理。\n\n\n\n * compositor thread\n   \n   首先将页面分成若干层，然后切分为一块又一块的小图块，然后将图块发送给光栅线程。当图层上面的图块都被栅格化后，合成线程会收集绘画四边形的信息来构建一个合成帧。合成帧构建完成之后，合成线程就会向浏览器进程提交一个渲染帧，合成帧会被发送给gpu从而展示在屏幕上。\n\n * main thread\n   \n   \n   \n   这里大家就很熟悉了，chrome devtools的timeline里main那一栏显示的内容就是main thread完成的相关任务：某段js的执行、recalculate style、update layer tree、paint、composite layers等等。\n\n * compositor tile worker(s) 可能有一个或多个线程，比如pc端的chrome是2个或4个，安卓和safari为1个或2个不等。是由compositor thread创建的，专门用来处理tile（小图块） 的rasterization（前文说过的光栅化）。\n\n可以看到compositor thread是一个很核心的东西，后面的俩线程都是由他主要进行控制的。 同时，用户输入是直接进入compositor thread的，一方面在那些不需要执行js或者没有css动画、不重绘等的场景时，可以直接对用户输入进行处理和响应，而main thread是有很复杂的任务流程的。这使得浏览器可以快速响应用户的滚动、打字等等输入，完全不用进主线程。就比如说js动画要走主线程，css动画有的不会走主线程，直接在 compositor thread 中完成\n\n> 所以说 css 动画会不会被 js 阻塞呢，答案是有时会有时不会，比如 transform，opacity，filter。transform在gpu直接创建一个新的层\n\n\n# 回流与重绘\n\n\n# reflow（回流）\n\n当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。\n\n\n# repaint（重绘）\n\n改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。\n\n哪些属性会触发回流与重绘\n\n(1)display:none 的节点不会被加入render tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。\n\n(2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。\n\n(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。\n\n\n\n# css 硬件加速\n\ncss3 硬件加速又叫做 gpu 加速，是利用 gpu 进行渲染，减少 cpu 操作的一种优化方案。由于 gpu 中的 transform3d 等 css 属性不会触发 repaint，所以能大大提高网页的性能。\n\n在 gpu 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层 ，一旦独立出来，就不会影响其它 dom 的布局（主线程），所以我们可以利用这些规则，将经常变换的 dom 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 layout 和 paint 的时间了。\n\n如下几个css属性可以触发硬件加速：\n\n * transform（ translate3d、translatez(0)等）\n * opacity\n * filter（滤镜：drop-shadow()、opacity()，函数与已有的box-shadow、opacity属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速）\n * will-change：哪一个属性即将发生变化，进而进行优化。\n\n\n# js 会阻塞 dom\n\n * 现代浏览器会并行加载js文件，但是按照书写顺序执行代码\n * 加载或者执行js时会阻塞对标签的解析，也就是阻塞了dom树的形成，只有等到js执行完毕，浏览器才会继续解析标签。没有dom树，浏览器就无法渲染，所以当加载很大的js文件时，可以看到页面很长时间是一片空白\n * 之所以会阻塞对标签的解析是因为加载的js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，然后生成dom树，性能比较差\n\n\n# css 不会阻塞 dom 解析但会阻塞渲染\n\n * 因为需要具有 dom 以及 cssom 才会构建渲染树，加载 css 的时候肯定无法继续渲染\n\n> 为什么把 js 放在底部，css 放在顶部\n\njs 放在顶部会阻塞 dom 的渲染，浏览器可能一直转圈圈，而 css 不会阻塞 dom 解析。\n\n我们会将 js 放在后面，以减少first paint的时间\n\n\n# script标签中的async，defer\n\n * script标签中的async，defer\n\n",charsets:{cjk:!0}},{title:"代码规范",frontmatter:{title:"代码规范",date:"2020-09-20T10:27:54.000Z",categories:"规范"},regularPath:"/code-style/code-style.html",relativePath:"code-style/code-style.md",key:"v-93f09142",path:"/code-style/code-style.html",headers:[{level:2,title:"使用默认值",slug:"使用默认值",normalizedTitle:"使用默认值",charIndex:11},{level:2,title:"解构语法",slug:"解构语法",normalizedTitle:"解构语法",charIndex:20},{level:2,title:"删掉注释的代码",slug:"删掉注释的代码",normalizedTitle:"删掉注释的代码",charIndex:28},{level:2,title:"尽量不用“非”条件句",slug:"尽量不用-非-条件句",normalizedTitle:"尽量不用“非”条件句",charIndex:39},{level:2,title:"使用Array.includes来处理多个条件",slug:"使用array-includes来处理多个条件",normalizedTitle:"使用array.includes来处理多个条件",charIndex:53},{level:2,title:"多个类似函数",slug:"多个类似函数",normalizedTitle:"多个类似函数",charIndex:80},{level:2,title:"使用 && 运算符化简表达式",slug:"使用-运算符化简表达式",normalizedTitle:"使用 &amp;&amp; 运算符化简表达式",charIndex:null},{level:2,title:"空值合并运算符 '??'",slug:"空值合并运算符",normalizedTitle:"空值合并运算符 '??'",charIndex:108},{level:3,title:"与 || 比较",slug:"与-比较",normalizedTitle:"与 || 比较",charIndex:2234},{level:2,title:"可选链操作符 '?.'",slug:"可选链操作符",normalizedTitle:"可选链操作符 '?.'",charIndex:124},{level:2,title:"一些技巧",slug:"一些技巧",normalizedTitle:"一些技巧",charIndex:147},{level:2,title:"多个变量赋值，交换变量",slug:"多个变量赋值-交换变量",normalizedTitle:"多个变量赋值，交换变量",charIndex:155},{level:2,title:"字符串重复",slug:"字符串重复",normalizedTitle:"字符串重复",charIndex:170},{level:2,title:"双非位运算符",slug:"双非位运算符",normalizedTitle:"双非位运算符",charIndex:179},{level:2,title:"数组中的最大值最小值",slug:"数组中的最大值最小值",normalizedTitle:"数组中的最大值最小值",charIndex:189},{level:2,title:"巧用this实现链式调用",slug:"巧用this实现链式调用",normalizedTitle:"巧用this实现链式调用",charIndex:203},{level:2,title:"新对象替换老对象",slug:"新对象替换老对象",normalizedTitle:"新对象替换老对象",charIndex:219},{level:2,title:"对象数组去重",slug:"对象数组去重",normalizedTitle:"对象数组去重",charIndex:231},{level:2,title:"巧用apply",slug:"巧用apply",normalizedTitle:"巧用apply",charIndex:241},{level:2,title:"合并对象",slug:"合并对象",normalizedTitle:"合并对象",charIndex:252},{level:2,title:"Array.filter(Boolean)",slug:"array-filter-boolean",normalizedTitle:"array.filter(boolean)",charIndex:260}],lastUpdated:"3/29/2022, 7:44:01 PM",lastUpdatedTimestamp:1648554241e3,headersStr:"使用默认值 解构语法 删掉注释的代码 尽量不用“非”条件句 使用Array.includes来处理多个条件 多个类似函数 使用 && 运算符化简表达式 空值合并运算符 '??' 与 || 比较 可选链操作符 '?.' 一些技巧 多个变量赋值，交换变量 字符串重复 双非位运算符 数组中的最大值最小值 巧用this实现链式调用 新对象替换老对象 对象数组去重 巧用apply 合并对象 Array.filter(Boolean)",content:"# 代码规范\n\n * 使用默认值\n * 解构语法\n * 删掉注释的代码\n * 尽量不用“非”条件句\n * 使用Array.includes来处理多个条件\n * 多个类似函数\n * 使用 && 运算符化简表达式\n * 空值合并运算符 '??'\n * 可选链操作符 '?.'\n * 代码风格\n * 一些技巧\n * 多个变量赋值，交换变量\n * 字符串重复\n * 双非位运算符\n * 数组中的最大值最小值\n * 巧用this实现链式调用\n * 新对象替换老对象\n * 对象数组去重\n * 巧用apply\n * 合并对象\n * Array.filter(Boolean)\n\n\n# 使用默认值\n\n// Bad\nfunction createMicrobrewery(name) {\n    const brewryName = name || 'Hipster Brew'\n    // ...\n}\n\n// Good\nfunction createMicrobrewery(name = 'Hipster Brew') {\n    // ...\n}\n\n\n\n# 解构语法\n\n如果参数超过两个，可以使用解构语法，不用考虑参数的顺序\n\n// Bad\nfunction createMenu(title, body, buttonText, cancellable) {\n    // ...\n}\n// Good\nfunction createMenu({ title, body, buttonText, cancellable }) {\n    // ...\n}\n\ncreateMenu({\n    title: 'Foo',\n    body: 'Bar',\n    buttonText: 'Baz',\n    cancellable: true\n})\n\n\n\n# 删掉注释的代码\n\ngit存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧\n\n// Bad\ndoStuff()\n// doOtherStuff()\n// doSomeMoreStuff()\n// doSoMuchStuff()\n\n// Good\ndoStuff()\n\n\n\n# 尽量不用“非”条件句\n\n// Bad\nfunction isDOMNodeNotPresent(node) {\n    // ...\n}\n\nif (!isDOMNodeNotPresent(node)) {\n    // ...\n}\n// Good\nfunction isDOMNodeNotPresent(node) {\n    // ...\n}\n\nif (isDOMNodeNotPresent(node)) {   // if后面记得加空格\n    // ...\n}\n\n\n\n# 使用Array.includes来处理多个条件\n\nfunction test(fruit) {\n    if (fruit == 'apple' || fruit == 'banana') {\n        console.log(red)\n    }\n}\n// 如果有更多的红色水果怎么办\nfunction test(fruit) {\n    const redFruits = ['apple', 'strawberry', 'cherry']\n    if (redFruits.includes(fruit)) {\n        console.log(red)\n    }\n}\n\n\n\n# 多个类似函数\n\n update (node, key, attrName) {\n    let updateFn = this[attrName + 'Updater']\n    updateFn(node, key, attrName)\n }\n\n  textUpdater (node, value, key) {\n    // ...\n  }\n\n  modelUpdater (node, value, key) {\n    // ...\n  }\n\n\n\n# 使用 && 运算符化简表达式\n\n让我们考虑一个具有布尔值和函数的情况。\n\nlet isPrime = true;\nconst startWatching = () => {\n    console.log('Started Watching!');\n}\n\n\n像下面这样，通过检查布尔值来确定是否调用函数，代码太多了。\n\nif (isPrime) {\n    startWatching();\n}\n\n\n能否通过 AND（&&）运算符使用简写形式？是的，完全可以避免使用 if 语句。酷吧！\n\nisPrime && startWatching();\n\n\n\n# 空值合并运算符 '??'\n\n值既不是 null 也不是 undefined 的表达式称为“已定义的（defined）”。\n\na ?? b 的结果是：\n\n * 如果 a 是已定义的，则结果为 a，\n * 如果 a 不是已定义的，则结果为 b。\n * 如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。\n\n通常 ?? 的使用场景是，为可能是未定义的变量提供一个默认值。\n\nlet user;\n\nalert(user ?? \"Anonymous\"); // Anonymous\n\n\n\n# 与 || 比较\n\n它们之间重要的区别是：\n\n * || 返回第一个 真 值。\n * ?? 返回第一个 已定义的 值。\n\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\n\n\n\n# 可选链操作符 '?.'\n\n> 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。\n\nconst adventurer = {\n  name: 'Alice',\n  cat: {\n    name: 'Dinah'\n  }\n};\n\nconsole.log(adventurer.cat?.name)\n// Dinah\n\nconsole.log(adventurer.dog?.name)\n// undefined\n\nconsole.log(adventurer.dog.name)\n// Uncaught TypeError: Cannot read property 'name' of undefined\n\n\n\n# 一些技巧\n\nconst obj = {\n    max(a,b) {\n        return Math.max(a,b)\n    }\n}\n// 优化为\nconst obj = {\n    max: Math.max\n}\n\n\nvar numbers = [1, 4, 9];\nvar roots = numbers.map(Math.sqrt);\n\n[1,2,3,4].map(item => {\n    return item * 2\n})\n// 当只有一个 return 时简化为\n[1,2,3,4].map(item => item * 2)\n\n\n\n# 多个变量赋值，交换变量\n\n// 多个变量赋值\nlet a, b, c\na = 5\nb = 8\nc = 12\n\n// 利用数组解构\nlet [a, b, c] = [5, 8, 12]\n\n// 交换变量\nlet x = 'hello', y = 55\nconst tmp = x\nx = y\ny = tmp\n\n[x, y] = [y, x]\n\n\n\n# 字符串重复\n\nlet str = ''\nfor (let i = 0; i < 5; i++) {\n  str += 'hello '\n}\n\n// good\n'hello '.repeat(5)\n\n\n\n# 双非位运算符\n\n// bad\nconst floor = Math.floor(6.8) // 6\n\n// good\nconst floor = ~~6.8 // 6\n\n// ~ 是位运算NOT，按位取反\n\nvar iNum1 = 25; // 00000000000000000000000000011001\n\nvar iNum2 = ~iNum1; // 11111111111111111111111111100110\n\nconsole.log(iNum2);// 输出 \"-26\"\n\n\n总结一下取整方法\n\n * parseInt\n * Math.floor\n * 右移运算符 >> (除2后取整)\n * 双非位运算符 ~~\n\n\n# 数组中的最大值最小值\n\nconst arr = [2, 8, 15, 4]\nMath.max(...arr)\nMath.min(...arr)\n\n\n\n# 巧用this实现链式调用\n\n// 实现验证功能的函数\nvar CheckObject = function(){};\nCheckObject.prototype.checkName = function(){\n    //验证姓名\n    return this;\n}\nCheckObject.prototype.checEmail = function(){\n    //验证邮箱\n    return this;\n}\nCheckObject.prototype.checkPassword = function(){\n    //验证密码\n    return this;\n}\n\nvar a = new CheckObject();\na.checkName().checkEmail().checkPassword();\n\n\n\n# 新对象替换老对象\n\n以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：\n\nobj = { ...obj, newProp: 123 }\n\n\n\n# 对象数组去重\n\nlet arr = [\n  {\n    id: 1,\n    name: '1'\n  },\n  {\n    id: 2,\n    name: '2'\n  },\n  {\n    id: 3,\n    name: '3'\n  },\n  {\n    id: 1,\n    name: '1'\n  }\n]\nunique(arr) {\n  const res = new Map();\n  return arr.filter((arr) => !res.has(arr.id) && res.set(arr.id, 1));\n},\n\n\n\n# 巧用apply\n\n数组之间追加\n\nvar array1 = [12 , \"foo\" , {name \"Joe\"} , -2458];\nvar array2 = [\"Doe\" , 555 , 100];\nArray.prototype.push.apply(array1, array2);\n\n/* array1 值为 [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */\n\n\n获取数组中的最大值和最小值\n\nvar numbers = [5, 458 , 120 , -215 ];\nvar maxInNumbers = Math.max.apply(Math, numbers), //458\nmaxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458\n\n\n\n# 合并对象\n\nconst o1 = { a: 1 };\nconst o2 = { b: 2 };\nconst o3 = { c: 3 };\n\nconst obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。\n\n// 合并具有相同属性的对象\nconst o1 = { a: 1, b: 1, c: 1 };\nconst o2 = { b: 2, c: 2 };\nconst o3 = { c: 3 };\n\nconst obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n\n\n\n# Array.filter(Boolean)\n\n像 0, undefined, null, false, \"\", 这样的假值可以通过此方法轻易地过滤掉。\n\n[0, undefined, null, false, \"\", {}].filter(Boolean) // [{}]\n\n// 等价于\n[0, undefined, null, false, \"\", {}].filter(function (x) { return Boolean(x); });\n\n\nBoolean 是一个函数，它会对遍历数组中的元素，并根据元素的真假类型，对应返回 true 或 false.\n\nBoolean(0)         // false\nBoolean(undefined) // false\nBoolean(null)      // false\nBoolean(false)     // false\nBoolean(\"\")        // false\nBoolean({})        // true\n",normalizedContent:"# 代码规范\n\n * 使用默认值\n * 解构语法\n * 删掉注释的代码\n * 尽量不用“非”条件句\n * 使用array.includes来处理多个条件\n * 多个类似函数\n * 使用 && 运算符化简表达式\n * 空值合并运算符 '??'\n * 可选链操作符 '?.'\n * 代码风格\n * 一些技巧\n * 多个变量赋值，交换变量\n * 字符串重复\n * 双非位运算符\n * 数组中的最大值最小值\n * 巧用this实现链式调用\n * 新对象替换老对象\n * 对象数组去重\n * 巧用apply\n * 合并对象\n * array.filter(boolean)\n\n\n# 使用默认值\n\n// bad\nfunction createmicrobrewery(name) {\n    const brewryname = name || 'hipster brew'\n    // ...\n}\n\n// good\nfunction createmicrobrewery(name = 'hipster brew') {\n    // ...\n}\n\n\n\n# 解构语法\n\n如果参数超过两个，可以使用解构语法，不用考虑参数的顺序\n\n// bad\nfunction createmenu(title, body, buttontext, cancellable) {\n    // ...\n}\n// good\nfunction createmenu({ title, body, buttontext, cancellable }) {\n    // ...\n}\n\ncreatemenu({\n    title: 'foo',\n    body: 'bar',\n    buttontext: 'baz',\n    cancellable: true\n})\n\n\n\n# 删掉注释的代码\n\ngit存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧\n\n// bad\ndostuff()\n// dootherstuff()\n// dosomemorestuff()\n// dosomuchstuff()\n\n// good\ndostuff()\n\n\n\n# 尽量不用“非”条件句\n\n// bad\nfunction isdomnodenotpresent(node) {\n    // ...\n}\n\nif (!isdomnodenotpresent(node)) {\n    // ...\n}\n// good\nfunction isdomnodenotpresent(node) {\n    // ...\n}\n\nif (isdomnodenotpresent(node)) {   // if后面记得加空格\n    // ...\n}\n\n\n\n# 使用array.includes来处理多个条件\n\nfunction test(fruit) {\n    if (fruit == 'apple' || fruit == 'banana') {\n        console.log(red)\n    }\n}\n// 如果有更多的红色水果怎么办\nfunction test(fruit) {\n    const redfruits = ['apple', 'strawberry', 'cherry']\n    if (redfruits.includes(fruit)) {\n        console.log(red)\n    }\n}\n\n\n\n# 多个类似函数\n\n update (node, key, attrname) {\n    let updatefn = this[attrname + 'updater']\n    updatefn(node, key, attrname)\n }\n\n  textupdater (node, value, key) {\n    // ...\n  }\n\n  modelupdater (node, value, key) {\n    // ...\n  }\n\n\n\n# 使用 && 运算符化简表达式\n\n让我们考虑一个具有布尔值和函数的情况。\n\nlet isprime = true;\nconst startwatching = () => {\n    console.log('started watching!');\n}\n\n\n像下面这样，通过检查布尔值来确定是否调用函数，代码太多了。\n\nif (isprime) {\n    startwatching();\n}\n\n\n能否通过 and（&&）运算符使用简写形式？是的，完全可以避免使用 if 语句。酷吧！\n\nisprime && startwatching();\n\n\n\n# 空值合并运算符 '??'\n\n值既不是 null 也不是 undefined 的表达式称为“已定义的（defined）”。\n\na ?? b 的结果是：\n\n * 如果 a 是已定义的，则结果为 a，\n * 如果 a 不是已定义的，则结果为 b。\n * 如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。\n\n通常 ?? 的使用场景是，为可能是未定义的变量提供一个默认值。\n\nlet user;\n\nalert(user ?? \"anonymous\"); // anonymous\n\n\n\n# 与 || 比较\n\n它们之间重要的区别是：\n\n * || 返回第一个 真 值。\n * ?? 返回第一个 已定义的 值。\n\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\n\n\n\n# 可选链操作符 '?.'\n\n> 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。\n\nconst adventurer = {\n  name: 'alice',\n  cat: {\n    name: 'dinah'\n  }\n};\n\nconsole.log(adventurer.cat?.name)\n// dinah\n\nconsole.log(adventurer.dog?.name)\n// undefined\n\nconsole.log(adventurer.dog.name)\n// uncaught typeerror: cannot read property 'name' of undefined\n\n\n\n# 一些技巧\n\nconst obj = {\n    max(a,b) {\n        return math.max(a,b)\n    }\n}\n// 优化为\nconst obj = {\n    max: math.max\n}\n\n\nvar numbers = [1, 4, 9];\nvar roots = numbers.map(math.sqrt);\n\n[1,2,3,4].map(item => {\n    return item * 2\n})\n// 当只有一个 return 时简化为\n[1,2,3,4].map(item => item * 2)\n\n\n\n# 多个变量赋值，交换变量\n\n// 多个变量赋值\nlet a, b, c\na = 5\nb = 8\nc = 12\n\n// 利用数组解构\nlet [a, b, c] = [5, 8, 12]\n\n// 交换变量\nlet x = 'hello', y = 55\nconst tmp = x\nx = y\ny = tmp\n\n[x, y] = [y, x]\n\n\n\n# 字符串重复\n\nlet str = ''\nfor (let i = 0; i < 5; i++) {\n  str += 'hello '\n}\n\n// good\n'hello '.repeat(5)\n\n\n\n# 双非位运算符\n\n// bad\nconst floor = math.floor(6.8) // 6\n\n// good\nconst floor = ~~6.8 // 6\n\n// ~ 是位运算not，按位取反\n\nvar inum1 = 25; // 00000000000000000000000000011001\n\nvar inum2 = ~inum1; // 11111111111111111111111111100110\n\nconsole.log(inum2);// 输出 \"-26\"\n\n\n总结一下取整方法\n\n * parseint\n * math.floor\n * 右移运算符 >> (除2后取整)\n * 双非位运算符 ~~\n\n\n# 数组中的最大值最小值\n\nconst arr = [2, 8, 15, 4]\nmath.max(...arr)\nmath.min(...arr)\n\n\n\n# 巧用this实现链式调用\n\n// 实现验证功能的函数\nvar checkobject = function(){};\ncheckobject.prototype.checkname = function(){\n    //验证姓名\n    return this;\n}\ncheckobject.prototype.checemail = function(){\n    //验证邮箱\n    return this;\n}\ncheckobject.prototype.checkpassword = function(){\n    //验证密码\n    return this;\n}\n\nvar a = new checkobject();\na.checkname().checkemail().checkpassword();\n\n\n\n# 新对象替换老对象\n\n以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：\n\nobj = { ...obj, newprop: 123 }\n\n\n\n# 对象数组去重\n\nlet arr = [\n  {\n    id: 1,\n    name: '1'\n  },\n  {\n    id: 2,\n    name: '2'\n  },\n  {\n    id: 3,\n    name: '3'\n  },\n  {\n    id: 1,\n    name: '1'\n  }\n]\nunique(arr) {\n  const res = new map();\n  return arr.filter((arr) => !res.has(arr.id) && res.set(arr.id, 1));\n},\n\n\n\n# 巧用apply\n\n数组之间追加\n\nvar array1 = [12 , \"foo\" , {name \"joe\"} , -2458];\nvar array2 = [\"doe\" , 555 , 100];\narray.prototype.push.apply(array1, array2);\n\n/* array1 值为 [12 , \"foo\" , {name \"joe\"} , -2458 , \"doe\" , 555 , 100] */\n\n\n获取数组中的最大值和最小值\n\nvar numbers = [5, 458 , 120 , -215 ];\nvar maxinnumbers = math.max.apply(math, numbers), //458\nmaxinnumbers = math.max.call(math,5, 458 , 120 , -215); //458\n\n\n\n# 合并对象\n\nconst o1 = { a: 1 };\nconst o2 = { b: 2 };\nconst o3 = { c: 3 };\n\nconst obj = object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。\n\n// 合并具有相同属性的对象\nconst o1 = { a: 1, b: 1, c: 1 };\nconst o2 = { b: 2, c: 2 };\nconst o3 = { c: 3 };\n\nconst obj = object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n\n\n\n# array.filter(boolean)\n\n像 0, undefined, null, false, \"\", 这样的假值可以通过此方法轻易地过滤掉。\n\n[0, undefined, null, false, \"\", {}].filter(boolean) // [{}]\n\n// 等价于\n[0, undefined, null, false, \"\", {}].filter(function (x) { return boolean(x); });\n\n\nboolean 是一个函数，它会对遍历数组中的元素，并根据元素的真假类型，对应返回 true 或 false.\n\nboolean(0)         // false\nboolean(undefined) // false\nboolean(null)      // false\nboolean(false)     // false\nboolean(\"\")        // false\nboolean({})        // true\n",charsets:{cjk:!0}},{title:"BFC",frontmatter:{},regularPath:"/css/bfc.html",relativePath:"css/bfc.md",key:"v-73b79b9f",path:"/css/bfc.html",headers:[{level:2,title:"什么是BFC，BFC的布局规则是什么，如何创建BFC",slug:"什么是bfc-bfc的布局规则是什么-如何创建bfc",normalizedTitle:"什么是bfc，bfc的布局规则是什么，如何创建bfc",charIndex:10}],lastUpdated:"12/30/2022, 3:16:25 PM",lastUpdatedTimestamp:1672384585e3,headersStr:"什么是BFC，BFC的布局规则是什么，如何创建BFC",content:"# BFC\n\n\n# 什么是BFC，BFC的布局规则是什么，如何创建BFC\n\n * BFC的定义:\n\n> BFC（Block formatting context ）“块级格式上下文”。 是用于布局块级盒子的一块渲染区域。并且与这个区域的外部毫无关系。\n\n * BFC的布局规则\n\n> BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n> \n> 内部的Box会在垂直方向，一个接一个地放置。\n> \n> Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。\n> \n> BFC的区域不会与float box重叠。\n> \n> 计算BFC的高度时，浮动元素也参与计算。\n\n * 触发BFC的条件:\n\n满足下列条件之一就可以触发BFC\n\n> 1：根元素，即 <html>\n> \n> 2：浮动元素，float 的值不为 none\n> \n> 3：overflow 的值不为 visible\n> \n> 4：display 的值为 inline-block、table-cell、table-caption\n> \n> 5：position 的值为 absolute 或者 fixed\n\n * BFC的作用\n\n作用          原理\n外边距合并问题     同一个BFC的两个相邻Box的margin会发生重叠。\n浮动的高度塌陷问题   计算BFC的高度时，浮动元素也参与计算。\n双列布局        BFC 不得与任何浮动的外边距重叠。\n\n（1）可以阻止元素被浮动的元素覆盖，可做两栏自适应布局（BFC的区域不会与float box重叠。）\n\n\n\n触发红色盒子的BFC后\n\n\n\n（2）解决高度塌陷：我们知道当浮动的盒子的父元素没有高度时，会出现高度塌陷现象。\n\n\n\n父盒子触发BFC可以解决这个问题（计算BFC的高度时，浮动元素也参与计算）。\n\n（3）解决同一个BFC区域的垂直方向margin塌陷的问题\n\n\n\n分为两个不同的BFC之后可以解决 （属于同一个BFC的两个相邻Box的margin会发生重叠）",normalizedContent:"# bfc\n\n\n# 什么是bfc，bfc的布局规则是什么，如何创建bfc\n\n * bfc的定义:\n\n> bfc（block formatting context ）“块级格式上下文”。 是用于布局块级盒子的一块渲染区域。并且与这个区域的外部毫无关系。\n\n * bfc的布局规则\n\n> bfc就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n> \n> 内部的box会在垂直方向，一个接一个地放置。\n> \n> box垂直方向的距离由margin决定。属于同一个bfc的两个相邻box的margin会发生重叠。\n> \n> bfc的区域不会与float box重叠。\n> \n> 计算bfc的高度时，浮动元素也参与计算。\n\n * 触发bfc的条件:\n\n满足下列条件之一就可以触发bfc\n\n> 1：根元素，即 <html>\n> \n> 2：浮动元素，float 的值不为 none\n> \n> 3：overflow 的值不为 visible\n> \n> 4：display 的值为 inline-block、table-cell、table-caption\n> \n> 5：position 的值为 absolute 或者 fixed\n\n * bfc的作用\n\n作用          原理\n外边距合并问题     同一个bfc的两个相邻box的margin会发生重叠。\n浮动的高度塌陷问题   计算bfc的高度时，浮动元素也参与计算。\n双列布局        bfc 不得与任何浮动的外边距重叠。\n\n（1）可以阻止元素被浮动的元素覆盖，可做两栏自适应布局（bfc的区域不会与float box重叠。）\n\n\n\n触发红色盒子的bfc后\n\n\n\n（2）解决高度塌陷：我们知道当浮动的盒子的父元素没有高度时，会出现高度塌陷现象。\n\n\n\n父盒子触发bfc可以解决这个问题（计算bfc的高度时，浮动元素也参与计算）。\n\n（3）解决同一个bfc区域的垂直方向margin塌陷的问题\n\n\n\n分为两个不同的bfc之后可以解决 （属于同一个bfc的两个相邻box的margin会发生重叠）",charsets:{cjk:!0}},{title:"flex布局",frontmatter:{title:"flex布局",date:"2020-11-22T11:27:54.000Z",categories:"CSS"},regularPath:"/css/flex.html",relativePath:"css/flex.md",key:"v-55613da1",path:"/css/flex.html",headers:[{level:2,title:"flex 布局实例",slug:"flex-布局实例",normalizedTitle:"flex 布局实例",charIndex:1076}],lastUpdated:"5/9/2022, 3:52:37 PM",lastUpdatedTimestamp:1652082757e3,headersStr:"flex 布局实例",content:'# flex布局\n\n * flex常见属性\n * flex-grow，flex-shrink，flex-basis\n * flex:1\n * space-evenly\n * flex布局实例\n\n----------------------------------------\n\n * Flex 布局教程：语法篇\n * flex:1详解\n * 重点看这篇文章\n\n.item {flex: none;}\n.item {\n    flex-grow: 0;\n    flex-shrink: 0;\n    flex-basis: auto;\n}\n\n\n.item {flex: auto;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: auto;\n}\n\n\n.item {flex: 1;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n\n\n.item-1 {flex: 0%;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n\n.item-2 {flex: 24px;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 24px;\n}\n\n\n.item {flex: 2 3;}\n.item {\n    flex-grow: 2;\n    flex-shrink: 3;\n    flex-basis: 0%;\n}\n\n\nflex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：\n\nauto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。\n\ncontent：指根据该子元素的内容自动布局。(内容多的占比也会多)\n\n百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。\n\n\n * space-evenly为项目之间间距与项目与容器间距相等，相当于除去项目宽度，平均分配了剩余宽度作为项目左右margin。\n\n\n# flex 布局实例\n\n * 场景：一行5个卡片，卡片数量不限，自动换行，从左到右排列，比如现在有9个卡片：\n\n// 如下效果\n1 1 1 1 1\n1 1 1 1\n\n\n * 每一行子元素的总基准值是：20% * n\n * flex-grow 和 flex-shrink 都是 0，不允许放大和缩小，除基准值之外的剩余空间不会被分配\n\n.list {\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: start;\n}\n.item {\n  flex: 0 0 20%;\n}\n\n\n----------------------------------------\n\n * 场景：如何实现以下效果，文字部分左对齐，数字百分号部分右对齐\n\n\n\n<div class="wrap">\n  <div class="icon"><span></span></div>\n  <div class="name">满意</div>\n  <div class="num">100</div>\n  <div class="percent">10%</div>\n</div>\n\n\n.manner {\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  .icon {\n    text-align: left;\n    flex: 0 0 10%;\n  }\n  .name {\n    text-align: left;\n    flex: 0 0 35%;\n  }\n  .sum {\n    text-align: right;\n    flex: 0 0 30%;\n  }\n  \n  .percent {\n    text-align: right;\n    flex: 0 0 25%;\n  }\n}\n\n\n> 使用百分比的原因是在外层盒子变化时，里面的元素也会跟随着变化。\n> \n> 对齐方案使用 text-align 即可。',normalizedContent:'# flex布局\n\n * flex常见属性\n * flex-grow，flex-shrink，flex-basis\n * flex:1\n * space-evenly\n * flex布局实例\n\n----------------------------------------\n\n * flex 布局教程：语法篇\n * flex:1详解\n * 重点看这篇文章\n\n.item {flex: none;}\n.item {\n    flex-grow: 0;\n    flex-shrink: 0;\n    flex-basis: auto;\n}\n\n\n.item {flex: auto;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: auto;\n}\n\n\n.item {flex: 1;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n\n\n.item-1 {flex: 0%;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n\n.item-2 {flex: 24px;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 24px;\n}\n\n\n.item {flex: 2 3;}\n.item {\n    flex-grow: 2;\n    flex-shrink: 3;\n    flex-basis: 0%;\n}\n\n\nflex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：\n\nauto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。\n\ncontent：指根据该子元素的内容自动布局。(内容多的占比也会多)\n\n百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。\n\n\n * space-evenly为项目之间间距与项目与容器间距相等，相当于除去项目宽度，平均分配了剩余宽度作为项目左右margin。\n\n\n# flex 布局实例\n\n * 场景：一行5个卡片，卡片数量不限，自动换行，从左到右排列，比如现在有9个卡片：\n\n// 如下效果\n1 1 1 1 1\n1 1 1 1\n\n\n * 每一行子元素的总基准值是：20% * n\n * flex-grow 和 flex-shrink 都是 0，不允许放大和缩小，除基准值之外的剩余空间不会被分配\n\n.list {\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: start;\n}\n.item {\n  flex: 0 0 20%;\n}\n\n\n----------------------------------------\n\n * 场景：如何实现以下效果，文字部分左对齐，数字百分号部分右对齐\n\n\n\n<div class="wrap">\n  <div class="icon"><span></span></div>\n  <div class="name">满意</div>\n  <div class="num">100</div>\n  <div class="percent">10%</div>\n</div>\n\n\n.manner {\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  .icon {\n    text-align: left;\n    flex: 0 0 10%;\n  }\n  .name {\n    text-align: left;\n    flex: 0 0 35%;\n  }\n  .sum {\n    text-align: right;\n    flex: 0 0 30%;\n  }\n  \n  .percent {\n    text-align: right;\n    flex: 0 0 25%;\n  }\n}\n\n\n> 使用百分比的原因是在外层盒子变化时，里面的元素也会跟随着变化。\n> \n> 对齐方案使用 text-align 即可。',charsets:{cjk:!0}},{title:"CSS 常见问题",frontmatter:{},regularPath:"/css/problem.html",relativePath:"css/problem.md",key:"v-0a42a91f",path:"/css/problem.html",headers:[{level:2,title:"last-child 不生效问题",slug:"last-child-不生效问题",normalizedTitle:"last-child 不生效问题",charIndex:15}],lastUpdated:"5/11/2023, 4:00:15 PM",lastUpdatedTimestamp:1683792015e3,headersStr:"last-child 不生效问题",content:'# CSS 常见问题\n\n\n# last-child 不生效问题\n\n<div>\n  <p class="list">1</p>\n  <p class="list">2</p>\n  <p class="list">3</p>\n  <p class="list">4</p>\n  <div>footer</div>\n</div>\n\n<style>\n  .list:last-child {\n    color: red;\n  }\n</style>\n\n\n> el:last-child 的匹配规则是：第一步，查找 el 选择器匹配元素的所有同级元素（siblings）；第二步，在同级元素中查找最后一个元素；第三步，检验最后一个元素是否与选择器 el 匹配。\n> \n> .list:last-child 匹配到了 div，但 div 不匹配 .list，故选择器不生效。改法如下：\n\n<div>\n  <p class="list">1</p>\n  <p class="list">2</p>\n  <p class="list">3</p>\n  <p class="list">4</p>\n</div>\n<div>footer</div>\n\n<style>\n  .list:last-child {\n    color: red;\n  }\n</style>\n',normalizedContent:'# css 常见问题\n\n\n# last-child 不生效问题\n\n<div>\n  <p class="list">1</p>\n  <p class="list">2</p>\n  <p class="list">3</p>\n  <p class="list">4</p>\n  <div>footer</div>\n</div>\n\n<style>\n  .list:last-child {\n    color: red;\n  }\n</style>\n\n\n> el:last-child 的匹配规则是：第一步，查找 el 选择器匹配元素的所有同级元素（siblings）；第二步，在同级元素中查找最后一个元素；第三步，检验最后一个元素是否与选择器 el 匹配。\n> \n> .list:last-child 匹配到了 div，但 div 不匹配 .list，故选择器不生效。改法如下：\n\n<div>\n  <p class="list">1</p>\n  <p class="list">2</p>\n  <p class="list">3</p>\n  <p class="list">4</p>\n</div>\n<div>footer</div>\n\n<style>\n  .list:last-child {\n    color: red;\n  }\n</style>\n',charsets:{cjk:!0}},{title:"计算机基础",frontmatter:{},regularPath:"/computer/computer.html",relativePath:"computer/computer.md",key:"v-69aa6042",path:"/computer/computer.html",headers:[{level:2,title:"osi七层模型与tcp/ip五层模型",slug:"osi七层模型与tcp-ip五层模型",normalizedTitle:"osi七层模型与tcp/ip五层模型",charIndex:12},{level:2,title:"TCP与UDP的区别",slug:"tcp与udp的区别",normalizedTitle:"tcp与udp的区别",charIndex:481},{level:2,title:"TCP三次握手，四次挥手",slug:"tcp三次握手-四次挥手",normalizedTitle:"tcp三次握手，四次挥手",charIndex:1095},{level:2,title:"TCP如何可靠传输",slug:"tcp如何可靠传输",normalizedTitle:"tcp如何可靠传输",charIndex:2268},{level:2,title:"TCP拥塞控制",slug:"tcp拥塞控制",normalizedTitle:"tcp拥塞控制",charIndex:2457},{level:3,title:"慢热启动算法 – Slow Start",slug:"慢热启动算法-slow-start",normalizedTitle:"慢热启动算法 – slow start",charIndex:2519},{level:3,title:"拥塞避免算法 – Congestion Avoidance",slug:"拥塞避免算法-congestion-avoidance",normalizedTitle:"拥塞避免算法 – congestion avoidance",charIndex:2819},{level:3,title:"拥塞发生",slug:"拥塞发生",normalizedTitle:"拥塞发生",charIndex:2438},{level:3,title:"快恢复",slug:"快恢复",normalizedTitle:"快恢复",charIndex:3248},{level:2,title:"什么是 HTTP 协议",slug:"什么是-http-协议",normalizedTitle:"什么是 http 协议",charIndex:3469},{level:2,title:"长连接与多路复用",slug:"长连接与多路复用",normalizedTitle:"长连接与多路复用",charIndex:3975},{level:3,title:"怎么理解多路复用",slug:"怎么理解多路复用",normalizedTitle:"怎么理解多路复用",charIndex:5305},{level:3,title:"TCP 队头阻塞和 HTTP 队头阻塞",slug:"tcp-队头阻塞和-http-队头阻塞",normalizedTitle:"tcp 队头阻塞和 http 队头阻塞",charIndex:5559},{level:3,title:"TCP 长连接和 HTTP 长连接",slug:"tcp-长连接和-http-长连接",normalizedTitle:"tcp 长连接和 http 长连接",charIndex:5784},{level:3,title:"如何解决队头阻塞",slug:"如何解决队头阻塞",normalizedTitle:"如何解决队头阻塞",charIndex:6043},{level:3,title:"如何在 chrome 中查看 http 协议",slug:"如何在-chrome-中查看-http-协议",normalizedTitle:"如何在 chrome 中查看 http 协议",charIndex:6223},{level:3,title:"http 1.1 和 http 2 对比",slug:"http-1-1-和-http-2-对比",normalizedTitle:"http 1.1 和 http 2 对比",charIndex:6301},{level:2,title:"HTTPS",slug:"https",normalizedTitle:"https",charIndex:6780},{level:2,title:"http请求方法",slug:"http请求方法",normalizedTitle:"http请求方法",charIndex:8962},{level:2,title:"常见请求头",slug:"常见请求头",normalizedTitle:"常见请求头",charIndex:9356},{level:3,title:"请求头字段",slug:"请求头字段",normalizedTitle:"请求头字段",charIndex:9639},{level:2,title:"响应头字段",slug:"响应头字段",normalizedTitle:"响应头字段",charIndex:11485},{level:2,title:"Content-type",slug:"content-type",normalizedTitle:"content-type",charIndex:12347},{level:3,title:"用于前端请求",slug:"用于前端请求",normalizedTitle:"用于前端请求",charIndex:12364},{level:3,title:"用于后端响应",slug:"用于后端响应",normalizedTitle:"用于后端响应",charIndex:12686},{level:2,title:"进程与线程",slug:"进程与线程",normalizedTitle:"进程与线程",charIndex:12898},{level:2,title:"基于对象与面向对象",slug:"基于对象与面向对象",normalizedTitle:"基于对象与面向对象",charIndex:13218},{level:2,title:"ARP，RARP 协议",slug:"arp-rarp-协议",normalizedTitle:"arp，rarp 协议",charIndex:13426},{level:2,title:"数据库事务的四个特性",slug:"数据库事务的四个特性",normalizedTitle:"数据库事务的四个特性",charIndex:13884},{level:2,title:"数据库索引与B+树",slug:"数据库索引与b-树",normalizedTitle:"数据库索引与b+树",charIndex:14064},{level:2,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:14232},{level:2,title:"有限自动机",slug:"有限自动机",normalizedTitle:"有限自动机",charIndex:14432},{level:2,title:"编译原理的过程",slug:"编译原理的过程",normalizedTitle:"编译原理的过程",charIndex:14567},{level:2,title:"linux 解压命令",slug:"linux-解压命令",normalizedTitle:"linux 解压命令",charIndex:14619}],lastUpdated:"11/2/2023, 2:16:23 PM",lastUpdatedTimestamp:1698905783e3,headersStr:"osi七层模型与tcp/ip五层模型 TCP与UDP的区别 TCP三次握手，四次挥手 TCP如何可靠传输 TCP拥塞控制 慢热启动算法 – Slow Start 拥塞避免算法 – Congestion Avoidance 拥塞发生 快恢复 什么是 HTTP 协议 长连接与多路复用 怎么理解多路复用 TCP 队头阻塞和 HTTP 队头阻塞 TCP 长连接和 HTTP 长连接 如何解决队头阻塞 如何在 chrome 中查看 http 协议 http 1.1 和 http 2 对比 HTTPS http请求方法 常见请求头 请求头字段 响应头字段 Content-type 用于前端请求 用于后端响应 进程与线程 基于对象与面向对象 ARP，RARP 协议 数据库事务的四个特性 数据库索引与B+树 死锁 有限自动机 编译原理的过程 linux 解压命令",content:"# 计算机基础\n\n\n# osi七层模型与tcp/ip五层模型\n\nOSI定义了网络互连的七层框架\n\n * 应用层：针对你特定应用的协议\n * 表示层：设备固定的数据格式和网络标准数据格式之间的转化\n * 会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层\n * 传输层：管理两个节点之间的数据传递。负责可靠传输\n * 网络层：地址管理和路由选择\n * 数据链路层：互联设备之间传送和识别数据帧\n * 物理层：界定连接器和网线之间的规格\n\nTCP/IP四（五）层模型\n\n每一层都呼叫它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层）\n\n * 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。\n * 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。\n * 网络层：负责地址管理和路由选择。路由器工作在网络层。\n * 传输层：负责两台主机之间的数据传输。\n * 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。\n\n\n# TCP与UDP的区别\n\n * tcp 和 udp 都是属于传输层，传输层提供应用程序间的通信，其功能包括格式化信息流，提供可靠传输。\n\n * TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n\n * TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。\n\n * Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。\n\n * UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。\n\n为什么UDP有时比TCP更有优势?\n\n * UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。\n\n * 网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。\n\n * TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。\n\n * 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响\n\n\n# TCP三次握手，四次挥手\n\n三次握手：通俗的讲\n                客户端：HI听见了吗,\n                服务器端：HI我听见了，\n                客户端：我也听见你了。     接下来开始愉快地聊天\n四次握手：通俗的讲\n                客户端：我们分手把，\n                服务端：好的，你等我把数据给你传输完\n                服务端：我传输完了，\n                客户端：好了，可以分手了。 接下来就真正的分手了\n\n\n * 三次握手\n * 四次挥手\n * SYN (synchronous建立联机)\n * ACK (acknowledgement 确认)\n * FIN (finish结束)\n * Sequence number (顺序号码)\n * 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态\n\n为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。\n\n\n * 为什么是三次握手而不是两次握手？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n * 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。\n\n\n\n# TCP如何可靠传输\n\n * 重传机制\n * 滑动窗口\n   * 可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n * 流量控制\n   * TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\n * 拥塞控制\n   * 慢启动\n   * 拥塞避免\n   * 拥塞发生\n   * 快速恢复\n\n\n# TCP拥塞控制\n\n拥塞控制主要是四个算法：\n\n * 慢启动\n * 拥塞避免\n * 拥塞发生\n * 快速恢复\n\n图示\n\n\n# 慢热启动算法 – Slow Start\n\n所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。\n\n>  1. 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。 2) 每当收到一个ACK，cwnd大小加一，呈线性上升。 3) 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。 4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）\n\n\n# 拥塞避免算法 – Congestion Avoidance\n\n如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：\n\n> 收到一个ACK，则cwnd = cwnd + 1 / cwnd 2) 每当过了一个往返延迟时间RTT，cwnd大小加一。过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。\n\n\n# 拥塞发生\n\n最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。\n\n所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：\n\n * cwnd大小缩小为当前的一半\n * ssthresh设置为缩小后的cwnd大小\n * 然后进入快速恢复算法Fast Recovery。\n\n\n# 快恢复\n\n在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：\n\n * cwnd = cwnd + 3 * MSS，加3 * MSS的原因是因为收到3个重复的ACK。\n * 重传DACKs指定的数据包。\n * 如果再收到DACKs，那么cwnd大小增加一。\n * 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。\n\n\n# 什么是 HTTP 协议\n\n> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。\n\n版本         产生时间    内容                                             发展现状\nHTTP/0.9   1991年   不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求               没有作为正式的标准\nHTTP/1.0   1996年   传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令   正式作为标准\nHTTP/1.1   1997年   持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码               2015年前使用最广泛\nHTTP/2     2015年   多路复用、服务器推送、头信息压缩、二进制协议等                        逐渐覆盖市场\n\n\n# 长连接与多路复用\n\n * 长连接：在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n\n * 二进制分帧：在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。（1帧 = 8字节，最小通信单位）\n\n * 首部压缩：在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。\n   \n   在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。\n\n * 请求优先级：把HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。\n\n * 多路复用：在 HTTP 1.0 中，发起一个请求是这样的：\n\n浏览器请求 url -> 解析域名 -> 建立 HTTP 连接 -> 服务器处理文件 -> 返回数据 -> 浏览器解析、渲染文件 \n\n这个流程最大的问题是，每次请求都需要建立一次 HTTP 连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！\n\n为了解决这个问题， HTTP 1.1 中提供了 Keep-Alive，允许我们建立一次连接，来返回多次请求数据。\n\n但是这里有两个问题：\n\nHTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序。所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少\n\n最大并发数问题，假设我们在 Apache 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50\n\n而 HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。\n\nHTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍。\n\n就好比面试，HTTP1.1是一面之后，视频不断继续二面，HTTP2.0是只要有面试官来了就同时面试（传输数据）\n\n\n\n\n\n# 怎么理解多路复用\n\nHTTP/2是基于二进制“帧”的协议，HTTP/1.1是基于“文本分割”解析的协议。\n\nHTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序。\n\n而 HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。\n\n\n# TCP 队头阻塞和 HTTP 队头阻塞\n\n * TCP 队头阻塞：TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。\n * HTTP 队头阻塞：http1.1采用长连接，可以在一个TCP请求上，发送多个http请求。管道化的机制使得请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。这就会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞\n\n\n# TCP 长连接和 HTTP 长连接\n\n * HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。\n\n * TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。\n\n\n# 如何解决队头阻塞\n\n * TCP 队头阻塞：直接弃用。。详见Http3\n * HTTP 队头阻塞：\n   * 建立多个 Tcp 连接，如 chrome 最多限制6个并发请求，每个 TCP 连接对应一个 connection ID\n   * Http2 多路复用，对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接\n\n\n\n\n# 如何在 chrome 中查看 http 协议\n\n只需在 network 中右键点击表头，就可以控制展示的列，其中就有 protocol 选项。\n\n\n\n\n# http 1.1 和 http 2 对比\n\n在http 1.1，所以浏览器会限制同一个域的同时请求数，Chrome是限制6个，如图：\n\n\n\n但当我们开启了http/2之后，个数几乎没有限制了，如下图所示：\n\n\n\n不过请求的顺序及并发并不完全依赖于此，如果在项目中写了如下代码：\n\nasync getData() {\n  await this.getList1();\n  await this.getList2();\n  await this.getList3();\n  await this.getList4();\n  await this.getList5();\n}\n\n\n那么在 chrome 中的表现如下：\n\n\n\n我们一般可以优化为：\n\nasync getData() {\n  await Promise.all([\n    this.getList1(),\n    this.getList2(),\n    this.getList3(),\n    this.getList4(),\n    this.getList5(),\n  ]);\n}\n\n\n\n# HTTPS\n\nHTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。\n\n * HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的，保证了通信的保密性。当然SSL协议并不能对UDP应用进行保护\n\n * 虽然使用 HTTP 协议无法确定通信方，使用 SSL可以。SSL使用了一种被称为证书的手段，证书由值得信任的第三方机构颁发，使用HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。证书用以证明服务器和客户端是实际存在的。身份确认过程使用RSA非对称密钥加密方式（破解难度基于两个大素数乘积的因式分解难度），但是为了提高效率，身份确认完成后使用共商后的对称密钥。\n\n * SSL协议位于TCP/IP协议与各种应用层协议（不止能用于HTTP）之间，为数据通讯提供安全支持。\n   \n   SSL协议可分为两层：\n   \n   （1）SSL记录协议：建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。\n   \n   （2）SSL握手协议：建立在记录协议之上，用于数据传输开始前的双方身份认证、协商加密算法、交换加密密钥等。\n\n * 主要流程：\n   \n   * 客户端向服务器发起HTTPS请求，连接到服务器的443端口\n   * 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。\n   * 服务器将自己的公钥发送给客户端。\n   * 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。\n   * 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。\n   * 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。\n   * 然后服务器将加密后的密文发送给客户端。\n   * 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。\n\n * 注意： HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。\n\n * 为什么数据传输是用对称加密的？\n   \n   * 非对称加密的加解密效率非常低，而HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。\n   * 在 HTTPS 的场景中只有服务端保存了私钥，客户端不做非对称密钥生成，一对公钥和私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。\n\n----------------------------------------\n\n> https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。\n> \n> SSL和TLS都是加密协议 通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。 所谓https，其实就是身披ssl协议这层外壳的http。（回忆一下osi7层,TCP/IP4层，我们学的是5层）\n> \n> SSL协议采用的是非对称加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密.\n> \n> RSA算法：两个大素数p,q，n=pq,f(n)=(p-1)(q-1),1<b<f(n),a=b^-1modf(n),公钥n,b,私钥p,q,a\n> \n> 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ Certificate Authority, CA）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥与 CA 用私钥生成的数字签名等信息写成证书颁发给申请者。\n> \n> 当你访问使用 HTTPS（连接安全）的网站时，该网站的服务器会使用证书向浏览器（如 Chrome）证明该网站的身份。任何人都可以创建证书，随意声称对应的网站是任意网站。\n> \n> 为了确保您安全上网，Chrome 会要求网站使用来自受信任组织发放的证书。\n\n\n# http请求方法\n\nGET\n\n\nGET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.\n\nHEAD\n\n\nHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体，一般用于1.检查资源的有效性。 2.检查超链接的有效性。 3.检查网页是否被串改。\n\nPOST\n\n\nPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用.\n\nPUT\n\n\nPUT方法用请求有效载荷替换目标资源的所有当前表示。\n\nDELETE\n\n\nDELETE方法删除指定的资源。\n\nCONNECT\n\n\nCONNECT方法建立一个到由目标资源标识的服务器的隧道。\n\nOPTIONS\n\n\nOPTIONS方法用于描述目标资源的通信选项。\n\nTRACE\n\n\nTRACE方法沿着到目标资源的路径执行一个消息环回测试。\n\nPATCH\n\n\nPATCH方法用于对资源应用部分修改。\n\n\n# 常见请求头\n\nHTTP 首部字段是由首部字段名和字段值构成的，中间用冒号 : 分隔。\n\n首部字段名: 字段值\n\n\n另外，字段值对应单个 HTTP 首部字段可以有多个值，多个指令之间通过 ,分隔。如下所示。\n\nKeep-Alive: timeout=15, max=100\n\n\n若想要加优先级，则使用 q=来额外表示权重值 1 ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。\n\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n\n\n# 请求头字段\n\n * Accept\n\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\n\nAccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type/subtype 这种形式，一次指定多种媒体类型。\n\n\n * Accept-Encoding\n\nAccept-Encoding: gzip, deflate, br\n\nAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。\n\n\n * Accept-Language\n\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。\n\n\n * Cache-Control\n\nCache-Control: no-cache，缓存\n\n\n * Connection\n\nConnection: keep-alive\n\nHTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP 协议上维持持续连接，则需要指定Connection 首部字段的值为 Keep-Alive。\n\n\n * Cookie\n\n首部字段 Cookie 会告知服务器，当客户端想获得HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。\n\n\n * Host\n\nHost: www.baidu.com\n\n首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。\n\n\n * Referer\n\n首部字段 Referer 会告知服务器请求的原始资源的 URI。它记录了该 HTTP 请求的来源地址。\n\n如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值 。\n\n然而，这种方法并非万无一失。Referer 的值是由浏览器提供的 ，目前已经有一些方法可以篡改 Referer 值 \n\n即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。\n\n\n * Origin\n\n用来说明请求从哪里发起的，包括，且仅仅包括 协议和域名。\n这个参数一般只存在于CORS跨域请求中，可以看到 response 有对应的 header：Access-Control-Allow-Origin。\n\n\n * User-Agent\n\n首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n\n\n * Pragma\n\nPragma: no-cache\n\nPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。客户端会要求所有的中间服务器不返回缓存的资源。\n\n\n * Content-Type\n\nContent-Type来表示具体请求中的媒体类型信息。\n\napplication/x-www-form-urlencoded\n\n请求参数格式`key1=val1&key2=val2`的方式进行拼接，并放到请求实体里面，如果是中文或特殊字符等会自动进行URL转码。一般用于表单提交\n\napplication/json\n\napplication/json 作为响应头比较常见，用来告诉服务端消息主体是序列化后的 JSON 字符串，其中一个好处就是JSON 格式支持比键值对复杂得多的结构化数据。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持JSON.stringify，服务端语言也都有处理 JSON 的函数，使用起来没有困难。\n\n\n\n# 响应头字段\n\n预检请求相关响应头\n\n * Access-Control-Allow-Origin：响应头指定了该响应的资源是否被允许与给定的origin共享。\n\n * Access-Control-Allow-Methods: 响应首部 Access-Control-Allow-Methods 在对 preflight request.（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。\n\n * Access-Control-Allow-Headers: 响应首部 Access-Control-Allow-Headers 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息。\n\n * Access-Control-Allow-Credentials: 当请求要求携带证书信息（例如cookie,授权信息等）验证，服务器端是否允许携带\n\n * Access-Control-Max-Age: 本次预检请求的有效期，单位为秒\n\n----------------------------------------\n\n * Date\n\n服务端响应客户端的时间\n\n\n * Server\n\n服务器名字\n\n\n * Content-Type\n\n服务端发送的媒体类型\n\n\n * Set-Cookie\n\n浏览器会在当前页面所在域名设置cookie，当浏览器再次发送请求时，浏览器默认会自动将cookie放在请求头中的Cookie项中发送给服务器。\n\n\n * Cache-Control、E-Tag 、 Last-Modified\n\n * Content-Encoding\n\n文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。\n\n\n * Connection\n\nKeep-alive 长连接\n\n\n\n# Content-type\n\n\n# 用于前端请求\n\n * Content-Type 设置与 get 请求无关,一般与post请求相关\n\n * 当用 form 表单提交时 Content-Type 默认为application/x-www-form-urlencoded，当用XHR提交时，Content-Type默认为application/json\n\n * Content-Type 为 application/x-www-form-urlencoded时提交数据的方式为a = 123&b = 456&c = [1,2,3]\n\n * Content-Type为application/json时需要以json形式提交body: '{\"a\":123,\"b\":456}'\n\n\n# 用于后端响应\n\n * 'text/html' // 用于指定html文件\n\n * 'text/plain' // html的源码会显示到页面上\n\n * 'text/css' // 用于指定css文件\n\n * 'image/jpg' // 用于指定图片格式\n\n * 'aplication/javascript' // 用于指定js文件\n\n * 'application/json' // 用于指定请求接口的数据格式\n\n\n# 进程与线程\n\n * 进程是CPU资源分配的最小单位（能拥有资源和独立运行的最小单位）\n * 线程是CPU调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程）\n * 同一进程中的多条线程讲共享该进程中的全部系统资源，但是同一进程中的多个线程有各自的调用栈，自己的线程本地存储。一个进程可以有很多线程，每条线程并行执行不同的任务\n * 进程间通信方式：管道、信号量、消息队列、共享内存、套接字（socket）。\n * 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。（锁机制：包括互斥锁、条件变量、读写锁，信号量机制(Semaphore)，信号机制(Signal)）\n\n\n# 基于对象与面向对象\n\n * 面向对象的三大特点（封装，继承，多态）缺一不可，例如 c++，java\n * 基于对象的语言，使用一些封装好的对象，调用对象的方法，设置对象的属性，但是无法派生新的对象类型，只能使用现有对象的方法和属性。\n * javascript虽然通过原型链等实现了继承，通过arguments实现函数重载等特点，但是都是属于模拟实现，本质上还是基于对象的语言，实际上可以实现面向对象编程。\n\n\n# ARP，RARP 协议\n\narp协议：地址解析协议\n\n在局域网中，当主机 A 有数据要发送给主机 B 时，A 必须知道 B 的 IP 地址。\n\n但是仅仅有IP地址还是不够的，因为IP数据报文还需要在数据链路层封装成帧才能通过物理网络发送。因为发送端还必须有接收端的MAC地址，所以需要一个从IP地址到MAC地址的映射。ARP就是干这事情的协议。\n\n>  1. 主机 A 自身 arp 缓存表中，没有主机 B 的 MAC 信息，会在整个网络中广播 arp 请求\n>  2. 主机 B 接收到 arp 请求后，先将主机 A 的 MAC 的地址加入自己的 arp 缓存表中\n>  3. 再发送 arp 答复，我是主机 B，我的 mac 地址是什么\n>  4. 主机 A 添加主机 B 的 MAC 地址信息，给主机 B 发送信息，根据 arp 缓存表直接发送\n> \n> rarp协议：反向地址解析协议\n> \n> 局域网中，知道了某个主机的 MAC 地址，不知道某个主机的 IP 地址，通过 rarp 协议获得地址。\n\n\n# 数据库事务的四个特性\n\n事务（Transaction）是并发控制单位，是用户定义的一个操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。\n\n事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。\n\n\n# 数据库索引与B+树\n\n数据库索引其实就是为了使查询数据效率快。\n\n 1. 聚集索引（主键索引）：在数据库里面，所有行数都会按照主键索引进行排序。(拼音首字母作为主键查字典)\n 2. 非聚集索引：就是给普通字段加上索引。（偏旁部首去查）\n 3. 联合索引：就是好几个字段组成的索引，称为联合索引。（拼音+偏旁部首去查）\n\nB+树\n\n\n# 死锁\n\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\n\n例如：线程 A 持有 lockA 对象，并请求 lockB 对象；线程 B 持有 lockB 对象，并请求 lockA 对象。由于他们都在等待对方释放资源，所以会产生死锁\n\n\n# 有限自动机\n\n * 一般我们会用状态图来描述一个有限自动机（Finite Automata）。它有且只有一个起始状态（在状态图中，一个从不知道什么地方来的箭头指向的状态），有一些接受状态（状态图中有两个圈圈起来的状态）。\n * 有限自动机的输出是接受或者拒绝。\n\n\n# 编译原理的过程\n\n> 词法分析生成tokens流，语法分析转换成AST，AST节点遍历进行处理\n\n\n# linux 解压命令\n\nhttps://blog.csdn.net/qq_40232872/article/details/79159753",normalizedContent:"# 计算机基础\n\n\n# osi七层模型与tcp/ip五层模型\n\nosi定义了网络互连的七层框架\n\n * 应用层：针对你特定应用的协议\n * 表示层：设备固定的数据格式和网络标准数据格式之间的转化\n * 会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层\n * 传输层：管理两个节点之间的数据传递。负责可靠传输\n * 网络层：地址管理和路由选择\n * 数据链路层：互联设备之间传送和识别数据帧\n * 物理层：界定连接器和网线之间的规格\n\ntcp/ip四（五）层模型\n\n每一层都呼叫它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层）\n\n * 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。\n * 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。\n * 网络层：负责地址管理和路由选择。路由器工作在网络层。\n * 传输层：负责两台主机之间的数据传输。\n * 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。\n\n\n# tcp与udp的区别\n\n * tcp 和 udp 都是属于传输层，传输层提供应用程序间的通信，其功能包括格式化信息流，提供可靠传输。\n\n * tcp面向连接（如打电话要先拨号建立连接）;udp是无连接的，即发送数据之前不需要建立连接\n\n * tcp提供可靠的服务。也就是说，通过tcp连接传送的数据，无差错，不丢失，不重复，且按序到达;udp尽最大努力交付，即不保证可靠交付。\n\n * tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。\n\n * udp具有较好的实时性，工作效率比tcp高，适用于对高速传输和实时性有较高的通信或广播通信。\n\n为什么udp有时比tcp更有优势?\n\n * udp以其简单、传输快的优势，在越来越多场景下取代了tcp,如实时游戏。\n\n * 网速的提升给udp的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。\n\n * tcp为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于tcp内置的系统协议栈中，极难对其进行改进。\n\n * 采用tcp，一旦发生丢包，tcp会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于udp对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响\n\n\n# tcp三次握手，四次挥手\n\n三次握手：通俗的讲\n                客户端：hi听见了吗,\n                服务器端：hi我听见了，\n                客户端：我也听见你了。     接下来开始愉快地聊天\n四次握手：通俗的讲\n                客户端：我们分手把，\n                服务端：好的，你等我把数据给你传输完\n                服务端：我传输完了，\n                客户端：好了，可以分手了。 接下来就真正的分手了\n\n\n * 三次握手\n * 四次挥手\n * syn (synchronous建立联机)\n * ack (acknowledgement 确认)\n * fin (finish结束)\n * sequence number (顺序号码)\n * 为什么time_wait状态需要经过2msl(最大报文段生存时间)才能返回到close状态\n\n为了保证a发送的最后一个ack报文能够到达b。这个ack报文段有可能丢失，因而使处在last-ack状态的b收不到对已发送的fin+ack报文段的确认。b会超时重传这个fin+ack报文段，而a就能在2msl时间内收到这个重传的fin+ack报文段。\n\n\n * 为什么是三次握手而不是两次握手？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于tcp的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n * 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n\n建立连接的时候， 服务器在listen状态下，收到建立连接请求的syn报文后，把ack和syn放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的fin报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送fin报文给对方来表示同意现在关闭连接，因此，己方ack和fin一般都会分开发送，从而导致多了一次。\n\n\n\n# tcp如何可靠传输\n\n * 重传机制\n * 滑动窗口\n   * 可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n * 流量控制\n   * tcp 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\n * 拥塞控制\n   * 慢启动\n   * 拥塞避免\n   * 拥塞发生\n   * 快速恢复\n\n\n# tcp拥塞控制\n\n拥塞控制主要是四个算法：\n\n * 慢启动\n * 拥塞避免\n * 拥塞发生\n * 快速恢复\n\n图示\n\n\n# 慢热启动算法 – slow start\n\n所谓慢启动，也就是tcp连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。\n\n>  1. 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个mss大小的数据。 2) 每当收到一个ack，cwnd大小加一，呈线性上升。 3) 每当过了一个往返延迟时间rtt(round-trip time)，cwnd大小直接翻倍，乘以2，呈指数让升。 4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）\n\n\n# 拥塞避免算法 – congestion avoidance\n\n如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：\n\n> 收到一个ack，则cwnd = cwnd + 1 / cwnd 2) 每当过了一个往返延迟时间rtt，cwnd大小加一。过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。\n\n\n# 拥塞发生\n\n最为早期的tcp tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。\n\n所以，tcp reno算法进行了优化。当收到三个重复确认ack时，tcp开启快速重传fast retransmit算法，而不用等到rto超时再进行重传：\n\n * cwnd大小缩小为当前的一半\n * ssthresh设置为缩小后的cwnd大小\n * 然后进入快速恢复算法fast recovery。\n\n\n# 快恢复\n\n在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：\n\n * cwnd = cwnd + 3 * mss，加3 * mss的原因是因为收到3个重复的ack。\n * 重传dacks指定的数据包。\n * 如果再收到dacks，那么cwnd大小增加一。\n * 如果收到新的ack，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。\n\n\n# 什么是 http 协议\n\n> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于tcp/ip协议传输数据，互联网上应用最为广泛的一种网络协议,所有的www文件都必须遵守这个标准。设计http的初衷是为了提供一种发布和接收html页面的方法。\n\n版本         产生时间    内容                                             发展现状\nhttp/0.9   1991年   不涉及数据包传输，规定客户端和服务器之间通信格式，只能get请求               没有作为正式的标准\nhttp/1.0   1996年   传输内容格式不限制，增加put、patch、head、 options、delete命令   正式作为标准\nhttp/1.1   1997年   持久连接(长连接)、节约带宽、host域、管道机制、分块传输编码               2015年前使用最广泛\nhttp/2     2015年   多路复用、服务器推送、头信息压缩、二进制协议等                        逐渐覆盖市场\n\n\n# 长连接与多路复用\n\n * 长连接：在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启connection： keep-alive，一定程度上弥补了http1.0每次请求都要创建连接的缺点。\n\n * 二进制分帧：在http1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。（1帧 = 8字节，最小通信单位）\n\n * 首部压缩：在http1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。\n   \n   在http2.0中，我们使用了hpack（http2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。\n\n * 请求优先级：把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。\n\n * 多路复用：在 http 1.0 中，发起一个请求是这样的：\n\n浏览器请求 url -> 解析域名 -> 建立 http 连接 -> 服务器处理文件 -> 返回数据 -> 浏览器解析、渲染文件 \n\n这个流程最大的问题是，每次请求都需要建立一次 http 连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！\n\n为了解决这个问题， http 1.1 中提供了 keep-alive，允许我们建立一次连接，来返回多次请求数据。\n\n但是这里有两个问题：\n\nhttp 1.1 基于串行文件传输数据，因此这些请求必须是有序的，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序。所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少\n\n最大并发数问题，假设我们在 apache 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50\n\n而 http/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。\n\nhttp/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍。\n\n就好比面试，http1.1是一面之后，视频不断继续二面，http2.0是只要有面试官来了就同时面试（传输数据）\n\n\n\n\n\n# 怎么理解多路复用\n\nhttp/2是基于二进制“帧”的协议，http/1.1是基于“文本分割”解析的协议。\n\nhttp 1.1 基于串行文件传输数据，因此这些请求必须是有序的，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序。\n\n而 http/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。\n\n\n# tcp 队头阻塞和 http 队头阻塞\n\n * tcp 队头阻塞：tcp数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。\n * http 队头阻塞：http1.1采用长连接，可以在一个tcp请求上，发送多个http请求。管道化的机制使得请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。这就会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞\n\n\n# tcp 长连接和 http 长连接\n\n * http 的 keep-alive 也叫 http 长连接，该功能是由「应用程序」实现的，可以使得用同一个 tcp 连接来发送和接收多个 http 请求/应答，减少了 http 短连接带来的多次 tcp 连接建立和释放的开销。\n\n * tcp 的 keepalive 也叫 tcp 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。\n\n\n# 如何解决队头阻塞\n\n * tcp 队头阻塞：直接弃用。。详见http3\n * http 队头阻塞：\n   * 建立多个 tcp 连接，如 chrome 最多限制6个并发请求，每个 tcp 连接对应一个 connection id\n   * http2 多路复用，对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接\n\n\n\n\n# 如何在 chrome 中查看 http 协议\n\n只需在 network 中右键点击表头，就可以控制展示的列，其中就有 protocol 选项。\n\n\n\n\n# http 1.1 和 http 2 对比\n\n在http 1.1，所以浏览器会限制同一个域的同时请求数，chrome是限制6个，如图：\n\n\n\n但当我们开启了http/2之后，个数几乎没有限制了，如下图所示：\n\n\n\n不过请求的顺序及并发并不完全依赖于此，如果在项目中写了如下代码：\n\nasync getdata() {\n  await this.getlist1();\n  await this.getlist2();\n  await this.getlist3();\n  await this.getlist4();\n  await this.getlist5();\n}\n\n\n那么在 chrome 中的表现如下：\n\n\n\n我们一般可以优化为：\n\nasync getdata() {\n  await promise.all([\n    this.getlist1(),\n    this.getlist2(),\n    this.getlist3(),\n    this.getlist4(),\n    this.getlist5(),\n  ]);\n}\n\n\n\n# https\n\nhttp请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果http请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，netscape 公司制定了https协议，https可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。\n\n * http协议运行在tcp之上，所有传输的内容都是明文，https运行在ssl/tls之上，ssl/tls运行在tcp之上，所有传输的内容都经过加密的，保证了通信的保密性。当然ssl协议并不能对udp应用进行保护\n\n * 虽然使用 http 协议无法确定通信方，使用 ssl可以。ssl使用了一种被称为证书的手段，证书由值得信任的第三方机构颁发，使用https协议需要到ca申请证书，一般免费证书很少，需要交费。证书用以证明服务器和客户端是实际存在的。身份确认过程使用rsa非对称密钥加密方式（破解难度基于两个大素数乘积的因式分解难度），但是为了提高效率，身份确认完成后使用共商后的对称密钥。\n\n * ssl协议位于tcp/ip协议与各种应用层协议（不止能用于http）之间，为数据通讯提供安全支持。\n   \n   ssl协议可分为两层：\n   \n   （1）ssl记录协议：建立在可靠的传输协议（如tcp）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。\n   \n   （2）ssl握手协议：建立在记录协议之上，用于数据传输开始前的双方身份认证、协商加密算法、交换加密密钥等。\n\n * 主要流程：\n   \n   * 客户端向服务器发起https请求，连接到服务器的443端口\n   * 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。\n   * 服务器将自己的公钥发送给客户端。\n   * 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么https传输就无法继续。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，https中的第一次http请求结束。\n   * 客户端会发起https中的第二个http请求，将加密之后的客户端密钥发送给服务器。\n   * 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。\n   * 然后服务器将加密后的密文发送给客户端。\n   * 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样https中的第二个http请求结束，整个https传输完成。\n\n * 注意： https 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。\n\n * 为什么数据传输是用对称加密的？\n   \n   * 非对称加密的加解密效率非常低，而http的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。\n   * 在 https 的场景中只有服务端保存了私钥，客户端不做非对称密钥生成，一对公钥和私钥只能实现单向的加解密，所以https 中内容传输加密采取的是对称加密，而不是非对称加密。\n\n----------------------------------------\n\n> https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。\n> \n> ssl和tls都是加密协议 通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。 所谓https，其实就是身披ssl协议这层外壳的http。（回忆一下osi7层,tcp/ip4层，我们学的是5层）\n> \n> ssl协议采用的是非对称加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密.\n> \n> rsa算法：两个大素数p,q，n=pq,f(n)=(p-1)(q-1),1<b<f(n),a=b^-1modf(n),公钥n,b,私钥p,q,a\n> \n> 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ certificate authority, ca）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥与 ca 用私钥生成的数字签名等信息写成证书颁发给申请者。\n> \n> 当你访问使用 https（连接安全）的网站时，该网站的服务器会使用证书向浏览器（如 chrome）证明该网站的身份。任何人都可以创建证书，随意声称对应的网站是任意网站。\n> \n> 为了确保您安全上网，chrome 会要求网站使用来自受信任组织发放的证书。\n\n\n# http请求方法\n\nget\n\n\nget方法请求一个指定资源的表示形式. 使用get的请求应该只被用于获取数据.\n\nhead\n\n\nhead方法请求一个与get请求的响应相同的响应，但没有响应体，一般用于1.检查资源的有效性。 2.检查超链接的有效性。 3.检查网页是否被串改。\n\npost\n\n\npost方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用.\n\nput\n\n\nput方法用请求有效载荷替换目标资源的所有当前表示。\n\ndelete\n\n\ndelete方法删除指定的资源。\n\nconnect\n\n\nconnect方法建立一个到由目标资源标识的服务器的隧道。\n\noptions\n\n\noptions方法用于描述目标资源的通信选项。\n\ntrace\n\n\ntrace方法沿着到目标资源的路径执行一个消息环回测试。\n\npatch\n\n\npatch方法用于对资源应用部分修改。\n\n\n# 常见请求头\n\nhttp 首部字段是由首部字段名和字段值构成的，中间用冒号 : 分隔。\n\n首部字段名: 字段值\n\n\n另外，字段值对应单个 http 首部字段可以有多个值，多个指令之间通过 ,分隔。如下所示。\n\nkeep-alive: timeout=15, max=100\n\n\n若想要加优先级，则使用 q=来额外表示权重值 1 ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。\n\naccept-language: zh-cn,zh;q=0.9,en;q=0.8\n\n\n\n# 请求头字段\n\n * accept\n\naccept: image/webp,image/apng,image/*,*/*;q=0.8\n\naccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type/subtype 这种形式，一次指定多种媒体类型。\n\n\n * accept-encoding\n\naccept-encoding: gzip, deflate, br\n\naccept-encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。\n\n\n * accept-language\n\naccept-language: zh-cn,zh;q=0.9,en;q=0.8\n\n首部字段 accept-language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。\n\n\n * cache-control\n\ncache-control: no-cache，缓存\n\n\n * connection\n\nconnection: keep-alive\n\nhttp/1.1 之前的 http 版本的默认连接都是非持久连接。为此，如果想在旧版本的http 协议上维持持续连接，则需要指定connection 首部字段的值为 keep-alive。\n\n\n * cookie\n\n首部字段 cookie 会告知服务器，当客户端想获得http 状态管理支持时，就会在请求中包含从服务器接收到的 cookie。\n\n\n * host\n\nhost: www.baidu.com\n\n首部字段 host 会告知服务器，请求的资源所处的互联网主机名和端口号。host 首部字段在http/1.1 规范内是唯一一个必须被包含在请求内的首部字段。\n\n\n * referer\n\n首部字段 referer 会告知服务器请求的原始资源的 uri。它记录了该 http 请求的来源地址。\n\n如果黑客要对银行网站实施 csrf 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 referer 是指向黑客自己的网站。因此，要防御 csrf 攻击，银行网站只需要对于每一个转账请求验证其 referer 值 。\n\n然而，这种方法并非万无一失。referer 的值是由浏览器提供的 ，目前已经有一些方法可以篡改 referer 值 \n\n即便是使用最新的浏览器，黑客无法篡改 referer 值，这种方法仍然有问题。因为 referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，因此，用户自己可以设置浏览器使其在发送请求时不再提供 referer。当他们正常访问银行网站时，网站会因为请求没有 referer 值而认为是 csrf 攻击，拒绝合法用户的访问。\n\n\n * origin\n\n用来说明请求从哪里发起的，包括，且仅仅包括 协议和域名。\n这个参数一般只存在于cors跨域请求中，可以看到 response 有对应的 header：access-control-allow-origin。\n\n\n * user-agent\n\n首部字段 user-agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n\n\n * pragma\n\npragma: no-cache\n\npragma 是 http/1.1 之前版本的历史遗留字段，仅作为与 http/1.0 的向后兼容而定义。客户端会要求所有的中间服务器不返回缓存的资源。\n\n\n * content-type\n\ncontent-type来表示具体请求中的媒体类型信息。\n\napplication/x-www-form-urlencoded\n\n请求参数格式`key1=val1&key2=val2`的方式进行拼接，并放到请求实体里面，如果是中文或特殊字符等会自动进行url转码。一般用于表单提交\n\napplication/json\n\napplication/json 作为响应头比较常见，用来告诉服务端消息主体是序列化后的 json 字符串，其中一个好处就是json 格式支持比键值对复杂得多的结构化数据。由于 json 规范的流行，除了低版本 ie 之外的各大浏览器都原生支持json.stringify，服务端语言也都有处理 json 的函数，使用起来没有困难。\n\n\n\n# 响应头字段\n\n预检请求相关响应头\n\n * access-control-allow-origin：响应头指定了该响应的资源是否被允许与给定的origin共享。\n\n * access-control-allow-methods: 响应首部 access-control-allow-methods 在对 preflight request.（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。\n\n * access-control-allow-headers: 响应首部 access-control-allow-headers 用于 preflight request （预检请求）中，列出了将会在正式请求的 access-control-request-headers 字段中出现的首部信息。\n\n * access-control-allow-credentials: 当请求要求携带证书信息（例如cookie,授权信息等）验证，服务器端是否允许携带\n\n * access-control-max-age: 本次预检请求的有效期，单位为秒\n\n----------------------------------------\n\n * date\n\n服务端响应客户端的时间\n\n\n * server\n\n服务器名字\n\n\n * content-type\n\n服务端发送的媒体类型\n\n\n * set-cookie\n\n浏览器会在当前页面所在域名设置cookie，当浏览器再次发送请求时，浏览器默认会自动将cookie放在请求头中的cookie项中发送给服务器。\n\n\n * cache-control、e-tag 、 last-modified\n\n * content-encoding\n\n文档的编码（encode）方法。只有在解码之后才可以得到content-type头指定的内容类型。利用gzip压缩文档能够显著地减少html文档的下载时间。\n\n\n * connection\n\nkeep-alive 长连接\n\n\n\n# content-type\n\n\n# 用于前端请求\n\n * content-type 设置与 get 请求无关,一般与post请求相关\n\n * 当用 form 表单提交时 content-type 默认为application/x-www-form-urlencoded，当用xhr提交时，content-type默认为application/json\n\n * content-type 为 application/x-www-form-urlencoded时提交数据的方式为a = 123&b = 456&c = [1,2,3]\n\n * content-type为application/json时需要以json形式提交body: '{\"a\":123,\"b\":456}'\n\n\n# 用于后端响应\n\n * 'text/html' // 用于指定html文件\n\n * 'text/plain' // html的源码会显示到页面上\n\n * 'text/css' // 用于指定css文件\n\n * 'image/jpg' // 用于指定图片格式\n\n * 'aplication/javascript' // 用于指定js文件\n\n * 'application/json' // 用于指定请求接口的数据格式\n\n\n# 进程与线程\n\n * 进程是cpu资源分配的最小单位（能拥有资源和独立运行的最小单位）\n * 线程是cpu调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程）\n * 同一进程中的多条线程讲共享该进程中的全部系统资源，但是同一进程中的多个线程有各自的调用栈，自己的线程本地存储。一个进程可以有很多线程，每条线程并行执行不同的任务\n * 进程间通信方式：管道、信号量、消息队列、共享内存、套接字（socket）。\n * 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。（锁机制：包括互斥锁、条件变量、读写锁，信号量机制(semaphore)，信号机制(signal)）\n\n\n# 基于对象与面向对象\n\n * 面向对象的三大特点（封装，继承，多态）缺一不可，例如 c++，java\n * 基于对象的语言，使用一些封装好的对象，调用对象的方法，设置对象的属性，但是无法派生新的对象类型，只能使用现有对象的方法和属性。\n * javascript虽然通过原型链等实现了继承，通过arguments实现函数重载等特点，但是都是属于模拟实现，本质上还是基于对象的语言，实际上可以实现面向对象编程。\n\n\n# arp，rarp 协议\n\narp协议：地址解析协议\n\n在局域网中，当主机 a 有数据要发送给主机 b 时，a 必须知道 b 的 ip 地址。\n\n但是仅仅有ip地址还是不够的，因为ip数据报文还需要在数据链路层封装成帧才能通过物理网络发送。因为发送端还必须有接收端的mac地址，所以需要一个从ip地址到mac地址的映射。arp就是干这事情的协议。\n\n>  1. 主机 a 自身 arp 缓存表中，没有主机 b 的 mac 信息，会在整个网络中广播 arp 请求\n>  2. 主机 b 接收到 arp 请求后，先将主机 a 的 mac 的地址加入自己的 arp 缓存表中\n>  3. 再发送 arp 答复，我是主机 b，我的 mac 地址是什么\n>  4. 主机 a 添加主机 b 的 mac 地址信息，给主机 b 发送信息，根据 arp 缓存表直接发送\n> \n> rarp协议：反向地址解析协议\n> \n> 局域网中，知道了某个主机的 mac 地址，不知道某个主机的 ip 地址，通过 rarp 协议获得地址。\n\n\n# 数据库事务的四个特性\n\n事务（transaction）是并发控制单位，是用户定义的一个操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。\n\n事务具有四个特征：原子性（ atomicity ）、一致性（ consistency ）、隔离性（ isolation ）和持续性（ durability ）。这四个特性简称为 acid 特性。\n\n\n# 数据库索引与b+树\n\n数据库索引其实就是为了使查询数据效率快。\n\n 1. 聚集索引（主键索引）：在数据库里面，所有行数都会按照主键索引进行排序。(拼音首字母作为主键查字典)\n 2. 非聚集索引：就是给普通字段加上索引。（偏旁部首去查）\n 3. 联合索引：就是好几个字段组成的索引，称为联合索引。（拼音+偏旁部首去查）\n\nb+树\n\n\n# 死锁\n\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\n\n例如：线程 a 持有 locka 对象，并请求 lockb 对象；线程 b 持有 lockb 对象，并请求 locka 对象。由于他们都在等待对方释放资源，所以会产生死锁\n\n\n# 有限自动机\n\n * 一般我们会用状态图来描述一个有限自动机（finite automata）。它有且只有一个起始状态（在状态图中，一个从不知道什么地方来的箭头指向的状态），有一些接受状态（状态图中有两个圈圈起来的状态）。\n * 有限自动机的输出是接受或者拒绝。\n\n\n# 编译原理的过程\n\n> 词法分析生成tokens流，语法分析转换成ast，ast节点遍历进行处理\n\n\n# linux 解压命令\n\nhttps://blog.csdn.net/qq_40232872/article/details/79159753",charsets:{cjk:!0}},{title:"设计模式",frontmatter:{},regularPath:"/design-pattern/design-pattern.html",relativePath:"design-pattern/design-pattern.md",key:"v-f33b1342",path:"/design-pattern/design-pattern.html",headers:[{level:2,title:"工厂模式(Factory pattern)",slug:"工厂模式-factory-pattern",normalizedTitle:"工厂模式(factory pattern)",charIndex:591},{level:3,title:"工厂模式的实例",slug:"工厂模式的实例",normalizedTitle:"工厂模式的实例",charIndex:697},{level:3,title:"工厂模式的优势",slug:"工厂模式的优势",normalizedTitle:"工厂模式的优势",charIndex:1793},{level:2,title:"抽象工厂模式(abstract Factory Pattern)",slug:"抽象工厂模式-abstract-factory-pattern",normalizedTitle:"抽象工厂模式(abstract factory pattern)",charIndex:1937},{level:3,title:"抽象工厂模式的实例",slug:"抽象工厂模式的实例",normalizedTitle:"抽象工厂模式的实例",charIndex:2166},{level:3,title:"抽象工厂模式的优势",slug:"抽象工厂模式的优势",normalizedTitle:"抽象工厂模式的优势",charIndex:4408},{level:2,title:"单例模式(Singleton Pattern)",slug:"单例模式-singleton-pattern",normalizedTitle:"单例模式(singleton pattern)",charIndex:4478},{level:3,title:"单例模式的实例",slug:"单例模式的实例",normalizedTitle:"单例模式的实例",charIndex:4532},{level:3,title:"单例模式的优势",slug:"单例模式的优势",normalizedTitle:"单例模式的优势",charIndex:5459},{level:3,title:"单例模式的使用场景",slug:"单例模式的使用场景",normalizedTitle:"单例模式的使用场景",charIndex:5510},{level:2,title:"建造者模式",slug:"建造者模式",normalizedTitle:"建造者模式",charIndex:312},{level:3,title:"白话解释",slug:"白话解释",normalizedTitle:"白话解释",charIndex:6199},{level:2,title:"适配器模式(Adapter Pattern)",slug:"适配器模式-adapter-pattern",normalizedTitle:"适配器模式(adapter pattern)",charIndex:7648},{level:3,title:"适配器模式的实例",slug:"适配器模式的实例",normalizedTitle:"适配器模式的实例",charIndex:7736},{level:3,title:"适配器模式的优势",slug:"适配器模式的优势",normalizedTitle:"适配器模式的优势",charIndex:9801},{level:2,title:"装饰器模式(Decorator Pattern)",slug:"装饰器模式-decorator-pattern",normalizedTitle:"装饰器模式(decorator pattern)",charIndex:9850},{level:3,title:"装饰器模式的实例",slug:"装饰器模式的实例",normalizedTitle:"装饰器模式的实例",charIndex:9926},{level:3,title:"装饰器模式的优势",slug:"装饰器模式的优势",normalizedTitle:"装饰器模式的优势",charIndex:11018},{level:2,title:"过滤器模式(Filter Pattern)",slug:"过滤器模式-filter-pattern",normalizedTitle:"过滤器模式(filter pattern)",charIndex:11074},{level:3,title:"过滤器模式的实例",slug:"过滤器模式的实例",normalizedTitle:"过滤器模式的实例",charIndex:11126},{level:3,title:"过滤器模式优势",slug:"过滤器模式优势",normalizedTitle:"过滤器模式优势",charIndex:15407}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"工厂模式(Factory pattern) 工厂模式的实例 工厂模式的优势 抽象工厂模式(abstract Factory Pattern) 抽象工厂模式的实例 抽象工厂模式的优势 单例模式(Singleton Pattern) 单例模式的实例 单例模式的优势 单例模式的使用场景 建造者模式 白话解释 适配器模式(Adapter Pattern) 适配器模式的实例 适配器模式的优势 装饰器模式(Decorator Pattern) 装饰器模式的实例 装饰器模式的优势 过滤器模式(Filter Pattern) 过滤器模式的实例 过滤器模式优势",content:"# 设计模式\n\nJavaScript 设计模式，设计模式是一种思想，和语言无关。\n\n * 开发效率\n * 可维护性\n\n相关书籍\n\n * 《大话设计模式》\n * 《设计模式：可服用面向对象软件的基础》\n * 《headfirst 设计模式》\n * 《JavaScript 设计模式》\n * 《JavaScript中的设计模式》\n\n\n# 面向对象的 JavaScript\n\n * 类\n * 实例\n * 构造函数\n * 继承\n * 多态\n * 封装\n * 原型\n * class语法\n * 具体看面向对象编程\n\n\n# 设计模式\n\n * 创建型模式\n   \n   * 工厂模式\n   * 抽象工厂模式\n   * 单例模式\n   * 建造者模式\n   * 原型模式\n\n * 结构型模式\n   \n   * 适配器模式\n   * 桥接模式\n   * 过滤器模式\n   * 组合模式\n   * 装饰器模式\n   * 外观模式\n   * 享元模式\n   * 代理模式\n\n * 行为型模式\n   \n   * 责任链模式\n   * 命令模式\n   * 解释器模式\n   * 迭代器模式\n   * 中介者模式\n   * 备忘录模式\n   * 观察者模式\n   * 状态模式\n   * 空对象模式\n   * 策略模式\n   * 模板模式\n   * 访问者模式\n\n * 适配器模式\n\n * 装饰器模式\n\n\n# 工厂模式(Factory pattern)\n\n工厂模式是比较常用的设计模式之一，那么什么叫工厂模式呢？简单来说，就是你需要什么东西不直接使用new的方法生成实例，然后统一通过工厂进行生产加工再生成实例。\n\n\n# 工厂模式的实例\n\n比如我们现在有很多形状比如圆形，矩形和正方形。这类都是属于形状，那我们是不是可以通过专门生产形状的工厂来生成它们的实例么？\n\nclass Circle {\n    draw() {\n        console.log(\"I'm a circle\")\n    }\n}\nclass Rectangle {\n    draw() {\n        console.log(\"I'm a rectangle\")\n    }\n}\nclass Square {\n    draw() {\n        console.log(\"I'm a square\")\n    }\n}\n\n\n那么接下来，我们可以建立一个专门生产形状的工厂来生产它们了。即根据字符串来产生对应需要的类。你在这里可以看到类的出口都已经在一个方法中了。\n\nclass ShapeFactory {\n    getShape(shapeType){\n        switch(shapeType) {\n            case 'CIRCLE':\n                return new Circle();\n            case 'RECTANGLE':\n                return new Rectangle();\n            case 'SQUARE':\n                return new Square();\n            default:\n                return null;\n        }\n    }\n}\n\n\n那么我们需要使用的时候，就可以直接只需要new出一个工厂，在根据字符串就能拿到对应的需要生产的类了。而不需要分别对类进行new。\n\nconst shapeFactory = new ShapeFactory();\n// 通过工厂拿各种形状\nconst shape1 = shapeFactory.getShape('CIRCLE');\nshape1.draw();\nconst shape2 = shapeFactory.getShape('RECTANGLE');\nshape2.draw();\nconst shape3 = shapeFactory.getShape('SQUARE');\nshape3.draw();\n/**\n * output:\n * I'm a circle\n * I'm a rectangle\n * I'm a square\n */\n\n\n\n# 工厂模式的优势\n\n那么使用工厂模式的好处也是显而易见的，比如实例的生产比较复杂，或者说生成实例后还需要额外加工，这个时候工厂给了我们一个统一的出入口，也方便了日后对这个实例的修改。比如你要修改工厂产出是一个单例的时候，就不需要在所有的类中修改，而只要在工厂出口修改即可达到目标。\n\n\n# 抽象工厂模式(abstract Factory Pattern)\n\n上文讲到了工厂模式，这篇文章将抽象工厂，抽象工厂的名字是真的很抽象，也很容易让人抽象的理解，那么什么是抽象工厂呢？\n\n其实抽象工厂，简单来说就是工厂的工厂，因为一般来说一个工厂只负责加载一类组件，那么你有很多小类组件需要生产，那么势必会有很多小类的工厂。那么你最终生产一个大类，那就要很多小类的工厂负责生产。那么如何更方便的管理或者说生产这些工厂呢？那就用生产工厂的工厂来生成吧。\n\n\n# 抽象工厂模式的实例\n\n先把上文说的形状工厂搬过来\n\n// 这是之前上文说的形状工厂\nclass Circle {\n    draw() {\n        console.log(\"I'm a circle\")\n    }\n}\nclass Rectangle {\n    draw() {\n        console.log(\"I'm a rectangle\")\n    }\n}\nclass Square {\n    draw() {\n        console.log(\"I'm a square\")\n    }\n}\nclass ShapeFactory {\n    getShape(shapeType){\n        switch(shapeType) {\n            case 'CIRCLE':\n                return new Circle();\n            case 'RECTANGLE':\n                return new Rectangle();\n            case 'SQUARE':\n                return new Square();\n            default:\n                return null;\n        }\n    }\n}\n\n\n这时候你已经有形状了，但你觉得不美观，你还需要颜色，那么你这个时候，你又搞了个颜色工厂，如下：\n\n// 再新加一个颜色工厂\nclass Red {\n    fill() {\n        console.log(\"fill red\")\n    }\n}\nclass Blue {\n    fill() {\n        console.log(\"fill blue\")\n    }\n}\nclass Green {\n    fill() {\n        console.log(\"fill green\")\n    }\n}\nclass ColorFactory {\n    getColor(color){\n        switch(color) {\n            case 'RED':\n                return new Red();\n            case 'BLUE':\n                return new Blue();\n            case 'GREEN':\n                return new Green();\n            default:\n                return null;\n        }\n    }\n}\n\n\n颜色工厂好了，但是你担心，以后工厂多了，不好管理咋办，那还是走之前的套路，把工厂通过抽象工厂生产出来。如下：\n\n// 最后添加抽象工厂\nclass FactoryProducer {\n    static getFactory(choice){\n        switch(choice) {\n            case 'SHAPE':\n                return new ShapeFactory();\n            case 'COLOR':\n                return new ColorFactory();\n            default:\n                return null;\n        }\n    }\n}\n\n\n那么这个时候和上文一样只需要new出一个抽象工厂，就能把所有需要的东西拿到手了:\n\n//通过抽象工厂拿形状工厂\nconst shapeFactory = FactoryProducer.getFactory('SHAPE');\n// 通过工厂拿各种形状\nconst shape1 = shapeFactory.getShape('CIRCLE');\nshape1.draw();\nconst shape2 = shapeFactory.getShape('RECTANGLE');\nshape2.draw();\nconst shape3 = shapeFactory.getShape('SQUARE');\nshape3.draw();\n//通过抽象工厂拿颜色工厂\nconst colorFactory = FactoryProducer.getFactory('COLOR');\n// 通过工厂拿各种颜色\nconst color1 = colorFactory.getColor('RED');\ncolor1.fill();\nconst color2 = colorFactory.getColor('BLUE');\ncolor2.fill();\nconst color3 = colorFactory.getColor('GREEN');\ncolor3.fill();\n/**\n * output：\n * I'm a circle\n * I'm a rectangle\n * I'm a square\n * fill red\n * fill blue\n * fill green\n */\n\n\n\n# 抽象工厂模式的优势\n\n那么使用抽象工厂模式的好处和工厂模式的好处很相似，给工厂做了一个统一的出入口，也方便了日后对这个工厂的修改。\n\n\n# 单例模式(Singleton Pattern)\n\n什么叫单例模式，简单来说就是一个实例只生产一次。\n\n\n# 单例模式的实例\n\n这个很简单，我觉得可以直接看代码。\n\n这是一种“懒汉式”写法，还有一种叫饿汉式写法，区别是懒汉使用时才初始化，饿汉则先初始化，用的时候直接给。\n\n由于js不需要考虑线程安全，所以推荐使用懒汉式写法，饿汉在JS中反而容易产生没必要的垃圾。\n\n> 惰性单例是指在需要的时候才创建\n\nclass SingleObject {\n    constructor() {\n        // 防止调用new初始化\n        if(new.target != undefined) {\n            const errorMsg = \"This is single object,Can't use keyword new!\";\n            const tipMsg = \"You should use method getInstance to get instance。\";\n            throw new Error(`\\n${errorMsg}\\n${tipMsg}`)\n        }\n    }\n    static getInstance(){\n        // 生产单例\n        if(SingleObject.instance) {\n            return SingleObject.instance;\n        }\n        SingleObject.instance = {};\n        SingleObject.instance.__proto__ = SingleObject.prototype;\n        return SingleObject.instance;\n    }\n    showMessage(){\n       console.log(\"Hello World!\");\n    }\n}\nconst instance = SingleObject.getInstance();\ninstance.showMessage();\n/**\n * output:\n * Hello World!\n */\n\n\n\n# 单例模式的优势\n\n对于频繁使用且可重复使用的对象，可以极大来减少内存消耗和没必要的垃圾回收。\n\n\n# 单例模式的使用场景\n\n在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现”不良反应“，可以采用单例模式，具体的场景如下：\n\n * 在整个项目中需要一个共享访问点或共享数据，例如一个Web上的计数器，可以不用每次把刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；\n * 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。\n * 在项目开发时有一些对象其实我们只需要一个，比如：线程池、缓存、日志对象等等。\n\n\n# 建造者模式\n\n在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。\n\n建造者模式(Builder pattern)，将一个复杂对象的构建层与其表示层相互分离，使得同样的构建过程可以采用不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。\n\n在工厂模式中，对创建的结果都是一个完整的个体，我们对参见的过程不为所知，只了解创建的结果对象。而在建造者模式中我们关心的是对象的创建过程，因此我们通常将创建对象的类模块化，这样使被创建的类的每一个模块都可以得到灵活的运用和高质量的复用。\n\n\n# 白话解释\n\n> 在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。\n\n    //产品——产品类\n    function Product(){\n        this.design = \"\";\n        this.db = \"\";\n        this.front = \"\";\n        this.back = \"\";\n    }\n    //产品经理——指导类\n    function ProductManager(){\n        this.startWork = function(engineer){\n            engineer.productDesign();\n            engineer.frontEnd();\n            engineer.backEnd();\n            engineer.dbManageer();\n        }\n    }\n    //工程师——建造者类\n    function Engineer(){\n        this.productDesign = function(){\n            console.log(\"产品设计好了\");\n        };\n        this.dbManageer = function(){\n            console.log(\"数据库设计好了\");\n        };\n        this.backEnd = function(){\n            console.log(\"后台写好了\");\n        };\n        this.frontEnd = function(){\n            console.log(\"前台写好了\");\n        };\n        this.done = function(){\n            var product = new Product();\n            product.design = \"done\";\n            product.db = \"done\";\n            product.back = \"done\";\n            product.front = \"done\";\n            return product;\n        }\n    }\n\n\t\tlet engineer = new Engineer()\n    let productmanager = new ProductManager()\n    productmanager.startWork(engineer)\n\t\t// 产品设计好了\n    // 前台写好了\n\t\t// 后台写好了\n\t\t// 数据库设计好了\n\t\tlet product = engineer.done()\n\t\tconsole.log(product)\n\t\t/**\n\t\t\tProduct\n        back: \"done\"\n        db: \"done\"\n        design: \"done\"\n        front: \"done\"\n\t\t*/\n\n\n\n# 适配器模式(Adapter Pattern)\n\n适配器模式是作为两个不同接口的一种聚合，把比如说SD卡适配器，无论使用TF或SD卡或者其它卡，对外输出都是USB接口。\n\n\n# 适配器模式的实例\n\n首先我们有两个设备一个是Vlc播放器，一个是Mp4播放器，一个需要使用playVlc按钮来播放，一个要使用playMp4来播放。\n\nclass VlcPlayer {\n    playVlc(fileName) {\n       console.log(\"Playing vlc file. Name: \"+ fileName);      \n    }\n}\nclass Mp4Player  {\n    playMp4(fileName) {\n        console.log(\"Playing mp4 file. Name: \"+ fileName);      \n    }\n}\n\n\n但是我就想通过一个播放按钮来播放，我不管他是什么播放设备，这个时候，我们就需要一个适配器来做这个事情。\n\nclass MediaAdapter {\n    constructor(audioType){\n        switch(audioType) {\n            case 'vlc':\n                MediaAdapter.advancedMusicPlayer = new VlcPlayer();\n                break;\n            case 'mp4':\n                MediaAdapter.advancedMusicPlayer = new Mp4Player();\n                break;\n        }\n    }\n    play(audioType, fileName) {\n        switch(audioType) {\n            case 'vlc':\n                MediaAdapter.advancedMusicPlayer.playVlc(fileName);\n                break;\n            case 'mp4':\n                MediaAdapter.advancedMusicPlayer.playMp4(fileName);\n                break;\n        }\n    }\n }\n\n\n通过适配器我们可以把各种设备桥接到一个音频设备上。\n\nclass AudioPlayer{\n    play(audioType, fileName) {\n        switch(audioType) {\n            case 'mp3':\n                console.log(\"Playing mp3 file. Name: \"+ fileName);\n                break;\n            case 'vlc':\n            case 'mp4':\n                    AudioPlayer.mediaAdapter = new MediaAdapter(audioType);\n                    AudioPlayer.mediaAdapter.play(audioType, fileName);\n                break;\n            default:\n                console.log(\"Invalid media. \"+\n                    audioType + \" format not supported\");\n                break;\n        }\n    }  \n }\n\n\n那么这个时候我们就可以直接通过这个音频设备来播放我们想要播放的音频了\n\nconst audioPlayer = new AudioPlayer();\n audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\");\n audioPlayer.play(\"mp4\", \"alone.mp4\");\n audioPlayer.play(\"vlc\", \"far far away.vlc\");\n audioPlayer.play(\"avi\", \"mind me.avi\");\n  /**\n  * output:\n  * Playing mp3 file. Name: beyond the horizon.mp3\n  * Playing mp4 file. Name: alone.mp4\n  * Playing vlc file. Name: far far away.vlc\n  * Invalid media. avi format not supported\n  */\n\n\n\n# 适配器模式的优势\n\n可以让两个不同接口作为一个适配的接口使用，这样对下层的关心可以减少.\n\n\n# 装饰器模式(Decorator Pattern)\n\n装饰器模式实现了不改变原有对象，在原有对象上实现功能的添加。这是一种对原有对象的一种包装。\n\n\n# 装饰器模式的实例\n\n假设现在有两个形状，一个矩形一个圆形，这时候我们希望能在形状上实现一些特殊的功能，但又不改变原来的类，我们要如何做呢？\n\nclass Rectangle {\n    draw() {\n       console.log(\"Shape: Rectangle\");\n    }\n}\nclass Circle {\n    draw() {\n       console.log(\"Shape: Circle\");\n    }\n}\n\n\n这时我们可以用装饰器来实现，假设我们要给形状添加颜色功能\n\nclass RedShapeDecorator {\n    constructor(decoratedShape) {\n       this.decoratedShape = decoratedShape;    \n    }\n    draw() {\n       this.decoratedShape.draw();        \n       this.setRedBorder();\n    }\n    setRedBorder(){\n       console.log(\"Border Color: Red\");\n    }\n}\n\n\n那么在使用装饰器的类，在画圆的时候就实现了了画边框的颜色。\n\nconst circle = new Circle();\nconst redCircle = new RedShapeDecorator(new Circle());\nconst redRectangle = new RedShapeDecorator(new Rectangle());\nconsole.log(\"Circle with normal border\");\ncircle.draw();\nconsole.log(\"\\nCircle of red border\");\nredCircle.draw();\nconsole.log(\"\\nRectangle of red border\");\nredRectangle.draw();\n/**\n * output:\n * Circle with normal border\n * Shape: Circle\n * \n * Circle of red border\n * Shape: Circle\n * Border Color: Red\n * \n * Rectangle of red border\n * Shape: Rectangle\n * Border Color: Red\n */\n\n\n\n# 装饰器模式的优势\n\n即使原有对象发生改变，装饰器是种非侵入式功能添加，对原有对象的影响也能降低到最小。\n\n\n# 过滤器模式(Filter Pattern)\n\n通过多个单一的功能筛选构建出一个复杂的筛选功能。\n\n\n# 过滤器模式的实例\n\n首先定义一个对象，我们后续可以通过名字(name)，性别(gender)，婚姻状况(maritalStatus)\n\n// 定义对象\nclass Person {\n    constructor(name, gender, maritalStatus){\n       this.name = name;\n       this.gender = gender;\n       this.maritalStatus = maritalStatus;    \n    }\n    getName() {\n       return this.name;\n    }\n    getGender() {\n       return this.gender;\n    }\n    getMaritalStatus() {\n       return this.maritalStatus;\n    }  \n}\n\n\n定义一些单一功能的筛选条件，比如啊判断是男，是女，是不是单身。\n\n// 添加筛选条件\nclass CriteriaMale {\n    meetCriteria(persons) {\n       const malePersons = [];\n       for (const person of persons) {\n          if(person.getGender().toUpperCase() == \"MALE\"){\n             malePersons.push(person);\n          }\n       }\n       return malePersons;\n    }\n}\nclass CriteriaFemale {\n    meetCriteria(persons) {\n       const femalePersons = [];\n       for (const person of persons) {\n          if(person.getGender().toUpperCase() == \"FEMALE\"){\n             femalePersons.push(person);\n          }\n       }\n       return femalePersons;\n    }\n}\nclass CriteriaSingle {\n    meetCriteria(persons) {\n       const singlePersons = [];\n       for (const person of persons) {\n          if(person.getMaritalStatus().toUpperCase() == \"SINGLE\"){\n             singlePersons.push(person);\n          }\n       }\n       return singlePersons;\n    }\n}\n\n\n将单一功能增加对应的操作符，使单一功能筛选条件能通过组合来实现复杂的筛选。\n\n// 添加筛选操作符\nclass AndCriteria {\n    constructor(criteria, otherCriteria) {\n       this.criteria = criteria;\n       this.otherCriteria = otherCriteria;\n    }\n    meetCriteria(persons) {\n       const firstCriteriaPersons = this.criteria.meetCriteria(persons);\n       return this.otherCriteria.meetCriteria(firstCriteriaPersons);\n    }\n }\n class OrCriteria{\n    constructor(criteria, otherCriteria) {\n       this.criteria = criteria;\n       this.otherCriteria = otherCriteria;\n    }\n    meetCriteria(persons) {\n       const firstCriteriaItems = this.criteria.meetCriteria(persons);\n       const otherCriteriaItems = this.otherCriteria.meetCriteria(persons);\n       for (const person of otherCriteriaItems) {\n          if(firstCriteriaItems.indexOf(person)==-1){\n            firstCriteriaItems.push(person);\n          }\n       }\n       return firstCriteriaItems;\n    }\n }\n\n\n使用单一筛选条件或是组合单一筛选条件来筛选，达到复杂筛选目的\n\nfunction printPersons(persons){\n    for (const  person of persons) {\n       console.log(person);\n    }\n}\nconst persons = [];\npersons.push(new Person(\"Robert\",\"Male\", \"Single\"));\npersons.push(new Person(\"John\",\"Male\", \"Married\"));\npersons.push(new Person(\"Laura\",\"Female\", \"Married\"));\npersons.push(new Person(\"Diana\",\"Female\", \"Single\"));\npersons.push(new Person(\"Mike\",\"Male\", \"Single\"));\npersons.push(new Person(\"Bobby\",\"Male\", \"Single\"));\nconst male = new CriteriaMale();\nconst female = new CriteriaFemale();\nconst single = new CriteriaSingle();\nconst singleMale = new AndCriteria(single, male);\nconst singleOrFemale = new OrCriteria(single, female);\nconsole.log(\"Males: \");\nprintPersons(male.meetCriteria(persons));\nconsole.log(\"\\nFemales: \");\nprintPersons(female.meetCriteria(persons));\nconsole.log(\"\\nSingle Males: \");\nprintPersons(singleMale.meetCriteria(persons));\nconsole.log(\"\\nSingle Or Females: \");\nprintPersons(singleOrFemale.meetCriteria(persons));\n/**\n * output:\n * Males: \n * Person { name: 'Robert', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'John', gender: 'Male', maritalStatus: 'Married' }\n * Person { name: 'Mike', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Bobby', gender: 'Male', maritalStatus: 'Single' }\n * \n * Females: \n * Person { name: 'Laura', gender: 'Female', maritalStatus: 'Married' }\n * Person { name: 'Diana', gender: 'Female', maritalStatus: 'Single' }\n * \n * Single Males: \n * Person { name: 'Robert', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Mike', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Bobby', gender: 'Male', maritalStatus: 'Single' }\n * \n * Single Or Females: \n * Person { name: 'Robert', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Diana', gender: 'Female', maritalStatus: 'Single' }\n * Person { name: 'Mike', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Bobby', gender: 'Male', maritalStatus: 'Single' }\n * Person { name: 'Laura', gender: 'Female', maritalStatus: 'Married' }\n */\n\n\n\n# 过滤器模式优势\n\n在需要做类的筛选的时候，通过每次单一功能的筛选，再做聚合能极大的降低筛选功能的复杂性。",normalizedContent:"# 设计模式\n\njavascript 设计模式，设计模式是一种思想，和语言无关。\n\n * 开发效率\n * 可维护性\n\n相关书籍\n\n * 《大话设计模式》\n * 《设计模式：可服用面向对象软件的基础》\n * 《headfirst 设计模式》\n * 《javascript 设计模式》\n * 《javascript中的设计模式》\n\n\n# 面向对象的 javascript\n\n * 类\n * 实例\n * 构造函数\n * 继承\n * 多态\n * 封装\n * 原型\n * class语法\n * 具体看面向对象编程\n\n\n# 设计模式\n\n * 创建型模式\n   \n   * 工厂模式\n   * 抽象工厂模式\n   * 单例模式\n   * 建造者模式\n   * 原型模式\n\n * 结构型模式\n   \n   * 适配器模式\n   * 桥接模式\n   * 过滤器模式\n   * 组合模式\n   * 装饰器模式\n   * 外观模式\n   * 享元模式\n   * 代理模式\n\n * 行为型模式\n   \n   * 责任链模式\n   * 命令模式\n   * 解释器模式\n   * 迭代器模式\n   * 中介者模式\n   * 备忘录模式\n   * 观察者模式\n   * 状态模式\n   * 空对象模式\n   * 策略模式\n   * 模板模式\n   * 访问者模式\n\n * 适配器模式\n\n * 装饰器模式\n\n\n# 工厂模式(factory pattern)\n\n工厂模式是比较常用的设计模式之一，那么什么叫工厂模式呢？简单来说，就是你需要什么东西不直接使用new的方法生成实例，然后统一通过工厂进行生产加工再生成实例。\n\n\n# 工厂模式的实例\n\n比如我们现在有很多形状比如圆形，矩形和正方形。这类都是属于形状，那我们是不是可以通过专门生产形状的工厂来生成它们的实例么？\n\nclass circle {\n    draw() {\n        console.log(\"i'm a circle\")\n    }\n}\nclass rectangle {\n    draw() {\n        console.log(\"i'm a rectangle\")\n    }\n}\nclass square {\n    draw() {\n        console.log(\"i'm a square\")\n    }\n}\n\n\n那么接下来，我们可以建立一个专门生产形状的工厂来生产它们了。即根据字符串来产生对应需要的类。你在这里可以看到类的出口都已经在一个方法中了。\n\nclass shapefactory {\n    getshape(shapetype){\n        switch(shapetype) {\n            case 'circle':\n                return new circle();\n            case 'rectangle':\n                return new rectangle();\n            case 'square':\n                return new square();\n            default:\n                return null;\n        }\n    }\n}\n\n\n那么我们需要使用的时候，就可以直接只需要new出一个工厂，在根据字符串就能拿到对应的需要生产的类了。而不需要分别对类进行new。\n\nconst shapefactory = new shapefactory();\n// 通过工厂拿各种形状\nconst shape1 = shapefactory.getshape('circle');\nshape1.draw();\nconst shape2 = shapefactory.getshape('rectangle');\nshape2.draw();\nconst shape3 = shapefactory.getshape('square');\nshape3.draw();\n/**\n * output:\n * i'm a circle\n * i'm a rectangle\n * i'm a square\n */\n\n\n\n# 工厂模式的优势\n\n那么使用工厂模式的好处也是显而易见的，比如实例的生产比较复杂，或者说生成实例后还需要额外加工，这个时候工厂给了我们一个统一的出入口，也方便了日后对这个实例的修改。比如你要修改工厂产出是一个单例的时候，就不需要在所有的类中修改，而只要在工厂出口修改即可达到目标。\n\n\n# 抽象工厂模式(abstract factory pattern)\n\n上文讲到了工厂模式，这篇文章将抽象工厂，抽象工厂的名字是真的很抽象，也很容易让人抽象的理解，那么什么是抽象工厂呢？\n\n其实抽象工厂，简单来说就是工厂的工厂，因为一般来说一个工厂只负责加载一类组件，那么你有很多小类组件需要生产，那么势必会有很多小类的工厂。那么你最终生产一个大类，那就要很多小类的工厂负责生产。那么如何更方便的管理或者说生产这些工厂呢？那就用生产工厂的工厂来生成吧。\n\n\n# 抽象工厂模式的实例\n\n先把上文说的形状工厂搬过来\n\n// 这是之前上文说的形状工厂\nclass circle {\n    draw() {\n        console.log(\"i'm a circle\")\n    }\n}\nclass rectangle {\n    draw() {\n        console.log(\"i'm a rectangle\")\n    }\n}\nclass square {\n    draw() {\n        console.log(\"i'm a square\")\n    }\n}\nclass shapefactory {\n    getshape(shapetype){\n        switch(shapetype) {\n            case 'circle':\n                return new circle();\n            case 'rectangle':\n                return new rectangle();\n            case 'square':\n                return new square();\n            default:\n                return null;\n        }\n    }\n}\n\n\n这时候你已经有形状了，但你觉得不美观，你还需要颜色，那么你这个时候，你又搞了个颜色工厂，如下：\n\n// 再新加一个颜色工厂\nclass red {\n    fill() {\n        console.log(\"fill red\")\n    }\n}\nclass blue {\n    fill() {\n        console.log(\"fill blue\")\n    }\n}\nclass green {\n    fill() {\n        console.log(\"fill green\")\n    }\n}\nclass colorfactory {\n    getcolor(color){\n        switch(color) {\n            case 'red':\n                return new red();\n            case 'blue':\n                return new blue();\n            case 'green':\n                return new green();\n            default:\n                return null;\n        }\n    }\n}\n\n\n颜色工厂好了，但是你担心，以后工厂多了，不好管理咋办，那还是走之前的套路，把工厂通过抽象工厂生产出来。如下：\n\n// 最后添加抽象工厂\nclass factoryproducer {\n    static getfactory(choice){\n        switch(choice) {\n            case 'shape':\n                return new shapefactory();\n            case 'color':\n                return new colorfactory();\n            default:\n                return null;\n        }\n    }\n}\n\n\n那么这个时候和上文一样只需要new出一个抽象工厂，就能把所有需要的东西拿到手了:\n\n//通过抽象工厂拿形状工厂\nconst shapefactory = factoryproducer.getfactory('shape');\n// 通过工厂拿各种形状\nconst shape1 = shapefactory.getshape('circle');\nshape1.draw();\nconst shape2 = shapefactory.getshape('rectangle');\nshape2.draw();\nconst shape3 = shapefactory.getshape('square');\nshape3.draw();\n//通过抽象工厂拿颜色工厂\nconst colorfactory = factoryproducer.getfactory('color');\n// 通过工厂拿各种颜色\nconst color1 = colorfactory.getcolor('red');\ncolor1.fill();\nconst color2 = colorfactory.getcolor('blue');\ncolor2.fill();\nconst color3 = colorfactory.getcolor('green');\ncolor3.fill();\n/**\n * output：\n * i'm a circle\n * i'm a rectangle\n * i'm a square\n * fill red\n * fill blue\n * fill green\n */\n\n\n\n# 抽象工厂模式的优势\n\n那么使用抽象工厂模式的好处和工厂模式的好处很相似，给工厂做了一个统一的出入口，也方便了日后对这个工厂的修改。\n\n\n# 单例模式(singleton pattern)\n\n什么叫单例模式，简单来说就是一个实例只生产一次。\n\n\n# 单例模式的实例\n\n这个很简单，我觉得可以直接看代码。\n\n这是一种“懒汉式”写法，还有一种叫饿汉式写法，区别是懒汉使用时才初始化，饿汉则先初始化，用的时候直接给。\n\n由于js不需要考虑线程安全，所以推荐使用懒汉式写法，饿汉在js中反而容易产生没必要的垃圾。\n\n> 惰性单例是指在需要的时候才创建\n\nclass singleobject {\n    constructor() {\n        // 防止调用new初始化\n        if(new.target != undefined) {\n            const errormsg = \"this is single object,can't use keyword new!\";\n            const tipmsg = \"you should use method getinstance to get instance。\";\n            throw new error(`\\n${errormsg}\\n${tipmsg}`)\n        }\n    }\n    static getinstance(){\n        // 生产单例\n        if(singleobject.instance) {\n            return singleobject.instance;\n        }\n        singleobject.instance = {};\n        singleobject.instance.__proto__ = singleobject.prototype;\n        return singleobject.instance;\n    }\n    showmessage(){\n       console.log(\"hello world!\");\n    }\n}\nconst instance = singleobject.getinstance();\ninstance.showmessage();\n/**\n * output:\n * hello world!\n */\n\n\n\n# 单例模式的优势\n\n对于频繁使用且可重复使用的对象，可以极大来减少内存消耗和没必要的垃圾回收。\n\n\n# 单例模式的使用场景\n\n在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现”不良反应“，可以采用单例模式，具体的场景如下：\n\n * 在整个项目中需要一个共享访问点或共享数据，例如一个web上的计数器，可以不用每次把刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；\n * 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。\n * 在项目开发时有一些对象其实我们只需要一个，比如：线程池、缓存、日志对象等等。\n\n\n# 建造者模式\n\n在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。\n\n建造者模式(builder pattern)，将一个复杂对象的构建层与其表示层相互分离，使得同样的构建过程可以采用不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。\n\n在工厂模式中，对创建的结果都是一个完整的个体，我们对参见的过程不为所知，只了解创建的结果对象。而在建造者模式中我们关心的是对象的创建过程，因此我们通常将创建对象的类模块化，这样使被创建的类的每一个模块都可以得到灵活的运用和高质量的复用。\n\n\n# 白话解释\n\n> 在建造者模式里，有个指导者(director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。\n\n    //产品——产品类\n    function product(){\n        this.design = \"\";\n        this.db = \"\";\n        this.front = \"\";\n        this.back = \"\";\n    }\n    //产品经理——指导类\n    function productmanager(){\n        this.startwork = function(engineer){\n            engineer.productdesign();\n            engineer.frontend();\n            engineer.backend();\n            engineer.dbmanageer();\n        }\n    }\n    //工程师——建造者类\n    function engineer(){\n        this.productdesign = function(){\n            console.log(\"产品设计好了\");\n        };\n        this.dbmanageer = function(){\n            console.log(\"数据库设计好了\");\n        };\n        this.backend = function(){\n            console.log(\"后台写好了\");\n        };\n        this.frontend = function(){\n            console.log(\"前台写好了\");\n        };\n        this.done = function(){\n            var product = new product();\n            product.design = \"done\";\n            product.db = \"done\";\n            product.back = \"done\";\n            product.front = \"done\";\n            return product;\n        }\n    }\n\n\t\tlet engineer = new engineer()\n    let productmanager = new productmanager()\n    productmanager.startwork(engineer)\n\t\t// 产品设计好了\n    // 前台写好了\n\t\t// 后台写好了\n\t\t// 数据库设计好了\n\t\tlet product = engineer.done()\n\t\tconsole.log(product)\n\t\t/**\n\t\t\tproduct\n        back: \"done\"\n        db: \"done\"\n        design: \"done\"\n        front: \"done\"\n\t\t*/\n\n\n\n# 适配器模式(adapter pattern)\n\n适配器模式是作为两个不同接口的一种聚合，把比如说sd卡适配器，无论使用tf或sd卡或者其它卡，对外输出都是usb接口。\n\n\n# 适配器模式的实例\n\n首先我们有两个设备一个是vlc播放器，一个是mp4播放器，一个需要使用playvlc按钮来播放，一个要使用playmp4来播放。\n\nclass vlcplayer {\n    playvlc(filename) {\n       console.log(\"playing vlc file. name: \"+ filename);      \n    }\n}\nclass mp4player  {\n    playmp4(filename) {\n        console.log(\"playing mp4 file. name: \"+ filename);      \n    }\n}\n\n\n但是我就想通过一个播放按钮来播放，我不管他是什么播放设备，这个时候，我们就需要一个适配器来做这个事情。\n\nclass mediaadapter {\n    constructor(audiotype){\n        switch(audiotype) {\n            case 'vlc':\n                mediaadapter.advancedmusicplayer = new vlcplayer();\n                break;\n            case 'mp4':\n                mediaadapter.advancedmusicplayer = new mp4player();\n                break;\n        }\n    }\n    play(audiotype, filename) {\n        switch(audiotype) {\n            case 'vlc':\n                mediaadapter.advancedmusicplayer.playvlc(filename);\n                break;\n            case 'mp4':\n                mediaadapter.advancedmusicplayer.playmp4(filename);\n                break;\n        }\n    }\n }\n\n\n通过适配器我们可以把各种设备桥接到一个音频设备上。\n\nclass audioplayer{\n    play(audiotype, filename) {\n        switch(audiotype) {\n            case 'mp3':\n                console.log(\"playing mp3 file. name: \"+ filename);\n                break;\n            case 'vlc':\n            case 'mp4':\n                    audioplayer.mediaadapter = new mediaadapter(audiotype);\n                    audioplayer.mediaadapter.play(audiotype, filename);\n                break;\n            default:\n                console.log(\"invalid media. \"+\n                    audiotype + \" format not supported\");\n                break;\n        }\n    }  \n }\n\n\n那么这个时候我们就可以直接通过这个音频设备来播放我们想要播放的音频了\n\nconst audioplayer = new audioplayer();\n audioplayer.play(\"mp3\", \"beyond the horizon.mp3\");\n audioplayer.play(\"mp4\", \"alone.mp4\");\n audioplayer.play(\"vlc\", \"far far away.vlc\");\n audioplayer.play(\"avi\", \"mind me.avi\");\n  /**\n  * output:\n  * playing mp3 file. name: beyond the horizon.mp3\n  * playing mp4 file. name: alone.mp4\n  * playing vlc file. name: far far away.vlc\n  * invalid media. avi format not supported\n  */\n\n\n\n# 适配器模式的优势\n\n可以让两个不同接口作为一个适配的接口使用，这样对下层的关心可以减少.\n\n\n# 装饰器模式(decorator pattern)\n\n装饰器模式实现了不改变原有对象，在原有对象上实现功能的添加。这是一种对原有对象的一种包装。\n\n\n# 装饰器模式的实例\n\n假设现在有两个形状，一个矩形一个圆形，这时候我们希望能在形状上实现一些特殊的功能，但又不改变原来的类，我们要如何做呢？\n\nclass rectangle {\n    draw() {\n       console.log(\"shape: rectangle\");\n    }\n}\nclass circle {\n    draw() {\n       console.log(\"shape: circle\");\n    }\n}\n\n\n这时我们可以用装饰器来实现，假设我们要给形状添加颜色功能\n\nclass redshapedecorator {\n    constructor(decoratedshape) {\n       this.decoratedshape = decoratedshape;    \n    }\n    draw() {\n       this.decoratedshape.draw();        \n       this.setredborder();\n    }\n    setredborder(){\n       console.log(\"border color: red\");\n    }\n}\n\n\n那么在使用装饰器的类，在画圆的时候就实现了了画边框的颜色。\n\nconst circle = new circle();\nconst redcircle = new redshapedecorator(new circle());\nconst redrectangle = new redshapedecorator(new rectangle());\nconsole.log(\"circle with normal border\");\ncircle.draw();\nconsole.log(\"\\ncircle of red border\");\nredcircle.draw();\nconsole.log(\"\\nrectangle of red border\");\nredrectangle.draw();\n/**\n * output:\n * circle with normal border\n * shape: circle\n * \n * circle of red border\n * shape: circle\n * border color: red\n * \n * rectangle of red border\n * shape: rectangle\n * border color: red\n */\n\n\n\n# 装饰器模式的优势\n\n即使原有对象发生改变，装饰器是种非侵入式功能添加，对原有对象的影响也能降低到最小。\n\n\n# 过滤器模式(filter pattern)\n\n通过多个单一的功能筛选构建出一个复杂的筛选功能。\n\n\n# 过滤器模式的实例\n\n首先定义一个对象，我们后续可以通过名字(name)，性别(gender)，婚姻状况(maritalstatus)\n\n// 定义对象\nclass person {\n    constructor(name, gender, maritalstatus){\n       this.name = name;\n       this.gender = gender;\n       this.maritalstatus = maritalstatus;    \n    }\n    getname() {\n       return this.name;\n    }\n    getgender() {\n       return this.gender;\n    }\n    getmaritalstatus() {\n       return this.maritalstatus;\n    }  \n}\n\n\n定义一些单一功能的筛选条件，比如啊判断是男，是女，是不是单身。\n\n// 添加筛选条件\nclass criteriamale {\n    meetcriteria(persons) {\n       const malepersons = [];\n       for (const person of persons) {\n          if(person.getgender().touppercase() == \"male\"){\n             malepersons.push(person);\n          }\n       }\n       return malepersons;\n    }\n}\nclass criteriafemale {\n    meetcriteria(persons) {\n       const femalepersons = [];\n       for (const person of persons) {\n          if(person.getgender().touppercase() == \"female\"){\n             femalepersons.push(person);\n          }\n       }\n       return femalepersons;\n    }\n}\nclass criteriasingle {\n    meetcriteria(persons) {\n       const singlepersons = [];\n       for (const person of persons) {\n          if(person.getmaritalstatus().touppercase() == \"single\"){\n             singlepersons.push(person);\n          }\n       }\n       return singlepersons;\n    }\n}\n\n\n将单一功能增加对应的操作符，使单一功能筛选条件能通过组合来实现复杂的筛选。\n\n// 添加筛选操作符\nclass andcriteria {\n    constructor(criteria, othercriteria) {\n       this.criteria = criteria;\n       this.othercriteria = othercriteria;\n    }\n    meetcriteria(persons) {\n       const firstcriteriapersons = this.criteria.meetcriteria(persons);\n       return this.othercriteria.meetcriteria(firstcriteriapersons);\n    }\n }\n class orcriteria{\n    constructor(criteria, othercriteria) {\n       this.criteria = criteria;\n       this.othercriteria = othercriteria;\n    }\n    meetcriteria(persons) {\n       const firstcriteriaitems = this.criteria.meetcriteria(persons);\n       const othercriteriaitems = this.othercriteria.meetcriteria(persons);\n       for (const person of othercriteriaitems) {\n          if(firstcriteriaitems.indexof(person)==-1){\n            firstcriteriaitems.push(person);\n          }\n       }\n       return firstcriteriaitems;\n    }\n }\n\n\n使用单一筛选条件或是组合单一筛选条件来筛选，达到复杂筛选目的\n\nfunction printpersons(persons){\n    for (const  person of persons) {\n       console.log(person);\n    }\n}\nconst persons = [];\npersons.push(new person(\"robert\",\"male\", \"single\"));\npersons.push(new person(\"john\",\"male\", \"married\"));\npersons.push(new person(\"laura\",\"female\", \"married\"));\npersons.push(new person(\"diana\",\"female\", \"single\"));\npersons.push(new person(\"mike\",\"male\", \"single\"));\npersons.push(new person(\"bobby\",\"male\", \"single\"));\nconst male = new criteriamale();\nconst female = new criteriafemale();\nconst single = new criteriasingle();\nconst singlemale = new andcriteria(single, male);\nconst singleorfemale = new orcriteria(single, female);\nconsole.log(\"males: \");\nprintpersons(male.meetcriteria(persons));\nconsole.log(\"\\nfemales: \");\nprintpersons(female.meetcriteria(persons));\nconsole.log(\"\\nsingle males: \");\nprintpersons(singlemale.meetcriteria(persons));\nconsole.log(\"\\nsingle or females: \");\nprintpersons(singleorfemale.meetcriteria(persons));\n/**\n * output:\n * males: \n * person { name: 'robert', gender: 'male', maritalstatus: 'single' }\n * person { name: 'john', gender: 'male', maritalstatus: 'married' }\n * person { name: 'mike', gender: 'male', maritalstatus: 'single' }\n * person { name: 'bobby', gender: 'male', maritalstatus: 'single' }\n * \n * females: \n * person { name: 'laura', gender: 'female', maritalstatus: 'married' }\n * person { name: 'diana', gender: 'female', maritalstatus: 'single' }\n * \n * single males: \n * person { name: 'robert', gender: 'male', maritalstatus: 'single' }\n * person { name: 'mike', gender: 'male', maritalstatus: 'single' }\n * person { name: 'bobby', gender: 'male', maritalstatus: 'single' }\n * \n * single or females: \n * person { name: 'robert', gender: 'male', maritalstatus: 'single' }\n * person { name: 'diana', gender: 'female', maritalstatus: 'single' }\n * person { name: 'mike', gender: 'male', maritalstatus: 'single' }\n * person { name: 'bobby', gender: 'male', maritalstatus: 'single' }\n * person { name: 'laura', gender: 'female', maritalstatus: 'married' }\n */\n\n\n\n# 过滤器模式优势\n\n在需要做类的筛选的时候，通过每次单一功能的筛选，再做聚合能极大的降低筛选功能的复杂性。",charsets:{cjk:!0}},{title:"commander和Inquirer",frontmatter:{},regularPath:"/engineering/commander.html",relativePath:"engineering/commander.md",key:"v-02e836bf",path:"/engineering/commander.html",headers:[{level:2,title:"commander",slug:"commander",normalizedTitle:"commander",charIndex:2},{level:3,title:"program 变量",slug:"program-变量",normalizedTitle:"program 变量",charIndex:125},{level:3,title:"version",slug:"version",normalizedTitle:"version",charIndex:357},{level:3,title:"option",slug:"option",normalizedTitle:"option",charIndex:489},{level:2,title:"Inquirer",slug:"inquirer",normalizedTitle:"inquirer",charIndex:12}],lastUpdated:"3/29/2022, 12:21:20 PM",lastUpdatedTimestamp:164852768e4,headersStr:"commander program 变量 version option Inquirer",content:"# commander和Inquirer\n\n本文主要介绍 node 命令行的交互工具 commander（处理命令行参数） 和 inquirer（处理问题交互）\n\n\n# commander\n\n完整的 node.js 命令行解决方案：官方文档\n\n\n# program 变量\n\n为简化使用，Commander 提供了一个全局对象 program\n\nconst { program } = require('commander');\n\n\n如果程序较为复杂，用户需要以多种方式来使用 Commander，如单元测试等。创建本地Command对象是一种更好的方式：\n\nconst { Command } = require('commander');\nconst program = new Command();\n\n\n\n# version\n\n作用：定义命令程序的版本号 用法示例：.version('0.0.1', '-v, --version') 参数解析：\n\n 1. 第一个参数 版本号<必须>\n 2. 第二个参数 自定义标志<可省略>：默认为 -V 和 --version\n\n\n# option\n\nCommander 使用.option()方法来定义选项，同时可以附加选项的简介。每个选项可以定义一个短选项名称（-后面接单个字符）和一个长选项名称（--后面接一个或多个单词），使用逗号、空格或|分隔。\n\nboolean 型选项 、带参数选项\n\n有两种最常用的选项，一类是 boolean 型选项，选项无需配置参数，另一类选项则可以设置参数（使用尖括号声明在该选项后，如--expect <value>）。如果在命令行中不指定具体的选项及参数，则会被定义为undefined。第三个参数为默认值。\n\n// test.js\nprogram\n  .version('0.0.1', '-v, --version')\n  .option('-d, --debug', 'output extra debugging')\n  .option('-s, --small', 'small pizza size')\n  .option('-p, --pizza-type <type>', 'flavour of pizza');\n\n// 解析 process.argv\nprogram.parse(process.argv);\n\nif (program.debug) console.log(program.opts());\nif (program.small) console.log('- small pizza size');\nif (program.pizzaType) console.log(`- ${program.pizzaType}`);\n\n\n测试输出\n\nnode test.js -v    \n# 0.0.1\n\nnode test.js --help\n# Usage: test [options]\n# Options:\n#   -v, --version            output the version number\n#   -d, --debug              output extra debugging\n#   -s, --small              small pizza size\n#   -p, --pizza-type <type>  flavour of pizza\n#   -h, --help               display help for command\n\nnode test.js -d -s\n# { version: '0.0.1', debug: true, small: true, pizzaType: undefined }\n# - small pizza size\n\nnode test.js -d -s -p\n# error: option '-p, --pizza-type <type>' argument missing\n\nnode test.js -d -s -p fruit \n# { version: '0.0.1', debug: true, small: true, pizzaType: 'fruit' }\n# - small pizza size\n# - fruit\n\n\n\n# Inquirer\n\n一组通用的交互式命令行用户界面：官方文档\n\nvar inquirer = require('inquirer');\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers => {\n    // Use user feedback for... whatever!!\n  })\n  .catch(error => {\n    if (error.isTtyError) {\n      // Prompt couldn't be rendered in the current environment\n    } else {\n      // Something else when wrong\n    }\n  });\n\n\n这里只举一个简单的例子，更多参数查看文档\n\n// test.js\nconst inquirer = require('inquirer');\ninquirer\n    .prompt([{\n        type: 'list',\n        name: 'type',\n        message: '选择创建类型',\n        choices: [{ name: '应用程序' }, { name: '组件库' }]\n    }, {\n        type: 'input',\n        name: 'name',\n        message: '输入名称',\n        validate: function (value) {\n            if (value) {\n                return true;\n            }\n            return '输入名称';\n        }\n    }]).then((answers) => {\n        console.log(answers);\n    });\n\n\n交互界面\n\nnode tset.js\n\n? 选择创建类型 (Use arrow keys)\n❯ 应用程序 \n  组件库 \n\n# 选择 \"应用程序\" 后输入名称 test\n? 选择创建类型 应用程序\n? 输入名称 test\n{ type: '应用程序', name: 'test' }\n",normalizedContent:"# commander和inquirer\n\n本文主要介绍 node 命令行的交互工具 commander（处理命令行参数） 和 inquirer（处理问题交互）\n\n\n# commander\n\n完整的 node.js 命令行解决方案：官方文档\n\n\n# program 变量\n\n为简化使用，commander 提供了一个全局对象 program\n\nconst { program } = require('commander');\n\n\n如果程序较为复杂，用户需要以多种方式来使用 commander，如单元测试等。创建本地command对象是一种更好的方式：\n\nconst { command } = require('commander');\nconst program = new command();\n\n\n\n# version\n\n作用：定义命令程序的版本号 用法示例：.version('0.0.1', '-v, --version') 参数解析：\n\n 1. 第一个参数 版本号<必须>\n 2. 第二个参数 自定义标志<可省略>：默认为 -v 和 --version\n\n\n# option\n\ncommander 使用.option()方法来定义选项，同时可以附加选项的简介。每个选项可以定义一个短选项名称（-后面接单个字符）和一个长选项名称（--后面接一个或多个单词），使用逗号、空格或|分隔。\n\nboolean 型选项 、带参数选项\n\n有两种最常用的选项，一类是 boolean 型选项，选项无需配置参数，另一类选项则可以设置参数（使用尖括号声明在该选项后，如--expect <value>）。如果在命令行中不指定具体的选项及参数，则会被定义为undefined。第三个参数为默认值。\n\n// test.js\nprogram\n  .version('0.0.1', '-v, --version')\n  .option('-d, --debug', 'output extra debugging')\n  .option('-s, --small', 'small pizza size')\n  .option('-p, --pizza-type <type>', 'flavour of pizza');\n\n// 解析 process.argv\nprogram.parse(process.argv);\n\nif (program.debug) console.log(program.opts());\nif (program.small) console.log('- small pizza size');\nif (program.pizzatype) console.log(`- ${program.pizzatype}`);\n\n\n测试输出\n\nnode test.js -v    \n# 0.0.1\n\nnode test.js --help\n# usage: test [options]\n# options:\n#   -v, --version            output the version number\n#   -d, --debug              output extra debugging\n#   -s, --small              small pizza size\n#   -p, --pizza-type <type>  flavour of pizza\n#   -h, --help               display help for command\n\nnode test.js -d -s\n# { version: '0.0.1', debug: true, small: true, pizzatype: undefined }\n# - small pizza size\n\nnode test.js -d -s -p\n# error: option '-p, --pizza-type <type>' argument missing\n\nnode test.js -d -s -p fruit \n# { version: '0.0.1', debug: true, small: true, pizzatype: 'fruit' }\n# - small pizza size\n# - fruit\n\n\n\n# inquirer\n\n一组通用的交互式命令行用户界面：官方文档\n\nvar inquirer = require('inquirer');\ninquirer\n  .prompt([\n    /* pass your questions in here */\n  ])\n  .then(answers => {\n    // use user feedback for... whatever!!\n  })\n  .catch(error => {\n    if (error.isttyerror) {\n      // prompt couldn't be rendered in the current environment\n    } else {\n      // something else when wrong\n    }\n  });\n\n\n这里只举一个简单的例子，更多参数查看文档\n\n// test.js\nconst inquirer = require('inquirer');\ninquirer\n    .prompt([{\n        type: 'list',\n        name: 'type',\n        message: '选择创建类型',\n        choices: [{ name: '应用程序' }, { name: '组件库' }]\n    }, {\n        type: 'input',\n        name: 'name',\n        message: '输入名称',\n        validate: function (value) {\n            if (value) {\n                return true;\n            }\n            return '输入名称';\n        }\n    }]).then((answers) => {\n        console.log(answers);\n    });\n\n\n交互界面\n\nnode tset.js\n\n? 选择创建类型 (use arrow keys)\n❯ 应用程序 \n  组件库 \n\n# 选择 \"应用程序\" 后输入名称 test\n? 选择创建类型 应用程序\n? 输入名称 test\n{ type: '应用程序', name: 'test' }\n",charsets:{cjk:!0}},{title:"圣杯布局和双飞翼布局",frontmatter:{title:"圣杯布局和双飞翼布局",date:"2018-09-18T19:00:54.000Z",categories:"CSS"},regularPath:"/css/layout.html",relativePath:"css/layout.md",key:"v-37be6dff",path:"/css/layout.html",headers:[{level:2,title:"传统三栏布局",slug:"传统三栏布局",normalizedTitle:"传统三栏布局",charIndex:2},{level:2,title:"圣杯布局",slug:"圣杯布局",normalizedTitle:"圣杯布局",charIndex:1292},{level:3,title:"1.这是初始状态，我们来构造圣杯布局",slug:"_1-这是初始状态-我们来构造圣杯布局",normalizedTitle:"1.这是初始状态，我们来构造圣杯布局",charIndex:1355},{level:3,title:"2.我们首先给middle,left,right三个盒子加上浮动",slug:"_2-我们首先给middle-left-right三个盒子加上浮动",normalizedTitle:"2.我们首先给middle,left,right三个盒子加上浮动",charIndex:2003},{level:3,title:"3.这里先介绍一下margin-left",slug:"_3-这里先介绍一下margin-left",normalizedTitle:"3.这里先介绍一下margin-left",charIndex:2086},{level:3,title:"3.最后用相对定位调整位置",slug:"_3-最后用相对定位调整位置",normalizedTitle:"3.最后用相对定位调整位置",charIndex:2200},{level:2,title:"双飞翼布局",slug:"双飞翼布局",normalizedTitle:"双飞翼布局",charIndex:1297},{level:3,title:"1.初始状态",slug:"_1-初始状态",normalizedTitle:"1.初始状态",charIndex:3075},{level:3,title:"2.给left,right,middle加浮动",slug:"_2-给left-right-middle加浮动",normalizedTitle:"2.给left,right,middle加浮动",charIndex:3296},{level:3,title:"3.margin-left调整位置",slug:"_3-margin-left调整位置",normalizedTitle:"3.margin-left调整位置",charIndex:3324}],lastUpdated:"3/7/2023, 7:37:22 PM",lastUpdatedTimestamp:1678189042e3,headersStr:"传统三栏布局 圣杯布局 1.这是初始状态，我们来构造圣杯布局 2.我们首先给middle,left,right三个盒子加上浮动 3.这里先介绍一下margin-left 3.最后用相对定位调整位置 双飞翼布局 1.初始状态 2.给left,right,middle加浮动 3.margin-left调整位置",content:'# 传统三栏布局\n\n<style>\n    .wrap {\n        display: flex;\n    }\n    .middle {        \n        flex: 1;\n    }\n    .left {\n        width: 300px;\n    }\n    .right {        \n        width: 300px;\n    }\n</style>\n\n</head>\n<body>\n    <div class="wrap">\n        <div class="left"></div>\n        <div class="middle"></div>\n        <div class="right"></div>\n    </div>\n</body>\n\n\n<style>\n    .middle {\n        margin: 0 300px;\n    }\n    .left {\n        width: 300px;\n        float: left;\n    }\n    .right {        \n        width: 300px;\n        float: right;\n    }\n</style>\n\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="middle"></div>\n</body>\n\n\n<style>\n    .middle {\n        margin: 0 300px;\n    }\n    .left {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 300px;\n    }\n    .right {  \n        position: absolute;\n        top: 0;\n        right: 0;      \n        width: 300px;\n    }\n</style>\n\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="middle"></div>\n</body>\n\n\n<style>\n\t.box {\n\t\tdisplay: grid;\n    \tgrid-template-columns: 200px auto 200px;\n\t}\n</style>\n\n</head>\n<body>\n\t<div class="box">\n\t\t<div class="left"></div>\n\t\t<div class="middle"></div>\n\t\t<div class="right"></div>\n\t</div>\n</body>\n\n\n圣杯布局跟双飞翼布局的实现，目的都是左右两栏固定宽度，中间部分自适应。 中间栏放在最前面优先渲染。\n\n\n# 圣杯布局\n\n\n# 1.这是初始状态，我们来构造圣杯布局\n\n\t<style>\n\t\t.header {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\t\t.content {\n\t\t\tpadding: 0 100px;/*左右各留出100px*/\n\t\t}\n\t\t.footer {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\t\t.middle {\t\t\n\t\t\twidth: 100%;\n\t\t\theight: 80px;\n\t\t\tbackground: green;\n\t\t}\n\t\t.left {\n\t\t\twidth: 100px;\n\t\t\theight: 80px;\n\t\t\tbackground: yellow;\n\t\t}\n\t\t.right {\t\t\n\t\t\twidth: 100px;\n\t\t\theight: 80px;\n\t\t\tbackground: pink\n\t\t}\n\t</style>\n<body>\n\t  <div class="header"></div>\n     \t<div class="content">\n\t\t\t<div class="middle"></div>\n\t\t\t<div class="left"></div>\n\t\t\t<div class="right"></div>\n\t\t</div>\n\t  <div class="footer"></div>\n</body>\n\n\n\n# 2.我们首先给middle,left,right三个盒子加上浮动\n\nfloat:left\n\n出现了高度塌陷给content加上overflow:hidden\n\n\n# 3.这里先介绍一下margin-left\n\n当margin-left的值为%时，数值基于父对象的百分比左外边距。\n\n给黄色盒子加上margin-left:-100%\n\n给粉色盒子加上margin-left:-100px\n\n\n# 3.最后用相对定位调整位置\n\n给黄色盒子加上position:relative;right:100px\n\n给粉色盒子加上position:relative;left:100px\n\n\n# 双飞翼布局\n\n<style>\n        .header {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.content {\n\t\t\toverflow: hidden;\n\t\t}\n\n\t\t.footer {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.middle {\t\t\t\n\t\t\twidth: 100%;\n\t\t\tfloat: left;\n\t\t}\n         .inner-middle{\n\t\t\twidth:100%;\n\t\t\theight: 80px;\n\t\t\tbackground: green;\t\t\t\n\t\t}\n\t\t.left {\n\t\t\twidth: 100px;\n\t\t\tfloat: left;\n\t\t\theight: 80px;\n\t\t\tmargin-left: -100%;\n\t\t\tbackground: yellow;\n\t\t}\n\n\t\t.right {\t\t\t\n\t\t\twidth: 100px;\n\t\t\tfloat: left;\n\t\t\theight: 80px;\n\t\t\tmargin-left: -100px;\n\t\t\tbackground: pink\n\t\t}\n</style>\n\n<div class="header"></div>\n\t<div class="content">\n\t\t<div class="middle">\n\t\t\t<div class="inner-middle"></div>\n\t\t</div>\n\t\t<div class="left"></div>\n\t\t<div class="right"></div>\n\t</div>\n<div class="footer"></div>\n\n\n\n# 1.初始状态\n\n<div class="header"></div>\n\t<div class="content">\n\t\t<div class="middle">\n\t\t\t<div class="inner-middle"></div>\n\t\t</div>\n\t\t<div class="left"></div>\n\t\t<div class="right"></div>\n\t</div>\n<div class="footer"></div>\n\n\n\n# 2.给left,right,middle加浮动\n\n\n# 3.margin-left调整位置\n\n给黄色盒子加上margin-left:-100%\n\n给粉色盒子加上margin-left:-100px',normalizedContent:'# 传统三栏布局\n\n<style>\n    .wrap {\n        display: flex;\n    }\n    .middle {        \n        flex: 1;\n    }\n    .left {\n        width: 300px;\n    }\n    .right {        \n        width: 300px;\n    }\n</style>\n\n</head>\n<body>\n    <div class="wrap">\n        <div class="left"></div>\n        <div class="middle"></div>\n        <div class="right"></div>\n    </div>\n</body>\n\n\n<style>\n    .middle {\n        margin: 0 300px;\n    }\n    .left {\n        width: 300px;\n        float: left;\n    }\n    .right {        \n        width: 300px;\n        float: right;\n    }\n</style>\n\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="middle"></div>\n</body>\n\n\n<style>\n    .middle {\n        margin: 0 300px;\n    }\n    .left {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 300px;\n    }\n    .right {  \n        position: absolute;\n        top: 0;\n        right: 0;      \n        width: 300px;\n    }\n</style>\n\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="middle"></div>\n</body>\n\n\n<style>\n\t.box {\n\t\tdisplay: grid;\n    \tgrid-template-columns: 200px auto 200px;\n\t}\n</style>\n\n</head>\n<body>\n\t<div class="box">\n\t\t<div class="left"></div>\n\t\t<div class="middle"></div>\n\t\t<div class="right"></div>\n\t</div>\n</body>\n\n\n圣杯布局跟双飞翼布局的实现，目的都是左右两栏固定宽度，中间部分自适应。 中间栏放在最前面优先渲染。\n\n\n# 圣杯布局\n\n\n# 1.这是初始状态，我们来构造圣杯布局\n\n\t<style>\n\t\t.header {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\t\t.content {\n\t\t\tpadding: 0 100px;/*左右各留出100px*/\n\t\t}\n\t\t.footer {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\t\t.middle {\t\t\n\t\t\twidth: 100%;\n\t\t\theight: 80px;\n\t\t\tbackground: green;\n\t\t}\n\t\t.left {\n\t\t\twidth: 100px;\n\t\t\theight: 80px;\n\t\t\tbackground: yellow;\n\t\t}\n\t\t.right {\t\t\n\t\t\twidth: 100px;\n\t\t\theight: 80px;\n\t\t\tbackground: pink\n\t\t}\n\t</style>\n<body>\n\t  <div class="header"></div>\n     \t<div class="content">\n\t\t\t<div class="middle"></div>\n\t\t\t<div class="left"></div>\n\t\t\t<div class="right"></div>\n\t\t</div>\n\t  <div class="footer"></div>\n</body>\n\n\n\n# 2.我们首先给middle,left,right三个盒子加上浮动\n\nfloat:left\n\n出现了高度塌陷给content加上overflow:hidden\n\n\n# 3.这里先介绍一下margin-left\n\n当margin-left的值为%时，数值基于父对象的百分比左外边距。\n\n给黄色盒子加上margin-left:-100%\n\n给粉色盒子加上margin-left:-100px\n\n\n# 3.最后用相对定位调整位置\n\n给黄色盒子加上position:relative;right:100px\n\n给粉色盒子加上position:relative;left:100px\n\n\n# 双飞翼布局\n\n<style>\n        .header {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.content {\n\t\t\toverflow: hidden;\n\t\t}\n\n\t\t.footer {\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground: red;\n\t\t}\n\n\t\t.middle {\t\t\t\n\t\t\twidth: 100%;\n\t\t\tfloat: left;\n\t\t}\n         .inner-middle{\n\t\t\twidth:100%;\n\t\t\theight: 80px;\n\t\t\tbackground: green;\t\t\t\n\t\t}\n\t\t.left {\n\t\t\twidth: 100px;\n\t\t\tfloat: left;\n\t\t\theight: 80px;\n\t\t\tmargin-left: -100%;\n\t\t\tbackground: yellow;\n\t\t}\n\n\t\t.right {\t\t\t\n\t\t\twidth: 100px;\n\t\t\tfloat: left;\n\t\t\theight: 80px;\n\t\t\tmargin-left: -100px;\n\t\t\tbackground: pink\n\t\t}\n</style>\n\n<div class="header"></div>\n\t<div class="content">\n\t\t<div class="middle">\n\t\t\t<div class="inner-middle"></div>\n\t\t</div>\n\t\t<div class="left"></div>\n\t\t<div class="right"></div>\n\t</div>\n<div class="footer"></div>\n\n\n\n# 1.初始状态\n\n<div class="header"></div>\n\t<div class="content">\n\t\t<div class="middle">\n\t\t\t<div class="inner-middle"></div>\n\t\t</div>\n\t\t<div class="left"></div>\n\t\t<div class="right"></div>\n\t</div>\n<div class="footer"></div>\n\n\n\n# 2.给left,right,middle加浮动\n\n\n# 3.margin-left调整位置\n\n给黄色盒子加上margin-left:-100%\n\n给粉色盒子加上margin-left:-100px',charsets:{cjk:!0}},{title:"盒子模型",frontmatter:{title:"盒子模型",date:"2020-11-26T11:27:54.000Z",categories:"CSS"},regularPath:"/css/box.html",relativePath:"css/box.md",key:"v-0a94c1c2",path:"/css/box.html",headers:[{level:2,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:44},{level:2,title:"脱离文档流",slug:"脱离文档流",normalizedTitle:"脱离文档流",charIndex:19},{level:2,title:"BFC",slug:"bfc",normalizedTitle:"bfc",charIndex:28},{level:2,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:35}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"分类 脱离文档流 BFC 清除浮动",content:'# 盒子模型\n\n * 盒子模型\n * 脱离文档流\n * BFC\n * 清除浮动\n\n\n# 分类\n\n * w3c标准盒模型\n   * 包括 width, height, margin, padding, border\n   * 可视宽度是 width + padding + border\n   * box-sizing: content-box;\n * ie盒模型\n   * 也包括 width, height, margin, padding, border\n   * 可视宽度 width\n   * box-sizing: border-box;\n\n\n# 脱离文档流\n\n * 所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。\n * 脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。\n * 浮动 ( float ) 和绝对定位 ( position:absolute )\n   * 均脱离文档流\n   * 均不占位\n   * 浮动情况下，其他元素会自动在其右边排列。绝对定位会完全忽视其存在。\n\n\n# BFC\n\n * BFC的定义:\n\nBFC（Block formatting context ）“块级格式上下文”。 是用于布局块级盒子的一块渲染区域。并且与这个区域的外部毫无关系。\n\n\n * BFC的布局规则\n\n 内部的Box会在垂直方向，一个接一个地放置。\n\n Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。\n\n 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n\n BFC的区域不会与float box重叠。\n\n BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n\n 计算BFC的高度时，浮动元素也参与计算。\n\n\n * 触发BFC的条件:\n\n满足下列条件之一就可以触发BFC\n\n 1：根元素，即html元素\n\n 2：float的值不为none\n\n 3：overflow的值不为visible\n\n 4：display的值为inline-block、table-cell、table-caption\n\n 5：position的值为absolute或者fixed\n\n\n * BFC的作用\n\n（1）可以阻止元素被浮动的元素覆盖（可做两栏布局自适应）\n\n\n\n触发红色盒子的BFC后\n\n\n\n<style>\n       .box1{\n            float: left;\n            width: 100px;\n            height: 100px;\n            background: green;\n        }\n        .box2{\n            height: 500px;\n            background: red;\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n  <div class="box1"></div>\n  <div class="box2"></div>\n</body>\n\n\n（2）解决高度塌陷：我们知道当浮动的盒子的父元素没有高度时，会出现高度塌陷现象。\n\n\n\n父盒子触发BFC可以解决这个问题,根据布局规则的最后一条。\n\n（3）解决同一个BFC区域的垂直方向margin塌陷的问题\n\n\n\n分为两个不同的BFC之后可以解决\n\n\n# 清除浮动\n\n>  1. 浮动元素后面加空 div\n>  2. 利用 BFC\n>  3. 利用 after 伪元素\n\n * 浮动元素后面加一个空的div，并为它清除浮动\n\n<style>\n  .wrap{\n    width:500px;\n    height:400px;\n    border:1px solid red;\n    margin:0 auto;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n  .nofloat{\n    width:300px;\n    height:150px;\n    background:red;\n  }\n  .clear{\n    clear:both;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n  <div class="clear"></div>\n  <div class="nofloat">不想被浮动影响</div>\n</div>\n\n\n * 利用BFC特性清除浮动（BFC中浮动元素也会参与计算高度）\n\n<style>\n  .wrap{\n    width:500px;\n    border:1px solid red;\n    margin:0 auto;\n    overflow:hidden;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n  .nofloat{\n    width:300px;\n    height:150px;\n    background:red;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n  <div class="nofloat">不想被浮动影响</div>\n</div>\n\n\n * 使用after伪元素，给浮动元素的父元素清除浮动\n\n<style>\n  .wrap{\n    width:500px;\n    border:1px solid red;\n    margin:0 auto;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n\n  .wrap:after{\n    content:\'clear\';\n    display:block;\n    height:0;\n    clear:both;\n    overflow:hidden;\n    visibility:hidden;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n</div>\n',normalizedContent:'# 盒子模型\n\n * 盒子模型\n * 脱离文档流\n * bfc\n * 清除浮动\n\n\n# 分类\n\n * w3c标准盒模型\n   * 包括 width, height, margin, padding, border\n   * 可视宽度是 width + padding + border\n   * box-sizing: content-box;\n * ie盒模型\n   * 也包括 width, height, margin, padding, border\n   * 可视宽度 width\n   * box-sizing: border-box;\n\n\n# 脱离文档流\n\n * 所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。\n * 脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。\n * 浮动 ( float ) 和绝对定位 ( position:absolute )\n   * 均脱离文档流\n   * 均不占位\n   * 浮动情况下，其他元素会自动在其右边排列。绝对定位会完全忽视其存在。\n\n\n# bfc\n\n * bfc的定义:\n\nbfc（block formatting context ）“块级格式上下文”。 是用于布局块级盒子的一块渲染区域。并且与这个区域的外部毫无关系。\n\n\n * bfc的布局规则\n\n 内部的box会在垂直方向，一个接一个地放置。\n\n box垂直方向的距离由margin决定。属于同一个bfc的两个相邻box的margin会发生重叠。\n\n 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n\n bfc的区域不会与float box重叠。\n\n bfc就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n\n 计算bfc的高度时，浮动元素也参与计算。\n\n\n * 触发bfc的条件:\n\n满足下列条件之一就可以触发bfc\n\n 1：根元素，即html元素\n\n 2：float的值不为none\n\n 3：overflow的值不为visible\n\n 4：display的值为inline-block、table-cell、table-caption\n\n 5：position的值为absolute或者fixed\n\n\n * bfc的作用\n\n（1）可以阻止元素被浮动的元素覆盖（可做两栏布局自适应）\n\n\n\n触发红色盒子的bfc后\n\n\n\n<style>\n       .box1{\n            float: left;\n            width: 100px;\n            height: 100px;\n            background: green;\n        }\n        .box2{\n            height: 500px;\n            background: red;\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n  <div class="box1"></div>\n  <div class="box2"></div>\n</body>\n\n\n（2）解决高度塌陷：我们知道当浮动的盒子的父元素没有高度时，会出现高度塌陷现象。\n\n\n\n父盒子触发bfc可以解决这个问题,根据布局规则的最后一条。\n\n（3）解决同一个bfc区域的垂直方向margin塌陷的问题\n\n\n\n分为两个不同的bfc之后可以解决\n\n\n# 清除浮动\n\n>  1. 浮动元素后面加空 div\n>  2. 利用 bfc\n>  3. 利用 after 伪元素\n\n * 浮动元素后面加一个空的div，并为它清除浮动\n\n<style>\n  .wrap{\n    width:500px;\n    height:400px;\n    border:1px solid red;\n    margin:0 auto;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n  .nofloat{\n    width:300px;\n    height:150px;\n    background:red;\n  }\n  .clear{\n    clear:both;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n  <div class="clear"></div>\n  <div class="nofloat">不想被浮动影响</div>\n</div>\n\n\n * 利用bfc特性清除浮动（bfc中浮动元素也会参与计算高度）\n\n<style>\n  .wrap{\n    width:500px;\n    border:1px solid red;\n    margin:0 auto;\n    overflow:hidden;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n  .nofloat{\n    width:300px;\n    height:150px;\n    background:red;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n  <div class="nofloat">不想被浮动影响</div>\n</div>\n\n\n * 使用after伪元素，给浮动元素的父元素清除浮动\n\n<style>\n  .wrap{\n    width:500px;\n    border:1px solid red;\n    margin:0 auto;\n  }\n  .float{\n    width:200px;\n    height:200px;\n    background:#ccc;\n    float:left;\n  }\n\n  .wrap:after{\n    content:\'clear\';\n    display:block;\n    height:0;\n    clear:both;\n    overflow:hidden;\n    visibility:hidden;\n  }\n</style>\n\n<div class="wrap">\n  <div class="float">浮动</div>\n</div>\n',charsets:{cjk:!0}},{title:"process.env全局变量",frontmatter:{},regularPath:"/engineering/env.html",relativePath:"engineering/env.md",key:"v-69e9675f",path:"/engineering/env.html",headers:[{level:2,title:"vue-cli",slug:"vue-cli",normalizedTitle:"vue-cli",charIndex:24},{level:3,title:"模式",slug:"模式",normalizedTitle:"模式",charIndex:222},{level:3,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:159},{level:3,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:827},{level:3,title:"在客户端侧代码中使用环境变量",slug:"在客户端侧代码中使用环境变量",normalizedTitle:"在客户端侧代码中使用环境变量",charIndex:899},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:984},{level:3,title:"process.env",slug:"process-env",normalizedTitle:"process.env",charIndex:2},{level:3,title:"process.cwd",slug:"process-cwd",normalizedTitle:"process.cwd",charIndex:2149},{level:3,title:"compiler",slug:"compiler",normalizedTitle:"compiler",charIndex:2204},{level:3,title:"webpack.DefinePlugin",slug:"webpack-defineplugin",normalizedTitle:"webpack.defineplugin",charIndex:2338},{level:2,title:"具体实现",slug:"具体实现",normalizedTitle:"具体实现",charIndex:2913},{level:2,title:"如何验证",slug:"如何验证",normalizedTitle:"如何验证",charIndex:4723},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4815}],lastUpdated:"3/31/2022, 7:39:54 PM",lastUpdatedTimestamp:1648726794e3,headersStr:"vue-cli 模式 环境变量 优先级 在客户端侧代码中使用环境变量 实现原理 process.env process.cwd compiler webpack.DefinePlugin 具体实现 如何验证 总结",content:'# process.env全局变量\n\n众所周知，vue-cli 中有 .env 创建全局变量的功能，项目中可以直接使用 process.env.[变量名] 来使用。\n\n最近在公司自研 cli 创建的项目中并没有发现此功能，于是打算了解一下 process.env 的原理并探索如何在 cli 工具中实现读取 .env 环境变量的功能，使其在客户端侧使用。\n\n\n# vue-cli\n\n首先我们看一下 vue-cli 的相关概念：原文地址\n\n\n# 模式\n\n一个 Vue CLI 项目有三个模式：\n\n * development 模式用于 vue-cli-service serve\n * test 模式用于 vue-cli-service test:unit\n * production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e\n\n当运行 vue-cli-service 命令时，所有的环境变量都从对应的环境文件中载入。如果文件内部不包含 NODE_ENV 变量，它的值将取决于模式，例如，\n\n * 在 production 模式下被设置为 "production"\n * 在 test 模式下被设置为 "test"，默认则是 "development"。\n\n\n# 环境变量\n\n你可以在你的项目根目录中放置下列文件来指定环境变量：\n\n.env                # 在所有的环境中被载入\n.env.local          # 在所有的环境中被载入，但会被 git 忽略\n.env.[mode]         # 只在指定的模式中被载入\n.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略\n\n\n一个环境文件只包含环境变量的“键=值”对：\n\nFOO=bar\nVUE_APP_NOT_SECRET_CODE=some_value\n\n\n\n# 优先级\n\n为一个特定模式准备的环境文件（例如 .env.production）将会比一般的环境文件（例如 .env）拥有更高的优先级。\n\n\n# 在客户端侧代码中使用环境变量\n\nconsole.log(process.env.VUE_APP_NOT_SECRET_CODE); // some_value\n\n\n\n# 实现原理\n\n整个过程其实分为两步：\n\n 1. 如何读取 .env 中的变量\n 2. 如何在客户端侧代码中全局使用\n\n在介绍之前，先来复习一些相关的知识点。\n\n\n# process.env\n\nprocess 对象提供有关当前 Node.js 进程的信息并对其进行控制。它可以作为全局可用。\n\nprocess.env 属性返回包含用户环境的对象，包含了当前Shell的所有环境变量。比如，process.env.HOME 返回用户的主目录。\n\n// 可以直接在 node 程序中输出\nconsole.log(process.env);\n\n\n项目中通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的阶段，生产阶段设为 production，开发阶段设为 development。NODE_ENV 这个名称只是开发社区的一种共识，名称内容是可以修改的。\n\n如何设置 这个 process.env.NODE_ENV 环境变量呢？在webpack项目里，我们可以通过设置package.json来实现，但是Windows 系统和Mac系统有区别。\n\n// windows\n{\n  "scripts": {\n    "dev": "set NODE_ENV=development &&  webpack-dev-server --open --hot",\n    "build": "set NODE_ENV=production &&   --progress --hide-modules"\n  }\n}\n\n// mac\n{\n  "scripts": {\n    "dev": "export NODE_ENV=development &&  webpack-dev-server --open --hot",\n    "build": "export NODE_ENV=production &&   --progress --hide-modules"\n  }\n}\n\n\ncross-env 是一个跨平台设置环境变量的第三方包，它可以让你只配置一行命令，就能轻松地在多个平台设置环境变量。\n\n{\n  ...\n  "scripts": {\n    "dev": "cross-env NODE_ENV=development webpack-dev-server --open --hot",\n    "build": "cross-env NODE_ENV=production webpack --mode=production  --progress --hide-modules"\n  },\n}\n\n\n这样我们就可以在项目里取到 process.env.NODE_ENV 的值，然后利用这个值来区分当前环境。\n\n\n# process.cwd\n\nprocess.cwd() 方法返回 Node.js 进程的当前工作目录。\n\n\n# compiler\n\nCompiler 对象包含了当前运行Webpack的配置，包括entry、output、loaders等配置，这个对象在启动Webpack时被实例化，而且是全局唯一的。Plugin可以通过该对象获取到 Webpack 的配置信息进行处理。\n\n\n# webpack.DefinePlugin\n\nDefinePlugin 允许在 编译时 将你代码中的变量替换为其他值或表达式。\n\n换种方式理解就是可以向应用中注入全局变量。\n\nTIP\n\n请注意，由于本插件会直接替换文本，因此提供的值必须在字符串本身中再包含一个 实际的引号 。通常，可以使用类似 \'"production"\' 这样的替换引号，或者直接用 JSON.stringify(\'production\')。\n\n// 这样写的话\nnew webpack.DefinePlugin({\n    \'process.env.NODE_ENV\': \'production\',\n})\n\n// production是一个变量，并不是我们想象中的字符串\nif (production === \'production\') {\n    console.log(\'production\');\n}\n\n\n// 所以需要这么写\nnew webpack.DefinePlugin({\n    \'process.env.NODE_ENV\': JSON.stringify(\'production\'),\n})\n// 或者\nnew webpack.DefinePlugin({\n    \'process.env.NODE_ENV\': \'"production"\',\n})\n\n\n\n# 具体实现\n\n首先我们需要读取 .env 文件中的内容并解析出来，并赋值到 process.env 中去。\n\n这里可以用到工具库 dotenv，使用其中的 parse 方法来解析。\n\nimport * as dotenv from \'dotenv\';\n// 从 .env 文件中取出变量赋值给 process.env\nfunction loadEnv (mode) {\n    // 当前路径\n    const basePath = path.resolve(process.cwd());\n\n    const load = envPath => {\n        let env = {};\n        try {\n            const content = fs.readFileSync(envPath);\n            env = dotenv.parse(content) || {};\n        } catch (err) {\n            if (err.toString().indexOf(\'ENOENT\') < 0) {\n                logger.error(err);\n            }\n        }\n        return env;\n    };\n\n    let env = {};\n    // 注意此处的优先级\n    [\'.env\', `.env.${mode}`, `.env.${mode}.local`].forEach(envName => {\n        const envPath = path.resolve(basePath, envName);\n        if (fs.existsSync(envPath)) {\n            env = Object.assign(env, load(envPath));\n        }\n    });\n    process.env.NODE_ENV = mode;\n    Object.keys(env).forEach(key => {\n        if (!process.env.hasOwnProperty(key)) {\n            process.env[key] = env[key];\n        }\n    });\n}\n\n\n找到 cli 项目中 webpack 配置项的部分，使用 webpack.DefinePlugin 来注入变量\n\nmodule: {\n  \trules: [],\n    plugins: [\n      new webpack.DefinePlugin({\n        ...resolveClientEnv(),\n        \'__GLOBAL_VAR__\': \'1\'\n      })\n    ]\n}\n\n\n其中的 resolveClientEnv 的功能是从 process.env 中解析出来用到的变量，因为其中的变量不一定都是我们所需要的，同时我们也可以在这个方法中要求变量名的前缀，即不满足前缀要求的不能被解析。\n\n/**\n * 解析 process.env 中符合要求的变量在客服端侧使用\n * 要求变量前缀符合: GLOBAL_VAR_\n */\nexport function resolveClientEnv () {\n    const prefixRE = /^GLOBAL_VAR_/;\n    const env = {};\n    Object.keys(process.env).forEach(key => {\n        if (prefixRE.test(key) || key === \'NODE_ENV\') {\n            env[key] = process.env[key];\n        }\n    });\n\n    for (const key in env) {\n        env[key] = JSON.stringify(env[key]);\n    }\n    return {\n        \'process.env\': env\n    };\n}\n\n\n\n# 如何验证\n\n在项目中创建 .env、.env.development、.env.production 三个文件，使用 cli 启动项目，测试客户端侧代码中的变量输出及优先级。\n\n\n# 总结\n\n综上所述，项目中使用的 process.env 其实和 node 中的 process.env 不是一回事，项目中使用的是我们自定义的全局变量，可以更改为其他名字，实现原理其实是 webpack + dotenv + webpack.definePlugin 的作用。\n\nnode 中的 process.env 是自带的 api。',normalizedContent:'# process.env全局变量\n\n众所周知，vue-cli 中有 .env 创建全局变量的功能，项目中可以直接使用 process.env.[变量名] 来使用。\n\n最近在公司自研 cli 创建的项目中并没有发现此功能，于是打算了解一下 process.env 的原理并探索如何在 cli 工具中实现读取 .env 环境变量的功能，使其在客户端侧使用。\n\n\n# vue-cli\n\n首先我们看一下 vue-cli 的相关概念：原文地址\n\n\n# 模式\n\n一个 vue cli 项目有三个模式：\n\n * development 模式用于 vue-cli-service serve\n * test 模式用于 vue-cli-service test:unit\n * production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e\n\n当运行 vue-cli-service 命令时，所有的环境变量都从对应的环境文件中载入。如果文件内部不包含 node_env 变量，它的值将取决于模式，例如，\n\n * 在 production 模式下被设置为 "production"\n * 在 test 模式下被设置为 "test"，默认则是 "development"。\n\n\n# 环境变量\n\n你可以在你的项目根目录中放置下列文件来指定环境变量：\n\n.env                # 在所有的环境中被载入\n.env.local          # 在所有的环境中被载入，但会被 git 忽略\n.env.[mode]         # 只在指定的模式中被载入\n.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略\n\n\n一个环境文件只包含环境变量的“键=值”对：\n\nfoo=bar\nvue_app_not_secret_code=some_value\n\n\n\n# 优先级\n\n为一个特定模式准备的环境文件（例如 .env.production）将会比一般的环境文件（例如 .env）拥有更高的优先级。\n\n\n# 在客户端侧代码中使用环境变量\n\nconsole.log(process.env.vue_app_not_secret_code); // some_value\n\n\n\n# 实现原理\n\n整个过程其实分为两步：\n\n 1. 如何读取 .env 中的变量\n 2. 如何在客户端侧代码中全局使用\n\n在介绍之前，先来复习一些相关的知识点。\n\n\n# process.env\n\nprocess 对象提供有关当前 node.js 进程的信息并对其进行控制。它可以作为全局可用。\n\nprocess.env 属性返回包含用户环境的对象，包含了当前shell的所有环境变量。比如，process.env.home 返回用户的主目录。\n\n// 可以直接在 node 程序中输出\nconsole.log(process.env);\n\n\n项目中通常的做法是，新建一个环境变量node_env，用它确定当前所处的阶段，生产阶段设为 production，开发阶段设为 development。node_env 这个名称只是开发社区的一种共识，名称内容是可以修改的。\n\n如何设置 这个 process.env.node_env 环境变量呢？在webpack项目里，我们可以通过设置package.json来实现，但是windows 系统和mac系统有区别。\n\n// windows\n{\n  "scripts": {\n    "dev": "set node_env=development &&  webpack-dev-server --open --hot",\n    "build": "set node_env=production &&   --progress --hide-modules"\n  }\n}\n\n// mac\n{\n  "scripts": {\n    "dev": "export node_env=development &&  webpack-dev-server --open --hot",\n    "build": "export node_env=production &&   --progress --hide-modules"\n  }\n}\n\n\ncross-env 是一个跨平台设置环境变量的第三方包，它可以让你只配置一行命令，就能轻松地在多个平台设置环境变量。\n\n{\n  ...\n  "scripts": {\n    "dev": "cross-env node_env=development webpack-dev-server --open --hot",\n    "build": "cross-env node_env=production webpack --mode=production  --progress --hide-modules"\n  },\n}\n\n\n这样我们就可以在项目里取到 process.env.node_env 的值，然后利用这个值来区分当前环境。\n\n\n# process.cwd\n\nprocess.cwd() 方法返回 node.js 进程的当前工作目录。\n\n\n# compiler\n\ncompiler 对象包含了当前运行webpack的配置，包括entry、output、loaders等配置，这个对象在启动webpack时被实例化，而且是全局唯一的。plugin可以通过该对象获取到 webpack 的配置信息进行处理。\n\n\n# webpack.defineplugin\n\ndefineplugin 允许在 编译时 将你代码中的变量替换为其他值或表达式。\n\n换种方式理解就是可以向应用中注入全局变量。\n\ntip\n\n请注意，由于本插件会直接替换文本，因此提供的值必须在字符串本身中再包含一个 实际的引号 。通常，可以使用类似 \'"production"\' 这样的替换引号，或者直接用 json.stringify(\'production\')。\n\n// 这样写的话\nnew webpack.defineplugin({\n    \'process.env.node_env\': \'production\',\n})\n\n// production是一个变量，并不是我们想象中的字符串\nif (production === \'production\') {\n    console.log(\'production\');\n}\n\n\n// 所以需要这么写\nnew webpack.defineplugin({\n    \'process.env.node_env\': json.stringify(\'production\'),\n})\n// 或者\nnew webpack.defineplugin({\n    \'process.env.node_env\': \'"production"\',\n})\n\n\n\n# 具体实现\n\n首先我们需要读取 .env 文件中的内容并解析出来，并赋值到 process.env 中去。\n\n这里可以用到工具库 dotenv，使用其中的 parse 方法来解析。\n\nimport * as dotenv from \'dotenv\';\n// 从 .env 文件中取出变量赋值给 process.env\nfunction loadenv (mode) {\n    // 当前路径\n    const basepath = path.resolve(process.cwd());\n\n    const load = envpath => {\n        let env = {};\n        try {\n            const content = fs.readfilesync(envpath);\n            env = dotenv.parse(content) || {};\n        } catch (err) {\n            if (err.tostring().indexof(\'enoent\') < 0) {\n                logger.error(err);\n            }\n        }\n        return env;\n    };\n\n    let env = {};\n    // 注意此处的优先级\n    [\'.env\', `.env.${mode}`, `.env.${mode}.local`].foreach(envname => {\n        const envpath = path.resolve(basepath, envname);\n        if (fs.existssync(envpath)) {\n            env = object.assign(env, load(envpath));\n        }\n    });\n    process.env.node_env = mode;\n    object.keys(env).foreach(key => {\n        if (!process.env.hasownproperty(key)) {\n            process.env[key] = env[key];\n        }\n    });\n}\n\n\n找到 cli 项目中 webpack 配置项的部分，使用 webpack.defineplugin 来注入变量\n\nmodule: {\n  \trules: [],\n    plugins: [\n      new webpack.defineplugin({\n        ...resolveclientenv(),\n        \'__global_var__\': \'1\'\n      })\n    ]\n}\n\n\n其中的 resolveclientenv 的功能是从 process.env 中解析出来用到的变量，因为其中的变量不一定都是我们所需要的，同时我们也可以在这个方法中要求变量名的前缀，即不满足前缀要求的不能被解析。\n\n/**\n * 解析 process.env 中符合要求的变量在客服端侧使用\n * 要求变量前缀符合: global_var_\n */\nexport function resolveclientenv () {\n    const prefixre = /^global_var_/;\n    const env = {};\n    object.keys(process.env).foreach(key => {\n        if (prefixre.test(key) || key === \'node_env\') {\n            env[key] = process.env[key];\n        }\n    });\n\n    for (const key in env) {\n        env[key] = json.stringify(env[key]);\n    }\n    return {\n        \'process.env\': env\n    };\n}\n\n\n\n# 如何验证\n\n在项目中创建 .env、.env.development、.env.production 三个文件，使用 cli 启动项目，测试客户端侧代码中的变量输出及优先级。\n\n\n# 总结\n\n综上所述，项目中使用的 process.env 其实和 node 中的 process.env 不是一回事，项目中使用的是我们自定义的全局变量，可以更改为其他名字，实现原理其实是 webpack + dotenv + webpack.defineplugin 的作用。\n\nnode 中的 process.env 是自带的 api。',charsets:{cjk:!0}},{title:"面向对象编程",frontmatter:{title:"面向对象编程",date:"2019-01-18T16:00:54.000Z",categories:"设计模式"},regularPath:"/design-pattern/object.html",relativePath:"design-pattern/object.md",key:"v-5946fd9f",path:"/design-pattern/object.html",headers:[{level:2,title:"如何创建一个类",slug:"如何创建一个类",normalizedTitle:"如何创建一个类",charIndex:93},{level:3,title:"属性与方法的封装",slug:"属性与方法的封装",normalizedTitle:"属性与方法的封装",charIndex:427},{level:2,title:"通过闭包实现类的静态变量",slug:"通过闭包实现类的静态变量",normalizedTitle:"通过闭包实现类的静态变量",charIndex:1521},{level:2,title:"创建对象的安全模式",slug:"创建对象的安全模式",normalizedTitle:"创建对象的安全模式",charIndex:2534},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:3208},{level:3,title:"构造函数继承",slug:"构造函数继承",normalizedTitle:"构造函数继承",charIndex:4093},{level:3,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:4959},{level:3,title:"原型式继承",slug:"原型式继承",normalizedTitle:"原型式继承",charIndex:5940},{level:3,title:"寄生式继承",slug:"寄生式继承",normalizedTitle:"寄生式继承",charIndex:6330},{level:3,title:"寄生组合式继承",slug:"寄生组合式继承",normalizedTitle:"寄生组合式继承",charIndex:6685},{level:3,title:"继承单对象属性的extend方法",slug:"继承单对象属性的extend方法",normalizedTitle:"继承单对象属性的extend方法",charIndex:8063},{level:3,title:"多继承",slug:"多继承",normalizedTitle:"多继承",charIndex:8269},{level:2,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:9044},{level:3,title:"类形式实现",slug:"类形式实现",normalizedTitle:"类形式实现",charIndex:9470}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"如何创建一个类 属性与方法的封装 通过闭包实现类的静态变量 创建对象的安全模式 继承 构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承 继承单对象属性的extend方法 多继承 多态 类形式实现",content:"# 面向对象编程\n\nJavaScript这种解释型的弱类型语言没有经典强类型语言中那种通过class等关键字实现类的封装方式，JavaScript中都是通过一些特性模仿实现的。\n\n\n# 如何创建一个类\n\n首先声明一个函数保存在一个变量里，然后在这个函数（类）的内部通过this变量添加属性或者方法来实现对类添加属性或者方法。\n\nvar Book = functoin(id,bookname,price){\n    this.id = id;\n    this.bookname = bookname;\n    this.price = price;\n}\n//这样我们实现了封装，当使用功能方法时，我们不能直接使用这个Book类，需要用new关键字来实例化\n//可以使用点语法访问实例化对象的属性和方法\n\nvar book = new Book(10,'设计模式',50);\nconsole.log(book.bookname);//设计模式\n\n\n\n# 属性与方法的封装\n\n由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的：私有变量，私有方法\n\n函数内部通过this创建的属性可看做是对象的：共有属性，共有方法\n\n而通过this创建的方法，不但可以访问到对象的共有属性与共有方法，而且还能访问到私有属性和私有方法，可以看做：特权方法\n\n在对象创建时通过这些特权方法可以初始化实例对象的一些属性：构造器\n\nvar Book = function(id,name,price){\n    //私有属性\n    var num = 1;\n    //私有方法\n    function checkId(){\n        \n    };\n    //特权方法\n    this.getName = function(){};\n    this.getPrice = function(){};\n    this.setName = function(){};\n    this.setPrice = function(){};\n    //对象公有属性\n    this.copy = function(){};\n    //构造器\n    this.setName(name);\n    this.setPrice(price);\n}\n\n\n在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n\nprototype对象中的属性和方法称为共有属性和共有方法\n\n（ 无需实例化就可以调用的方法就叫静态方法。 ）\n\n//类静态公有属性，方法\nBook.isChinese = true;\nBook.resetTime = function(){\n    console.log('new Time')\n};\nBook.prototype = {\n    //公有属性\n    isJSBook: false\n    //公有方法\n    display: function(){}\n}\n\n//测试代码\nvar b = new Book(11,'设计模式',50)；\nconsole.log(b.num);     //undefined\nconsole.log(b.isJSBook);//false\nconsole.log(b.id);      //11\nconsole.log(b.isChinese);//undefined\nconsole.log(Book.isChinese);//true\nBook.resetTime();        //undefined\n\n\n\n# 通过闭包实现类的静态变量\n\n闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样他既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量，如\n\nbookNum： 静态私有变量\n\ncheckBook()：静态私有方法\n\nprice,checkID()：闭包内部的私有变量以及私有方法\n\n//利用闭包实现\nvar Book = (function(){\n    //静态私有变量\n    var bookNum = 0;\n    //静态私有方法\n    function checkBook(name){}\n    //创建类\n    function book(newId,newName,newPrice){\n        //私有变量\n        var name,price;\n        //私有方法\n        function checkID(id){}\n        //特权方法\n        this.getName = function(){};\n        this.getPrice = function(){};\n        this.setName = function(){};\n        this.setPrice = function(){};\n        //公有属性\n        this.id = newId;\n        //公有方法\n        this.copy = function(){}\n        bookNum++\n        if(bookNum > 100)\n            throw new Error('我们仅出版100本书')\n        //构造器\n        this.setName(name);\n        this.setPrice(price);\n    }\n    //构造原型\n    _book.prototype = {\n        //静态公有属性\n        isJSBook:false,\n        //静态公有方法\n        display: function(){}\n    };\n    //返回类\n    return _book；\n})()\n\n\n\n# 创建对象的安全模式\n\nvar Book = function(title,time,type){\n    this.title = title;\n    this.time = time;\n    this.type = type;\n}\n//实例化一本书\nvar book = Book('JavaScript','2014','js');\n//测试\nconsole.log(book);//undefined\nconsole.log(window.title);//JavaScript\nconsole.log(window.time);//2014\nconsole.log(window.type);//js\n\n\nnew关键字的作用可以看作是对当前对象的this不停地赋值\n\n例子中没有new，则会直接执行这个函数\n\n//图书安全类\nvar Book = function(title,time,type){\n    //判断执行过程中this是否是当前这个对象（如果是说明是用new创建的）\n    if(this instanceof Book){\n        this.title = title;\n        this.time = time;\n        this.type = type;\n    }else{\n        return new Book((title,time,type);\n    }\n}\n//测试\nvar book = Book('JavaScript','2014','js');\n\n\n\n# 继承\n\n# 类式继承\n\n//声明父类\nfunction SuperClass(){\n    this.superValue = true;\n}\n//为父类添加共有方法\nSuperClass.prototype.getSuperValue = function(){\n  \treturn this.superValue;  \n};\n//声明子类\nfunction SubClass(){\n    this.subValue = false;\n}\n\n//继承父类\nSubClass.prototype = new SuperClass()'\n//为子类添加共有方法\nSubClass.prototype.getSubValue = function(){\n    return this.subValue;\n}'\n\n//测试\nvar instance = new SubClass();\nconsole.log(instance.getSubValue);   //false\nconsole.log(instance.getSuperValue); //true\n\n\ninstanceof 可以检测某个对象是否是某个类的实例\n\nconsole.log(instance instanceof SuperClass); //true\nconsole.log(instance instanceof SubClass);   //true\nconsole.log(SubClass instanceof SuperClass); //false\nconsole.log(SubClass.prototype instanceof SuperClass) //true\n\n//所有创建的对象都是原生对象Object的实例\n\n\n缺点：\n\n 1. 父类中的共有属性要是引用类型，就会在子类中被所有实例共用\n\n 2. 由于子类实现的继承是靠原型对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n\n# 构造函数继承\n\n//声明父类\nfunction SuperClass(id){\n    //引用类型共有属性\n    this.books = ['JavaScript','html','css'];\n    //值类型共有属性\n    this.id = id;\n}\n\n//父类声明原型方法\nSuperClass.prototype.showBooks = function(){\n    console.log(this.books);\n}\n\n//声明子类\nfunction SubClass(id){\n    //继承父类\n    SuperClass.call(this,id);\n}\n\n//创建第一个子类的实例\nvar instance1 = new SubClass(10);\n//创建第二个子类的实例\nvar instance2 = new SubClass(11);\n\ninstance1.books.push('设计模式');\nconsole.log(instance1.books); //['JavaScript','html','css','设计模式']\nconsole.log(instance1.id);  //10\nconsole.log(instance2.books); //['JavaScript','html','css']\nconsole.log(instance2.id);\t//11\n\ninstance1.showBooks(); //TypeError\n\n\nSuperClass.call(this,id);这条语句是构造函数继承的精华，由于call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类继承了父类的共有属性。\n\n缺点：父类的原型方法不会被子类继承，如果要被继承必须放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共有，违反了代码复用的原则在\n\n\n# 组合继承\n\n * 类式继承是通过子类的原型对父类实例化来实现的\n * 构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n * 组合继承同时实现这两点\n\n//声明父类\nfunction SuperClass(id){\n    //引用类型共有属性\n    this.books = ['JavaScript','html','css'];\n    //值类型共有属性\n    this.name = name;\n}\n\n//父类声明原型方法\nSuperClass.prototype.getName = function(){\n    console.log(this.name);\n}\n\n//声明子类\nfunction SubClass(name,time){\n    //构造函数继承父类name属性\n    SuperClass.call(this,name);\n}\n\n//类式继承 \nSubClass.prototype = new SuperClass();\n//子类原型方法\nSubClass.prototype.getTime = function(){\n    console.log(this.time)\n};\n\n//测试\n\nvar instance1 = new SubClass('js book',2014);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books); //['JavaScript','html','css','设计模式']\ninstance1.getName(); //js book\ninstance1.getTime();//2014\n\nvar instance2 = new SubClass('css book',2013);\nconsole.log(instance1.books); //['JavaScript','html','css']\ninstance1.getName(); //css book\ninstance1.getTime();//2013\n\n\n缺点：\n\n 1. 使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数，因此父类构造函数调用了两遍。\n\n\n# 原型式继承\n\n//这是对类式继承的封装，其中的过渡对象就相当于类式继承中的子类\nfunction inheritObkect(o){\n    //声明一个过渡函数对象\n    function F(){}\n    //过渡对象的原型继承父对象\n    F.prototype = o;\n    //返回过渡对象的一个实例，该实例的原型继承了父对象\n    return new F();\n}\n\nvar book = {\n    name: 'js book',\n    alikeBook:['css book','html book']\n};\nvar newBook = inheritObkect(book);\nvar newBook.name = 'ajax book'\n\n\n这种方式由于F过渡类中的构造函数无内容，所以开销比较小。\n\n缺点：仍然存在类式继承的缺点\n\n\n# 寄生式继承\n\nvar book = {\n    name: 'js book',\n    alikeBook:['css book','html book']\n};\n\nfunction createBook(obj){\n    //通过原型继承方式创建新对象\n    var o = new inheritObject(obj);\n    //拓展新对象\n    o.getName = function(){\n        console.log(name);\n    };\n    //返回拓展后的新对象\n    return o;\n}\n\n\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n\n# 寄生组合式继承\n\n寄生式继承依托于原型继承，原型继承又与类式继承相像。\n\n寄生组合式继承是寄生式继承和构造函数继承两种模式的组合，也是对组合继承的改进。\n\n组合继承 = 类式继承+构造函数继承（子类不是父类的实例，而子类的原型是父类的实例）\n\n寄生组合式继承= 寄生式继承+构造函数继承\n\nfunction inheritPrototype(subClass,superClass){\n    //复制一份父类的原型副本保存在变量中\n    var p = inheritObject(superClass.prototype);\n    //修正因为重写子类原型导致子类的constructor属性被修改\n    p.construcor = subClass;\n    //设置子类的原型\n    subClass.prototype = p;\n}\n\n\n组合式继承中，通过构造函数继承的属性和方法是没有问题的，所以我们主要探究通过寄生式继承重新继承父类的原型。在构造函数继承中我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，这个副本我们通过原型继承便可得到，但是这个复制对象p中的construstor指向的不是subClass，因此在寄生式继承中要对p做一次增强，修复其construstor指向不正确的问题，再赋给子类的原型。\n\n\t\t//定义父类\n\t\tfunction SuperClass(name){\n\t\t\tthis.name = name;\n\t\t\tthis.colors = ['red','blue','green'];\n\t\t}\n\t\t//定义父类原型方法\n\t\tSuperClass.prototype.getName = function(){\n\t\t\tconsole.log(this.name);\n\t\t}\n\t\t//定义子类\n\t\tfunction SubClass(name,time){\n\t\t\t//构造函数式继承\n\t\t\tSuperClass.call(this,name);\n\t\t\t//子类新增属性\n\t\t\tthis.time = time;\n\t\t}\n\t\t//寄生式继承父类原型\n\t\tinheritPrototype(SubClass,SuperClass);\n\t\t//子类新增原型方法\n\t\tSubClass.prototype.getTime = function(){\n\t\t\tconsole.log(this.time);\n\t\t};\n\n\t\t//测试\n\t\tvar instance1 = new SubClass('js book',2014);\n\t\tvar instance2 = new SubClass('css book',2013);\n\n\t\tinstance1.colors.push('black');\n\t\tconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\", \"black\"]\n\t\tconsole.log(instance2.colors); //[\"red\", \"blue\", \"green\"]\n\t\tinstance2.getTime(); //2013\n\t\tinstance2.getName(); //css book\n\n\n\n# 继承单对象属性的extend方法\n\n//单继承 属性复制\nvar extend = function(target,source){\n    //遍历源对象中的属性\n    for(var property in source){\n        target[property] = source[property];\n    }\n    //返回目标对象\n    return target;\n}\n\n\n\n# 多继承\n\nvar mix = function(){\n    var i = 1,                    //从第二个参数起为被继承的对象\n    \tlen = arguments.length,   //获取参数长度\n        target = arguments[0],    //第一个对象为目标对象\n        arg;                      //缓存参数对象\n    for(;i < len;i++){\n        arg = arguments[i];\n        for(var property in arg){\n            target[property] = arg[property];\n        }\n    }\n    return target;\n}\n\n\n我们也可以将它绑定到原生对象Object上，这样所有的对象就可以拥有这个方法了。\n\nObject.prototype.mix = function(){\n    var i = 1,                    //从第二个参数起为被继承的对象\n    \tlen = arguments.length,   //获取参数长度\n        arg;                      //缓存参数对象\n    for(;i < len;i++){\n        arg = arguments[i];\n        for(var property in arg){\n            this[property] = arg[property];\n        }\n    }\n}\n\n//测试\notherBook.mix(book1,book2);\n\n\n\n# 多态\n\n多态，对同一个方法多种调用方式，要对传入的参数做判断以实现多种调用方式，如果我们定义一个add方法，如果不传参数返回10，如果传一个参数返回10+参数，如果传两个参数返回相加的结果\n\nfunction add(){\n    //获取参数\n    var arg = arguments;\n    //获取参数长度\n        len = arg.length;\n    switch(len){\n        case 0:\n            return 10;\n        case 1:\n            return 10 + arg[0];\n        case 2:\n            return arg[0] + arg[1];\n    }\n}\n\n//测试\nconsole.log(add());\nconsole.log(add(5));\nconsole.log(add(6,7));\n\n\n\n# 类形式实现\n\nfunction Add(){\n    function zero(){\n        return 10;\n    }\n    function one(num){\n        return 10+num;\n    }\n    function two(num1,num2){\n        return num1+num2\n    }\n    //相加共有方法\n    this.add = function(){\n        var arg = arguments;\n    \t//获取参数长度\n            len = arg.length;\n    switch(len){\n        case 0:\n            return zero();\n        case 1:\n            return one(arg[0]);\n        case 2:\n            return two(arg[0],arg[1]);\n    }\n}\n    \n//测试\nvar A = new add();\nconsole.log(A.add());\nconsole.log(A.add(5));\nconsole.log(A.add(6,7))\n",normalizedContent:"# 面向对象编程\n\njavascript这种解释型的弱类型语言没有经典强类型语言中那种通过class等关键字实现类的封装方式，javascript中都是通过一些特性模仿实现的。\n\n\n# 如何创建一个类\n\n首先声明一个函数保存在一个变量里，然后在这个函数（类）的内部通过this变量添加属性或者方法来实现对类添加属性或者方法。\n\nvar book = functoin(id,bookname,price){\n    this.id = id;\n    this.bookname = bookname;\n    this.price = price;\n}\n//这样我们实现了封装，当使用功能方法时，我们不能直接使用这个book类，需要用new关键字来实例化\n//可以使用点语法访问实例化对象的属性和方法\n\nvar book = new book(10,'设计模式',50);\nconsole.log(book.bookname);//设计模式\n\n\n\n# 属性与方法的封装\n\n由于javascript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的：私有变量，私有方法\n\n函数内部通过this创建的属性可看做是对象的：共有属性，共有方法\n\n而通过this创建的方法，不但可以访问到对象的共有属性与共有方法，而且还能访问到私有属性和私有方法，可以看做：特权方法\n\n在对象创建时通过这些特权方法可以初始化实例对象的一些属性：构造器\n\nvar book = function(id,name,price){\n    //私有属性\n    var num = 1;\n    //私有方法\n    function checkid(){\n        \n    };\n    //特权方法\n    this.getname = function(){};\n    this.getprice = function(){};\n    this.setname = function(){};\n    this.setprice = function(){};\n    //对象公有属性\n    this.copy = function(){};\n    //构造器\n    this.setname(name);\n    this.setprice(price);\n}\n\n\n在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法\n\nprototype对象中的属性和方法称为共有属性和共有方法\n\n（ 无需实例化就可以调用的方法就叫静态方法。 ）\n\n//类静态公有属性，方法\nbook.ischinese = true;\nbook.resettime = function(){\n    console.log('new time')\n};\nbook.prototype = {\n    //公有属性\n    isjsbook: false\n    //公有方法\n    display: function(){}\n}\n\n//测试代码\nvar b = new book(11,'设计模式',50)；\nconsole.log(b.num);     //undefined\nconsole.log(b.isjsbook);//false\nconsole.log(b.id);      //11\nconsole.log(b.ischinese);//undefined\nconsole.log(book.ischinese);//true\nbook.resettime();        //undefined\n\n\n\n# 通过闭包实现类的静态变量\n\n闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样他既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量，如\n\nbooknum： 静态私有变量\n\ncheckbook()：静态私有方法\n\nprice,checkid()：闭包内部的私有变量以及私有方法\n\n//利用闭包实现\nvar book = (function(){\n    //静态私有变量\n    var booknum = 0;\n    //静态私有方法\n    function checkbook(name){}\n    //创建类\n    function book(newid,newname,newprice){\n        //私有变量\n        var name,price;\n        //私有方法\n        function checkid(id){}\n        //特权方法\n        this.getname = function(){};\n        this.getprice = function(){};\n        this.setname = function(){};\n        this.setprice = function(){};\n        //公有属性\n        this.id = newid;\n        //公有方法\n        this.copy = function(){}\n        booknum++\n        if(booknum > 100)\n            throw new error('我们仅出版100本书')\n        //构造器\n        this.setname(name);\n        this.setprice(price);\n    }\n    //构造原型\n    _book.prototype = {\n        //静态公有属性\n        isjsbook:false,\n        //静态公有方法\n        display: function(){}\n    };\n    //返回类\n    return _book；\n})()\n\n\n\n# 创建对象的安全模式\n\nvar book = function(title,time,type){\n    this.title = title;\n    this.time = time;\n    this.type = type;\n}\n//实例化一本书\nvar book = book('javascript','2014','js');\n//测试\nconsole.log(book);//undefined\nconsole.log(window.title);//javascript\nconsole.log(window.time);//2014\nconsole.log(window.type);//js\n\n\nnew关键字的作用可以看作是对当前对象的this不停地赋值\n\n例子中没有new，则会直接执行这个函数\n\n//图书安全类\nvar book = function(title,time,type){\n    //判断执行过程中this是否是当前这个对象（如果是说明是用new创建的）\n    if(this instanceof book){\n        this.title = title;\n        this.time = time;\n        this.type = type;\n    }else{\n        return new book((title,time,type);\n    }\n}\n//测试\nvar book = book('javascript','2014','js');\n\n\n\n# 继承\n\n# 类式继承\n\n//声明父类\nfunction superclass(){\n    this.supervalue = true;\n}\n//为父类添加共有方法\nsuperclass.prototype.getsupervalue = function(){\n  \treturn this.supervalue;  \n};\n//声明子类\nfunction subclass(){\n    this.subvalue = false;\n}\n\n//继承父类\nsubclass.prototype = new superclass()'\n//为子类添加共有方法\nsubclass.prototype.getsubvalue = function(){\n    return this.subvalue;\n}'\n\n//测试\nvar instance = new subclass();\nconsole.log(instance.getsubvalue);   //false\nconsole.log(instance.getsupervalue); //true\n\n\ninstanceof 可以检测某个对象是否是某个类的实例\n\nconsole.log(instance instanceof superclass); //true\nconsole.log(instance instanceof subclass);   //true\nconsole.log(subclass instanceof superclass); //false\nconsole.log(subclass.prototype instanceof superclass) //true\n\n//所有创建的对象都是原生对象object的实例\n\n\n缺点：\n\n 1. 父类中的共有属性要是引用类型，就会在子类中被所有实例共用\n\n 2. 由于子类实现的继承是靠原型对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。\n\n\n# 构造函数继承\n\n//声明父类\nfunction superclass(id){\n    //引用类型共有属性\n    this.books = ['javascript','html','css'];\n    //值类型共有属性\n    this.id = id;\n}\n\n//父类声明原型方法\nsuperclass.prototype.showbooks = function(){\n    console.log(this.books);\n}\n\n//声明子类\nfunction subclass(id){\n    //继承父类\n    superclass.call(this,id);\n}\n\n//创建第一个子类的实例\nvar instance1 = new subclass(10);\n//创建第二个子类的实例\nvar instance2 = new subclass(11);\n\ninstance1.books.push('设计模式');\nconsole.log(instance1.books); //['javascript','html','css','设计模式']\nconsole.log(instance1.id);  //10\nconsole.log(instance2.books); //['javascript','html','css']\nconsole.log(instance2.id);\t//11\n\ninstance1.showbooks(); //typeerror\n\n\nsuperclass.call(this,id);这条语句是构造函数继承的精华，由于call这个方法可以更改函数的作用环境，因此在子类中，对superclass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类继承了父类的共有属性。\n\n缺点：父类的原型方法不会被子类继承，如果要被继承必须放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共有，违反了代码复用的原则在\n\n\n# 组合继承\n\n * 类式继承是通过子类的原型对父类实例化来实现的\n * 构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的\n * 组合继承同时实现这两点\n\n//声明父类\nfunction superclass(id){\n    //引用类型共有属性\n    this.books = ['javascript','html','css'];\n    //值类型共有属性\n    this.name = name;\n}\n\n//父类声明原型方法\nsuperclass.prototype.getname = function(){\n    console.log(this.name);\n}\n\n//声明子类\nfunction subclass(name,time){\n    //构造函数继承父类name属性\n    superclass.call(this,name);\n}\n\n//类式继承 \nsubclass.prototype = new superclass();\n//子类原型方法\nsubclass.prototype.gettime = function(){\n    console.log(this.time)\n};\n\n//测试\n\nvar instance1 = new subclass('js book',2014);\ninstance1.books.push('设计模式');\nconsole.log(instance1.books); //['javascript','html','css','设计模式']\ninstance1.getname(); //js book\ninstance1.gettime();//2014\n\nvar instance2 = new subclass('css book',2013);\nconsole.log(instance1.books); //['javascript','html','css']\ninstance1.getname(); //css book\ninstance1.gettime();//2013\n\n\n缺点：\n\n 1. 使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数，因此父类构造函数调用了两遍。\n\n\n# 原型式继承\n\n//这是对类式继承的封装，其中的过渡对象就相当于类式继承中的子类\nfunction inheritobkect(o){\n    //声明一个过渡函数对象\n    function f(){}\n    //过渡对象的原型继承父对象\n    f.prototype = o;\n    //返回过渡对象的一个实例，该实例的原型继承了父对象\n    return new f();\n}\n\nvar book = {\n    name: 'js book',\n    alikebook:['css book','html book']\n};\nvar newbook = inheritobkect(book);\nvar newbook.name = 'ajax book'\n\n\n这种方式由于f过渡类中的构造函数无内容，所以开销比较小。\n\n缺点：仍然存在类式继承的缺点\n\n\n# 寄生式继承\n\nvar book = {\n    name: 'js book',\n    alikebook:['css book','html book']\n};\n\nfunction createbook(obj){\n    //通过原型继承方式创建新对象\n    var o = new inheritobject(obj);\n    //拓展新对象\n    o.getname = function(){\n        console.log(name);\n    };\n    //返回拓展后的新对象\n    return o;\n}\n\n\n寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法\n\n\n# 寄生组合式继承\n\n寄生式继承依托于原型继承，原型继承又与类式继承相像。\n\n寄生组合式继承是寄生式继承和构造函数继承两种模式的组合，也是对组合继承的改进。\n\n组合继承 = 类式继承+构造函数继承（子类不是父类的实例，而子类的原型是父类的实例）\n\n寄生组合式继承= 寄生式继承+构造函数继承\n\nfunction inheritprototype(subclass,superclass){\n    //复制一份父类的原型副本保存在变量中\n    var p = inheritobject(superclass.prototype);\n    //修正因为重写子类原型导致子类的constructor属性被修改\n    p.construcor = subclass;\n    //设置子类的原型\n    subclass.prototype = p;\n}\n\n\n组合式继承中，通过构造函数继承的属性和方法是没有问题的，所以我们主要探究通过寄生式继承重新继承父类的原型。在构造函数继承中我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，这个副本我们通过原型继承便可得到，但是这个复制对象p中的construstor指向的不是subclass，因此在寄生式继承中要对p做一次增强，修复其construstor指向不正确的问题，再赋给子类的原型。\n\n\t\t//定义父类\n\t\tfunction superclass(name){\n\t\t\tthis.name = name;\n\t\t\tthis.colors = ['red','blue','green'];\n\t\t}\n\t\t//定义父类原型方法\n\t\tsuperclass.prototype.getname = function(){\n\t\t\tconsole.log(this.name);\n\t\t}\n\t\t//定义子类\n\t\tfunction subclass(name,time){\n\t\t\t//构造函数式继承\n\t\t\tsuperclass.call(this,name);\n\t\t\t//子类新增属性\n\t\t\tthis.time = time;\n\t\t}\n\t\t//寄生式继承父类原型\n\t\tinheritprototype(subclass,superclass);\n\t\t//子类新增原型方法\n\t\tsubclass.prototype.gettime = function(){\n\t\t\tconsole.log(this.time);\n\t\t};\n\n\t\t//测试\n\t\tvar instance1 = new subclass('js book',2014);\n\t\tvar instance2 = new subclass('css book',2013);\n\n\t\tinstance1.colors.push('black');\n\t\tconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\", \"black\"]\n\t\tconsole.log(instance2.colors); //[\"red\", \"blue\", \"green\"]\n\t\tinstance2.gettime(); //2013\n\t\tinstance2.getname(); //css book\n\n\n\n# 继承单对象属性的extend方法\n\n//单继承 属性复制\nvar extend = function(target,source){\n    //遍历源对象中的属性\n    for(var property in source){\n        target[property] = source[property];\n    }\n    //返回目标对象\n    return target;\n}\n\n\n\n# 多继承\n\nvar mix = function(){\n    var i = 1,                    //从第二个参数起为被继承的对象\n    \tlen = arguments.length,   //获取参数长度\n        target = arguments[0],    //第一个对象为目标对象\n        arg;                      //缓存参数对象\n    for(;i < len;i++){\n        arg = arguments[i];\n        for(var property in arg){\n            target[property] = arg[property];\n        }\n    }\n    return target;\n}\n\n\n我们也可以将它绑定到原生对象object上，这样所有的对象就可以拥有这个方法了。\n\nobject.prototype.mix = function(){\n    var i = 1,                    //从第二个参数起为被继承的对象\n    \tlen = arguments.length,   //获取参数长度\n        arg;                      //缓存参数对象\n    for(;i < len;i++){\n        arg = arguments[i];\n        for(var property in arg){\n            this[property] = arg[property];\n        }\n    }\n}\n\n//测试\notherbook.mix(book1,book2);\n\n\n\n# 多态\n\n多态，对同一个方法多种调用方式，要对传入的参数做判断以实现多种调用方式，如果我们定义一个add方法，如果不传参数返回10，如果传一个参数返回10+参数，如果传两个参数返回相加的结果\n\nfunction add(){\n    //获取参数\n    var arg = arguments;\n    //获取参数长度\n        len = arg.length;\n    switch(len){\n        case 0:\n            return 10;\n        case 1:\n            return 10 + arg[0];\n        case 2:\n            return arg[0] + arg[1];\n    }\n}\n\n//测试\nconsole.log(add());\nconsole.log(add(5));\nconsole.log(add(6,7));\n\n\n\n# 类形式实现\n\nfunction add(){\n    function zero(){\n        return 10;\n    }\n    function one(num){\n        return 10+num;\n    }\n    function two(num1,num2){\n        return num1+num2\n    }\n    //相加共有方法\n    this.add = function(){\n        var arg = arguments;\n    \t//获取参数长度\n            len = arg.length;\n    switch(len){\n        case 0:\n            return zero();\n        case 1:\n            return one(arg[0]);\n        case 2:\n            return two(arg[0],arg[1]);\n    }\n}\n    \n//测试\nvar a = new add();\nconsole.log(a.add());\nconsole.log(a.add(5));\nconsole.log(a.add(6,7))\n",charsets:{cjk:!0}},{title:"yeoman脚手架工具",frontmatter:{title:"yeoman脚手架工具",date:"2020-08-28T10:37:54.000Z",categories:"前端工程化"},regularPath:"/engineering/engineering.html",relativePath:"engineering/engineering.md",key:"v-2c5dd41f",path:"/engineering/engineering.html",headers:[{level:2,title:"工程化和脚手架的理解",slug:"工程化和脚手架的理解",normalizedTitle:"工程化和脚手架的理解",charIndex:2},{level:2,title:"yeoman",slug:"yeoman",normalizedTitle:"yeoman",charIndex:254},{level:3,title:"sub-generator",slug:"sub-generator",normalizedTitle:"sub-generator",charIndex:717},{level:3,title:"总结一下使用步骤",slug:"总结一下使用步骤",normalizedTitle:"总结一下使用步骤",charIndex:817},{level:3,title:"自定义Generator来搭建自己的脚手架",slug:"自定义generator来搭建自己的脚手架",normalizedTitle:"自定义generator来搭建自己的脚手架",charIndex:937},{level:3,title:"如何使用命令行交互的方式实现询问用户输入",slug:"如何使用命令行交互的方式实现询问用户输入",normalizedTitle:"如何使用命令行交互的方式实现询问用户输入",charIndex:2189},{level:3,title:"如何创建一个自定义的vue脚手架",slug:"如何创建一个自定义的vue脚手架",normalizedTitle:"如何创建一个自定义的vue脚手架",charIndex:2916}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"工程化和脚手架的理解 yeoman sub-generator 总结一下使用步骤 自定义Generator来搭建自己的脚手架 如何使用命令行交互的方式实现询问用户输入 如何创建一个自定义的vue脚手架",content:"# 工程化和脚手架的理解\n\n谈谈你对工程化的初步认识？\n\n> 前端工程化我认为可以提高开发效率，提高代码质量，简便流程。\n> \n> 就目前公司所做的项目来说，工程化所带来的优点是，无论从项目的编码到编译，打包到部署，都十分方便和规范，对开发人员特别友好。\n\n你认为脚手架除了为我们创建项目结构，还有什么更深的意义？\n\n> 我觉得脚手架是帮我们减少「为减少重复性工作而做的重复性工作」的工具，只需要几行命令，目录结构，脚本，配置等等都已经搞好了，我们只需要写核心代码就好，而不用关心其他重复性的事情。\n\n\n# yeoman\n\n在谈论脚手架时，我们想到的都是vue-cli等比较集成的脚手架，而Yeoman是一种通用的工具，便于创建属于自己的脚手架，很值得学习。\n\n> Yeoman主要有三部分组成：yo（脚手架工具）、grunt（构建工具）、bower（包管理器）。这三个工具是分别独立开发的，但是需要配合使用，来实现我们高效的工作流模式。\n\n安装：cnpm install -g yo grunt-cli bower\n\n安装后在命令行中输入 yo，在这里显示的是我的系统中已经安装的generator的库\n\n可以选择install generator，然后搜索我们想安装的generator，比如webapp，然后安装即可。\n\n----------------------------------------\n\n现在我们要使用generator-node：creates a base template to start a new Node.js module.\n\n直接运行yo node，则会直接在文件夹中创建好目录结构\n\n\n# sub-generator\n\n如果不需要生成整个项目结构，只需生成ESLint等配置文件，就可以用sub-generator,用:来表示\n\nyo node:cli：其中的cli就是子集生成器\n\n\n# 总结一下使用步骤\n\n 1. 明确需求\n 2. 找到合适的Generator\n 3. 全局范围安装找到的Generator\n 4. 通过Yo运行对应的Generator\n 5. 通过命令行交互填写选项\n 6. 生成你所需要的项目结构\n\n\n# 自定义Generator来搭建自己的脚手架\n\n比如用vue-cli创建项目时，并没有vue-router,vuex等，需要手动引入，如果把这些也放入脚手架中就很方便\n\n首先使用npm init初始化一个package.json文件\n\n安装cnpm install yeoman-generator,提供了生成器的基类\n\nGenerator的一个基本结构如下\n\n> |- generators/..........生成器目录 |- app/..............默认生成器目录 |- index.js.......默认生成器实现 |- templates/foo.txt..模板文件 |-package.json..........模块包配置文件\n> \n> 其中的index.js是作为Generator 的核心入口\n> \n> 需要导出一个继承自 Yeoman Generator 的类型\n> \n> Yeoman Generator 在工作时会自动调用此类型定义的方法\n\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n    writing () {\n        // Yeoman 自动在生成文件阶段调用此方法\n        // 我们尝试往项目目录中写入文件\n        this.fs.write(\n        \tthis.destinationPath('temp.txt'),\n            Math.random().toString()\n        )\n        \n        // 还可以通过模板方式写入文件到目标目录\n        // 模板文件路径\n        const tmpl = this.templatePath('foo.txt')\n        // 输出目标路径\n        const output = this.destinationPath('foo.txt')\n        // 模板数据上下文\n        const context = { title: 'hello', success: false }\n        \n        this.fs.copyTpl(tmpl, output, context)\n    }\n}\n\n\n编写好之后使用npm link使其成为一个全局模块包，这样在别的地方也能使用yo 'name'调用这个模块\n\n# 使用模板文件\n\n模板文件，支持 EJS 模板标记\n<%= title %>\n\n<% if (success) { %>\n哈哈哈\n<% } %>\n\ntitle和success在模板上下文中赋值\n\n\n之后同样运行yo 'name'创建模板文件，如下：\n\n> 模板文件，支持 EJS 模板标记 hello\n\n\n# 如何使用命令行交互的方式实现询问用户输入\n\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n    prompting () {\n      return this.prompt([\n        {\n          type: 'input',\n          name: 'name', // 命令行需要输入的\n          message: 'Your project name',\n          default: this.appname\n        }\n      ])\n      .then(answers => {\n        this.answers = answers\n      })\n    }\n    writing () {\n        // 模板文件路径\n        const tmpl = this.templatePath('bar.html') // 在bar.html中可以写 <h1><%= name %></h1>\n        // 输出目标路径\n        const output = this.destinationPath('bar.html')\n        // 模板数据上下文\n        const context = this.answers // name传进上下文\n        \n        this.fs.copyTpl(tmpl, output, context)\n    }\n}\n\n\n\n# 如何创建一个自定义的vue脚手架\n\n * 把写好的vue文件目录结构拷贝到templates目录下\n * 重写writing方法，因为不只是创建单个文件，每一个文件都需要创建\n\nconst Generator = require('yeoman-generator')\n\nmodule.exports = class extends Generator {\n    prompting () {\n      return this.prompt([\n        {\n          type: 'input',\n          name: 'name', // 命令行需要输入的\n          message: 'Your project name',\n          default: this.appname\n        }\n      ])\n      .then(answers => {\n        this.answers = answers\n      })\n    }\n    writing () {\n        const templates = [\n            'a.js',\n            'src/main.js',\n            //...需要的文件\n        ]\n        templates.forEach(item => {\n            this.fs.copyTpl(\n                this.templatePath(item),\n                this.destinationPath(item),\n                this.answers\n            )\n        })\n    }\n}\n",normalizedContent:"# 工程化和脚手架的理解\n\n谈谈你对工程化的初步认识？\n\n> 前端工程化我认为可以提高开发效率，提高代码质量，简便流程。\n> \n> 就目前公司所做的项目来说，工程化所带来的优点是，无论从项目的编码到编译，打包到部署，都十分方便和规范，对开发人员特别友好。\n\n你认为脚手架除了为我们创建项目结构，还有什么更深的意义？\n\n> 我觉得脚手架是帮我们减少「为减少重复性工作而做的重复性工作」的工具，只需要几行命令，目录结构，脚本，配置等等都已经搞好了，我们只需要写核心代码就好，而不用关心其他重复性的事情。\n\n\n# yeoman\n\n在谈论脚手架时，我们想到的都是vue-cli等比较集成的脚手架，而yeoman是一种通用的工具，便于创建属于自己的脚手架，很值得学习。\n\n> yeoman主要有三部分组成：yo（脚手架工具）、grunt（构建工具）、bower（包管理器）。这三个工具是分别独立开发的，但是需要配合使用，来实现我们高效的工作流模式。\n\n安装：cnpm install -g yo grunt-cli bower\n\n安装后在命令行中输入 yo，在这里显示的是我的系统中已经安装的generator的库\n\n可以选择install generator，然后搜索我们想安装的generator，比如webapp，然后安装即可。\n\n----------------------------------------\n\n现在我们要使用generator-node：creates a base template to start a new node.js module.\n\n直接运行yo node，则会直接在文件夹中创建好目录结构\n\n\n# sub-generator\n\n如果不需要生成整个项目结构，只需生成eslint等配置文件，就可以用sub-generator,用:来表示\n\nyo node:cli：其中的cli就是子集生成器\n\n\n# 总结一下使用步骤\n\n 1. 明确需求\n 2. 找到合适的generator\n 3. 全局范围安装找到的generator\n 4. 通过yo运行对应的generator\n 5. 通过命令行交互填写选项\n 6. 生成你所需要的项目结构\n\n\n# 自定义generator来搭建自己的脚手架\n\n比如用vue-cli创建项目时，并没有vue-router,vuex等，需要手动引入，如果把这些也放入脚手架中就很方便\n\n首先使用npm init初始化一个package.json文件\n\n安装cnpm install yeoman-generator,提供了生成器的基类\n\ngenerator的一个基本结构如下\n\n> |- generators/..........生成器目录 |- app/..............默认生成器目录 |- index.js.......默认生成器实现 |- templates/foo.txt..模板文件 |-package.json..........模块包配置文件\n> \n> 其中的index.js是作为generator 的核心入口\n> \n> 需要导出一个继承自 yeoman generator 的类型\n> \n> yeoman generator 在工作时会自动调用此类型定义的方法\n\nconst generator = require('yeoman-generator')\n\nmodule.exports = class extends generator {\n    writing () {\n        // yeoman 自动在生成文件阶段调用此方法\n        // 我们尝试往项目目录中写入文件\n        this.fs.write(\n        \tthis.destinationpath('temp.txt'),\n            math.random().tostring()\n        )\n        \n        // 还可以通过模板方式写入文件到目标目录\n        // 模板文件路径\n        const tmpl = this.templatepath('foo.txt')\n        // 输出目标路径\n        const output = this.destinationpath('foo.txt')\n        // 模板数据上下文\n        const context = { title: 'hello', success: false }\n        \n        this.fs.copytpl(tmpl, output, context)\n    }\n}\n\n\n编写好之后使用npm link使其成为一个全局模块包，这样在别的地方也能使用yo 'name'调用这个模块\n\n# 使用模板文件\n\n模板文件，支持 ejs 模板标记\n<%= title %>\n\n<% if (success) { %>\n哈哈哈\n<% } %>\n\ntitle和success在模板上下文中赋值\n\n\n之后同样运行yo 'name'创建模板文件，如下：\n\n> 模板文件，支持 ejs 模板标记 hello\n\n\n# 如何使用命令行交互的方式实现询问用户输入\n\nconst generator = require('yeoman-generator')\n\nmodule.exports = class extends generator {\n    prompting () {\n      return this.prompt([\n        {\n          type: 'input',\n          name: 'name', // 命令行需要输入的\n          message: 'your project name',\n          default: this.appname\n        }\n      ])\n      .then(answers => {\n        this.answers = answers\n      })\n    }\n    writing () {\n        // 模板文件路径\n        const tmpl = this.templatepath('bar.html') // 在bar.html中可以写 <h1><%= name %></h1>\n        // 输出目标路径\n        const output = this.destinationpath('bar.html')\n        // 模板数据上下文\n        const context = this.answers // name传进上下文\n        \n        this.fs.copytpl(tmpl, output, context)\n    }\n}\n\n\n\n# 如何创建一个自定义的vue脚手架\n\n * 把写好的vue文件目录结构拷贝到templates目录下\n * 重写writing方法，因为不只是创建单个文件，每一个文件都需要创建\n\nconst generator = require('yeoman-generator')\n\nmodule.exports = class extends generator {\n    prompting () {\n      return this.prompt([\n        {\n          type: 'input',\n          name: 'name', // 命令行需要输入的\n          message: 'your project name',\n          default: this.appname\n        }\n      ])\n      .then(answers => {\n        this.answers = answers\n      })\n    }\n    writing () {\n        const templates = [\n            'a.js',\n            'src/main.js',\n            //...需要的文件\n        ]\n        templates.foreach(item => {\n            this.fs.copytpl(\n                this.templatepath(item),\n                this.destinationpath(item),\n                this.answers\n            )\n        })\n    }\n}\n",charsets:{cjk:!0}},{title:"规范化标准ESLint",frontmatter:{title:"规范化标准ESLint",date:"2020-09-10T22:27:54.000Z",categories:"前端工程化"},regularPath:"/engineering/eslint.html",relativePath:"engineering/eslint.md",key:"v-627741de",path:"/engineering/eslint.html",headers:[{level:2,title:"ESLint 安装与配置",slug:"eslint-安装与配置",normalizedTitle:"eslint 安装与配置",charIndex:2},{level:2,title:"配置注释",slug:"配置注释",normalizedTitle:"配置注释",charIndex:536},{level:2,title:"ESLint 结合自动化工具",slug:"eslint-结合自动化工具",normalizedTitle:"eslint 结合自动化工具",charIndex:744},{level:3,title:"eslint 检查 TypeScript",slug:"eslint-检查-typescript",normalizedTitle:"eslint 检查 typescript",charIndex:1939},{level:2,title:"Stylelint",slug:"stylelint",normalizedTitle:"stylelint",charIndex:2257},{level:2,title:"Prettier",slug:"prettier",normalizedTitle:"prettier",charIndex:2619},{level:2,title:"Git Hooks",slug:"git-hooks",normalizedTitle:"git hooks",charIndex:2705}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"ESLint 安装与配置 配置注释 ESLint 结合自动化工具 eslint 检查 TypeScript Stylelint Prettier Git Hooks",content:"# ESLint 安装与配置\n\n安装：npm init --yes，npm intall eslint --save-dev\n\n配置：eslint --init，此时会有一些问题，按需回答即可，一般选用 Standard 规范，安装一些依赖之后\n\n使用eslint foo.js检查目标文件即可\n\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true, // 运行环境 browser/node/commonjs等，可以同时使用\n    es6: false\n  },\n  extends: [ // 继承公共配置\n    'standard'\n  ],\n  parserOptions: { // 语法解析器，只是检测语法，env中的 es6 设置了 false，还是不可用\n    ecmaVersion: 2015\n  },\n  rules: { // 校验规则\n    'no-alert': \"error\" // 有 off/warn/error 选项\n  },\n  globals: { // 声明可以使用的全局成员\n    \"jQuery\": \"readonly\"\n  }\n}\n\n\n\n# 配置注释\n\n> standard 标准不支持 模板字符串语法，但是在项目中某一行我还是想用一下怎么办，可以通过配置注释\n> \n> 禁用规则：no-template-curly-in-string\n\nconst str1 = '${name} is a coder' // eslint-disable-line no-template-curly-in-string\n\nconsole.log(str1)\n\n\n\n# ESLint 结合自动化工具\n\n# ESLint 结合 gulp\n\n在已经配置好 gulp 的项目中安装gulp-eslint：yarn add gulp-eslint --save-dev\n\n初始化.eslintrc.js配置文件\n\n// gulpfile.js\nconst script = () => {\n  return src('src/assets/scripts/*.js', { base: 'src' })\n    .pipe(plugins.eslint()) // 如果只加入这一行只会检查错误，而不会抛出错误\n    .pipe(plugins.eslint.format())\n    .pipe(plugins.eslint.failAfterError())\n    .pipe(plugins.babel({ presets: ['@babel/preset-env'] }))\n    .pipe(dest('temp'))\n    .pipe(bs.reload({ stream: true }))\n}\n\n\n# ESLint 结合 webpack\n\n安装eslint-loader，初始化.eslintrc.js配置文件\n\n// webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/main.js',\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, \n        exclude: /node_modules/, \n        use: 'babel-loader'\n      },\n      {\n        test: /\\.js$/, \n        exclude: /node_modules/, \n        use: 'eslint-loader',\n        enfore: 'pre' // 优先级最高\n      },\n      {\n        test: /\\.css$/, \n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: 'src/index.html'\n    })\n  ]\n}\n\n\n> vue-cli 在安装过程中有选项会自动集成 eslint 配置\n\n\n# eslint 检查 TypeScript\n\n * eslint 初始化时选择 TypeScript\n\n// .eslintrc.js\n\nmodule.exports = {\n  env: {\n    browser: true,\n    es2020: true\n  },\n  extends: [\n    'standard'\n  ],\n  parser: '@typescript-eslint/parser',\n  parserOptions: {\n    ecmaVersion: 11\n  },\n  plugins: [\n    '@typescript-eslint'\n  ],\n  rules: {\n  }\n}\n\n\n\n# Stylelint\n\n * 提供默认的代码检查规则\n * 提供CLI工具，快速调用\n * 通过插件支持Sass，Less，PostCSS\n * 支持 Gulp 或 Webpack 集成\n\n安装 stylelint ：yarn add stylelint -D\n\n安装配置模块：stylelint-config-standard\n\nsass配置模块：stylelint-config-sass-guidelines\n\n// .stylelintrc.js\nmodules.exports = {\n    extends: [\"stylelint-config-standard\", \"stylelint-config-sass-guidelines\"]\n}\n\n\n执行检查：stylelint ./index.sass\n\n\n# Prettier\n\n安装：yarn add prettier -D\n\n运行：prettier style.css --write可以自动将格式化后的文件覆盖源文件\n\n\n# Git Hooks\n\n * Git Hooks也称之为 git 钩子，每个钩子都对应一个任务（commit/push）\n * 通过 shell 脚本可以编写钩子任务触发时要具体执行的操作\n\n.git/hooks/pre-commit.sample为commit之前的钩子函数，可以新建一个pre-commit文件写一些操作\n\nHusky可以实现Git Hooks的使用需求\n\n安装：yarn add Husky -D\n\n// 在package.json中配置\n\n{\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"eslint ./index.js\"\n        }\n    }   \n}\n\n\n此外还有lint-staged模块等",normalizedContent:"# eslint 安装与配置\n\n安装：npm init --yes，npm intall eslint --save-dev\n\n配置：eslint --init，此时会有一些问题，按需回答即可，一般选用 standard 规范，安装一些依赖之后\n\n使用eslint foo.js检查目标文件即可\n\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true, // 运行环境 browser/node/commonjs等，可以同时使用\n    es6: false\n  },\n  extends: [ // 继承公共配置\n    'standard'\n  ],\n  parseroptions: { // 语法解析器，只是检测语法，env中的 es6 设置了 false，还是不可用\n    ecmaversion: 2015\n  },\n  rules: { // 校验规则\n    'no-alert': \"error\" // 有 off/warn/error 选项\n  },\n  globals: { // 声明可以使用的全局成员\n    \"jquery\": \"readonly\"\n  }\n}\n\n\n\n# 配置注释\n\n> standard 标准不支持 模板字符串语法，但是在项目中某一行我还是想用一下怎么办，可以通过配置注释\n> \n> 禁用规则：no-template-curly-in-string\n\nconst str1 = '${name} is a coder' // eslint-disable-line no-template-curly-in-string\n\nconsole.log(str1)\n\n\n\n# eslint 结合自动化工具\n\n# eslint 结合 gulp\n\n在已经配置好 gulp 的项目中安装gulp-eslint：yarn add gulp-eslint --save-dev\n\n初始化.eslintrc.js配置文件\n\n// gulpfile.js\nconst script = () => {\n  return src('src/assets/scripts/*.js', { base: 'src' })\n    .pipe(plugins.eslint()) // 如果只加入这一行只会检查错误，而不会抛出错误\n    .pipe(plugins.eslint.format())\n    .pipe(plugins.eslint.failaftererror())\n    .pipe(plugins.babel({ presets: ['@babel/preset-env'] }))\n    .pipe(dest('temp'))\n    .pipe(bs.reload({ stream: true }))\n}\n\n\n# eslint 结合 webpack\n\n安装eslint-loader，初始化.eslintrc.js配置文件\n\n// webpack.config.js\nconst htmlwebpackplugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/main.js',\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, \n        exclude: /node_modules/, \n        use: 'babel-loader'\n      },\n      {\n        test: /\\.js$/, \n        exclude: /node_modules/, \n        use: 'eslint-loader',\n        enfore: 'pre' // 优先级最高\n      },\n      {\n        test: /\\.css$/, \n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new htmlwebpackplugin({\n      template: 'src/index.html'\n    })\n  ]\n}\n\n\n> vue-cli 在安装过程中有选项会自动集成 eslint 配置\n\n\n# eslint 检查 typescript\n\n * eslint 初始化时选择 typescript\n\n// .eslintrc.js\n\nmodule.exports = {\n  env: {\n    browser: true,\n    es2020: true\n  },\n  extends: [\n    'standard'\n  ],\n  parser: '@typescript-eslint/parser',\n  parseroptions: {\n    ecmaversion: 11\n  },\n  plugins: [\n    '@typescript-eslint'\n  ],\n  rules: {\n  }\n}\n\n\n\n# stylelint\n\n * 提供默认的代码检查规则\n * 提供cli工具，快速调用\n * 通过插件支持sass，less，postcss\n * 支持 gulp 或 webpack 集成\n\n安装 stylelint ：yarn add stylelint -d\n\n安装配置模块：stylelint-config-standard\n\nsass配置模块：stylelint-config-sass-guidelines\n\n// .stylelintrc.js\nmodules.exports = {\n    extends: [\"stylelint-config-standard\", \"stylelint-config-sass-guidelines\"]\n}\n\n\n执行检查：stylelint ./index.sass\n\n\n# prettier\n\n安装：yarn add prettier -d\n\n运行：prettier style.css --write可以自动将格式化后的文件覆盖源文件\n\n\n# git hooks\n\n * git hooks也称之为 git 钩子，每个钩子都对应一个任务（commit/push）\n * 通过 shell 脚本可以编写钩子任务触发时要具体执行的操作\n\n.git/hooks/pre-commit.sample为commit之前的钩子函数，可以新建一个pre-commit文件写一些操作\n\nhusky可以实现git hooks的使用需求\n\n安装：yarn add husky -d\n\n// 在package.json中配置\n\n{\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"eslint ./index.js\"\n        }\n    }   \n}\n\n\n此外还有lint-staged模块等",charsets:{cjk:!0}},{title:"gulp构建工具",frontmatter:{title:"gulp构建工具",date:"2020-09-01T09:47:00.000Z",categories:"前端工程化"},regularPath:"/engineering/gulp.html",relativePath:"engineering/gulp.md",key:"v-a28862e2",path:"/engineering/gulp.html",headers:[{level:2,title:"什么是gulp",slug:"什么是gulp",normalizedTitle:"什么是gulp",charIndex:2},{level:2,title:"gulp初体验",slug:"gulp初体验",normalizedTitle:"gulp初体验",charIndex:153},{level:3,title:"组合任务（串行，并行）",slug:"组合任务-串行-并行",normalizedTitle:"组合任务（串行，并行）",charIndex:601},{level:3,title:"gulp处理异步任务",slug:"gulp处理异步任务",normalizedTitle:"gulp处理异步任务",charIndex:1076},{level:2,title:"压缩过程实现",slug:"压缩过程实现",normalizedTitle:"压缩过程实现",charIndex:1839},{level:3,title:"利用gulp的API来简化",slug:"利用gulp的api来简化",normalizedTitle:"利用gulp的api来简化",charIndex:2433},{level:2,title:"构建实例",slug:"构建实例",normalizedTitle:"构建实例",charIndex:2716},{level:3,title:"插件越来越多怎么办",slug:"插件越来越多怎么办",normalizedTitle:"插件越来越多怎么办",charIndex:4419},{level:2,title:"怎么实现热更新",slug:"怎么实现热更新",normalizedTitle:"怎么实现热更新",charIndex:4739},{level:3,title:"怎么实现修改src下面的文件，自动执行编译过程，再更新到页面",slug:"怎么实现修改src下面的文件-自动执行编译过程-再更新到页面",normalizedTitle:"怎么实现修改src下面的文件，自动执行编译过程，再更新到页面",charIndex:5192},{level:3,title:"压缩文件",slug:"压缩文件",normalizedTitle:"压缩文件",charIndex:6480},{level:3,title:"构建完成的处理",slug:"构建完成的处理",normalizedTitle:"构建完成的处理",charIndex:6937},{level:3,title:"封装工作流",slug:"封装工作流",normalizedTitle:"封装工作流",charIndex:7098}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"什么是gulp gulp初体验 组合任务（串行，并行） gulp处理异步任务 压缩过程实现 利用gulp的API来简化 构建实例 插件越来越多怎么办 怎么实现热更新 怎么实现修改src下面的文件，自动执行编译过程，再更新到页面 压缩文件 构建完成的处理 封装工作流",content:"# 什么是gulp\n\ngulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快。\n\ngulp：The streaming build system\n\n\n# gulp初体验\n\n初始一个项目文件夹叫gulp，使用npm init初始化package.json文件，然后使用cnpm install -g gulp安装\n\n依赖，code gulpfile.js新建一个gulpfile.js文件，作为入口文件，示例如下：\n\nexports.foo = done => {\n  console.log('foo task working~')\n  done() // 标识任务完成\n}\n\nexports.default = done => {\n  console.log('default task working~')\n  done() // 标识任务完成\n}\n\nconst gulp = require('gulp')\n\ngulp.task('bar', done => {\n  console.log('bar working')\n  done()\n})\n\n// 分别运行如下：\n// gulp foo\n// gulp\n// gulp bar\n\n\n\n# 组合任务（串行，并行）\n\nconst { series, parallel } = require('gulp')\n\nconst task1 = done => {\n  setTimeout(() => {\n    console.log('task1')\n    done()\n  }, 1000)\n}\n\nconst task2 = done => {\n  setTimeout(() => {\n    console.log('task2')\n    done()\n  }, 1000)\n}\n\nconst task3 = done => {\n  setTimeout(() => {\n    console.log('task3')\n    done()\n  }, 1000)\n}\n\nexports.foo = series(task1, task2, task3)   // 串行\nexports.bar = parallel(task1, task2, task3) // 并行\n\n// 执行 gulp foo, gulp bar\n\n\n\n# gulp处理异步任务\n\nexports.callback = done => {\n  console.log('callback')\n  done()\n}\n\nexports.callback_error = done => {\n  console.log('callback error')\n  done(new Error('task failed'))\n}\n\nexports.promise = () => {\n  console.log('promise task')\n  return Promise.resolve()\n}\n\nexports.promise_error = () => {\n  console.log('promise task')\n  return Promise.reject('task failed')\n}\n\nconst timeout = time => {\n  return new Promise(resolve => {\n    setTimeout(resolve, time)\n  })\n}\n\nexports.async = async () => {\n  await timeout(1000)\n  console.log('async task')\n}\n\n// 处理文件 stream\nexports.stream = () => {\n  const readStream = fs.createReadStream('package.json')\n  const writeStream = fs.createWriteStream('temp.txt')\n  readStream.pipe(writeStream)\n  return readStream\n}\n\n\n\n# 压缩过程实现\n\nconst fs = require('fs')\nconst { Transform } = require('stream')\n\nexports.default = () => {\n  // 文件读取流\n  const read = fs.createReadStream('foo.css')\n  // 文件写入流\n  const write = fs.createWriteStream('foo.min.css')\n  // 文件转换流\n  const transform = new Transform({\n    transform: (chunk, encoding, callback) => {\n      // 核心转换过程实现\n      // chunk => 读取流中读取到的内容\n      const input = chunk.toString()\n      const output = input.replace(/\\s+/g, '').replace(/\\/\\*.+?\\*\\//g, '')\n      callback(null, output)\n    }\n  })\n\n  read\n    .pipe(transform) // 转换\n    .pipe(write) // 写入\n\n  return read\n}\n\n\n\n# 利用gulp的API来简化\n\nconst { src, dest } = require('gulp')\nconst cleanCss = require('gulp-clean-css')\nconst rename = require('gulp-rename')\n\nexports.default = () => {\n  return src('src/*.css')\n    .pipe(cleanCss())\n    .pipe(rename({ extname: '.min.css' }))\n    .pipe(dest('dist'))\n}\n\n\n\n# 构建实例\n\n现在有一个目录结构，如何实现构建\n\n> ── src ├── about.html ├── index.html ├── assets └── styles ├── demo.scss ├── main.scss ├── _icons.scss └── _variables.scss └── scripts ├── main.js └── images ├── logo.png ├── a.svg\n\n * 需要在src的同级目录下创建dist目录，且保留src的目录结构\n * scss编译成css\n * 利用 babel 将 es6 转成 es5\n * png，svg图片进行压缩要先\n * 每次构建要先删除原有的dist\n\n// gulpfile.js\nconst { src, dest, parallel, series } = require('gulp')\nconst sass = require('gulp-sass') // cnpm install -D gulp-sass\nconst babel = require('gulp-babel')\nconst swig = require('gulp-swig') // html模板引擎 cnpm install -D gulp-swig \nconst imagemin = require('gulp-imagemin')\n\nconst del = require('del') // 删除功能的插件 cnpm install -D del\n\nconst data = { // 模板数据\n    // ...\n}\n\nconst clean = () => {\n  return del(['dist'])\n}\n\nconst style = () => {\n    return src('src/assets/styles/*.scss', { base: 'src' }) // base 基准目录\n    \t.pipe(sass())\n    \t.pipe(dest('dist'))\n}\n\nconst script = () => {\n    return src('src/assets/scripts/*.js', { base: 'src' })\n    \t.pipe(babel({ presets: ['@babel/preset-env'] })) //babel只是平台，需要安装\n\t\t.pipe(dest('dist'))                             // @babel/core 和 @babel/preset-env\n}                \n\nconst page = () => {\n    return src('src/*.html, { base: 'src' }）\n         .pipe(swig({ data }))\n    \t .pipe(dest('dist'))\n}\n\nconst image = () => {\n     return src('src/assets/images/**', { base: 'src' })\n         .pipe(imagemin())\n    \t .pipe(dest('dist'))\n}\n\n// public目录的拷贝\nconst extra = () => {\n  return src('public/**', { base: 'public' })\n    .pipe(dest('dist'))\n}\n\nconst compile = parallel(style, script, page, image) // compile只执行src的处理\n\nconst build = series(clean, parallel(compile, extra)) // 先删除\n\nmodule.exports = {\n  compile,\n  build\n}\n\n\n\n# 插件越来越多怎么办\n\ncnpm install -D gulp-load-plugins 使用这个插件自动加载插件所有\n\n// gulpfile.js\nconst loadPlugins = require('gulp-load-plugins')\nconst plugins = loadPlugins()\n\nconst style = () => {\n  return src('src/assets/styles/*.scss', { base: 'src' }) \n    .pipe(plugins.sass()) // 所有插件使用plugin.sass()去使用\n    .pipe(dest('dist'))\n}\n\n\n\n# 怎么实现热更新\n\n * 会自动打开浏览器\n * 修改dist下的文件，页面会自动更新\n\n----------------------------------------\n\n安装browser-sync插件：cnpm install -D browser-sync\n\n// gulpfile.js中增加以下内容\n\nconst browserSync = require('browser-sync')\nconst bs = browserSync.create()\n\nconst serve = () => {\n  bs.init({\n    notify: false,\n    files: 'dist/**',    // 热更新文件\n    port: 2080,\n    server: {\n      baseDir: 'dist'    // 基准目录\n    }\n  })\n}\n\nmodule.exports = {\n  compile,\n  build,\n  serve  \n}\n\n\n\n# 怎么实现修改src下面的文件，自动执行编译过程，再更新到页面\n\n使用watch插件来监听，同时优化一下组合任务\n\nconst { src, dest, parallel, series, watch } = require('gulp')\n\nconst serve = () => {\n  watch('src/assets/styles/*.scss', style)\n  watch('src/assets/scripts/*.js', script)\n  watch('src/*.html', page)\n    \n  watch([\n    'src/assets/images/**',\n    'public/**'\n  ], bs.reload)\n\n  bs.init({\n    notify: false,\n    files: 'dist/**',\n    server: {\n      baseDir: ['dist', 'src', 'public'] // 起服务时按顺序找文件，dist找不到就找src,图片就在src中\n      routes: {\n        '/node_modules': 'node_modules' // html文件中\n      }\n    }\n  })\n}\n\n// 编译源文件到dist目录\nconst compile = parallel(style, script, page)\n\n// 上线之前执行的任务：包括对图片的压缩等只需执行一次的任务\nconst build = series(clean, parallel(compile, image, extra))\n\n// 开发过程中的任务，先编译再起服务器\nconst develop = series(compile, serve)\n\nmodule.exports = {\n  compile,\n  build,\n  serve,\n  develop\n}\n\n\n现在html文件中存在引用外部文件的方式\n\n  \x3c!-- build:css assets/styles/main.css --\x3e\n  <link rel=\"stylesheet\" href=\"assets/styles/main.css\">\n  \x3c!-- endbuild --\x3e\n\n  \x3c!-- 处理成下面这种 --\x3e\n  <link rel=\"stylesheet\" href=\"assets/styles/vendor.css\">\n\n\n需要安装useref插件：cnpm install -D gulp-useref，在gulpfile.js中创建一个新任务\n\nconst useref = () => {\n  return src('dist/*.html', { base: 'dist' })\n    .pipe(plugins.useref({ searchPath: ['dist', '.'] }))\n    .pipe(dest('dist'))\n}\n\n\n\n# 压缩文件\n\n安装cnpm install -D gulp-htmlmin gulp-uglify gulp-clean-css\n\nconst min = () => {\n  return src('dist/**', { base: 'dist' })\n    .pipe(plugins.if(/\\.js$/, plugins.uglify()))\n    .pipe(plugins.if(/\\.css$/, plugins.cleanCss()))\n    .pipe(plugins.if(/\\.html$/, plugins.htmlmin({\n      collapseWhitespace: true,\n      minifyCSS: true,\n      minifyJS: true\n    })))\n    .pipe(dest('release')) // 如果写dist会有文件冲突\n}\n\n// 解决办法是把目前的dist改为temp，作为中间文件，最后再压缩到dist中\n\n\n\n# 构建完成的处理\n\n// 选择需要导出的任务\nmodule.exports = {\n  build,\n  develop\n}\n\n// 把他写在package.json中\n\"scripts\": {\n    \"build\": \"gulp build\",\n    \"develop\": \"gulp develop\"\n}\n\n\n\n# 封装工作流\n\n将构建过程封装，发布并使用模块，就不必在每个项目中单独去重复写gulpfile.js",normalizedContent:"# 什么是gulp\n\ngulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，api也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快。\n\ngulp：the streaming build system\n\n\n# gulp初体验\n\n初始一个项目文件夹叫gulp，使用npm init初始化package.json文件，然后使用cnpm install -g gulp安装\n\n依赖，code gulpfile.js新建一个gulpfile.js文件，作为入口文件，示例如下：\n\nexports.foo = done => {\n  console.log('foo task working~')\n  done() // 标识任务完成\n}\n\nexports.default = done => {\n  console.log('default task working~')\n  done() // 标识任务完成\n}\n\nconst gulp = require('gulp')\n\ngulp.task('bar', done => {\n  console.log('bar working')\n  done()\n})\n\n// 分别运行如下：\n// gulp foo\n// gulp\n// gulp bar\n\n\n\n# 组合任务（串行，并行）\n\nconst { series, parallel } = require('gulp')\n\nconst task1 = done => {\n  settimeout(() => {\n    console.log('task1')\n    done()\n  }, 1000)\n}\n\nconst task2 = done => {\n  settimeout(() => {\n    console.log('task2')\n    done()\n  }, 1000)\n}\n\nconst task3 = done => {\n  settimeout(() => {\n    console.log('task3')\n    done()\n  }, 1000)\n}\n\nexports.foo = series(task1, task2, task3)   // 串行\nexports.bar = parallel(task1, task2, task3) // 并行\n\n// 执行 gulp foo, gulp bar\n\n\n\n# gulp处理异步任务\n\nexports.callback = done => {\n  console.log('callback')\n  done()\n}\n\nexports.callback_error = done => {\n  console.log('callback error')\n  done(new error('task failed'))\n}\n\nexports.promise = () => {\n  console.log('promise task')\n  return promise.resolve()\n}\n\nexports.promise_error = () => {\n  console.log('promise task')\n  return promise.reject('task failed')\n}\n\nconst timeout = time => {\n  return new promise(resolve => {\n    settimeout(resolve, time)\n  })\n}\n\nexports.async = async () => {\n  await timeout(1000)\n  console.log('async task')\n}\n\n// 处理文件 stream\nexports.stream = () => {\n  const readstream = fs.createreadstream('package.json')\n  const writestream = fs.createwritestream('temp.txt')\n  readstream.pipe(writestream)\n  return readstream\n}\n\n\n\n# 压缩过程实现\n\nconst fs = require('fs')\nconst { transform } = require('stream')\n\nexports.default = () => {\n  // 文件读取流\n  const read = fs.createreadstream('foo.css')\n  // 文件写入流\n  const write = fs.createwritestream('foo.min.css')\n  // 文件转换流\n  const transform = new transform({\n    transform: (chunk, encoding, callback) => {\n      // 核心转换过程实现\n      // chunk => 读取流中读取到的内容\n      const input = chunk.tostring()\n      const output = input.replace(/\\s+/g, '').replace(/\\/\\*.+?\\*\\//g, '')\n      callback(null, output)\n    }\n  })\n\n  read\n    .pipe(transform) // 转换\n    .pipe(write) // 写入\n\n  return read\n}\n\n\n\n# 利用gulp的api来简化\n\nconst { src, dest } = require('gulp')\nconst cleancss = require('gulp-clean-css')\nconst rename = require('gulp-rename')\n\nexports.default = () => {\n  return src('src/*.css')\n    .pipe(cleancss())\n    .pipe(rename({ extname: '.min.css' }))\n    .pipe(dest('dist'))\n}\n\n\n\n# 构建实例\n\n现在有一个目录结构，如何实现构建\n\n> ── src ├── about.html ├── index.html ├── assets └── styles ├── demo.scss ├── main.scss ├── _icons.scss └── _variables.scss └── scripts ├── main.js └── images ├── logo.png ├── a.svg\n\n * 需要在src的同级目录下创建dist目录，且保留src的目录结构\n * scss编译成css\n * 利用 babel 将 es6 转成 es5\n * png，svg图片进行压缩要先\n * 每次构建要先删除原有的dist\n\n// gulpfile.js\nconst { src, dest, parallel, series } = require('gulp')\nconst sass = require('gulp-sass') // cnpm install -d gulp-sass\nconst babel = require('gulp-babel')\nconst swig = require('gulp-swig') // html模板引擎 cnpm install -d gulp-swig \nconst imagemin = require('gulp-imagemin')\n\nconst del = require('del') // 删除功能的插件 cnpm install -d del\n\nconst data = { // 模板数据\n    // ...\n}\n\nconst clean = () => {\n  return del(['dist'])\n}\n\nconst style = () => {\n    return src('src/assets/styles/*.scss', { base: 'src' }) // base 基准目录\n    \t.pipe(sass())\n    \t.pipe(dest('dist'))\n}\n\nconst script = () => {\n    return src('src/assets/scripts/*.js', { base: 'src' })\n    \t.pipe(babel({ presets: ['@babel/preset-env'] })) //babel只是平台，需要安装\n\t\t.pipe(dest('dist'))                             // @babel/core 和 @babel/preset-env\n}                \n\nconst page = () => {\n    return src('src/*.html, { base: 'src' }）\n         .pipe(swig({ data }))\n    \t .pipe(dest('dist'))\n}\n\nconst image = () => {\n     return src('src/assets/images/**', { base: 'src' })\n         .pipe(imagemin())\n    \t .pipe(dest('dist'))\n}\n\n// public目录的拷贝\nconst extra = () => {\n  return src('public/**', { base: 'public' })\n    .pipe(dest('dist'))\n}\n\nconst compile = parallel(style, script, page, image) // compile只执行src的处理\n\nconst build = series(clean, parallel(compile, extra)) // 先删除\n\nmodule.exports = {\n  compile,\n  build\n}\n\n\n\n# 插件越来越多怎么办\n\ncnpm install -d gulp-load-plugins 使用这个插件自动加载插件所有\n\n// gulpfile.js\nconst loadplugins = require('gulp-load-plugins')\nconst plugins = loadplugins()\n\nconst style = () => {\n  return src('src/assets/styles/*.scss', { base: 'src' }) \n    .pipe(plugins.sass()) // 所有插件使用plugin.sass()去使用\n    .pipe(dest('dist'))\n}\n\n\n\n# 怎么实现热更新\n\n * 会自动打开浏览器\n * 修改dist下的文件，页面会自动更新\n\n----------------------------------------\n\n安装browser-sync插件：cnpm install -d browser-sync\n\n// gulpfile.js中增加以下内容\n\nconst browsersync = require('browser-sync')\nconst bs = browsersync.create()\n\nconst serve = () => {\n  bs.init({\n    notify: false,\n    files: 'dist/**',    // 热更新文件\n    port: 2080,\n    server: {\n      basedir: 'dist'    // 基准目录\n    }\n  })\n}\n\nmodule.exports = {\n  compile,\n  build,\n  serve  \n}\n\n\n\n# 怎么实现修改src下面的文件，自动执行编译过程，再更新到页面\n\n使用watch插件来监听，同时优化一下组合任务\n\nconst { src, dest, parallel, series, watch } = require('gulp')\n\nconst serve = () => {\n  watch('src/assets/styles/*.scss', style)\n  watch('src/assets/scripts/*.js', script)\n  watch('src/*.html', page)\n    \n  watch([\n    'src/assets/images/**',\n    'public/**'\n  ], bs.reload)\n\n  bs.init({\n    notify: false,\n    files: 'dist/**',\n    server: {\n      basedir: ['dist', 'src', 'public'] // 起服务时按顺序找文件，dist找不到就找src,图片就在src中\n      routes: {\n        '/node_modules': 'node_modules' // html文件中\n      }\n    }\n  })\n}\n\n// 编译源文件到dist目录\nconst compile = parallel(style, script, page)\n\n// 上线之前执行的任务：包括对图片的压缩等只需执行一次的任务\nconst build = series(clean, parallel(compile, image, extra))\n\n// 开发过程中的任务，先编译再起服务器\nconst develop = series(compile, serve)\n\nmodule.exports = {\n  compile,\n  build,\n  serve,\n  develop\n}\n\n\n现在html文件中存在引用外部文件的方式\n\n  \x3c!-- build:css assets/styles/main.css --\x3e\n  <link rel=\"stylesheet\" href=\"assets/styles/main.css\">\n  \x3c!-- endbuild --\x3e\n\n  \x3c!-- 处理成下面这种 --\x3e\n  <link rel=\"stylesheet\" href=\"assets/styles/vendor.css\">\n\n\n需要安装useref插件：cnpm install -d gulp-useref，在gulpfile.js中创建一个新任务\n\nconst useref = () => {\n  return src('dist/*.html', { base: 'dist' })\n    .pipe(plugins.useref({ searchpath: ['dist', '.'] }))\n    .pipe(dest('dist'))\n}\n\n\n\n# 压缩文件\n\n安装cnpm install -d gulp-htmlmin gulp-uglify gulp-clean-css\n\nconst min = () => {\n  return src('dist/**', { base: 'dist' })\n    .pipe(plugins.if(/\\.js$/, plugins.uglify()))\n    .pipe(plugins.if(/\\.css$/, plugins.cleancss()))\n    .pipe(plugins.if(/\\.html$/, plugins.htmlmin({\n      collapsewhitespace: true,\n      minifycss: true,\n      minifyjs: true\n    })))\n    .pipe(dest('release')) // 如果写dist会有文件冲突\n}\n\n// 解决办法是把目前的dist改为temp，作为中间文件，最后再压缩到dist中\n\n\n\n# 构建完成的处理\n\n// 选择需要导出的任务\nmodule.exports = {\n  build,\n  develop\n}\n\n// 把他写在package.json中\n\"scripts\": {\n    \"build\": \"gulp build\",\n    \"develop\": \"gulp develop\"\n}\n\n\n\n# 封装工作流\n\n将构建过程封装，发布并使用模块，就不必在每个项目中单独去重复写gulpfile.js",charsets:{cjk:!0}},{title:"自动化构建与grunt",frontmatter:{title:"自动化构建与grunt",date:"2020-08-31T20:53:00.000Z",categories:"前端工程化"},regularPath:"/engineering/grunt.html",relativePath:"engineering/grunt.md",key:"v-1c0f0a82",path:"/engineering/grunt.html",headers:[{level:2,title:"什么是自动化构建",slug:"什么是自动化构建",normalizedTitle:"什么是自动化构建",charIndex:2},{level:2,title:"grunt",slug:"grunt",normalizedTitle:"grunt",charIndex:372}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"什么是自动化构建 grunt",content:"# 什么是自动化构建\n\n比如在项目中需要通过sass main.css来编译css文件，不必要每次都使用命令行命令来编译。\n\n可以用npm scripts来实现自动化构建，在package.json中书写\n\n// 类似与这种就是自动化构建 \n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"build\": \"node build/build.js\",\n    \"lint\": \"eslint --fix --ext .js,.vue src\",\n    \"precommit\": \"npm run lint\"\n}\n\n\n\n# grunt\n\ngrunt是一款构建工具，在项目中使用npm init初始化一个package.json文件，然后使用npm install grunt\n\n安装，安装成功之后创建gruntfile.js作为入口文件，编写如下：\n\n// Grunt的入口文件\n// 需要导出一个函数，此函数接收一个 grunt 的形参\n\nmodule.exports = grunt => {\n  grunt.registerTask('foo', ()=>{\n    console.log('hello grunt')\n  }) // grunt foo\n\n  grunt.registerTask('bar', ()=>{\n    console.log('hello grunt bar')\n  }) // grunt bar\n\n  grunt.registerTask('default', ()=>{\n    console.log('default task')\n  }) // grunt\n\n  grunt.registerTask('default', ['foo', 'bar']) // grunt\n\n  // 模拟异步任务\n  grunt.registerTask('async', function () {\n    const done = this.async()\n    setTimeout(() => {\n      console.log('async task')\n      done()\n    })\n  }, 1000) // grunt async\n  \n  // 标记任务失败\n  grunt.registerTask('bad', ()=>{\n    console.log('hello grunt bar')\n    return false\n  }) // grunt bad 会执行失败\n}\n\n\ninitConfig方法\n\nmodule.exports = grunt => {\n    grunt.initConfig({\n        foo: {\n            bar: 123\n        }\n    })  \n  \n  grunt.registerTask('foo', ()=>{\n    console.log(grunt.config('foo.bar'))\n  }) // grunt foo 输出 123\n}\n\n\n多目标任务\n\nmodule.exports = grunt => {\n\n  grunt.initConfig({\n    build: {\n      options: { // 配置选项\n        foo: 'bar'\n      },\n      css: {\n        options: {\n          foo: 'baz'\n        }\n      },\n      js: '2'\n    }\n  })\n\n  // 多目标模式，可以让任务根据配置形成多个子任务\n  grunt.registerMultiTask('build', function () {\n    console.log(this.options())\n    console.log(`target: ${this.target}, data: ${this.data}`)\n  })\n}\n\n// grunt build\n// 输出\n\nRunning \"build:css\" (build) task\n{ foo: 'baz' }\ntarget: css, data: [object Object]\n\nRunning \"build:js\" (build) task\n{ foo: 'bar' }\ntarget: js, data: 2\n\nDone.\n\n\n插件使用：clean插件删除文件\n\nmodule.exports = grunt => {\n    grunt.initConfig({\n        clean: {\n            temp: 'temp/**'\n        }\n    })\n    \n    grunt.loadNpmTasks('grunt-contrib-clean')\n}\n\n// grunt clean 可删除temp下对应文件\n\n\n * grunt-sass\n * grunt-babel\n\nconst sass = require('sass')\nconst loadGruntTasks = require('load-grunt-tasks')\n\nmodule.exports = grunt => {\n  grunt.initConfig({\n    sass: {\n      options: {\n        sourceMap: true, // 生成map文件\n        implementation: sass\n      },\n      main: {\n        files: {\n          'dist/css/main.css': 'src/scss/main.scss' // 目录\n        }\n      }\n    },\n    babel: {\n      options: {\n        sourceMap: true,\n        presets: ['@babel/preset-env']\n      },\n      main: {\n        files: {\n          'dist/js/app.js': 'src/js/app.js'\n        }\n      }\n    },\n    watch: { // 监听\n      js: {\n        files: ['src/js/*.js'],\n        tasks: ['babel']\n      },\n      css: {\n        files: ['src/scss/*.scss'],\n        tasks: ['sass']\n      }\n    }\n  })\n\n  // grunt.loadNpmTasks('grunt-sass')\n  loadGruntTasks(grunt) // 自动加载所有的 grunt 插件中的任务\n\n  grunt.registerTask('default', ['sass', 'babel', 'watch']) // 首先执行 sass, babel 任务，再监听\n}\n",normalizedContent:"# 什么是自动化构建\n\n比如在项目中需要通过sass main.css来编译css文件，不必要每次都使用命令行命令来编译。\n\n可以用npm scripts来实现自动化构建，在package.json中书写\n\n// 类似与这种就是自动化构建 \n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"build\": \"node build/build.js\",\n    \"lint\": \"eslint --fix --ext .js,.vue src\",\n    \"precommit\": \"npm run lint\"\n}\n\n\n\n# grunt\n\ngrunt是一款构建工具，在项目中使用npm init初始化一个package.json文件，然后使用npm install grunt\n\n安装，安装成功之后创建gruntfile.js作为入口文件，编写如下：\n\n// grunt的入口文件\n// 需要导出一个函数，此函数接收一个 grunt 的形参\n\nmodule.exports = grunt => {\n  grunt.registertask('foo', ()=>{\n    console.log('hello grunt')\n  }) // grunt foo\n\n  grunt.registertask('bar', ()=>{\n    console.log('hello grunt bar')\n  }) // grunt bar\n\n  grunt.registertask('default', ()=>{\n    console.log('default task')\n  }) // grunt\n\n  grunt.registertask('default', ['foo', 'bar']) // grunt\n\n  // 模拟异步任务\n  grunt.registertask('async', function () {\n    const done = this.async()\n    settimeout(() => {\n      console.log('async task')\n      done()\n    })\n  }, 1000) // grunt async\n  \n  // 标记任务失败\n  grunt.registertask('bad', ()=>{\n    console.log('hello grunt bar')\n    return false\n  }) // grunt bad 会执行失败\n}\n\n\ninitconfig方法\n\nmodule.exports = grunt => {\n    grunt.initconfig({\n        foo: {\n            bar: 123\n        }\n    })  \n  \n  grunt.registertask('foo', ()=>{\n    console.log(grunt.config('foo.bar'))\n  }) // grunt foo 输出 123\n}\n\n\n多目标任务\n\nmodule.exports = grunt => {\n\n  grunt.initconfig({\n    build: {\n      options: { // 配置选项\n        foo: 'bar'\n      },\n      css: {\n        options: {\n          foo: 'baz'\n        }\n      },\n      js: '2'\n    }\n  })\n\n  // 多目标模式，可以让任务根据配置形成多个子任务\n  grunt.registermultitask('build', function () {\n    console.log(this.options())\n    console.log(`target: ${this.target}, data: ${this.data}`)\n  })\n}\n\n// grunt build\n// 输出\n\nrunning \"build:css\" (build) task\n{ foo: 'baz' }\ntarget: css, data: [object object]\n\nrunning \"build:js\" (build) task\n{ foo: 'bar' }\ntarget: js, data: 2\n\ndone.\n\n\n插件使用：clean插件删除文件\n\nmodule.exports = grunt => {\n    grunt.initconfig({\n        clean: {\n            temp: 'temp/**'\n        }\n    })\n    \n    grunt.loadnpmtasks('grunt-contrib-clean')\n}\n\n// grunt clean 可删除temp下对应文件\n\n\n * grunt-sass\n * grunt-babel\n\nconst sass = require('sass')\nconst loadgrunttasks = require('load-grunt-tasks')\n\nmodule.exports = grunt => {\n  grunt.initconfig({\n    sass: {\n      options: {\n        sourcemap: true, // 生成map文件\n        implementation: sass\n      },\n      main: {\n        files: {\n          'dist/css/main.css': 'src/scss/main.scss' // 目录\n        }\n      }\n    },\n    babel: {\n      options: {\n        sourcemap: true,\n        presets: ['@babel/preset-env']\n      },\n      main: {\n        files: {\n          'dist/js/app.js': 'src/js/app.js'\n        }\n      }\n    },\n    watch: { // 监听\n      js: {\n        files: ['src/js/*.js'],\n        tasks: ['babel']\n      },\n      css: {\n        files: ['src/scss/*.scss'],\n        tasks: ['sass']\n      }\n    }\n  })\n\n  // grunt.loadnpmtasks('grunt-sass')\n  loadgrunttasks(grunt) // 自动加载所有的 grunt 插件中的任务\n\n  grunt.registertask('default', ['sass', 'babel', 'watch']) // 首先执行 sass, babel 任务，再监听\n}\n",charsets:{cjk:!0}},{title:"Rollup",frontmatter:{title:"Rollup",date:"2020-09-10T10:27:54.000Z",categories:"前端工程化"},regularPath:"/engineering/rollup.html",relativePath:"engineering/rollup.md",key:"v-5907ba7a",path:"/engineering/rollup.html",headers:[{level:2,title:"Rollup快速上手",slug:"rollup快速上手",normalizedTitle:"rollup快速上手",charIndex:2},{level:2,title:"rollup配置文件",slug:"rollup配置文件",normalizedTitle:"rollup配置文件",charIndex:987},{level:2,title:"Rollup使用插件",slug:"rollup使用插件",normalizedTitle:"rollup使用插件",charIndex:1183},{level:3,title:"Rollup 加载 node_modules 中的 NPM 模块",slug:"rollup-加载-node-modules-中的-npm-模块",normalizedTitle:"rollup 加载 node_modules 中的 npm 模块",charIndex:1436},{level:3,title:"Rollup 加载 CommonJS",slug:"rollup-加载-commonjs",normalizedTitle:"rollup 加载 commonjs",charIndex:1707},{level:2,title:"代码拆分",slug:"代码拆分",normalizedTitle:"代码拆分",charIndex:1925},{level:3,title:"多入口打包",slug:"多入口打包",normalizedTitle:"多入口打包",charIndex:2227},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:2630}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"Rollup快速上手 rollup配置文件 Rollup使用插件 Rollup 加载 node_modules 中的 NPM 模块 Rollup 加载 CommonJS 代码拆分 多入口打包 优缺点",content:"# Rollup快速上手\n\n举例：src 目录下有如下三个文件\n\n// messages.js\nexport default {\n  hi: 'Hey Guys, I am zce~'\n}\n\n// logger.js\nexport const log = msg => {\n  console.log('---------- INFO ----------')\n  console.log(msg)\n  console.log('--------------------------')\n}\n\nexport const error = msg => {\n  console.error('---------- ERROR ----------')\n  console.error(msg)\n  console.error('---------------------------')\n}\n\n// index.js\n// 导入模块成员\nimport { log } from './logger'\nimport messages from './messages'\n\n// 使用模块成员\nconst msg = messages.hi\n\nlog(msg)\n\n\n安装 Rollup：yarn add rollup --dev\n\n执行打包命令：yarn rollup ./src/index.js --format iife --file dist/bundle.js\n\nRollup会自动执行tree shaking，去除无效代码\n\n// bundle.js\n(function () {\n  'use strict';\n\n  const log = msg => {\n    console.log('---------- INFO ----------');\n    console.log(msg);\n    console.log('--------------------------');\n  };\n\n  var messages = {\n    hi: 'Hey Guys, I am zce~'\n  };\n\n  // 导入模块成员\n\n  // 使用模块成员\n  const msg = messages.hi;\n\n  log(msg);\n\n}());\n\n\n\n# rollup配置文件\n\n// rollup.config.js\nexport default {\n  input: 'src/index.js',   // 入口\n  output: {\n    file: 'dist/bundle.js',\n    format: 'iife'\n  }\n}\n\n\n运行命令：yarn rollup --config rollup.config.js\n\n\n# Rollup使用插件\n\n安装可以导入 json 的插件：yarn add rollup-plugin-json --dev\n\nimport json from 'rollup-plugin-json'\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    file: 'dist/bundle.js',\n    format: 'iife'\n  },\n  plugins: [\n    json()  // 调用的结果\n  ]\n}\n\n\n\n# Rollup 加载 node_modules 中的 NPM 模块\n\nyarn add rollup-plugin-node-resolve --dev，配置同上\n\n// index.js\n\n// 导入模块成员\nimport _ from 'lodash-es'\nimport { log } from './logger'\n\n// 使用模块成员\nlog(_.camelCase('hello world'))\n\n\n> Rollup 默认只能使用 ES Modules模块，所以要导入 lodash-es，不能导入原本的 lodash\n\n\n# Rollup 加载 CommonJS\n\n> 因为依旧很多第三方模块使用 ComminJS 规范，所以需要插件处理\n\nyarn add rollup-plugin-commonjs --dev\n\n// 自己写一个 CommonJS 规范的模块 cjs-module.js\nmodule.exports = {\n  foo: 'bar'\n}\n\n// index.js\nimport cjs from './cjs-module'\n\n\n\n# 代码拆分\n\n// 动态导入\nimport('./logger').then(({ log }) => { // import('./logger')返回promise，解构提取log方法\n  log('code splitting~')\n})\n\n\n> 使用代码拆分不能用 iife 格式，应该使用 AMD 或者 CommonJS 规范，而在浏览器端只能使用 AMD 规范\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    dir: 'dist', // 多个文件，使用 dir\n    format: 'amd'\n  }\n}\n\n\n\n# 多入口打包\n\nexport default {\n  input: {\n    foo: 'src/index.js',  // 两个入口\n    bar: 'src/album.js'\n  },\n  output: {\n    dir: 'dist',\n    format: 'amd'\n  }\n}\n\n// 最后在 dist 目录下生成3个文件，foo.js，bar.js，和公共部分的js\n\n\n  \x3c!-- AMD 标准格式的输出 bundle 不能直接引用 --\x3e\n  \x3c!-- <script src=\"foo.js\"><\/script> --\x3e\n  \x3c!-- 需要 Require.js 这样的库 --\x3e\n  <script src=\"https://unpkg.com/requirejs@2.3.6/require.js\" data-main=\"foo.js\"><\/script>\n\n\n\n# 优缺点\n\n * 输出结果更加扁平\n * 自动移除未引用代码\n * 打包结果依然完全可读\n\n----------------------------------------\n\n * 加载非 ESM 的第三方模块比较复杂\n * 模块最终都被打包到一个函数中，无法实现 HMR\n * 浏览器环境中，代码拆分功能依赖 AMD 库\n\n----------------------------------------\n\n开发应用程序使用 webpack，开发一个框架或者类库使用 Rollup",normalizedContent:"# rollup快速上手\n\n举例：src 目录下有如下三个文件\n\n// messages.js\nexport default {\n  hi: 'hey guys, i am zce~'\n}\n\n// logger.js\nexport const log = msg => {\n  console.log('---------- info ----------')\n  console.log(msg)\n  console.log('--------------------------')\n}\n\nexport const error = msg => {\n  console.error('---------- error ----------')\n  console.error(msg)\n  console.error('---------------------------')\n}\n\n// index.js\n// 导入模块成员\nimport { log } from './logger'\nimport messages from './messages'\n\n// 使用模块成员\nconst msg = messages.hi\n\nlog(msg)\n\n\n安装 rollup：yarn add rollup --dev\n\n执行打包命令：yarn rollup ./src/index.js --format iife --file dist/bundle.js\n\nrollup会自动执行tree shaking，去除无效代码\n\n// bundle.js\n(function () {\n  'use strict';\n\n  const log = msg => {\n    console.log('---------- info ----------');\n    console.log(msg);\n    console.log('--------------------------');\n  };\n\n  var messages = {\n    hi: 'hey guys, i am zce~'\n  };\n\n  // 导入模块成员\n\n  // 使用模块成员\n  const msg = messages.hi;\n\n  log(msg);\n\n}());\n\n\n\n# rollup配置文件\n\n// rollup.config.js\nexport default {\n  input: 'src/index.js',   // 入口\n  output: {\n    file: 'dist/bundle.js',\n    format: 'iife'\n  }\n}\n\n\n运行命令：yarn rollup --config rollup.config.js\n\n\n# rollup使用插件\n\n安装可以导入 json 的插件：yarn add rollup-plugin-json --dev\n\nimport json from 'rollup-plugin-json'\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    file: 'dist/bundle.js',\n    format: 'iife'\n  },\n  plugins: [\n    json()  // 调用的结果\n  ]\n}\n\n\n\n# rollup 加载 node_modules 中的 npm 模块\n\nyarn add rollup-plugin-node-resolve --dev，配置同上\n\n// index.js\n\n// 导入模块成员\nimport _ from 'lodash-es'\nimport { log } from './logger'\n\n// 使用模块成员\nlog(_.camelcase('hello world'))\n\n\n> rollup 默认只能使用 es modules模块，所以要导入 lodash-es，不能导入原本的 lodash\n\n\n# rollup 加载 commonjs\n\n> 因为依旧很多第三方模块使用 comminjs 规范，所以需要插件处理\n\nyarn add rollup-plugin-commonjs --dev\n\n// 自己写一个 commonjs 规范的模块 cjs-module.js\nmodule.exports = {\n  foo: 'bar'\n}\n\n// index.js\nimport cjs from './cjs-module'\n\n\n\n# 代码拆分\n\n// 动态导入\nimport('./logger').then(({ log }) => { // import('./logger')返回promise，解构提取log方法\n  log('code splitting~')\n})\n\n\n> 使用代码拆分不能用 iife 格式，应该使用 amd 或者 commonjs 规范，而在浏览器端只能使用 amd 规范\n\nexport default {\n  input: 'src/index.js',\n  output: {\n    dir: 'dist', // 多个文件，使用 dir\n    format: 'amd'\n  }\n}\n\n\n\n# 多入口打包\n\nexport default {\n  input: {\n    foo: 'src/index.js',  // 两个入口\n    bar: 'src/album.js'\n  },\n  output: {\n    dir: 'dist',\n    format: 'amd'\n  }\n}\n\n// 最后在 dist 目录下生成3个文件，foo.js，bar.js，和公共部分的js\n\n\n  \x3c!-- amd 标准格式的输出 bundle 不能直接引用 --\x3e\n  \x3c!-- <script src=\"foo.js\"><\/script> --\x3e\n  \x3c!-- 需要 require.js 这样的库 --\x3e\n  <script src=\"https://unpkg.com/requirejs@2.3.6/require.js\" data-main=\"foo.js\"><\/script>\n\n\n\n# 优缺点\n\n * 输出结果更加扁平\n * 自动移除未引用代码\n * 打包结果依然完全可读\n\n----------------------------------------\n\n * 加载非 esm 的第三方模块比较复杂\n * 模块最终都被打包到一个函数中，无法实现 hmr\n * 浏览器环境中，代码拆分功能依赖 amd 库\n\n----------------------------------------\n\n开发应用程序使用 webpack，开发一个框架或者类库使用 rollup",charsets:{cjk:!0}},{title:"单元测试",frontmatter:{},regularPath:"/engineering/test.html",relativePath:"engineering/test.md",key:"v-5446e962",path:"/engineering/test.html",headers:[{level:2,title:"Jest",slug:"jest",normalizedTitle:"jest",charIndex:34},{level:3,title:"配置方式",slug:"配置方式",normalizedTitle:"配置方式",charIndex:125},{level:3,title:"transform",slug:"transform",normalizedTitle:"transform",charIndex:494},{level:3,title:"testEnvironment",slug:"testenvironment",normalizedTitle:"testenvironment",charIndex:464},{level:3,title:"testEnvironmentOptions",slug:"testenvironmentoptions",normalizedTitle:"testenvironmentoptions",charIndex:1916},{level:2,title:"框架提供的单测工具",slug:"框架提供的单测工具",normalizedTitle:"框架提供的单测工具",charIndex:2198},{level:3,title:"Vue Test Utils",slug:"vue-test-utils",normalizedTitle:"vue test utils",charIndex:2212},{level:3,title:"San-test-utils",slug:"san-test-utils",normalizedTitle:"san-test-utils",charIndex:2331},{level:2,title:"单测覆盖率",slug:"单测覆盖率",normalizedTitle:"单测覆盖率",charIndex:2372}],lastUpdated:"8/3/2022, 8:01:09 PM",lastUpdatedTimestamp:1659528069e3,headersStr:"Jest 配置方式 transform testEnvironment testEnvironmentOptions 框架提供的单测工具 Vue Test Utils San-test-utils 单测覆盖率",content:"# 单元测试\n\n前端抢饭碗系列之Vue项目中如何做单元测试\n\n\n# Jest\n\nJest是Facebook出品的一个测试框架，相较于其他测试框架，最大的特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n官方文档\n\n\n# 配置方式\n\npackage.json 或者 jest.config.js\n\n// package.json\n{\n  \"name\": \"my-project\",\n  \"jest\": {\n    // ...\n  }\n}\n\n\n// jest.config.js\nmodule.exports = {\n  \trootDir: path.resolve(__dirname, '../../'),\n    moduleFileExtensions: ['js', 'json', 'vue'],\n    moduleNameMapper: {\n        '^@/(.*)$': '<rootDir>/src/$1', // 把 @ 设置为 /src 的别名\n    },\n    testEnvironment: 'jsdom',\n    transform: {\n        '^.+\\\\.js$': '<rootDir>/node_modules/babel-jest',\n        '.*\\\\.(vue)$': '<rootDir>/node_modules/vue-jest',\n    },\n    snapshotSerializers: ['<rootDir>/node_modules/jest-serializer-vue'],\n    setupFiles: ['<rootDir>/test/unit/setup'],\n    coverageDirectory: '<rootDir>/test/unit/coverage',\n    collectCoverageFrom: ['src/**/*.{js,vue}', '!src/main.js', '!src/router/index.js', '!**/node_modules/**'],\n};\n\n\n\n# transform\n\nJest 默认只会处理 javascript 语法，所以项目中如果有 ES6、vue 等语法，需要配置 transform（预处理器）来处理。\n\n{\n  // ...\n  \"jest\": {\n    // 告诉 Jest 处理 `*.vue` 文件\n    \"moduleFileExtensions\": [\"js\", \"json\", \"vue\"],\n    // 用 `vue-jest` 处理 `*.vue` 文件\n    \"transform\": {\n      \"\\\\.[jt]sx?$\": \"babel-jest\",\n      \".*\\\\.(vue)$\": \"vue-jest\"\n    }\n  }\n}\n\n\n使用babel\n\n由于我们配置的环境是 node，它的语法是CommonJS，因此 test 文件中使用ES6 语法 import 时会报错。\n\nbabel-jest 不支持 babel7 版本，可以安装如下：\n\nyarn add babel-jest babel-core@^7.0.0-bridge.0 @babel/core\n\n\n当运行jest 命令时，babel-jest 会检测当前环境是否安装了 babel-core，如果安装了，会去取 .babelrc 的配置并执行 babel 对代码进行转化。我们还需在根目录下创建 .babelrc 文件：\n\n{\n    \"presets\": [\"@babel/preset-env\"],\n    \"plugins\": [\n        \"@babel/plugin-syntax-dynamic-import\" // 支持 import 语法\n    ]\n}\n\n\n\n# testEnvironment\n\njest 默认为 node 环境，如果你构建的是一个 web app ，那么需要使用 jsdom。或者可以在测试文件顶部加上如下配置：\n\n/**\n * @jest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div');\n  expect(element).not.toBeNull();\n});\n\n\n\n# testEnvironmentOptions\n\nOptions 会作为参数传递给 testEnvironment。\n\n/**\n * @jest-environment jsdom\n * @jest-environment-options {\"url\": \"https://jestjs.io/\"}\n */\n\ntest('use jsdom and set the URL in this test file', () => {\n  expect(window.location.href).toBe('https://jestjs.io/');\n});\n\n\n\n# 框架提供的单测工具\n\n\n# Vue Test Utils\n\nVue Test Utils 是 Vue.js 官方的单元测试实用工具库。\n\n * Vue Test Utils 1 用于 Vue 2.\n * Vue Test Utils 2 用于 Vue 3.\n\n\n# San-test-utils\n\n * github地址\n\n * 官方文档\n\n\n# 单测覆盖率\n\n * 单元测试覆盖率\n * 代码覆盖率工具 Istanbul 入门教程",normalizedContent:"# 单元测试\n\n前端抢饭碗系列之vue项目中如何做单元测试\n\n\n# jest\n\njest是facebook出品的一个测试框架，相较于其他测试框架，最大的特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n官方文档\n\n\n# 配置方式\n\npackage.json 或者 jest.config.js\n\n// package.json\n{\n  \"name\": \"my-project\",\n  \"jest\": {\n    // ...\n  }\n}\n\n\n// jest.config.js\nmodule.exports = {\n  \trootdir: path.resolve(__dirname, '../../'),\n    modulefileextensions: ['js', 'json', 'vue'],\n    modulenamemapper: {\n        '^@/(.*)$': '<rootdir>/src/$1', // 把 @ 设置为 /src 的别名\n    },\n    testenvironment: 'jsdom',\n    transform: {\n        '^.+\\\\.js$': '<rootdir>/node_modules/babel-jest',\n        '.*\\\\.(vue)$': '<rootdir>/node_modules/vue-jest',\n    },\n    snapshotserializers: ['<rootdir>/node_modules/jest-serializer-vue'],\n    setupfiles: ['<rootdir>/test/unit/setup'],\n    coveragedirectory: '<rootdir>/test/unit/coverage',\n    collectcoveragefrom: ['src/**/*.{js,vue}', '!src/main.js', '!src/router/index.js', '!**/node_modules/**'],\n};\n\n\n\n# transform\n\njest 默认只会处理 javascript 语法，所以项目中如果有 es6、vue 等语法，需要配置 transform（预处理器）来处理。\n\n{\n  // ...\n  \"jest\": {\n    // 告诉 jest 处理 `*.vue` 文件\n    \"modulefileextensions\": [\"js\", \"json\", \"vue\"],\n    // 用 `vue-jest` 处理 `*.vue` 文件\n    \"transform\": {\n      \"\\\\.[jt]sx?$\": \"babel-jest\",\n      \".*\\\\.(vue)$\": \"vue-jest\"\n    }\n  }\n}\n\n\n使用babel\n\n由于我们配置的环境是 node，它的语法是commonjs，因此 test 文件中使用es6 语法 import 时会报错。\n\nbabel-jest 不支持 babel7 版本，可以安装如下：\n\nyarn add babel-jest babel-core@^7.0.0-bridge.0 @babel/core\n\n\n当运行jest 命令时，babel-jest 会检测当前环境是否安装了 babel-core，如果安装了，会去取 .babelrc 的配置并执行 babel 对代码进行转化。我们还需在根目录下创建 .babelrc 文件：\n\n{\n    \"presets\": [\"@babel/preset-env\"],\n    \"plugins\": [\n        \"@babel/plugin-syntax-dynamic-import\" // 支持 import 语法\n    ]\n}\n\n\n\n# testenvironment\n\njest 默认为 node 环境，如果你构建的是一个 web app ，那么需要使用 jsdom。或者可以在测试文件顶部加上如下配置：\n\n/**\n * @jest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createelement('div');\n  expect(element).not.tobenull();\n});\n\n\n\n# testenvironmentoptions\n\noptions 会作为参数传递给 testenvironment。\n\n/**\n * @jest-environment jsdom\n * @jest-environment-options {\"url\": \"https://jestjs.io/\"}\n */\n\ntest('use jsdom and set the url in this test file', () => {\n  expect(window.location.href).tobe('https://jestjs.io/');\n});\n\n\n\n# 框架提供的单测工具\n\n\n# vue test utils\n\nvue test utils 是 vue.js 官方的单元测试实用工具库。\n\n * vue test utils 1 用于 vue 2.\n * vue test utils 2 用于 vue 3.\n\n\n# san-test-utils\n\n * github地址\n\n * 官方文档\n\n\n# 单测覆盖率\n\n * 单元测试覆盖率\n * 代码覆盖率工具 istanbul 入门教程",charsets:{cjk:!0}},{title:"git操作",frontmatter:{title:"git操作",date:"2020-12-17T11:27:54.000Z",categories:"规范"},regularPath:"/git/git.html",relativePath:"git/git.md",key:"v-1a6af8df",path:"/git/git.html",headers:[{level:2,title:"git",slug:"git",normalizedTitle:"git",charIndex:2},{level:3,title:"commit 规范",slug:"commit-规范",normalizedTitle:"commit 规范",charIndex:19},{level:3,title:"sourceTree",slug:"sourcetree",normalizedTitle:"sourcetree",charIndex:32},{level:3,title:"合并多条 commit",slug:"合并多条-commit",normalizedTitle:"合并多条 commit",charIndex:46},{level:3,title:"git reset --soft [commitID]",slug:"git-reset-soft-commitid",normalizedTitle:"git reset --soft [commitid]",charIndex:1180},{level:3,title:"git stash",slug:"git-stash",normalizedTitle:"git stash",charIndex:61},{level:3,title:"git commit --amend",slug:"git-commit-amend",normalizedTitle:"git commit --amend",charIndex:74},{level:3,title:"拉取本地不存在的远程分支",slug:"拉取本地不存在的远程分支",normalizedTitle:"拉取本地不存在的远程分支",charIndex:1458},{level:2,title:"gitemoji",slug:"gitemoji",normalizedTitle:"gitemoji",charIndex:96},{level:2,title:"cherry-pick",slug:"cherry-pick",normalizedTitle:"cherry-pick",charIndex:108},{level:2,title:"一些问题",slug:"一些问题",normalizedTitle:"一些问题",charIndex:1694}],lastUpdated:"10/14/2022, 2:59:06 PM",lastUpdatedTimestamp:1665730746e3,headersStr:"git commit 规范 sourceTree 合并多条 commit git reset --soft [commitID] git stash git commit --amend 拉取本地不存在的远程分支 gitemoji cherry-pick 一些问题",content:"# git操作\n\n * git\n * commit 规范\n * sourceTree\n * 合并多条 commit\n * git stash\n * git commit --amend\n * gitemoji\n * cherry-pick\n\n\n# git\n\n * git常见命令：https://blog.csdn.net/web_csdn_share/article/details/79243308\n * git reset原理：https://www.cnblogs.com/wangwenjin2026/p/11549285.html\n * 什么是fork：https://www.liaoxuefeng.com/wiki/896043488029600/900937935629664\n\n\n# commit 规范\n\n> commitizen是一个nodejs命令行工具，通过交互的方式，生成符合规范的git commit，使用如下\n\ngit add .\ngit cz\n\n\n# 如何安装\n\n// 全局安装\nnpm install -g commitizen \n// 或本地安装\n$ npm install --save-dev commitizen\n// 安装适配器\nnpm install cz-conventional-changelog\n\n\n\n# sourceTree\n\n * 便于查看分支图表\n * Dark 主题\n\n\n# 合并多条 commit\n\n# git rebase\n\n演示地址\n\n参考这一次彻底搞懂 Git Rebase，完美生活：git rebase -i | Linux 中国，【Git】rebase 用法小结\n\ngit rebase -i head~3 // 合并最近三条commit\n\n\n弹出编辑界面\n\n> pick b931dac 修改test2为test pick efd10a0 feat: 群引流加好友时间 pick 860aea3 合并\n> \n> # commands\n> \n> pick：保留该commit（缩写:p）\n> \n> reword：保留该commit，但我需要修改该commit的注释（缩写:r）\n> \n> edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\n> \n> squash：将该commit和前一个commit合并（缩写:s）\n> \n> fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）\n> \n> exec：执行shell命令（缩写:x）\n> \n> drop：我要丢弃该commit（缩写:d）\n\n我一般选择rff命令，使用最上面的提交并修改，后两条合并，然后继续进入编辑界面修改提交记录，:wq 退出\n\n\n# git reset --soft [commitID]\n\n> 带 --soft 参数的区别在于把改动内容添加到暂存区 相当于执行了git add .\n\n\n# git stash\n\n场景：正在feature分支写代码时，线上出现bug，需要切回master修复\n\ngit stash\ngit checkout master\n// 修复中...\ngit checkout <feture_branch> //切换刚才功能开发的分支\ngit stash pop //取出修改\n\n\n\n# git commit --amend\n\n修改git提交记录用法详解\n\n\n# 拉取本地不存在的远程分支\n\ngit checkout -b 1.0 origin/1.0\ngit pull\n\n\n\n# gitemoji\n\nhttps://gitmoji.js.org/\n\n\n# cherry-pick\n\ngit cherry-pick 教程\n\n如有冲突则解决冲突后 git add . git cherry-pick --continue\n\nrebase、merge、cherry-pick 都有 --abort（相当于反悔，回到操作之前的状态）\n\n\n# 一些问题\n\n1、2021.8.14 github修改密码校验为 token 校验\n\n * https://blog.csdn.net/weixin_41010198/article/details/119698015\n\n * https://blog.csdn.net/m0_46332820/article/details/119708248\n\n2、怎么配置命令行代理\n\n// 配置代理：\ngit config --global http.proxy <代理地址>\n// 用完重置：\ngit config --global --unset http.proxy\n\n\n3、cd .. 和 cd - 有什么区别\n\n * cd..：返回到上一级目录\n * cd -：返回到上一次的工作目录\n\n4、git add .与git add -A的区别\n\n * git add .：将修改和新增的文件添加到暂存区\n * git add -A：将修改，新增和删除的文件添加到暂存区（方便恢复被删除的文件）",normalizedContent:"# git操作\n\n * git\n * commit 规范\n * sourcetree\n * 合并多条 commit\n * git stash\n * git commit --amend\n * gitemoji\n * cherry-pick\n\n\n# git\n\n * git常见命令：https://blog.csdn.net/web_csdn_share/article/details/79243308\n * git reset原理：https://www.cnblogs.com/wangwenjin2026/p/11549285.html\n * 什么是fork：https://www.liaoxuefeng.com/wiki/896043488029600/900937935629664\n\n\n# commit 规范\n\n> commitizen是一个nodejs命令行工具，通过交互的方式，生成符合规范的git commit，使用如下\n\ngit add .\ngit cz\n\n\n# 如何安装\n\n// 全局安装\nnpm install -g commitizen \n// 或本地安装\n$ npm install --save-dev commitizen\n// 安装适配器\nnpm install cz-conventional-changelog\n\n\n\n# sourcetree\n\n * 便于查看分支图表\n * dark 主题\n\n\n# 合并多条 commit\n\n# git rebase\n\n演示地址\n\n参考这一次彻底搞懂 git rebase，完美生活：git rebase -i | linux 中国，【git】rebase 用法小结\n\ngit rebase -i head~3 // 合并最近三条commit\n\n\n弹出编辑界面\n\n> pick b931dac 修改test2为test pick efd10a0 feat: 群引流加好友时间 pick 860aea3 合并\n> \n> # commands\n> \n> pick：保留该commit（缩写:p）\n> \n> reword：保留该commit，但我需要修改该commit的注释（缩写:r）\n> \n> edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\n> \n> squash：将该commit和前一个commit合并（缩写:s）\n> \n> fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）\n> \n> exec：执行shell命令（缩写:x）\n> \n> drop：我要丢弃该commit（缩写:d）\n\n我一般选择rff命令，使用最上面的提交并修改，后两条合并，然后继续进入编辑界面修改提交记录，:wq 退出\n\n\n# git reset --soft [commitid]\n\n> 带 --soft 参数的区别在于把改动内容添加到暂存区 相当于执行了git add .\n\n\n# git stash\n\n场景：正在feature分支写代码时，线上出现bug，需要切回master修复\n\ngit stash\ngit checkout master\n// 修复中...\ngit checkout <feture_branch> //切换刚才功能开发的分支\ngit stash pop //取出修改\n\n\n\n# git commit --amend\n\n修改git提交记录用法详解\n\n\n# 拉取本地不存在的远程分支\n\ngit checkout -b 1.0 origin/1.0\ngit pull\n\n\n\n# gitemoji\n\nhttps://gitmoji.js.org/\n\n\n# cherry-pick\n\ngit cherry-pick 教程\n\n如有冲突则解决冲突后 git add . git cherry-pick --continue\n\nrebase、merge、cherry-pick 都有 --abort（相当于反悔，回到操作之前的状态）\n\n\n# 一些问题\n\n1、2021.8.14 github修改密码校验为 token 校验\n\n * https://blog.csdn.net/weixin_41010198/article/details/119698015\n\n * https://blog.csdn.net/m0_46332820/article/details/119708248\n\n2、怎么配置命令行代理\n\n// 配置代理：\ngit config --global http.proxy <代理地址>\n// 用完重置：\ngit config --global --unset http.proxy\n\n\n3、cd .. 和 cd - 有什么区别\n\n * cd..：返回到上一级目录\n * cd -：返回到上一次的工作目录\n\n4、git add .与git add -a的区别\n\n * git add .：将修改和新增的文件添加到暂存区\n * git add -a：将修改，新增和删除的文件添加到暂存区（方便恢复被删除的文件）",charsets:{cjk:!0}},{title:"英语学习",frontmatter:{},regularPath:"/interview/english.html",relativePath:"interview/english.md",key:"v-614479ff",path:"/interview/english.html",headers:[{level:2,title:"单词",slug:"单词",normalizedTitle:"单词",charIndex:11},{level:2,title:"长句",slug:"长句",normalizedTitle:"长句",charIndex:489},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:1763}],lastUpdated:"9/2/2022, 8:20:25 PM",lastUpdatedTimestamp:1662121225e3,headersStr:"单词 长句 文章",content:"# 英语学习\n\n\n# 单词\n\nMISSION       PLUG IN       THRESHOLD   RIPPLE EFFECT   BENCHMARKS     DELIMITED\niteration     conflated     hazards     handy           capable        clumsy\nsomewhat      reach for     underused   literal         mechanism      collision\nergonomic     intuitively   nuances     constitute      introduce      infamously\nretrieve      dedicated     awkward     clunk           Nevertheless   melt\ncome across   recursive     grasp       crude           paradigm       \n\n\n# 长句\n\n * This is done on a best-effort basis as some compile-to-JavaScript languages may provide more accurate source maps than others.\n * resource-intensive\n * Jest will use them to try and map code coverage against the original source code when writing reports and checking thresholds.\n * jest transform: A map from regular expressions to paths to transformers. Optionally, a tuple with configuration options can be passed as second argument: {filePattern: ['path-to-transformer', {options}]}. For example, here is how you can configure babel-jest for non-default behavior: {'\\\\.js$': ['babel-jest', {rootMode: 'upward'}]}.\n * Jest runs the code of your project as JavaScript, hence a transformer is needed if you use some syntax not supported by Node out of the box (such as JSX, TypeScript, Vue templates). By default, Jest will use babel-jest transformer, which will load your project's Babel configuration and transform any file matching the /\\.[jt]sx?$/ RegExp (in other words, any .js, .jsx, .ts or .tsx file). In addition, babel-jest will inject the Babel plugin necessary for mock hoisting talked about in ES Module mocking.\n * Remember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors\n\n\n# 文章\n\n * When You Should Prefer Map Over Object In JavaScript",normalizedContent:"# 英语学习\n\n\n# 单词\n\nmission       plug in       threshold   ripple effect   benchmarks     delimited\niteration     conflated     hazards     handy           capable        clumsy\nsomewhat      reach for     underused   literal         mechanism      collision\nergonomic     intuitively   nuances     constitute      introduce      infamously\nretrieve      dedicated     awkward     clunk           nevertheless   melt\ncome across   recursive     grasp       crude           paradigm       \n\n\n# 长句\n\n * this is done on a best-effort basis as some compile-to-javascript languages may provide more accurate source maps than others.\n * resource-intensive\n * jest will use them to try and map code coverage against the original source code when writing reports and checking thresholds.\n * jest transform: a map from regular expressions to paths to transformers. optionally, a tuple with configuration options can be passed as second argument: {filepattern: ['path-to-transformer', {options}]}. for example, here is how you can configure babel-jest for non-default behavior: {'\\\\.js$': ['babel-jest', {rootmode: 'upward'}]}.\n * jest runs the code of your project as javascript, hence a transformer is needed if you use some syntax not supported by node out of the box (such as jsx, typescript, vue templates). by default, jest will use babel-jest transformer, which will load your project's babel configuration and transform any file matching the /\\.[jt]sx?$/ regexp (in other words, any .js, .jsx, .ts or .tsx file). in addition, babel-jest will inject the babel plugin necessary for mock hoisting talked about in es module mocking.\n * remember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors\n\n\n# 文章\n\n * when you should prefer map over object in javascript",charsets:{cjk:!0}},{title:"常考算法整理",frontmatter:{title:"常考算法整理",date:"2021-03-12T09:21:01.000Z",categories:"面试"},regularPath:"/interview/algorithm.html",relativePath:"interview/algorithm.md",key:"v-4f8373df",path:"/interview/algorithm.html",headers:[{level:2,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:2},{level:2,title:"回溯算法",slug:"回溯算法",normalizedTitle:"回溯算法",charIndex:149},{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:254},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:332},{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:380},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:35},{level:2,title:"二叉树",slug:"二叉树",normalizedTitle:"二叉树",charIndex:585},{level:2,title:"DFS / BFS",slug:"dfs-bfs",normalizedTitle:"dfs / bfs",charIndex:730},{level:2,title:"十大排序算法",slug:"十大排序算法",normalizedTitle:"十大排序算法",charIndex:847},{level:2,title:"双指针",slug:"双指针",normalizedTitle:"双指针",charIndex:1044}],lastUpdated:"3/16/2023, 6:45:18 PM",lastUpdatedTimestamp:1678963518e3,headersStr:"动态规划 回溯算法 栈 字符串 链表 数组 二叉树 DFS / BFS 十大排序算法 双指针",content:"# 动态规划\n\n * 爬楼梯\n * 最大子序列和 / 最大子序列和对应数组\n * 最长重复子数组\n * 无重复字符的最长子串\n * 最长递增子序列\n * 最长公共子序列\n * 买卖股票的最佳时机\n * 三角形最小路径和\n * 打家劫舍\n * 不同路径\n * 最小路径和\n * 分割等和子集\n\n\n# 回溯算法\n\n * 组合总和 i / 组合总和 ii / 数组找n个数求和\n * 数字全排列 / 二维数组全排列\n * 括号生成\n * 电话号码的数字组合\n * 子集\n * 路径总和\n * 路径总和ii\n\n\n# 栈\n\n * 最长有效括号\n * 去除重复字母\n * 移掉 k 位数字\n * 接雨水\n * 柱状图中的最大矩形\n * 最大矩形\n * 两个栈实现队列\n\n\n# 字符串\n\n * 最长公共前缀\n * 重复的子字符串\n * 字符串相加\n * 比较版本号\n\n\n# 链表\n\n * 环形链表 i\n * 环形链表 ii\n * 反转链表\n * 合并两个有序链表\n * 合并 k 个有序链表\n * 删除链表倒数第 n 个节点\n * 链表中倒数第k个节点\n * 奇偶链表\n * 相交链表\n\n\n# 数组\n\n * 合并两个有序数组\n * 合并区间\n * 旋转矩阵\n * 顺时针打印矩阵\n * 二分查找\n * 数组中第k大元素\n * 长度最小子数组\n * 下一个排列\n * 二分查找\n\n\n# 二叉树\n\n * 前序，中序，后序（递归 / 非递归）\n * 判断二叉树是否相同\n * 判断二叉树是否对称\n * 合并二叉树\n * 求二叉树的深度\n * 翻转二叉树\n * 二叉树的层次遍历\n * 求二叉树的宽度\n * 二叉树的右视图\n * 二叉搜索树的第K大节点\n * 最近公共祖先\n\n\n# DFS / BFS\n\n * DFS (递归 / 非递归)\n * BFS（非递归）\n * 求根到叶子节点数字之和\n * 路径总和\n * 岛屿数量\n * 岛屿最大面积\n * 打家劫舍iii\n * 单词接龙\n * N叉数的最大深度\n\n\n# 十大排序算法\n\n * 冒泡排序\n * 选择排序\n * 插入排序\n * 希尔排序\n * 归并排序\n * 快速排序\n * 堆排序\n * 计数排序\n * 桶排序\n * 基数排序\n * sort原理：当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。 对于长度大于1000的数组，采用的是快排与插入排序混合的方式进行排序的，因为，当数据量很小的时候，插入排序效率优于快排。\n\n\n# 双指针\n\n * x的平方根",normalizedContent:"# 动态规划\n\n * 爬楼梯\n * 最大子序列和 / 最大子序列和对应数组\n * 最长重复子数组\n * 无重复字符的最长子串\n * 最长递增子序列\n * 最长公共子序列\n * 买卖股票的最佳时机\n * 三角形最小路径和\n * 打家劫舍\n * 不同路径\n * 最小路径和\n * 分割等和子集\n\n\n# 回溯算法\n\n * 组合总和 i / 组合总和 ii / 数组找n个数求和\n * 数字全排列 / 二维数组全排列\n * 括号生成\n * 电话号码的数字组合\n * 子集\n * 路径总和\n * 路径总和ii\n\n\n# 栈\n\n * 最长有效括号\n * 去除重复字母\n * 移掉 k 位数字\n * 接雨水\n * 柱状图中的最大矩形\n * 最大矩形\n * 两个栈实现队列\n\n\n# 字符串\n\n * 最长公共前缀\n * 重复的子字符串\n * 字符串相加\n * 比较版本号\n\n\n# 链表\n\n * 环形链表 i\n * 环形链表 ii\n * 反转链表\n * 合并两个有序链表\n * 合并 k 个有序链表\n * 删除链表倒数第 n 个节点\n * 链表中倒数第k个节点\n * 奇偶链表\n * 相交链表\n\n\n# 数组\n\n * 合并两个有序数组\n * 合并区间\n * 旋转矩阵\n * 顺时针打印矩阵\n * 二分查找\n * 数组中第k大元素\n * 长度最小子数组\n * 下一个排列\n * 二分查找\n\n\n# 二叉树\n\n * 前序，中序，后序（递归 / 非递归）\n * 判断二叉树是否相同\n * 判断二叉树是否对称\n * 合并二叉树\n * 求二叉树的深度\n * 翻转二叉树\n * 二叉树的层次遍历\n * 求二叉树的宽度\n * 二叉树的右视图\n * 二叉搜索树的第k大节点\n * 最近公共祖先\n\n\n# dfs / bfs\n\n * dfs (递归 / 非递归)\n * bfs（非递归）\n * 求根到叶子节点数字之和\n * 路径总和\n * 岛屿数量\n * 岛屿最大面积\n * 打家劫舍iii\n * 单词接龙\n * n叉数的最大深度\n\n\n# 十大排序算法\n\n * 冒泡排序\n * 选择排序\n * 插入排序\n * 希尔排序\n * 归并排序\n * 快速排序\n * 堆排序\n * 计数排序\n * 桶排序\n * 基数排序\n * sort原理：当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。 对于长度大于1000的数组，采用的是快排与插入排序混合的方式进行排序的，因为，当数据量很小的时候，插入排序效率优于快排。\n\n\n# 双指针\n\n * x的平方根",charsets:{cjk:!0}},{title:"外企整理",frontmatter:{},regularPath:"/interview/foreign-company.html",relativePath:"interview/foreign-company.md",key:"v-9f6e0502",path:"/interview/foreign-company.html",lastUpdated:"1/27/2022, 4:20:48 PM",lastUpdatedTimestamp:1643271648e3,headersStr:null,content:"# 外企整理\n\n * jerry.ai ：硅谷明星创业公司，远程工作，相关文章",normalizedContent:"# 外企整理\n\n * jerry.ai ：硅谷明星创业公司，远程工作，相关文章",charsets:{cjk:!0}},{title:"面试题（十）",frontmatter:{title:"面试题（十）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-10.html",relativePath:"interview/interview-10.md",key:"v-374d8d79",path:"/interview/interview-10.html",headers:[{level:2,title:"call, apply, bind 的区别？怎么实现",slug:"call-apply-bind-的区别-怎么实现",normalizedTitle:"call, apply, bind 的区别？怎么实现",charIndex:13},{level:2,title:"vue的生命周期",slug:"vue的生命周期",normalizedTitle:"vue的生命周期",charIndex:47},{level:3,title:"beforeCreate( 创建前 )",slug:"beforecreate-创建前",normalizedTitle:"beforecreate( 创建前 )",charIndex:534},{level:3,title:"created ( 创建后 ）",slug:"created-创建后",normalizedTitle:"created ( 创建后 ）",charIndex:641},{level:3,title:"beforeMount（挂载之前）",slug:"beforemount-挂载之前",normalizedTitle:"beforemount（挂载之前）",charIndex:969},{level:3,title:"mounted（挂载）",slug:"mounted-挂载",normalizedTitle:"mounted（挂载）",charIndex:1082},{level:3,title:"beforeUpdate（更新之前）",slug:"beforeupdate-更新之前",normalizedTitle:"beforeupdate（更新之前）",charIndex:1154},{level:3,title:"updated（更新后）",slug:"updated-更新后",normalizedTitle:"updated（更新后）",charIndex:1224},{level:3,title:"beforeDestroy（销毁前）",slug:"beforedestroy-销毁前",normalizedTitle:"beforedestroy（销毁前）",charIndex:1355},{level:3,title:"destroyed（销毁后）",slug:"destroyed-销毁后",normalizedTitle:"destroyed（销毁后）",charIndex:1437},{level:2,title:"16进制颜色转换为rgb",slug:"_16进制颜色转换为rgb",normalizedTitle:"16进制颜色转换为rgb",charIndex:59},{level:2,title:"keep-alive了解吗",slug:"keep-alive了解吗",normalizedTitle:"keep-alive了解吗",charIndex:75},{level:3,title:"一个场景",slug:"一个场景",normalizedTitle:"一个场景",charIndex:1903},{level:2,title:"聊聊LRU算法",slug:"聊聊lru算法",normalizedTitle:"聊聊lru算法",charIndex:92},{level:2,title:"Vue中组件生命周期调用顺序",slug:"vue中组件生命周期调用顺序",normalizedTitle:"vue中组件生命周期调用顺序",charIndex:103},{level:3,title:"加载渲染过程",slug:"加载渲染过程",normalizedTitle:"加载渲染过程",charIndex:2807},{level:3,title:"子组件更新过程",slug:"子组件更新过程",normalizedTitle:"子组件更新过程",charIndex:2918},{level:3,title:"父组件更新过程",slug:"父组件更新过程",normalizedTitle:"父组件更新过程",charIndex:2981},{level:3,title:"销毁过程",slug:"销毁过程",normalizedTitle:"销毁过程",charIndex:3023},{level:2,title:"你都做过哪些Vue的性能优化",slug:"你都做过哪些vue的性能优化",normalizedTitle:"你都做过哪些vue的性能优化",charIndex:121},{level:2,title:"npm install 原理",slug:"npm-install-原理",normalizedTitle:"npm install 原理",charIndex:139},{level:2,title:"Map,weakMap,Set,weakSet",slug:"map-weakmap-set-weakset",normalizedTitle:"map,weakmap,set,weakset",charIndex:157},{level:2,title:"什么是尾递归和尾调用",slug:"什么是尾递归和尾调用",normalizedTitle:"什么是尾递归和尾调用",charIndex:184},{level:2,title:"link 与 @import 的区别",slug:"link-与-import-的区别",normalizedTitle:"link 与 @import 的区别",charIndex:198},{level:2,title:"数组 map() 和 forEach() 方法的区别？",slug:"数组-map-和-foreach-方法的区别",normalizedTitle:"数组 map() 和 foreach() 方法的区别？",charIndex:220},{level:2,title:"静态网站",slug:"静态网站",normalizedTitle:"静态网站",charIndex:254},{level:3,title:"什么是静态网站生成器",slug:"什么是静态网站生成器",normalizedTitle:"什么是静态网站生成器",charIndex:5041},{level:3,title:"常见的静态网站生成器",slug:"常见的静态网站生成器",normalizedTitle:"常见的静态网站生成器",charIndex:5166},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:5321}],lastUpdated:"3/15/2023, 7:26:00 PM",lastUpdatedTimestamp:167887956e4,headersStr:"call, apply, bind 的区别？怎么实现 vue的生命周期 beforeCreate( 创建前 ) created ( 创建后 ） beforeMount（挂载之前） mounted（挂载） beforeUpdate（更新之前） updated（更新后） beforeDestroy（销毁前） destroyed（销毁后） 16进制颜色转换为rgb keep-alive了解吗 一个场景 聊聊LRU算法 Vue中组件生命周期调用顺序 加载渲染过程 子组件更新过程 父组件更新过程 销毁过程 你都做过哪些Vue的性能优化 npm install 原理 Map,weakMap,Set,weakSet 什么是尾递归和尾调用 link 与 @import 的区别 数组 map() 和 forEach() 方法的区别？ 静态网站 什么是静态网站生成器 常见的静态网站生成器 应用场景",content:'# 面试题（十）\n\n * call, apply, bind 的区别？怎么实现\n * 介绍一下vue的生命周期\n * 16进制颜色转换为rgb\n * keep-alive了解吗\n * 聊聊LRU算法\n * Vue中组件生命周期调用顺序\n * 你都做过哪些Vue的性能优化\n * npm install 原理\n * Map,weakMap,Set,weakSet\n * 什么是尾递归和尾调用\n * link 与 @import 的区别\n * 数组 map() 和 forEach() 方法的区别？\n * 什么是静态网站\n\n\n# call, apply, bind 的区别？怎么实现\n\n> 都是用来改变函数的 this 对象的指向的。\n> \n> 第一个参数都是 this 要指向的对象。\n> \n> 都可以利用后续参数传参。 区别：\n> \n> call 接受函数传参方式为：fn.call(this, 1, 2, 3)\n> \n> apply 接受函数传参方式为：fn.apply(this,[1, 2, 3])\n> \n> bind 的返回值为一个新的函数，需要再次调用： fn.bind(this)(1, 2, 3)\n\n * 手写代码整理\n\n\n# vue的生命周期\n\n\n# beforeCreate( 创建前 )\n\n使用这个钩子，组件的选项对象并没有创建，el和data都还没初始化，所以data、methods和computed等都用不了。一般用来在组件挂在之前渲染一些东西。\n\n\n# created ( 创建后 ）\n\n这时候上面的data、methods、computed都已经创建完成了，数据观测，属性和方法的运算，watch/event事件回调都完成了，但这时候挂载阶段mount还没开始，是el并没有完成。这是最常用的生命周期钩子，可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也在这里发ajax请求，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter（路由守卫）中完成\n\n\n# beforeMount（挂载之前）\n\n挂载之前被调用，render（渲染）函数首次被调用（虚拟DOM），这里已经完成了模板编译，data里面的数据和模板会生产HTML，这里el也完成了，但并没有挂载到html页面上。\n\n\n# mounted（挂载）\n\n挂载完成了，这时候HTML模板会被渲染到HTML中，还可以做一些ajax操作。但mounted只能执行一次。\n\n\n# beforeUpdate（更新之前）\n\n更新指数据更新，发生在虚拟DOM重新渲染和补丁之前，在这个钩子中可以更改状态而不发生重绘。\n\n\n# updated（更新后）\n\n在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用\n\n\n# beforeDestroy（销毁前）\n\n在实例销毁前调用，但实例还可以用。\n\n这里还可以使用this，一般用来做重置操作，比如清除定时器和DOM监听事件。\n\n\n# destroyed（销毁后）\n\n在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用\n\n\n# 16进制颜色转换为rgb\n\nfunction hex2rgb(hex) {\n\tconst str = hex.slice(1),\n\t\tres = []\n\tif (str.length === 3) {\n\t\tfor (const w of str) {\n\t\t\tres.push(parseInt(w + w, 16))\n\t\t}\n\t} else {\n\t\tfor (let i = 0; i < 6; i += 2) {\n\t\t\tres.push(parseInt(str[i] + str[i + 1], 16))\n\t\t}\n\t}\n\treturn res\n}\n\n\n\n# keep-alive了解吗\n\n> keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\n\n\n# 一个场景\n\n用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。 总的来说，keep-alive用于保存组件的渲染状态\n\n> keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。\n> \n> 常用的两个属性include/exclude，允许组件有条件的进行缓存。\n> \n> 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。\n> \n> keep-alive的中还运用了LRU(Least Recently Used)算法。\n> \n> 使用 vue-des-tools 可以查看当前组件是否缓存\n\n<keep-alive> 是一个抽象组件，\n\n * 首次渲染的时候设置缓存\n * 缓存渲染的时候不会执行组件的 created、mounted 等钩子函数, 而是对缓存的组件执行patch 过程，最后直接更新到目标元素。\n\n使用 LRU 缓存策略对组件进行缓存\n\n * 命中缓存，则直接返回缓存，同时更新缓存key的位置\n * 不命中缓存则设置进缓存，同时检查缓存的实例数量是否超过 max\n\n * Vue keep-alive深入理解及实践总结\n * keep-alive的实现原理及LRU缓存策略\n * vue多级菜单(路由)导致缓存(keep-alive)失效\n\n\n# 聊聊LRU算法\n\n> 操作系统内存管理：分页，分段，段页结合\n> \n> LRU（最近最久未使用）属于页面置换算法中的一种，其他还有 FIFO（先进先出算法），OPT（最佳置换算法）等等\n\n操作系统页面置换算法\n\nleetcode146：LRU缓存机制\n\n题解\n\n\n# Vue中组件生命周期调用顺序\n\n组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。\n\n组件的销毁操作是先父后子，销毁完成的顺序是先子后父。\n\n\n# 加载渲染过程\n\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted\n\n\n\n# 子组件更新过程\n\n父beforeUpdate->子beforeUpdate->子updated->父updated\n\n\n\n# 父组件更新过程\n\n父 beforeUpdate -> 父 updated\n\n\n\n# 销毁过程\n\n父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n\n\n\n# 你都做过哪些Vue的性能优化\n\n * v-if与v-show\n * 使用计算属性的缓存性\n * v-if与v-for连用的问题\n * V-for必须为item添加key，且避免使用 index 作为标识\n * 长列表优化\n   * 只需要静态展示不需要响应式的数据，使用Object.freeze冻结\n   * 虚拟列表，vue-infinite-scroll\n * 释放组件资源，监听事件，定时器销毁\n * 图片资源优化\n   * 大图 cdn 加速\n   * 图片懒加载\n   * 压缩图片大小，大多使用付费云服务\n * SPA 页面采用keep-alive缓存组件\n * 使用路由懒加载、异步组件，也不宜太多\n * 防抖、节流\n * 第三方模块按需导入，例如Element ui\n * sourcemap\n * 首屏渲染优化\n   * 服务端渲染\n   * 预渲染\n   * 路由懒加载\n   * loading动画\n\n\n# npm install 原理\n\nnpm install 原理分析\n\n\n# Map,weakMap,Set,weakSet\n\nJavaScript中的Map、WeakMap、Set和WeakSet介绍\n\n\n# 什么是尾递归和尾调用\n\n阶乘函数\n\nint fact(int n) {\n    if (n < 0)\n        return 0;\n    else if(n == 0 || n == 1)\n        return 1;\n    else\n        return n * fact(n - 1);\n}\n\n\n尾递归实现\n\nint facttail(int n, int res)\n{\n    if (n < 0)\n        return 0;\n    else if(n == 0)\n        return 1;\n    else if(n == 1)\n        return res;\n    else\n        return facttail(n - 1, n * res);\n}\n\n\n再举一个例子：计算 1 到 n 的整数的和\n\nconst sum = (n) => {\n  if (n <= 1) return n;\n  return n + sum(n-1) // 当前调用栈保留，还需计算 n + ...\n}\n\nconst sum = (n, prevSum = 0) => {\n  if (n <= 1) return n + prevSum;\n  return sum(n-1, n + prevSum)\n}\n\n\n根本思想：避免了入栈出栈造成的时间空间损耗\n\n// 尾调用\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n\n\n> 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。\n> \n> 这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。\n\n尾调用优化\n\n\n# link 与 @import 的区别\n\n * link是HTML提供的标签，不仅可以加载CSS 文件，还可以定义RSS、rel 连接属性等。 @import是CSS 提供的语法规则，只有导入CSS的作用。\n * 加载页面时，link 标签引入的 CSS 被同时加载。 @import 引入的 CSS 将在页面加载完毕后被加载。\n\n\n# 数组 map() 和 forEach() 方法的区别？\n\n这两个方法都是进行遍历数组的方法。map() 方法通过调回回调函数映射每一个元素到新元素上，并且返回的是一个新数组。另一方面，forEach() 为每个元素调用回调函数，但是它不返回新数组。forEach() 函数通常用于在迭代中产生副作用，而 map() 函数是一种常见的函数式编程技术\n\n * 如果你需要遍历数组，会造成元素变化，而且不需要返回值来生成一个新数组，你可以使用 forEach()\n * 对于保持数据的不变，map() 是正确的选择，原始数组的每一个值都会映射到一个新数组中\n\n\n# 静态网站\n\n\n# 什么是静态网站生成器\n\n * 静态网站生成器是使用一系列配置，模板以及数据，生成静态HTML文件及相关资源的工具\n * 这个功能也叫预渲染\n * 生成的网站不需要服务器，只需要放到支持静态资源的 Web Server 或 CDN 上即可运行\n\n\n# 常见的静态网站生成器\n\n * Jekyll（Ruby）\n * Hexo（Node）\n * Hugo（Golang）\n * Gatsby（Node/React）\n * Gridsome（Node/Vue）\n * 另外，Next.js，Nuxt.js 也能生成静态网站，但是它们更多被认为是服务端渲染框架\n\n\n# 应用场景\n\n * 不适合有大量路由页面的应用\n * 不适合有大量动态内容的应用\n * 适用于纯内容展示网站：博客，文档，宣传站等',normalizedContent:'# 面试题（十）\n\n * call, apply, bind 的区别？怎么实现\n * 介绍一下vue的生命周期\n * 16进制颜色转换为rgb\n * keep-alive了解吗\n * 聊聊lru算法\n * vue中组件生命周期调用顺序\n * 你都做过哪些vue的性能优化\n * npm install 原理\n * map,weakmap,set,weakset\n * 什么是尾递归和尾调用\n * link 与 @import 的区别\n * 数组 map() 和 foreach() 方法的区别？\n * 什么是静态网站\n\n\n# call, apply, bind 的区别？怎么实现\n\n> 都是用来改变函数的 this 对象的指向的。\n> \n> 第一个参数都是 this 要指向的对象。\n> \n> 都可以利用后续参数传参。 区别：\n> \n> call 接受函数传参方式为：fn.call(this, 1, 2, 3)\n> \n> apply 接受函数传参方式为：fn.apply(this,[1, 2, 3])\n> \n> bind 的返回值为一个新的函数，需要再次调用： fn.bind(this)(1, 2, 3)\n\n * 手写代码整理\n\n\n# vue的生命周期\n\n\n# beforecreate( 创建前 )\n\n使用这个钩子，组件的选项对象并没有创建，el和data都还没初始化，所以data、methods和computed等都用不了。一般用来在组件挂在之前渲染一些东西。\n\n\n# created ( 创建后 ）\n\n这时候上面的data、methods、computed都已经创建完成了，数据观测，属性和方法的运算，watch/event事件回调都完成了，但这时候挂载阶段mount还没开始，是el并没有完成。这是最常用的生命周期钩子，可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也在这里发ajax请求，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforerouteenter（路由守卫）中完成\n\n\n# beforemount（挂载之前）\n\n挂载之前被调用，render（渲染）函数首次被调用（虚拟dom），这里已经完成了模板编译，data里面的数据和模板会生产html，这里el也完成了，但并没有挂载到html页面上。\n\n\n# mounted（挂载）\n\n挂载完成了，这时候html模板会被渲染到html中，还可以做一些ajax操作。但mounted只能执行一次。\n\n\n# beforeupdate（更新之前）\n\n更新指数据更新，发生在虚拟dom重新渲染和补丁之前，在这个钩子中可以更改状态而不发生重绘。\n\n\n# updated（更新后）\n\n在由于数据更改导致地虚拟dom重新渲染和打补丁只会调用，调用时，组件dom已经更新，所以可以执行依赖于dom的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用\n\n\n# beforedestroy（销毁前）\n\n在实例销毁前调用，但实例还可以用。\n\n这里还可以使用this，一般用来做重置操作，比如清除定时器和dom监听事件。\n\n\n# destroyed（销毁后）\n\n在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用\n\n\n# 16进制颜色转换为rgb\n\nfunction hex2rgb(hex) {\n\tconst str = hex.slice(1),\n\t\tres = []\n\tif (str.length === 3) {\n\t\tfor (const w of str) {\n\t\t\tres.push(parseint(w + w, 16))\n\t\t}\n\t} else {\n\t\tfor (let i = 0; i < 6; i += 2) {\n\t\t\tres.push(parseint(str[i] + str[i + 1], 16))\n\t\t}\n\t}\n\treturn res\n}\n\n\n\n# keep-alive了解吗\n\n> keep-alive是一个抽象组件：它自身不会渲染一个 dom 元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\n\n\n# 一个场景\n\n用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。 总的来说，keep-alive用于保存组件的渲染状态\n\n> keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。\n> \n> 常用的两个属性include/exclude，允许组件有条件的进行缓存。\n> \n> 两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。\n> \n> keep-alive的中还运用了lru(least recently used)算法。\n> \n> 使用 vue-des-tools 可以查看当前组件是否缓存\n\n<keep-alive> 是一个抽象组件，\n\n * 首次渲染的时候设置缓存\n * 缓存渲染的时候不会执行组件的 created、mounted 等钩子函数, 而是对缓存的组件执行patch 过程，最后直接更新到目标元素。\n\n使用 lru 缓存策略对组件进行缓存\n\n * 命中缓存，则直接返回缓存，同时更新缓存key的位置\n * 不命中缓存则设置进缓存，同时检查缓存的实例数量是否超过 max\n\n * vue keep-alive深入理解及实践总结\n * keep-alive的实现原理及lru缓存策略\n * vue多级菜单(路由)导致缓存(keep-alive)失效\n\n\n# 聊聊lru算法\n\n> 操作系统内存管理：分页，分段，段页结合\n> \n> lru（最近最久未使用）属于页面置换算法中的一种，其他还有 fifo（先进先出算法），opt（最佳置换算法）等等\n\n操作系统页面置换算法\n\nleetcode146：lru缓存机制\n\n题解\n\n\n# vue中组件生命周期调用顺序\n\n组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。\n\n组件的销毁操作是先父后子，销毁完成的顺序是先子后父。\n\n\n# 加载渲染过程\n\n父beforecreate->父created->父beforemount->子beforecreate->子created->子beforemount- >子mounted->父mounted\n\n\n\n# 子组件更新过程\n\n父beforeupdate->子beforeupdate->子updated->父updated\n\n\n\n# 父组件更新过程\n\n父 beforeupdate -> 父 updated\n\n\n\n# 销毁过程\n\n父beforedestroy->子beforedestroy->子destroyed->父destroyed\n\n\n\n# 你都做过哪些vue的性能优化\n\n * v-if与v-show\n * 使用计算属性的缓存性\n * v-if与v-for连用的问题\n * v-for必须为item添加key，且避免使用 index 作为标识\n * 长列表优化\n   * 只需要静态展示不需要响应式的数据，使用object.freeze冻结\n   * 虚拟列表，vue-infinite-scroll\n * 释放组件资源，监听事件，定时器销毁\n * 图片资源优化\n   * 大图 cdn 加速\n   * 图片懒加载\n   * 压缩图片大小，大多使用付费云服务\n * spa 页面采用keep-alive缓存组件\n * 使用路由懒加载、异步组件，也不宜太多\n * 防抖、节流\n * 第三方模块按需导入，例如element ui\n * sourcemap\n * 首屏渲染优化\n   * 服务端渲染\n   * 预渲染\n   * 路由懒加载\n   * loading动画\n\n\n# npm install 原理\n\nnpm install 原理分析\n\n\n# map,weakmap,set,weakset\n\njavascript中的map、weakmap、set和weakset介绍\n\n\n# 什么是尾递归和尾调用\n\n阶乘函数\n\nint fact(int n) {\n    if (n < 0)\n        return 0;\n    else if(n == 0 || n == 1)\n        return 1;\n    else\n        return n * fact(n - 1);\n}\n\n\n尾递归实现\n\nint facttail(int n, int res)\n{\n    if (n < 0)\n        return 0;\n    else if(n == 0)\n        return 1;\n    else if(n == 1)\n        return res;\n    else\n        return facttail(n - 1, n * res);\n}\n\n\n再举一个例子：计算 1 到 n 的整数的和\n\nconst sum = (n) => {\n  if (n <= 1) return n;\n  return n + sum(n-1) // 当前调用栈保留，还需计算 n + ...\n}\n\nconst sum = (n, prevsum = 0) => {\n  if (n <= 1) return n + prevsum;\n  return sum(n-1, n + prevsum)\n}\n\n\n根本思想：避免了入栈出栈造成的时间空间损耗\n\n// 尾调用\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n\n\n> 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。\n> \n> 这就叫做"尾调用优化"（tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。\n\n尾调用优化\n\n\n# link 与 @import 的区别\n\n * link是html提供的标签，不仅可以加载css 文件，还可以定义rss、rel 连接属性等。 @import是css 提供的语法规则，只有导入css的作用。\n * 加载页面时，link 标签引入的 css 被同时加载。 @import 引入的 css 将在页面加载完毕后被加载。\n\n\n# 数组 map() 和 foreach() 方法的区别？\n\n这两个方法都是进行遍历数组的方法。map() 方法通过调回回调函数映射每一个元素到新元素上，并且返回的是一个新数组。另一方面，foreach() 为每个元素调用回调函数，但是它不返回新数组。foreach() 函数通常用于在迭代中产生副作用，而 map() 函数是一种常见的函数式编程技术\n\n * 如果你需要遍历数组，会造成元素变化，而且不需要返回值来生成一个新数组，你可以使用 foreach()\n * 对于保持数据的不变，map() 是正确的选择，原始数组的每一个值都会映射到一个新数组中\n\n\n# 静态网站\n\n\n# 什么是静态网站生成器\n\n * 静态网站生成器是使用一系列配置，模板以及数据，生成静态html文件及相关资源的工具\n * 这个功能也叫预渲染\n * 生成的网站不需要服务器，只需要放到支持静态资源的 web server 或 cdn 上即可运行\n\n\n# 常见的静态网站生成器\n\n * jekyll（ruby）\n * hexo（node）\n * hugo（golang）\n * gatsby（node/react）\n * gridsome（node/vue）\n * 另外，next.js，nuxt.js 也能生成静态网站，但是它们更多被认为是服务端渲染框架\n\n\n# 应用场景\n\n * 不适合有大量路由页面的应用\n * 不适合有大量动态内容的应用\n * 适用于纯内容展示网站：博客，文档，宣传站等',charsets:{cjk:!0}},{title:"手写代码（一）",frontmatter:{title:"手写代码（一）",date:"2020-03-20T09:52:01.000Z",categories:"面试"},regularPath:"/interview/code-1.html",relativePath:"interview/code-1.md",key:"v-2e1355ed",path:"/interview/code-1.html",headers:[{level:2,title:"防抖",slug:"防抖",normalizedTitle:"防抖",charIndex:14},{level:2,title:"节流",slug:"节流",normalizedTitle:"节流",charIndex:20},{level:2,title:"深拷贝",slug:"深拷贝",normalizedTitle:"深拷贝",charIndex:26},{level:2,title:"柯里化",slug:"柯里化",normalizedTitle:"柯里化",charIndex:33},{level:2,title:"函数组合",slug:"函数组合",normalizedTitle:"函数组合",charIndex:40},{level:2,title:"new",slug:"new",normalizedTitle:"new",charIndex:48},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:55},{level:2,title:"apply，call，bind",slug:"apply-call-bind",normalizedTitle:"apply，call，bind",charIndex:3394},{level:2,title:"promise.all",slug:"promise-all",normalizedTitle:"promise.all",charIndex:88},{level:2,title:"promise.race",slug:"promise-race",normalizedTitle:"promise.race",charIndex:103},{level:2,title:"promise.resolve",slug:"promise-resolve",normalizedTitle:"promise.resolve",charIndex:5451},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:4297},{level:2,title:"promise封装ajax",slug:"promise封装ajax",normalizedTitle:"promise封装ajax",charIndex:130},{level:2,title:"发布订阅模式",slug:"发布订阅模式",normalizedTitle:"发布订阅模式",charIndex:147},{level:2,title:"Symbol.iterator",slug:"symbol-iterator",normalizedTitle:"symbol.iterator",charIndex:157},{level:2,title:"数组扁平化",slug:"数组扁平化",normalizedTitle:"数组扁平化",charIndex:176},{level:2,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:185},{level:2,title:"并发请求控制",slug:"并发请求控制",normalizedTitle:"并发请求控制",charIndex:193},{level:2,title:"实现一个sleep函数",slug:"实现一个sleep函数",normalizedTitle:"实现一个sleep函数",charIndex:12629},{level:2,title:"实现 map 和 reduce",slug:"实现-map-和-reduce",normalizedTitle:"实现 map 和 reduce",charIndex:203},{level:2,title:"实现 'abcd'.f() 返回 'd-c-b-a'",slug:"实现-abcd-f-返回-d-c-b-a",normalizedTitle:"实现 'abcd'.f() 返回 'd-c-b-a'",charIndex:222},{level:2,title:"Object.create",slug:"object-create",normalizedTitle:"object.create",charIndex:252}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"防抖 节流 深拷贝 柯里化 函数组合 new instanceof apply，call，bind promise.all promise.race promise.resolve Promise promise封装ajax 发布订阅模式 Symbol.iterator 数组扁平化 数组去重 并发请求控制 实现一个sleep函数 实现 map 和 reduce 实现 'abcd'.f() 返回 'd-c-b-a' Object.create",content:"# 手写代码（一）\n\n * 防抖\n * 节流\n * 深拷贝\n * 柯里化\n * 函数组合\n * new\n * instanceof\n * apply,bind,call\n * promise.all\n * promise.race\n * promise\n * promise封装ajax\n * 发布订阅模式\n * Symbol.iterator\n * 数组扁平化\n * 数组去重\n * 并发请求控制\n * 实现 map 和 reduce\n * 实现 'abcd'.f() 返回 'd-c-b-a'\n * Object.create\n\n\n# 防抖\n\n所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n// 防抖debounce\nfunction debounce(fn, delay) {\n  let timer = null\n  return function () {\n    timer && clearTimeout(timer)\n    timer = setTimeout(() => {\n      /**\n      \tfn 中的 this 指向 debounce 中 return 的这个函数中的 this\n      \treturn 回来的这个函数中的 this 也就是指向直接调用 return 函数那个对象\n      */\n      fn.apply(this, arguments)\n    }, delay)\n  }\n}\n\nfunction out(){\n    console.log(\"防抖\")\n}\nwindow.onscroll = debounce(out, 1000)\n\n\n\n# 节流\n\n所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。\n\n// 使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行\nfunction throttle(fn, delay) {\n  let lastTime = 0;\n  return function() {\n    let now = Date.now();\n    if (now - lastTime >= delay) {\n      fn.apply(this, arguments);\n      lastTime = now;\n    }\n  }\n}\n\n// 使用定时器写法，delay 毫秒后第一次执行，第二次事件停止触发后依然会再一次执行\nfunction throttle2(fn, delay) {\n  let timer = null;\n  return function() {\n    if (!timer) {\n      timer = setTimeout(() => {\n        fn.apply(this, arguments);\n        timer = null;\n      }, delay);\n    }\n  };\n}\n\n// 使用定时器写法，事件会立即执行\nfunction throttle(fn, delay) {\n  let timer = null;\n  return function() {\n    if (!timer) {\n      fn.apply(this, arguments);\n      timer = setTimeout(() => {\n        timer = null;\n      }, delay)\n    }\n  };\n}\n\n\n\n# 深拷贝\n\nfunction deepClone(obj, hash = new WeakMap()) {\n    if (obj instanceof Date) return new Date(obj);\n    if (obj instanceof Error) return new Error(obj);\n    if (obj instanceof RegExp) return new RegExp(obj);\n    if (typeof obj !== \"object\" || obj === null) return obj; // 考虑数组\n    if (hash.get(obj)) return hash.get(obj);\n    let cloneObj = new Object();\n    hash.set(obj, cloneObj);\n    for (let key in obj) {\n        if (Object.hasOwn(obj, key)) {\n            cloneObj[key] = deepClone(obj[key], hash);\n        }\n    }\n    return cloneObj;\n}\n\n\n> 使用WeakMap，hash和obj存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。设想一下，如果我们要拷贝的对象非常庞大时，使用Map会对内存造成非常大的额外消耗，而且我们需要手动清除Map的属性才能释放这块内存，而WeakMap会帮我们巧妙化解这个问题。\n\n\n# 柯里化\n\nlet curry = (fn,...args)=> args.length < fn.length\n                ?(...arguments) => curry(fn,...args,...arguments)\n                :fn(...args)\n\n\n\n# 函数组合\n\nfunction compose(...args) {\n    return function(value) {\n        return args.reverse().reduce((acc, cur) => cur(acc), value)\n    }\n}\n\n\n\n# new\n\n>  1. 创造一个新的空对象\n>  2. 新对象的__proto__指向构造函数的原型对象\n>  3. 构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。\n>  4. 返回新对象地址\n\nfunction _new(constructor, ...args) {\n    let obj = new Object()\n    obj.__proto__ = constructor.prototype\n    constructor.call(obj, ...args)\n    return obj\n}\n\n/**\n\t\t上面代码可以再优化一下，模拟了 new 就别再用 new 了\n\t\t而且没有考虑构造函数存在返回值的情况，如果构造函数返回了对象那么则返回这个对象\n*/\nfunction _new(constructor, ...args) {\n  const obj = Object.create(fn.prototype); // 原型式继承\n  const ret = constructor.call(obj, ...args); // 继承属性\n  return typeof ret === \"object\" ? ret : obj;\n}\n\n\n\n# instanceof\n\nfunction _instanceof(left, right) {\n \t\tif (typeof L !== 'object') return false\n    let l = left.__proto__;\n    let r = right.prototype;\n    while (true) {\n        if (l === null) {\n            return false;\n        }\n        if (l === r) {\n            return true;\n        }\n        l = l.__proto__;\n    }\n}\n\n\n\n# apply，call，bind\n\n//apply\nFunction.prototype.myApply = function(context, args) {\n    context = context || window;\n    context.fn = this;\n    const result = context.fn(...args);\n    delete context.fn;\n    return result;\n    \n}\n\nlet obj = {}\nconsole.log(Math.max.myApply(obj, [1, 2, 3])) //3\n\n//call\nFunction.prototype.myCall = function(context, ...args) {\n    context = context || window;\n    context.fn = this;\n    const result = context.fn(...args);\n    delete context.fn;\n    return result;\n}\n\nlet obj = {}\nconsole.log(Math.max.myCall(obj, 1, 2, 3)) // 3\n\n//bind\nFunction.prototype.myBind = function(context, ...args) {\n    context = context || window;\n    context.fn = this;\n    return function() {\n        const result = context.fn(...args, ...arguments);\n        delete context.fn;\n        return result;   \n    }\n}\n\nlet obj = {}\nconsole.log(Math.max.myBind(obj, 1, 2, 3)(4)) // 4\n\n\n\n# promise.all\n\nPromise.all = function (promises) {\n    return new Promise((resolve, reject) => {\n        if (!promises || promises.length === 0) {\n            resolve([]);\n        }\n        let count = 0;\n        const result = [];\n        for (let i = 0; i < promises[i].length; i++) {\n            // 考虑到promises[i]可能是普通对象，则统一包装为Promise对象\n            Promise.resolve(promises[i]).then(res => {\n                result[i] = res;\n                if (++count === promises.length) {\n                    resolve(res);\n                }\n            }).catch(err => {\n                // 任何一个Promise对象执行失败，则调用reject()方法\n                reject(err);\n                return;\n            });\n        }\n    });\n}\n\n\n\n# promise.race\n\nPromise.race = function(promises) {\n    return new Promise((resolve, reject) => {\n       \t if (!promises || promises.length === 0) {\n            return;\n         }\n         for (const item of promises) {\n              Promise.resolve(item).then((res) => {\n                  resolve(res);\n                  return;\n              }).catch((err) => {\n                  reject(err);\n                  return;\n              })\n          }\n    });\n}\n\n\n\n# promise.resolve\n\nPromise.resolve = function (value) {\n    if (value instanceof promise) return value\n    return new Promise(resolve => resolve(value))\n}\n\n// 例子\nPromise.resolve(100).then(value => console.log(value))\n\n\n\n# Promise\n\n * 三种状态：pending，fulfilled，rejected\n * new Promise 时传进来一个执行器（参数是resolve和reject），是立即执行的\n * resolve函数的作用是改变状态为fulfilled，存储成功的值：value\n * reject函数的作用的改变状态为rejected，存储失败的原因：reason\n * then函数有两个参数，成功回调和失败回调，首先判断状态，fulfilled则执行成功回调，rejected则执行失败回调，pending则把回调存储起来\n * then要实现链式调用，需要返回 promise，then方法原来的操作可以放进新建 promise2 的执行器中立即执行，并且需要获取当前的返回值 x，传递给下一个 then 方法\n\nconst PENDING = 'pending' // 等待\nconst FULFILLED = 'fulfilled' // 成功\nconst REJECTED = 'rejected' //失败\n\nclass MyPromise {\n  constructor (executor) {\n    executor(this.resolve, this.reject);\n  }\n  // promise 状态\n  status = PENDING;\n  // 成功之后的值\n  value = undefined;\n  // 失败后的原因\n  reason = undefined;\n  // 成功回调，用数组的原因是可能有多个 promise.then\n  successCallback = [];\n  // 失败回调\n  failCallback = [];\n  // 定义成箭头函数的好处是 this 指向当前类\n  resolve = value => {\n    // 如果状态不是等待 阻止程序向下执行 因为状态一旦确定就不可以再改变\n    if (this.status !== PENDING) return;\n    // 将状态更改为成功\n    this.status = FULFILLED;\n    // 保存成功之后的值\n    this.value = value;\n    // 判断成功回调是否存在 存在则调用\n    while (this.successCallback.length) {\n     \tthis.successCallback.shift()(this.value);\n    }\n  }\n  reject = reason => {\n    // 如果状态不是等待 阻止程序向下执行\n    if (this.status !== PENDING) return;\n    // 将状态更改为失败\n    this.status = REJECTED;\n    // 保存失败后的原因\n    this.reason = reason;\n    // 判断失败回调是否存在 存在则调用\n    while (this.failCallback.length) {\n     \tthis.failCallback.shift()(this.reason); \n    }\n  }\n then = (successCallback, failCallback) => {\n   successCallback = successCallback ? successCallback : value => value;\n   return new MyPromise((resolve, reject) => {\n     if (this.status === FULLFILLED) {\n       let x = successCallback(this.value);\n       x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);\n     }\n     else if (this.status === REJECTED) {\n       failCallback(this.reason);\n     }\n     else {\n       this.successCallback.push(successCallback);\n       this.failCallback.push(failCallback);\n     }\n   });\n }\n catch = (failCallback) => {\n   return this.then(undefined, failCallback);\n }\n}\n\n// 测试\n\n// 1. 测试基本功能\nlet p = new MyPromise((resolve, reject) => {\n    resolve('success')\n    reject('fail')\n})\n\np.then(val => {\n  console.log(val)\n}, reason => {\n  console.log(reason)\n})\n\n// 2. 测试异步\nlet p = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('success')   \n    }, 2000)\n})\n\np.then(val => {\n  console.log(val)\n}, reason => {\n  console.log(reason)\n})\n\n// 3. 测试链式调用\nlet p = new MyPromise((resolve, reject) => {\n    resolve('success')\n})\n\np.then(res => {\n    console.log(res)\n    return 100\n}).then(val => {\n    console.log(val)\n})\n\n// 4. 测试 then 返回也是 promise\nlet p = new MyPromise((resolve, reject) => {\n    resolve('success')\n})\n\np.then(res => {\n    console.log(res)\n    return new MyPromise((resolve, reject) => {\n        resolve('other')\n    })\n}).then(val => {\n    console.log(val)\n})\n\n// 5. 测试 then 不传参数\nlet promise = new MyPromise((resolve, reject) => {\n    resolve('成功')\n})\n\np.then().then().then(val => console.log(val))\n\n\n\n# promise封装ajax\n\nfunction ajax (url) {\n    return new Promise(function (reslove, reject) {\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', url) \n        xhr.reponeseType = 'json'\n        xhr.onload = function () {\n            if(this.status === 200) {\n                reslove(this.response)\n            } else {\n                reject(new Error(this.statusText))\n            }\n        }\n        xhr.send()\n    })\n}\n\najax('/api/')\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))\n\n\n//promise.reslove\nPromise.resolve('foo')\n    .then(function (value) {\n \t   \t\tconsole.log(value)\n\t\t})\n\n\n\n# 发布订阅模式\n\n    // 类内部存储一个对象，包含事件名和对应的触发函数\n    // { click: [fn1, fn2], change: fn }\n    class EventEmitter {\n      constructor () {\n        this.subs = Object.create(null)\n      }\n      // 注册事件\n      $on (eventType, handler) {\n        this.subs[eventType] = this.subs[eventType] || []\n        this.subs[eventType].push(handler)\n      }\n\n      // 触发事件\n      $emit (eventType) {\n        if (this.subs[eventType]) {\n          this.subs[eventType].foreach(handler => {\n            handler()\n          })\n        }\n      }\n    }\n\n    // 测试\n    let em = new EventEmitter() // 信号中心\n    em.$on('click', () => {\n      console.log('click1')\n    })\n    em.$on('click', () => {\n      console.log('click2')\n    })\n    em.$emit('click')\n\n\n\n# Symbol.iterator\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [Symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor (let item of todos) {\n    console.log(item)\n}\n\n\n\n# 数组扁平化\n\n// 不带参数\nfunction flattern(arr) {\n    let res = [];\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            res = res.concat(flattern(item));\n        } else {\n            res.push(item);\n        }\n    }\n    return res;\n}\n// 带参数\nfunction flattern(arr, depth) {\n    let res = []\n    for(let item of arr){\n        if (Array.isArray(item) && depth > 0) {\n            res = res.concat(flattern(item, depth - 1))\n        } else {\n            res.push(item)\n        }\n    }\n    return res\n}\n\n// 一次性拍平\nfunction flat(arr) {\n  return arr.toString().split(',').map(item => +item)\n}\n\n\n\n# 数组去重\n\n（1）reduce + includes\n\nfunction deduplicate(arr) {\n    return arr.reduce((acc, cur) => acc.includes(cur) ? acc : acc.concat(cur), []);\n}\n// concat 不会改变原有数组，返回值为新数组，可拼接单个元素\n\n\n（2）利用ES6的Set数据结构\n\n> set 类似于数组，且成员值不重复都是唯一的，set本身是一个构造函数。\n\nfunction deduplicate(arr) {\n    return [...new Set(arr)];\n}\n\n\n（3）利用sort\n\nfunction deduplicate(arr) {\n    arr = arr.sort();\n    const res = [];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i - 1]) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n}\n\n\n（4）利用includes\n\nfunction deduplicate(arr) {\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (!res.includes(arr[i])) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n}\n\n\n\n# 并发请求控制\n\n> 实现一个批量请求函数 multiRequest(urls, maxNum)，要求如下： • 要求最大并发数 maxNum • 每当有一个请求返回，就留下一个空位，可以增加新的请求 • 所有请求完成后，结果按照 urls 里面的顺序依次打出\n\nfunction multiRequest(urls = [], maxNum) {\n    const len = urls.length\n    const result = new Array(len).fill(false)\n    let count = 0\n  \n    return new Promise((resolve, reject) => {\n        while (count < maxNum) {\n            next();\n        }\n        function next() {\n            let current = count++;\n            if (current >= len) {\n                !result.includes(false) && resolve(result);\n                return;\n            }\n            const url = urls[current];\n            fetch(url).then((res) => {\n                result[current] = res;\n                if (current < len) {\n                    next();\n                }\n            }).catch((err) => {\n                result[current] = err;\n                if (current < len) {\n                    next();\n                }\n            })\n        }\n    })\n}\n\n\n\n# 实现一个sleep函数\n\nconst sleep = (time) => {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\n\nsleep(1000).then(() => {\n  // 这里写你的操作\n})\n\n\n\n# 实现 map 和 reduce\n\nArray.prototype.myMap = function(fn) {\n    const arr = this;\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        res[i] = fn(arr[i], i, arr)\n    }\n    return res;\n};\n\nArray.prototype.myReduce = function(fn, initValue) {\n    const arr = this;\n    let val = initValue || arr[0]\n    for (let i = initValue ? 0 : 1; i < arr.length; i++) {\n        val = fn(val, arr[i], i, arr)\n    }\n    return val;\n};\n\n\n\n# 实现 'abcd'.f() 返回 'd-c-b-a'\n\nString.prototype.f = function() {\n    return this.split('').reverse().join('-')\n}\n\n\n\n# Object.create\n\n// Object.create 实现\nlet o = Object.create(obj) // o.__proto__ === obj\nObject.create = function (obj) {\n    function F() {}\n    F.prototype = obj;\n    return new F();\n};\n\n// 可以理解为\nObject.create = function (obj) {\n  return {\n    __proto__: obj\n  }\n}\n",normalizedContent:"# 手写代码（一）\n\n * 防抖\n * 节流\n * 深拷贝\n * 柯里化\n * 函数组合\n * new\n * instanceof\n * apply,bind,call\n * promise.all\n * promise.race\n * promise\n * promise封装ajax\n * 发布订阅模式\n * symbol.iterator\n * 数组扁平化\n * 数组去重\n * 并发请求控制\n * 实现 map 和 reduce\n * 实现 'abcd'.f() 返回 'd-c-b-a'\n * object.create\n\n\n# 防抖\n\n所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n// 防抖debounce\nfunction debounce(fn, delay) {\n  let timer = null\n  return function () {\n    timer && cleartimeout(timer)\n    timer = settimeout(() => {\n      /**\n      \tfn 中的 this 指向 debounce 中 return 的这个函数中的 this\n      \treturn 回来的这个函数中的 this 也就是指向直接调用 return 函数那个对象\n      */\n      fn.apply(this, arguments)\n    }, delay)\n  }\n}\n\nfunction out(){\n    console.log(\"防抖\")\n}\nwindow.onscroll = debounce(out, 1000)\n\n\n\n# 节流\n\n所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。\n\n// 使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行\nfunction throttle(fn, delay) {\n  let lasttime = 0;\n  return function() {\n    let now = date.now();\n    if (now - lasttime >= delay) {\n      fn.apply(this, arguments);\n      lasttime = now;\n    }\n  }\n}\n\n// 使用定时器写法，delay 毫秒后第一次执行，第二次事件停止触发后依然会再一次执行\nfunction throttle2(fn, delay) {\n  let timer = null;\n  return function() {\n    if (!timer) {\n      timer = settimeout(() => {\n        fn.apply(this, arguments);\n        timer = null;\n      }, delay);\n    }\n  };\n}\n\n// 使用定时器写法，事件会立即执行\nfunction throttle(fn, delay) {\n  let timer = null;\n  return function() {\n    if (!timer) {\n      fn.apply(this, arguments);\n      timer = settimeout(() => {\n        timer = null;\n      }, delay)\n    }\n  };\n}\n\n\n\n# 深拷贝\n\nfunction deepclone(obj, hash = new weakmap()) {\n    if (obj instanceof date) return new date(obj);\n    if (obj instanceof error) return new error(obj);\n    if (obj instanceof regexp) return new regexp(obj);\n    if (typeof obj !== \"object\" || obj === null) return obj; // 考虑数组\n    if (hash.get(obj)) return hash.get(obj);\n    let cloneobj = new object();\n    hash.set(obj, cloneobj);\n    for (let key in obj) {\n        if (object.hasown(obj, key)) {\n            cloneobj[key] = deepclone(obj[key], hash);\n        }\n    }\n    return cloneobj;\n}\n\n\n> 使用weakmap，hash和obj存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。设想一下，如果我们要拷贝的对象非常庞大时，使用map会对内存造成非常大的额外消耗，而且我们需要手动清除map的属性才能释放这块内存，而weakmap会帮我们巧妙化解这个问题。\n\n\n# 柯里化\n\nlet curry = (fn,...args)=> args.length < fn.length\n                ?(...arguments) => curry(fn,...args,...arguments)\n                :fn(...args)\n\n\n\n# 函数组合\n\nfunction compose(...args) {\n    return function(value) {\n        return args.reverse().reduce((acc, cur) => cur(acc), value)\n    }\n}\n\n\n\n# new\n\n>  1. 创造一个新的空对象\n>  2. 新对象的__proto__指向构造函数的原型对象\n>  3. 构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。\n>  4. 返回新对象地址\n\nfunction _new(constructor, ...args) {\n    let obj = new object()\n    obj.__proto__ = constructor.prototype\n    constructor.call(obj, ...args)\n    return obj\n}\n\n/**\n\t\t上面代码可以再优化一下，模拟了 new 就别再用 new 了\n\t\t而且没有考虑构造函数存在返回值的情况，如果构造函数返回了对象那么则返回这个对象\n*/\nfunction _new(constructor, ...args) {\n  const obj = object.create(fn.prototype); // 原型式继承\n  const ret = constructor.call(obj, ...args); // 继承属性\n  return typeof ret === \"object\" ? ret : obj;\n}\n\n\n\n# instanceof\n\nfunction _instanceof(left, right) {\n \t\tif (typeof l !== 'object') return false\n    let l = left.__proto__;\n    let r = right.prototype;\n    while (true) {\n        if (l === null) {\n            return false;\n        }\n        if (l === r) {\n            return true;\n        }\n        l = l.__proto__;\n    }\n}\n\n\n\n# apply，call，bind\n\n//apply\nfunction.prototype.myapply = function(context, args) {\n    context = context || window;\n    context.fn = this;\n    const result = context.fn(...args);\n    delete context.fn;\n    return result;\n    \n}\n\nlet obj = {}\nconsole.log(math.max.myapply(obj, [1, 2, 3])) //3\n\n//call\nfunction.prototype.mycall = function(context, ...args) {\n    context = context || window;\n    context.fn = this;\n    const result = context.fn(...args);\n    delete context.fn;\n    return result;\n}\n\nlet obj = {}\nconsole.log(math.max.mycall(obj, 1, 2, 3)) // 3\n\n//bind\nfunction.prototype.mybind = function(context, ...args) {\n    context = context || window;\n    context.fn = this;\n    return function() {\n        const result = context.fn(...args, ...arguments);\n        delete context.fn;\n        return result;   \n    }\n}\n\nlet obj = {}\nconsole.log(math.max.mybind(obj, 1, 2, 3)(4)) // 4\n\n\n\n# promise.all\n\npromise.all = function (promises) {\n    return new promise((resolve, reject) => {\n        if (!promises || promises.length === 0) {\n            resolve([]);\n        }\n        let count = 0;\n        const result = [];\n        for (let i = 0; i < promises[i].length; i++) {\n            // 考虑到promises[i]可能是普通对象，则统一包装为promise对象\n            promise.resolve(promises[i]).then(res => {\n                result[i] = res;\n                if (++count === promises.length) {\n                    resolve(res);\n                }\n            }).catch(err => {\n                // 任何一个promise对象执行失败，则调用reject()方法\n                reject(err);\n                return;\n            });\n        }\n    });\n}\n\n\n\n# promise.race\n\npromise.race = function(promises) {\n    return new promise((resolve, reject) => {\n       \t if (!promises || promises.length === 0) {\n            return;\n         }\n         for (const item of promises) {\n              promise.resolve(item).then((res) => {\n                  resolve(res);\n                  return;\n              }).catch((err) => {\n                  reject(err);\n                  return;\n              })\n          }\n    });\n}\n\n\n\n# promise.resolve\n\npromise.resolve = function (value) {\n    if (value instanceof promise) return value\n    return new promise(resolve => resolve(value))\n}\n\n// 例子\npromise.resolve(100).then(value => console.log(value))\n\n\n\n# promise\n\n * 三种状态：pending，fulfilled，rejected\n * new promise 时传进来一个执行器（参数是resolve和reject），是立即执行的\n * resolve函数的作用是改变状态为fulfilled，存储成功的值：value\n * reject函数的作用的改变状态为rejected，存储失败的原因：reason\n * then函数有两个参数，成功回调和失败回调，首先判断状态，fulfilled则执行成功回调，rejected则执行失败回调，pending则把回调存储起来\n * then要实现链式调用，需要返回 promise，then方法原来的操作可以放进新建 promise2 的执行器中立即执行，并且需要获取当前的返回值 x，传递给下一个 then 方法\n\nconst pending = 'pending' // 等待\nconst fulfilled = 'fulfilled' // 成功\nconst rejected = 'rejected' //失败\n\nclass mypromise {\n  constructor (executor) {\n    executor(this.resolve, this.reject);\n  }\n  // promise 状态\n  status = pending;\n  // 成功之后的值\n  value = undefined;\n  // 失败后的原因\n  reason = undefined;\n  // 成功回调，用数组的原因是可能有多个 promise.then\n  successcallback = [];\n  // 失败回调\n  failcallback = [];\n  // 定义成箭头函数的好处是 this 指向当前类\n  resolve = value => {\n    // 如果状态不是等待 阻止程序向下执行 因为状态一旦确定就不可以再改变\n    if (this.status !== pending) return;\n    // 将状态更改为成功\n    this.status = fulfilled;\n    // 保存成功之后的值\n    this.value = value;\n    // 判断成功回调是否存在 存在则调用\n    while (this.successcallback.length) {\n     \tthis.successcallback.shift()(this.value);\n    }\n  }\n  reject = reason => {\n    // 如果状态不是等待 阻止程序向下执行\n    if (this.status !== pending) return;\n    // 将状态更改为失败\n    this.status = rejected;\n    // 保存失败后的原因\n    this.reason = reason;\n    // 判断失败回调是否存在 存在则调用\n    while (this.failcallback.length) {\n     \tthis.failcallback.shift()(this.reason); \n    }\n  }\n then = (successcallback, failcallback) => {\n   successcallback = successcallback ? successcallback : value => value;\n   return new mypromise((resolve, reject) => {\n     if (this.status === fullfilled) {\n       let x = successcallback(this.value);\n       x instanceof mypromise ? x.then(resolve, reject) : resolve(x);\n     }\n     else if (this.status === rejected) {\n       failcallback(this.reason);\n     }\n     else {\n       this.successcallback.push(successcallback);\n       this.failcallback.push(failcallback);\n     }\n   });\n }\n catch = (failcallback) => {\n   return this.then(undefined, failcallback);\n }\n}\n\n// 测试\n\n// 1. 测试基本功能\nlet p = new mypromise((resolve, reject) => {\n    resolve('success')\n    reject('fail')\n})\n\np.then(val => {\n  console.log(val)\n}, reason => {\n  console.log(reason)\n})\n\n// 2. 测试异步\nlet p = new mypromise((resolve, reject) => {\n    settimeout(() => {\n        resolve('success')   \n    }, 2000)\n})\n\np.then(val => {\n  console.log(val)\n}, reason => {\n  console.log(reason)\n})\n\n// 3. 测试链式调用\nlet p = new mypromise((resolve, reject) => {\n    resolve('success')\n})\n\np.then(res => {\n    console.log(res)\n    return 100\n}).then(val => {\n    console.log(val)\n})\n\n// 4. 测试 then 返回也是 promise\nlet p = new mypromise((resolve, reject) => {\n    resolve('success')\n})\n\np.then(res => {\n    console.log(res)\n    return new mypromise((resolve, reject) => {\n        resolve('other')\n    })\n}).then(val => {\n    console.log(val)\n})\n\n// 5. 测试 then 不传参数\nlet promise = new mypromise((resolve, reject) => {\n    resolve('成功')\n})\n\np.then().then().then(val => console.log(val))\n\n\n\n# promise封装ajax\n\nfunction ajax (url) {\n    return new promise(function (reslove, reject) {\n        var xhr = new xmlhttprequest()\n        xhr.open('get', url) \n        xhr.reponesetype = 'json'\n        xhr.onload = function () {\n            if(this.status === 200) {\n                reslove(this.response)\n            } else {\n                reject(new error(this.statustext))\n            }\n        }\n        xhr.send()\n    })\n}\n\najax('/api/')\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))\n\n\n//promise.reslove\npromise.resolve('foo')\n    .then(function (value) {\n \t   \t\tconsole.log(value)\n\t\t})\n\n\n\n# 发布订阅模式\n\n    // 类内部存储一个对象，包含事件名和对应的触发函数\n    // { click: [fn1, fn2], change: fn }\n    class eventemitter {\n      constructor () {\n        this.subs = object.create(null)\n      }\n      // 注册事件\n      $on (eventtype, handler) {\n        this.subs[eventtype] = this.subs[eventtype] || []\n        this.subs[eventtype].push(handler)\n      }\n\n      // 触发事件\n      $emit (eventtype) {\n        if (this.subs[eventtype]) {\n          this.subs[eventtype].foreach(handler => {\n            handler()\n          })\n        }\n      }\n    }\n\n    // 测试\n    let em = new eventemitter() // 信号中心\n    em.$on('click', () => {\n      console.log('click1')\n    })\n    em.$on('click', () => {\n      console.log('click2')\n    })\n    em.$emit('click')\n\n\n\n# symbol.iterator\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor (let item of todos) {\n    console.log(item)\n}\n\n\n\n# 数组扁平化\n\n// 不带参数\nfunction flattern(arr) {\n    let res = [];\n    for (const item of arr) {\n        if (array.isarray(item)) {\n            res = res.concat(flattern(item));\n        } else {\n            res.push(item);\n        }\n    }\n    return res;\n}\n// 带参数\nfunction flattern(arr, depth) {\n    let res = []\n    for(let item of arr){\n        if (array.isarray(item) && depth > 0) {\n            res = res.concat(flattern(item, depth - 1))\n        } else {\n            res.push(item)\n        }\n    }\n    return res\n}\n\n// 一次性拍平\nfunction flat(arr) {\n  return arr.tostring().split(',').map(item => +item)\n}\n\n\n\n# 数组去重\n\n（1）reduce + includes\n\nfunction deduplicate(arr) {\n    return arr.reduce((acc, cur) => acc.includes(cur) ? acc : acc.concat(cur), []);\n}\n// concat 不会改变原有数组，返回值为新数组，可拼接单个元素\n\n\n（2）利用es6的set数据结构\n\n> set 类似于数组，且成员值不重复都是唯一的，set本身是一个构造函数。\n\nfunction deduplicate(arr) {\n    return [...new set(arr)];\n}\n\n\n（3）利用sort\n\nfunction deduplicate(arr) {\n    arr = arr.sort();\n    const res = [];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i - 1]) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n}\n\n\n（4）利用includes\n\nfunction deduplicate(arr) {\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (!res.includes(arr[i])) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n}\n\n\n\n# 并发请求控制\n\n> 实现一个批量请求函数 multirequest(urls, maxnum)，要求如下： • 要求最大并发数 maxnum • 每当有一个请求返回，就留下一个空位，可以增加新的请求 • 所有请求完成后，结果按照 urls 里面的顺序依次打出\n\nfunction multirequest(urls = [], maxnum) {\n    const len = urls.length\n    const result = new array(len).fill(false)\n    let count = 0\n  \n    return new promise((resolve, reject) => {\n        while (count < maxnum) {\n            next();\n        }\n        function next() {\n            let current = count++;\n            if (current >= len) {\n                !result.includes(false) && resolve(result);\n                return;\n            }\n            const url = urls[current];\n            fetch(url).then((res) => {\n                result[current] = res;\n                if (current < len) {\n                    next();\n                }\n            }).catch((err) => {\n                result[current] = err;\n                if (current < len) {\n                    next();\n                }\n            })\n        }\n    })\n}\n\n\n\n# 实现一个sleep函数\n\nconst sleep = (time) => {\n  return new promise(resolve => settimeout(resolve, time))\n}\n\nsleep(1000).then(() => {\n  // 这里写你的操作\n})\n\n\n\n# 实现 map 和 reduce\n\narray.prototype.mymap = function(fn) {\n    const arr = this;\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        res[i] = fn(arr[i], i, arr)\n    }\n    return res;\n};\n\narray.prototype.myreduce = function(fn, initvalue) {\n    const arr = this;\n    let val = initvalue || arr[0]\n    for (let i = initvalue ? 0 : 1; i < arr.length; i++) {\n        val = fn(val, arr[i], i, arr)\n    }\n    return val;\n};\n\n\n\n# 实现 'abcd'.f() 返回 'd-c-b-a'\n\nstring.prototype.f = function() {\n    return this.split('').reverse().join('-')\n}\n\n\n\n# object.create\n\n// object.create 实现\nlet o = object.create(obj) // o.__proto__ === obj\nobject.create = function (obj) {\n    function f() {}\n    f.prototype = obj;\n    return new f();\n};\n\n// 可以理解为\nobject.create = function (obj) {\n  return {\n    __proto__: obj\n  }\n}\n",charsets:{cjk:!0}},{title:"面试题（十一）",frontmatter:{title:"面试题（十一）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-11.html",relativePath:"interview/interview-11.md",key:"v-7d9ab412",path:"/interview/interview-11.html",headers:[{level:2,title:"MVVM",slug:"mvvm",normalizedTitle:"mvvm",charIndex:14},{level:2,title:"Vue渲染流程",slug:"vue渲染流程",normalizedTitle:"vue渲染流程",charIndex:22},{level:2,title:"Vue生命周期",slug:"vue生命周期",normalizedTitle:"vue生命周期",charIndex:33},{level:2,title:"父子组件生命周期",slug:"父子组件生命周期",normalizedTitle:"父子组件生命周期",charIndex:1497},{level:2,title:"vue和react的异同",slug:"vue和react的异同",normalizedTitle:"vue和react的异同",charIndex:56},{level:3,title:"1.核心思想",slug:"_1-核心思想",normalizedTitle:"1.核心思想",charIndex:1800},{level:3,title:"vue",slug:"vue",normalizedTitle:"vue",charIndex:56},{level:3,title:"react",slug:"react",normalizedTitle:"react",charIndex:60}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"MVVM Vue渲染流程 Vue生命周期 父子组件生命周期 vue和react的异同 1.核心思想 vue react",content:"# 面试题（十一）\n\n * MVVM\n * Vue渲染流程\n * Vue生命周期\n * 父子组件声明周期\n * vue和react的异同\n\n\n# MVVM\n\nMVVM 对应 3个组成部分，Model（模型）、View（视图） 和 ViewModel（视图模型）。\n\n * View 是用户在屏幕上看到的结构、布局和外观，也称UI。\n * ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。\n * Model 是数据和逻辑。\n\nView 不能和 Model 直接通信，它们只能通过 ViewModel 通信。Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\n严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定。\n\n\n# Vue渲染流程\n\n流程主要分为三个部分：\n\n 1. 模板编译，parse 解析模板生成抽象语法树（AST）；optimize 标记静态节点，在后续页面更新时会跳过静态节点；generate 将AST转成 render 函数，render 函数用于构建 VNode。\n 2. 构建VNode（虚拟dom），构建过程使用 createElement 构建 VNode，createElement 也是自定义 render 函数时接受到的第一个参数。\n 3. VNode转真实dom，patch 函数负责将 VNode 转换成真实dom，核心方法是createElm，递归创建真实dom树，最终渲染到页面上。\n\n\n# Vue生命周期\n\n 1. beforeCreate: 在实例创建之前调用，由于实例还未创建，所以无法访问实例上的 data、computed、method等。\n 2. created: 在实例创建完成后调用，这时已完成数据的观测，可以获取数据和更改数据，但还无法与dom进行交互，如果想要访问dom，可以使用 vm.$nextTick。此时可以对数据进行更改，不会触发 updated。\n 3. beforeMount: 在挂载之前调用，这时的模板已编译完成并生成render函数，准备开始渲染。在此时也可以对数据进行更改，不会触发 updated。\n 4. mounted: 在挂载完成后调用，真实的dom挂载完毕，可以访问到dom节点，使用 $refs 属性对dom进行操作。\n 5. beforeUpdate: 在更新之前调用，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，在当前阶段进行更改数据，不会造成重渲染。\n 6. updated： 在更新完成之后调用，组件dom已完成更新。要注意的是避免在此期间更改数据，这可能会导致死循环。\n 7. beforeDestroy： 在实例销毁之前调用，这时实例还可以被使用，一般这个周期内可以做清除计时器和取消事件监听的工作。\n 8. destroyed： 在实例销毁之后调用，这时已无法访问实例。当前实例从父实例中被移除，观测被卸载，所有事件监听器呗移除，子实例也统统被销毁。\n\n> created时已经可以访问到data和methods了，可以在此时进行调用接口。\n> \n> mounted是可以访问到DOM了，需要用到DOM的操作可以在此进行。\n\n\n# 父子组件生命周期\n\n加载渲染过程：\n\n> 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n\n子组件更新过程：\n\n> 父beforeUpdate->子beforeUpdate->子updated->父updated\n\n父组件更新过程：\n\n> 父beforeUpdate->父updated\n\n销毁过程：\n\n> 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n\n\n# vue和react的异同\n\n\n# 1.核心思想\n\nvue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。\n\n\n# vue\n\nvue的整体思想仍然是拥抱经典的html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等等)，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。另一方面，在针对组件数据上，vue2.0通过Object.defineProperty对数据做到了更细致的监听，精准实现组件级别的更新。\n\n\n# react\n\nreact整体上是函数式的思想，组件使用jsx语法，all in js，将html与css全都融入javaScript，jsx语法相对来说更加灵活，我一开始刚转过来也不是很适应，感觉写react应用感觉就像是在写javaScript。当组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent可以避免不必要的重新渲染（个人感觉这一点上不如vue做的好）。",normalizedContent:"# 面试题（十一）\n\n * mvvm\n * vue渲染流程\n * vue生命周期\n * 父子组件声明周期\n * vue和react的异同\n\n\n# mvvm\n\nmvvm 对应 3个组成部分，model（模型）、view（视图） 和 viewmodel（视图模型）。\n\n * view 是用户在屏幕上看到的结构、布局和外观，也称ui。\n * viewmodel 是一个绑定器，能和 view 层和 model 层进行通信。\n * model 是数据和逻辑。\n\nview 不能和 model 直接通信，它们只能通过 viewmodel 通信。model 和 viewmodel 之间的交互是双向的，viewmodel 通过双向数据绑定把 view 层和 model 层连接起来，因此 view 数据的变化会同步到 model 中，而 model 数据的变化也会立即反应到 view 上。\n\n严格的 mvvm 要求 view 不能和 model 直接通信，而 vue 在组件提供了 $refs 这个属性，让 model 可以直接操作 view，违反了这一规定。\n\n\n# vue渲染流程\n\n流程主要分为三个部分：\n\n 1. 模板编译，parse 解析模板生成抽象语法树（ast）；optimize 标记静态节点，在后续页面更新时会跳过静态节点；generate 将ast转成 render 函数，render 函数用于构建 vnode。\n 2. 构建vnode（虚拟dom），构建过程使用 createelement 构建 vnode，createelement 也是自定义 render 函数时接受到的第一个参数。\n 3. vnode转真实dom，patch 函数负责将 vnode 转换成真实dom，核心方法是createelm，递归创建真实dom树，最终渲染到页面上。\n\n\n# vue生命周期\n\n 1. beforecreate: 在实例创建之前调用，由于实例还未创建，所以无法访问实例上的 data、computed、method等。\n 2. created: 在实例创建完成后调用，这时已完成数据的观测，可以获取数据和更改数据，但还无法与dom进行交互，如果想要访问dom，可以使用 vm.$nexttick。此时可以对数据进行更改，不会触发 updated。\n 3. beforemount: 在挂载之前调用，这时的模板已编译完成并生成render函数，准备开始渲染。在此时也可以对数据进行更改，不会触发 updated。\n 4. mounted: 在挂载完成后调用，真实的dom挂载完毕，可以访问到dom节点，使用 $refs 属性对dom进行操作。\n 5. beforeupdate: 在更新之前调用，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，在当前阶段进行更改数据，不会造成重渲染。\n 6. updated： 在更新完成之后调用，组件dom已完成更新。要注意的是避免在此期间更改数据，这可能会导致死循环。\n 7. beforedestroy： 在实例销毁之前调用，这时实例还可以被使用，一般这个周期内可以做清除计时器和取消事件监听的工作。\n 8. destroyed： 在实例销毁之后调用，这时已无法访问实例。当前实例从父实例中被移除，观测被卸载，所有事件监听器呗移除，子实例也统统被销毁。\n\n> created时已经可以访问到data和methods了，可以在此时进行调用接口。\n> \n> mounted是可以访问到dom了，需要用到dom的操作可以在此进行。\n\n\n# 父子组件生命周期\n\n加载渲染过程：\n\n> 父beforecreate->父created->父beforemount->子beforecreate->子created->子beforemount->子mounted->父mounted\n\n子组件更新过程：\n\n> 父beforeupdate->子beforeupdate->子updated->父updated\n\n父组件更新过程：\n\n> 父beforeupdate->父updated\n\n销毁过程：\n\n> 父beforedestroy->子beforedestroy->子destroyed->父destroyed\n\n\n# vue和react的异同\n\n\n# 1.核心思想\n\nvue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。\n\n\n# vue\n\nvue的整体思想仍然是拥抱经典的html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等等)，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。另一方面，在针对组件数据上，vue2.0通过object.defineproperty对数据做到了更细致的监听，精准实现组件级别的更新。\n\n\n# react\n\nreact整体上是函数式的思想，组件使用jsx语法，all in js，将html与css全都融入javascript，jsx语法相对来说更加灵活，我一开始刚转过来也不是很适应，感觉写react应用感觉就像是在写javascript。当组件调用setstate或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldcomponentupdate或者purecomponent可以避免不必要的重新渲染（个人感觉这一点上不如vue做的好）。",charsets:{cjk:!0}},{title:"手写代码（二）",frontmatter:{title:"手写代码（二）",date:"2020-03-20T09:52:01.000Z",categories:"面试"},regularPath:"/interview/code-2.html",relativePath:"interview/code-2.md",key:"v-31a181ab",path:"/interview/code-2.html",headers:[{level:2,title:"new相关",slug:"new相关",normalizedTitle:"new相关",charIndex:14},{level:2,title:"Promise相关",slug:"promise相关",normalizedTitle:"promise相关",charIndex:23},{level:2,title:"作用域相关",slug:"作用域相关",normalizedTitle:"作用域相关",charIndex:36},{level:2,title:"this相关",slug:"this相关",normalizedTitle:"this相关",charIndex:45},{level:2,title:"css相关",slug:"css相关",normalizedTitle:"css相关",charIndex:55},{level:2,title:"原型相关",slug:"原型相关",normalizedTitle:"原型相关",charIndex:64},{level:2,title:"正则相关",slug:"正则相关",normalizedTitle:"正则相关",charIndex:72},{level:2,title:"场景题",slug:"场景题",normalizedTitle:"场景题",charIndex:80},{level:3,title:"解析url中",slug:"解析url中",normalizedTitle:"解析url中",charIndex:11110},{level:3,title:"repeat函数",slug:"repeat函数",normalizedTitle:"repeat函数",charIndex:12769},{level:3,title:"找k好成绩",slug:"找k好成绩",normalizedTitle:"找k好成绩",charIndex:13126},{level:3,title:"进制转换",slug:"进制转换",normalizedTitle:"进制转换",charIndex:13614},{level:3,title:"随机生成16进制",slug:"随机生成16进制",normalizedTitle:"随机生成16进制",charIndex:13838},{level:3,title:"16进制颜色转 rgb",slug:"_16进制颜色转-rgb",normalizedTitle:"16进制颜色转 rgb",charIndex:13943},{level:3,title:"有序数组找数求和",slug:"有序数组找数求和",normalizedTitle:"有序数组找数求和",charIndex:14286},{level:3,title:"判断2的整数次幂",slug:"判断2的整数次幂",normalizedTitle:"判断2的整数次幂",charIndex:14638},{level:3,title:"对象转为数组键值对",slug:"对象转为数组键值对",normalizedTitle:"对象转为数组键值对",charIndex:14846},{level:3,title:"开根号",slug:"开根号",normalizedTitle:"开根号",charIndex:14992},{level:3,title:"并发请求控制",slug:"并发请求控制",normalizedTitle:"并发请求控制",charIndex:15033},{level:3,title:"尝试重新请求",slug:"尝试重新请求",normalizedTitle:"尝试重新请求",charIndex:15913},{level:3,title:"loading动画",slug:"loading动画",normalizedTitle:"loading动画",charIndex:17133},{level:3,title:"实现一个cash类",slug:"实现一个cash类",normalizedTitle:"实现一个cash类",charIndex:17556},{level:3,title:"字符串替换",slug:"字符串替换",normalizedTitle:"字符串替换",charIndex:18741},{level:2,title:"判断对象有没有空值",slug:"判断对象有没有空值",normalizedTitle:"判断对象有没有空值",charIndex:19250}],lastUpdated:"3/16/2023, 6:45:18 PM",lastUpdatedTimestamp:1678963518e3,headersStr:"new相关 Promise相关 作用域相关 this相关 css相关 原型相关 正则相关 场景题 解析url中 repeat函数 找k好成绩 进制转换 随机生成16进制 16进制颜色转 rgb 有序数组找数求和 判断2的整数次幂 对象转为数组键值对 开根号 并发请求控制 尝试重新请求 loading动画 实现一个cash类 字符串替换 判断对象有没有空值",content:"# 手写代码（二）\n\n * new相关\n * Promise相关\n * 作用域相关\n * this相关\n * css相关\n * 原型相关\n * 正则相关\n * 场景题\n\n\n# new相关\n\nfunction Person(name) {\n  this.name = name\n  return name\n}\n\nlet p = new Person('Tom')\n// 返回什么 Person {name: \"Tom\"}\n\n\nfunction Person(name) {\n  this.name = name\n  return {}\n}\n\nlet p = new Person('Tom')\n// 返回什么 {}\n\n\n构造函数不需要显式的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值（忽略return）;如果return的是对象（如果是对象哪么就会丢失原有对象），则返回该对象。\n\n\n# Promise相关\n\nfunction a() {\n    console.log('a')\n    Promise.resolve().then(() => {\n        console.log('e')\n    })\n}\nfunction b() {\n    console.log('b')\n}\nfunction c() {\n    console.log('c')\n}\nfunction d() {\n    setTimeout(a, 0)\n\n    var temp = Promise.resolve().then(b) \n    setTimeout(c, 0)\n    console.log('d')\n}\n\nd() // d b a e c\n\n\n> 最常见的面试题\n\nasync function async1(){\n    console.log('async1 start')  //2\n    await async2()               \n    console.log('async1 end')    //6 放入了微队列  \n}                                //    相当于async2.then(()=>{console.log('async1 end')})\nasync function async2(){\n    console.log('async2')       //3\n}\nconsole.log('script start')     //1\nsetTimeout(function(){\n    console.log('setTimeout')   //8\n},0)\nasync1()\nnew Promise(function(resolve){\n    console.log('promise1')     //4\n    resolve()\n}).then(function(){\n    console.log('promise2')    //7   放入了微队列\n})\nconsole.log('script end')     //5\n\n//await是一个让出线程的标志。await后面的表达式会先执行一遍，将await 后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\n\n> 上题变形\n\nasync function async1() {\n    console.log('async1 start')\n    await async2() \n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2 start')\n    return new Promise((resolve, reject) => {\n        resolve()\n        console.log('async2 promise')\n    })\n}\nconsole.log('script start')\nsetTimeout(function() {\n    console.log('setTimeout')\n}, 0)\nasync1()\nnew Promise(function(resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function() {\n    console.log('promise2')\n}).then(function() {\n    console.log('promise3')\n})\nconsole.log('script end')\n\n/**\nscript start\nasync1 start\nasync2 start\nasync2 promise\npromise1\nscript end\npromise2\npromise3\nasync1 end     注意这里 async 显示返回了 promise ，最后执行\nsetTimeout\n*/\n\n\n> 微任务里再加一个微任务\n\nconsole.log(1);\nsetTimeout(() => {\n  console.log(2);\n});\nnew Promise(resolve => {\n  console.log(5);\n  resolve();\n  console.log(6);\n}).then(() => {\n  console.log(7);\n});\nPromise.resolve().then(() => {\n  console.log(8);\n  process.nextTick(() => {\n    console.log(9);\n  });\n});\n// 1 5 6 7 8 9 2\n\n\n> 设计一个 defer 函数，实现defer(3000).then(res => { // 30ms 后执行 }) ;\n> \n> 分析：延时函数\n\nfunction defer(time) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(1)\n        }, time)\n    })\n}\n\ndefer(3000).then(res => {\n    console.log(res)\n})\n// 或者\nfunction defer(time) {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time, 1)\n    })\n}\n\ndefer(3000).then(res => {\n    console.log(res)\n})\n\n\n> 改写回调\n\nsetTimeout(() => {\n    console.log(1)\n    setTimeout(() => {\n        console.log(2)\n        setTimeout(() => {\n            console.log(3)\n        }, 3000)\n    }, 2000)\n}, 1000)\n\n// promise 改写\nlet fn = (value, time) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(value)\n            resolve()\n        }, time)\n    })\n}\nfn(1, 1000).then(() => fn(2, 2000)).then(() => fn(3, 3000))\n\n// async await 改写\nasync function todo() {\n    await fn(1, 1000)\n    await fn(2, 2000)\n    await fn(3, 3000)\n}\ntodo()\n\n\n> 交替执行\n\nPromise.resolve().then(() => {\n    console.log('a')\n}).then(() => {\n    console.log('b')\n}).then(() => {\n    console.log('c')\n}).then(() => {\n    console.log('d')\n}).then(() => {\n    console.log('e')\n})\n\nPromise.resolve().then(() => {\n    console.log(1)\n}).then(() => {\n    console.log(2)\n}).then(() => {\n    console.log(3)\n}).then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n\n// a 1 b 2 c 3 d 4 e 5\n\n\nPromise.resolve().then(() => {\n    console.log(0)\n    return Promise.resolve(4)\n  \t/**\n  \t\t相当于这里多了两个微任务，然后交替执行\n  \t\t因为返回值可能是 Promise 的嵌套，当前 then 一定递归计算它的最终值，传给下一个 then 的回调\n  \t*/\n}).then(res => {\n    console.log(res)\n})\n\nPromise.resolve().then(() => {\n    console.log(1)\n}).then(() => {\n    console.log(2)\n}).then(() => {\n    console.log(3)\n}).then(() => {\n    console.log(5)\n}).then(() => {\n    console.log(6)\n})\n\n// 0 1 2 3 4 5 6\n\n\nconsole.log(1); \nsetTimeout(() => {\n  console.log(2);\n});\nnew Promise(resolve => {\n  console.log(3);\n  resolve('resolve');\n  console.log(4);\n  reject('error')\n}).catch((err) => {\n  console.log(err);\n}).then((res) => {\n  console.log(res)\n});\nPromise.resolve().then(() => {\n  console.log(5);\n});\nconsole.log(6);\n\n// 1 3 4 6 5 resolve 2\n\n\nsetTimeout(() => {\n    console.log(\"setTimeout\");\n});\nconsole.log(1);\nnew Promise(function(resolve, reject) {\n    console.log(2);\n    for (var i = 0; i < 1000; i ++) {\n        if (i === 10) {\n            console.log(10);\n        }\n        if (i === 999) {\n            resolve(999);\n        }\n    }\n    console.log(3); // resolve后面的代码依旧会执行\n}).then((val) => {\n    console.log(val);\n});\nconsole.log(4);\n\n// 1 2 10 3 4 999 setTimeout\n\n\n\n# 作用域相关\n\nvar length = 10;\nfunction fn() {\n    return this.length+1;\n}\nvar obj = {\n    length: 5,\n    test1: function() {\n        return fn();\n    }\n};\nobj.test2 = fn;\nconsole.log(obj.test1()) // 11\nconsole.log(fn() === obj.test1()) // true\n\n\n\nvar a = function () { \n    this.b =3\n}\nvar c = new a()\na.prototype.b = 9\nvar b = 7\na()\nconsole.log(b) // 3\nconsole.log(c.b) // 3\n\n\n\nvar obj1 = (function() {\n  var inner = '1-1';\n  return {\n    inner: '1-2',\n    say: function() {\n      console.log(inner); \n      console.log(this.inner);\n    }\n  }\n})();\n\nvar obj2 = { inner: '2-1' }\ndebugger\nobj1.say(); // 1-1, 1-2\nobj2.say = obj1.say;\nobj2.say(); // 1-1, 2-1\n\nvar a = 3\n(function (){\n    console.log(a)\n    var a = 4;\n})()\n// Uncaught TypeError: 3 is not a function\n\nvar a = 3;\n(function (){\n    console.log(a)\n    var a = 4;\n})()\n// undefined\n\n\nvar name = '123';\nvar obj = {\n   name: '456',\n   getName: function () {\n       function printName () {\n           console.log(this.name);\n       }\n       printName();\n   }\n}\nobj.getName(); // 123\n\n\n\nvar obj = {\n    say: function () {\n        var f1 = () => {\n            console.log(this)\n        }\n        f1()\n    },\n    pro: {\n        getPro: () => {\n            console.log(this)\n        }\n    }\n}\nvar o = obj.say\no() // window\nobj.say() // obj\nobj.pro.getPro() // window\n\n\nfunction a(b, c) {\n    var b;\n    alert(b); // 1\n}\na(1, 2);\n\n\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i)\n    }, 1000 * i)\n}\n// 每隔一秒输出一次 5，时间中的i作为参数成功传了进去，定时器加入队列，最后执行的时候从作用域找i，为5\n\nfor (var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function() {\n            console.log(i)\n        }, 1000 * i)\n    })(i)\n}\n// 输出0，1，2，3，4，闭包，i的值会保存下来\n\nfor (var i = 0; i < 5; i++) {\n    (function() {\n        setTimeout(function() {\n            console.log(i)\n        }, 1000 * i)\n    })(i)\n}\n// 每隔一秒输出一次 5，i的值没有传进去\n\n\n\n# this相关\n\nfunction Person() {  \n    this.age = 0;  \n    setTimeout(() => {\n        this.age++; // 指向 Person\n    }, 3000);\n}\nvar p = new Person();\n\n\nfunction Person() {  \n    this.age = 0\n    setTimeout(function() {\n        console.log(this) // 指向 window\n    }, 3000)\n}\nvar p = new Person();\n\n// 顺便复习以下箭头函数语法\nvar func1 = x => x;\nvar func2 = x => {x};\nvar func3 = x => ({x});\nconsole.log(func1(1)); // 1\nconsole.log(func2(1)); // undefined\nconsole.log(func3(1)); // {x: 1}\n\n\nconst fn = () => {\nthis.x = 'z';\n};\n\nconst b = {x: 'y'};\nfn.call(b);\nconsole.log(b); // {x: 'y'};\n\n\n\n# css相关\n\n<div class=\"lightblue\">\n   <div class=\"darkblue\">\n      <p>1. 颜色是？</p> \x3c!-- 深蓝 ，p没设置，继承上面的--\x3e\n   </div>\n</div>\n<div class=\"darkblue\">\n   <div class=\"lightblue\">\n      <p>2. 颜色是？</p> \x3c!-- 浅蓝 --\x3e\n   </div>\n</div>\n.lightblue { color: lightblue; }\n.darkblue { color: darkblue; }\n\n\x3c!-------------------------------------------\x3e\n\n<div class=\"lightblue\"> \n   <div class=\"darkblue\"> \x3c!-- 深蓝 --\x3e\n      <p>1. 颜色是？</p>\n   </div>\n</div>\n<div class=\"darkblue\">\n   <div class=\"lightblue\"> \x3c!-- 深蓝 --\x3e\n      <p>2. 颜色是？</p>\n   </div>\n</div>\n.lightblue p { color: lightblue; } \x3c!-- 优先级相同都是10 + 1，写在后面的覆盖写在前面的 --\x3e\n.darkblue p { color: darkblue; }\n\n\n<style>\n    .green {\n        background-color: green;\n    }\n\n    .red {\n        background-color: red;\n    }\n\n    .blue {\n        background-color: blue;\n    }\n</style>\n<body>\n    <div class=\"green blue red\">\n        fsdfasdfasd\n    </div>\n</body>\n\n\x3c!-- 蓝色 --\x3e\n\n\n\n# 原型相关\n\nfunction Animal() {}\nvar cat = new Animal();\nAnimal.prototype = {bark: true}; // 破坏了原型链\nvar dog = new Animal();\nconsole.log(cat.bark); // undefined\nconsole.log(dog.bark); // true\n\n\nfunction Animal() {}\nvar cat = new Animal();\nAnimal.prototype.bark = true;\nvar dog = new Animal();\nconsole.log(cat.bark); // true\nconsole.log(dog.bark); // true\n\nfunction Person(name) {\n\tthis.name = name;\n}\nPerson.prototype.print = function() {\n\treturn this.name;\n};\n\nconst a = new Person('abc').print.call({});\nconsole.log(a); // undefined\n\n\n// 怎么实现一个多重继承。。可以在一个object对象即可以输出M1的hello也可以输出M2.world\nfunction M1() {\nthis.hello = 'hello';\n}\n\nfunction M2() {\nthis.world = 'world';\n}\n\n// 首先让 M2 继承 M1\nM2.prototype = new M1()\n\nlet obj = {}\nobj.__proto__ = new M2()\n\nconsole.log(obj.hello, obj.world) // hello world\n\n\nFunction.prototype.a = () => console.log(1); \nObject.prototype.b = () => console.log(2); \nfunction A() {} const a = new A(); \na.a(); // a.a is not a function\na.b(); // 2\n\na.__proto__.__proto__ === A.prototype.__proto__ === Object.prototype\nA.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototype\n\n\n// 写下p、Parent、Function、Object的原型链\nfunction Parent() {}\nvar p = new Parent()\n\nconsole.log(p.__proto__ === Parent.prototype) // true\nconsole.log(Parent.__proto__ === Function.prototype) // true\nconsole.log(Parent.prototype.__proto__ === Object.prototype) // true\nconsole.log(Function.prototype.__proto__ === Object.prototype) // true\nconsole.log(Object.__proto__ === Function.prototype) // true\n\n\n\n# 正则相关\n\n * 正则中需要转义的字符：* . ? + $ ^ [ ] ( ) { } | \\ /\n\nvar a = 'hi, my name is {name}, I am {age} years old, my email is {email}.';\nvar b = {name:'max', age: 12, email: 'max@gmail.com'};\n\n\nfunction replace(tpl, data){\n    return tpl.replace(/\\{(\\w+)\\}/g, (matchStr, group) => data[group])\n}\n\n\n// 下划线转换驼峰\nconst toHump = str => {\n    return str.replace(/\\_(\\w)/g, (matchStr, group) => group.toUpperCase())\n}\n\n// 驼峰转换下划线\nconst toLine = str => {\n    return str.replace(/([A-Z])/g, (matchStr, group) => `_${group.toLowerCase()}`)\n}\n\n\n\n# 场景题\n\n> 爬虫在爬取页面前，需要对url列表进行标准化，实现一个处理url列表的函数-对缺少http前缀的url添加前缀，返回的url不能重复\n> \n> [\"nodejs.org\", \"http://nodejs.org\", \"http://bytedance.com\"] => [\"http://nodejs.org\", \"http://bytedance.com\"]\n\nfunction formaturl(urllist){\n    const res = []\n    for (let i in urllist) {\n        const reg = /^http:\\/\\//\n        const url = urllist[i]\n        const newUrl = reg.test(url) ? url : `http://${url}`\n        if (!res.includes(newUrl)) {\n            res.push(newUrl)\n        }\n    }\n    return res\n}\n\n\n\n# 解析url中\n\n参数为对象，考虑 key 重复，没有 val 和 转码\n\n// https://weibo.com/u/1627615060/home?wvr=5&from_outside&key=12&key=4&l=%E4%BB%8A%E6%97%A5%E7%89%B9%E5%8D%96\n\nconst getQuery = url => {\n    let query = {}\n    if (url.includes(\"?\")) {\n        const str = url.split(\"?\")[1]\n        const params = str.split(\"&\")\n        for(let i = 0; i < params.length; i++) {\n            let key = null, val = null\n            if (params[i].includes(\"=\")) {\n                key = params[i].split(\"=\")[0]\n                val = decodeURIComponent(params[i].split(\"=\")[1])\n            } else {\n                key = params[i]\n                val = null\n            }\n            if (query[key]) {\n                Array.isArray(query[key]) ?\n                    query[key].push(val) : query[key] = [query[key], val]\n            } else {\n                query[key] = val\n            }\n        }\n    }\n    return query\n}\n\n\n> 实现如下效果u.console(\"hello\").settimeout(3000).console(\"world\").settimeout(3000).console(\"hah\").settimeout(0).console(\"111\")，首先输出hello，3s后输出world,再间隔3s,再输出\n\n// 考点 this 是立即返回的，setTimeout 加入任务队列，时间需要累加计算\nclass U {\n    constructor() {\n        this.time = null\n        this.totalTime = 0\n    }\n\n    console(val) {\n        if (this.time === null) {\n            console.log(val)\n        } else {\n            this.totalTime += this.time\n            setTimeout(() => {\n                console.log(val)\n            }, this.totalTime)\n        }\n        return this\n    }\n\n    settimeout(time) {\n        this.time = time\n        return this\n    }\n}\n\nlet u = new U()\nu.console(\"hello\").settimeout(3000).console(\"world\").settimeout(3000).console(\"hah\").settimeout(0).console(\"111\")\n\n\n\n# repeat函数\n\n> 使下面调用代码能正常工作 const repeatFunc = repeat(console.log, 4, 3000); repeatFunc(\"helloworld\") //会输出4次 helloworld, 每次间隔3秒\n\n// 需要实现的函数\nfunction repeat (func, times, wait) {\n    return function() {\n        for (let i = 1; i <= times; i++) {\n            setTimeout(() => {\n                func(...arguments)\n            }, wait * i)\n        }\n    }\n}\n\n\n\n# 找k好成绩\n\n> 从一个包含学生成绩数组的中找到成绩第k好的所有学生的id, 学生信息如下：[{score:89,id:1}, {score:23,id:4}]。\n\nconst findK = (arr, k) => {\n    const store = Array.from(new Array(101), () => new Array())\n    for (let i = 0; i < arr.length; i++) {\n        store[arr[i].score].push(arr[i].id)\n    }\n    let count = 0\n    for (let i = 100; i >= 0; i--) {\n        if (!store[i].length) continue\n        count++\n        if (k === count) return store[i]\n    }\n}\n\n// 注：创建二维数组时，千万不要 new Array(101).fill([]), [] 指向的都是同一个\n\n\n\n# 进制转换\n\nfunction mulBase(num, base){\n    let str = \"\"\n    while (num !== 0) {\n        str += num % base\n        num = Math.floor(num / base)\n    }\n    return str.split('').reverse().join('')\n}\nconsole.log(mulBase(64,8));\n\n\n\n# 随机生成16进制\n\nfunction geneHex() {\n  return \"#\" + Math.floor((Math.random() * 0xFFFFFF)).toString(16)\n}\n\n\n\n# 16进制颜色转 rgb\n\nfunction hex2rgb(hex) {\n    const str = hex.slice(1),\n        res = []\n    if (str.length === 3) {\n        for (const w of str) {\n            res.push(parseInt(w + w, 16))\n        }\n    } else {\n        for (let i = 0; i < 6; i += 2) {\n            res.push(parseInt(str[i] + str[i + 1], 16))\n        }\n    }\n    return res\n}\n\n\n\n# 有序数组找数求和\n\n> 输入：[1,2,3,4,5]， 6\n\n * 双指针\n\nfunction foo(arr, target) {\n    let left = 0, right = arr.length - 1\n    while (left < right) {\n        if (arr[left] + arr[right] > target) {\n            right --\n        } else if (arr[left] + arr[right] === target) {\n            return [left, right]\n        } else {\n            left ++\n        }\n    }\n}\n\n\n\n# 判断2的整数次幂\n\n// 2: 10, 4: 100, 8: 1000, 16: 10000\n// 可以发现2的整数次幂都是1后面跟着许多0，如果减1分别对应\n// 1: 01, 3: 011, 7: 0111, 15: 01111\n// 如果作与运算，2 & 1 == 0，4 & 3 == 0\nfunction judge(num) {\n  return (num&(num - 1)) == 0\n}\n\n\n\n# 对象转为数组键值对\n\n{\n  name: 'A',\n\tage: 10\n}\n// 转换为\n[\n  {\n        key: 'name',\n        value: 'A'\n\t},\n\t{\n        key: 'age',\n        value: 10\n  }\n]\n\n\n\n# 开根号\n\n要求位数 0.0001，考虑 0 - 1 开根号越来越大\n\n\n\n\n\n# 并发请求控制\n\nfunction multiRequest(urls = [], maxNum) {\n    const len = urls.length\n    const result = new Array(len).fill(false)\n    let count = 0\n\n    return new Promise((resolve, reject) => {\n        while (count < maxNum) {\n            next()\n        }\n        function next() {\n            let current = count++\n            if (current >= len) {\n                !result.includes(false) && resolve(result)\n                return\n            }\n            const url = urls[current]\n            fetch(url)\n                .then((res) => {\n                    result[current] = res\n                    if (current < len) {\n                        next()\n                    }\n                })\n            .catch((err) => {\n                result[current] = err\n                if (current < len) {\n                    next()\n                }\n            })\n        }\n    })\n}\n\n\n\n# 尝试重新请求\n\nfunction requestRetry (url, retryNum) {\n    return request(url).catch(e => {\n        if (retryNum) {\n            return requestRetry(url, --retryNum)\n        } else {\n            return Promise.reject(e)\n        }\n    })\n}\n\n\n失败测试\n\nfunction tryRequest(request, times = 3) {\n    return request().catch(e => {\n        if (times) {\n            console.log('正在重试')\n            return tryRequest(request, --times)\n        } else {\n            return Promise.reject(e)\n        }\n    })\n}\n\nfunction request() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            reject('error')\n        }, 1000)\n    })\n}\n\ntryRequest(request, 3).then(console.log).catch(console.log)\n\n// 正在重试\n// 正在重试\n// 正在重试\n// error\n\n\n成功测试\n\nfunction tryRequest(request, times = 3) {\n    return request().catch(e => {\n        if (times) {\n            console.log('正在重试')\n            return tryRequest(request, --times)\n        } else {\n            return Promise.reject(e)\n        }\n    })\n}\n\nfunction request() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('success')\n        }, 1000)\n    })\n}\n\ntryRequest(request, 3).then(console.log).catch(console.log) // success\n\n\n\n# loading动画\n\n> vue项目中：loading控制页面加载动画，sort是一个消耗时间的排序操作，问loading动画会显示吗？\n\nthis.loading = true\nthis.data.sort()\nthis.loading = false\n\n// 答：不会，vue更新视图是异步的，虽然sort消耗时间，还是会把loading数据的改变缓冲为一次\n\nthis.loading = true // 宏\nthis.$nextTick(() => { // 微\n  this.data.sort()\n  this.loading = false\n})\n\n// 还是不会，$nextTick优先使用微任务，宏 => 微 => ui渲染\n\nthis.loading = true\nsetTimeout(() => {\n  this.data.sort()\n  this.loading = false\n}, 5000)\n// 会\n\n\n\n# 实现一个cash类\n\n//实现一个 Cash 类，期望执行下面代码：\nconst cash1 = new Cash(105);\nconst cash2 = new Cash(66);\nconst cash3 = cash1.add(cash2);\nconst cash4 = Cash.add(cash1, cash2);\nconst cash5 = new Cash(cash1 + cash2); // 考虑 valueOf\nconsole.log(`${cash3}`, `${cash4}`, `${cash5}`); // 考虑 toString\n// 1元7角1分 1元7角1分 1元7角1分\n\n\n// 写之前先复习一下 valueOf 和 toString\nconst a = {\n    val: 1,\n    valueOf() {\n        console.log('valueOf')\n        return this.val\n    },\n    toString() {\n        console.log('toString')\n        return this.val\n    }\n}\nconsole.log(a) // {val: 1, valueOf: ƒ, toString: ƒ}\nconsole.log(a + \"\") // valueOf 1\nconsole.log(a + 1) // valueOf 2\nconsole.log(a + {}) // valueOf 1[object Object]\nconsole.log(`${a}`) // toString 1\n\n\nclass Cash {\n    constructor(num) {\n        this.num = num\n    }\n    add(c1) {\n        return new Cash(this + c1)\n    }\n    static add(c1, c2) {\n        return new Cash(c1 + c2)\n    }\n    // valueOf 用于处理 new Cash(cash1 + cash2)\n    valueOf() {\n        return this.num\n    }\n    // toString 用于处理 cash3 => `${cash3}`\n    toString() {\n        this.sum=`${this.num}`\n        return `${this.sum[0]}元${this.sum[1]}角${this.sum[2]}元`\n    }\n}\n\n\nclass中static方法中的this指向哪里\n\n\n# 字符串替换\n\n\"ababab\".match(/a.*b/) // \"ababab\"，.是任意字符，贪婪匹配，尽可能多的匹配\n\"ababab\".match(/a.*?b/) // \"ab\"，非贪婪，尽可能少的匹配\n\n\nconst template = \"{{name }}很厉name害，才{{age }}岁\"\nconst context = { name: \"jawil\", age: \"15\" }\n\n// vue 插值表达式\nfunction fn(template, context) {\n    return template.replace(/\\{\\{(.*?)\\}\\}/g, (matchStr, group) => {\n        return context[group.trim()]\n    })\n}\n\n// es6模板字符串\nfunction replaceStr(str, obj) {\n    return str.replace(/\\$\\{(.*?)\\}/g, (matchStr, group) => {\n        return obj[group]\n    })\n}\n\n\n\n# 判断对象有没有空值\n\n> 判断一个对象没有空属性（undefined、 null）\n\n// 测试用例\nconst obj1 = {\n  prop1:{\n    subProp1: 0,\n    subPorp2: undefined,\n    subProp3: {\n      pp1: 123,\n      pp2: \"\"\n    },\n\t},\n\tprop2:\"test\"\n}\n\n// 递归\nfunction hasEmptyProp(obj){\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            if (obj[key] === null || obj[key] === undefined) {\n                return true\n            } else if (typeof obj[key] === 'object') {\n                if (hasEmptyProp(obj[key])) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n// 这种为什么不对？return 是箭头函数内部的 return，所以整体函数会一直返回 false\nfunction hasEmptyProp(obj){\n    Object.keys(obj).forEach(key => {\n      \tif (obj[key] === null || obj[key] === undefined) {\n          return true\n        } else if (typeof obj[key] === 'object') {\n          if (hasEmptyProp(obj[key])) {\n            return true\n          }\n        }\n    })\n    return false\n}\n\n// 非递归，对象可以理解为树，用广度优先的思想\nfunction hasEmptyProp(obj){\n    const queue = [obj]\n    while (queue.length) {\n        let prop = queue.shift()\n        if (prop === null || prop === undefined) {\n            return true\n        } else if (typeof prop === 'object') {\n            for (let key in prop) {\n                queue.push(prop[key])\n            }\n        }\n    }\n    return false\n}\n",normalizedContent:"# 手写代码（二）\n\n * new相关\n * promise相关\n * 作用域相关\n * this相关\n * css相关\n * 原型相关\n * 正则相关\n * 场景题\n\n\n# new相关\n\nfunction person(name) {\n  this.name = name\n  return name\n}\n\nlet p = new person('tom')\n// 返回什么 person {name: \"tom\"}\n\n\nfunction person(name) {\n  this.name = name\n  return {}\n}\n\nlet p = new person('tom')\n// 返回什么 {}\n\n\n构造函数不需要显式的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值（忽略return）;如果return的是对象（如果是对象哪么就会丢失原有对象），则返回该对象。\n\n\n# promise相关\n\nfunction a() {\n    console.log('a')\n    promise.resolve().then(() => {\n        console.log('e')\n    })\n}\nfunction b() {\n    console.log('b')\n}\nfunction c() {\n    console.log('c')\n}\nfunction d() {\n    settimeout(a, 0)\n\n    var temp = promise.resolve().then(b) \n    settimeout(c, 0)\n    console.log('d')\n}\n\nd() // d b a e c\n\n\n> 最常见的面试题\n\nasync function async1(){\n    console.log('async1 start')  //2\n    await async2()               \n    console.log('async1 end')    //6 放入了微队列  \n}                                //    相当于async2.then(()=>{console.log('async1 end')})\nasync function async2(){\n    console.log('async2')       //3\n}\nconsole.log('script start')     //1\nsettimeout(function(){\n    console.log('settimeout')   //8\n},0)\nasync1()\nnew promise(function(resolve){\n    console.log('promise1')     //4\n    resolve()\n}).then(function(){\n    console.log('promise2')    //7   放入了微队列\n})\nconsole.log('script end')     //5\n\n//await是一个让出线程的标志。await后面的表达式会先执行一遍，将await 后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsettimeout\n\n\n> 上题变形\n\nasync function async1() {\n    console.log('async1 start')\n    await async2() \n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2 start')\n    return new promise((resolve, reject) => {\n        resolve()\n        console.log('async2 promise')\n    })\n}\nconsole.log('script start')\nsettimeout(function() {\n    console.log('settimeout')\n}, 0)\nasync1()\nnew promise(function(resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function() {\n    console.log('promise2')\n}).then(function() {\n    console.log('promise3')\n})\nconsole.log('script end')\n\n/**\nscript start\nasync1 start\nasync2 start\nasync2 promise\npromise1\nscript end\npromise2\npromise3\nasync1 end     注意这里 async 显示返回了 promise ，最后执行\nsettimeout\n*/\n\n\n> 微任务里再加一个微任务\n\nconsole.log(1);\nsettimeout(() => {\n  console.log(2);\n});\nnew promise(resolve => {\n  console.log(5);\n  resolve();\n  console.log(6);\n}).then(() => {\n  console.log(7);\n});\npromise.resolve().then(() => {\n  console.log(8);\n  process.nexttick(() => {\n    console.log(9);\n  });\n});\n// 1 5 6 7 8 9 2\n\n\n> 设计一个 defer 函数，实现defer(3000).then(res => { // 30ms 后执行 }) ;\n> \n> 分析：延时函数\n\nfunction defer(time) {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            resolve(1)\n        }, time)\n    })\n}\n\ndefer(3000).then(res => {\n    console.log(res)\n})\n// 或者\nfunction defer(time) {\n    return new promise((resolve, reject) => {\n        settimeout(resolve, time, 1)\n    })\n}\n\ndefer(3000).then(res => {\n    console.log(res)\n})\n\n\n> 改写回调\n\nsettimeout(() => {\n    console.log(1)\n    settimeout(() => {\n        console.log(2)\n        settimeout(() => {\n            console.log(3)\n        }, 3000)\n    }, 2000)\n}, 1000)\n\n// promise 改写\nlet fn = (value, time) => {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            console.log(value)\n            resolve()\n        }, time)\n    })\n}\nfn(1, 1000).then(() => fn(2, 2000)).then(() => fn(3, 3000))\n\n// async await 改写\nasync function todo() {\n    await fn(1, 1000)\n    await fn(2, 2000)\n    await fn(3, 3000)\n}\ntodo()\n\n\n> 交替执行\n\npromise.resolve().then(() => {\n    console.log('a')\n}).then(() => {\n    console.log('b')\n}).then(() => {\n    console.log('c')\n}).then(() => {\n    console.log('d')\n}).then(() => {\n    console.log('e')\n})\n\npromise.resolve().then(() => {\n    console.log(1)\n}).then(() => {\n    console.log(2)\n}).then(() => {\n    console.log(3)\n}).then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n\n// a 1 b 2 c 3 d 4 e 5\n\n\npromise.resolve().then(() => {\n    console.log(0)\n    return promise.resolve(4)\n  \t/**\n  \t\t相当于这里多了两个微任务，然后交替执行\n  \t\t因为返回值可能是 promise 的嵌套，当前 then 一定递归计算它的最终值，传给下一个 then 的回调\n  \t*/\n}).then(res => {\n    console.log(res)\n})\n\npromise.resolve().then(() => {\n    console.log(1)\n}).then(() => {\n    console.log(2)\n}).then(() => {\n    console.log(3)\n}).then(() => {\n    console.log(5)\n}).then(() => {\n    console.log(6)\n})\n\n// 0 1 2 3 4 5 6\n\n\nconsole.log(1); \nsettimeout(() => {\n  console.log(2);\n});\nnew promise(resolve => {\n  console.log(3);\n  resolve('resolve');\n  console.log(4);\n  reject('error')\n}).catch((err) => {\n  console.log(err);\n}).then((res) => {\n  console.log(res)\n});\npromise.resolve().then(() => {\n  console.log(5);\n});\nconsole.log(6);\n\n// 1 3 4 6 5 resolve 2\n\n\nsettimeout(() => {\n    console.log(\"settimeout\");\n});\nconsole.log(1);\nnew promise(function(resolve, reject) {\n    console.log(2);\n    for (var i = 0; i < 1000; i ++) {\n        if (i === 10) {\n            console.log(10);\n        }\n        if (i === 999) {\n            resolve(999);\n        }\n    }\n    console.log(3); // resolve后面的代码依旧会执行\n}).then((val) => {\n    console.log(val);\n});\nconsole.log(4);\n\n// 1 2 10 3 4 999 settimeout\n\n\n\n# 作用域相关\n\nvar length = 10;\nfunction fn() {\n    return this.length+1;\n}\nvar obj = {\n    length: 5,\n    test1: function() {\n        return fn();\n    }\n};\nobj.test2 = fn;\nconsole.log(obj.test1()) // 11\nconsole.log(fn() === obj.test1()) // true\n\n\n\nvar a = function () { \n    this.b =3\n}\nvar c = new a()\na.prototype.b = 9\nvar b = 7\na()\nconsole.log(b) // 3\nconsole.log(c.b) // 3\n\n\n\nvar obj1 = (function() {\n  var inner = '1-1';\n  return {\n    inner: '1-2',\n    say: function() {\n      console.log(inner); \n      console.log(this.inner);\n    }\n  }\n})();\n\nvar obj2 = { inner: '2-1' }\ndebugger\nobj1.say(); // 1-1, 1-2\nobj2.say = obj1.say;\nobj2.say(); // 1-1, 2-1\n\nvar a = 3\n(function (){\n    console.log(a)\n    var a = 4;\n})()\n// uncaught typeerror: 3 is not a function\n\nvar a = 3;\n(function (){\n    console.log(a)\n    var a = 4;\n})()\n// undefined\n\n\nvar name = '123';\nvar obj = {\n   name: '456',\n   getname: function () {\n       function printname () {\n           console.log(this.name);\n       }\n       printname();\n   }\n}\nobj.getname(); // 123\n\n\n\nvar obj = {\n    say: function () {\n        var f1 = () => {\n            console.log(this)\n        }\n        f1()\n    },\n    pro: {\n        getpro: () => {\n            console.log(this)\n        }\n    }\n}\nvar o = obj.say\no() // window\nobj.say() // obj\nobj.pro.getpro() // window\n\n\nfunction a(b, c) {\n    var b;\n    alert(b); // 1\n}\na(1, 2);\n\n\nfor (var i = 0; i < 5; i++) {\n    settimeout(function() {\n        console.log(i)\n    }, 1000 * i)\n}\n// 每隔一秒输出一次 5，时间中的i作为参数成功传了进去，定时器加入队列，最后执行的时候从作用域找i，为5\n\nfor (var i = 0; i < 5; i++) {\n    (function(i) {\n        settimeout(function() {\n            console.log(i)\n        }, 1000 * i)\n    })(i)\n}\n// 输出0，1，2，3，4，闭包，i的值会保存下来\n\nfor (var i = 0; i < 5; i++) {\n    (function() {\n        settimeout(function() {\n            console.log(i)\n        }, 1000 * i)\n    })(i)\n}\n// 每隔一秒输出一次 5，i的值没有传进去\n\n\n\n# this相关\n\nfunction person() {  \n    this.age = 0;  \n    settimeout(() => {\n        this.age++; // 指向 person\n    }, 3000);\n}\nvar p = new person();\n\n\nfunction person() {  \n    this.age = 0\n    settimeout(function() {\n        console.log(this) // 指向 window\n    }, 3000)\n}\nvar p = new person();\n\n// 顺便复习以下箭头函数语法\nvar func1 = x => x;\nvar func2 = x => {x};\nvar func3 = x => ({x});\nconsole.log(func1(1)); // 1\nconsole.log(func2(1)); // undefined\nconsole.log(func3(1)); // {x: 1}\n\n\nconst fn = () => {\nthis.x = 'z';\n};\n\nconst b = {x: 'y'};\nfn.call(b);\nconsole.log(b); // {x: 'y'};\n\n\n\n# css相关\n\n<div class=\"lightblue\">\n   <div class=\"darkblue\">\n      <p>1. 颜色是？</p> \x3c!-- 深蓝 ，p没设置，继承上面的--\x3e\n   </div>\n</div>\n<div class=\"darkblue\">\n   <div class=\"lightblue\">\n      <p>2. 颜色是？</p> \x3c!-- 浅蓝 --\x3e\n   </div>\n</div>\n.lightblue { color: lightblue; }\n.darkblue { color: darkblue; }\n\n\x3c!-------------------------------------------\x3e\n\n<div class=\"lightblue\"> \n   <div class=\"darkblue\"> \x3c!-- 深蓝 --\x3e\n      <p>1. 颜色是？</p>\n   </div>\n</div>\n<div class=\"darkblue\">\n   <div class=\"lightblue\"> \x3c!-- 深蓝 --\x3e\n      <p>2. 颜色是？</p>\n   </div>\n</div>\n.lightblue p { color: lightblue; } \x3c!-- 优先级相同都是10 + 1，写在后面的覆盖写在前面的 --\x3e\n.darkblue p { color: darkblue; }\n\n\n<style>\n    .green {\n        background-color: green;\n    }\n\n    .red {\n        background-color: red;\n    }\n\n    .blue {\n        background-color: blue;\n    }\n</style>\n<body>\n    <div class=\"green blue red\">\n        fsdfasdfasd\n    </div>\n</body>\n\n\x3c!-- 蓝色 --\x3e\n\n\n\n# 原型相关\n\nfunction animal() {}\nvar cat = new animal();\nanimal.prototype = {bark: true}; // 破坏了原型链\nvar dog = new animal();\nconsole.log(cat.bark); // undefined\nconsole.log(dog.bark); // true\n\n\nfunction animal() {}\nvar cat = new animal();\nanimal.prototype.bark = true;\nvar dog = new animal();\nconsole.log(cat.bark); // true\nconsole.log(dog.bark); // true\n\nfunction person(name) {\n\tthis.name = name;\n}\nperson.prototype.print = function() {\n\treturn this.name;\n};\n\nconst a = new person('abc').print.call({});\nconsole.log(a); // undefined\n\n\n// 怎么实现一个多重继承。。可以在一个object对象即可以输出m1的hello也可以输出m2.world\nfunction m1() {\nthis.hello = 'hello';\n}\n\nfunction m2() {\nthis.world = 'world';\n}\n\n// 首先让 m2 继承 m1\nm2.prototype = new m1()\n\nlet obj = {}\nobj.__proto__ = new m2()\n\nconsole.log(obj.hello, obj.world) // hello world\n\n\nfunction.prototype.a = () => console.log(1); \nobject.prototype.b = () => console.log(2); \nfunction a() {} const a = new a(); \na.a(); // a.a is not a function\na.b(); // 2\n\na.__proto__.__proto__ === a.prototype.__proto__ === object.prototype\na.__proto__.__proto__ === function.prototype.__proto__ === object.prototype\n\n\n// 写下p、parent、function、object的原型链\nfunction parent() {}\nvar p = new parent()\n\nconsole.log(p.__proto__ === parent.prototype) // true\nconsole.log(parent.__proto__ === function.prototype) // true\nconsole.log(parent.prototype.__proto__ === object.prototype) // true\nconsole.log(function.prototype.__proto__ === object.prototype) // true\nconsole.log(object.__proto__ === function.prototype) // true\n\n\n\n# 正则相关\n\n * 正则中需要转义的字符：* . ? + $ ^ [ ] ( ) { } | \\ /\n\nvar a = 'hi, my name is {name}, i am {age} years old, my email is {email}.';\nvar b = {name:'max', age: 12, email: 'max@gmail.com'};\n\n\nfunction replace(tpl, data){\n    return tpl.replace(/\\{(\\w+)\\}/g, (matchstr, group) => data[group])\n}\n\n\n// 下划线转换驼峰\nconst tohump = str => {\n    return str.replace(/\\_(\\w)/g, (matchstr, group) => group.touppercase())\n}\n\n// 驼峰转换下划线\nconst toline = str => {\n    return str.replace(/([a-z])/g, (matchstr, group) => `_${group.tolowercase()}`)\n}\n\n\n\n# 场景题\n\n> 爬虫在爬取页面前，需要对url列表进行标准化，实现一个处理url列表的函数-对缺少http前缀的url添加前缀，返回的url不能重复\n> \n> [\"nodejs.org\", \"http://nodejs.org\", \"http://bytedance.com\"] => [\"http://nodejs.org\", \"http://bytedance.com\"]\n\nfunction formaturl(urllist){\n    const res = []\n    for (let i in urllist) {\n        const reg = /^http:\\/\\//\n        const url = urllist[i]\n        const newurl = reg.test(url) ? url : `http://${url}`\n        if (!res.includes(newurl)) {\n            res.push(newurl)\n        }\n    }\n    return res\n}\n\n\n\n# 解析url中\n\n参数为对象，考虑 key 重复，没有 val 和 转码\n\n// https://weibo.com/u/1627615060/home?wvr=5&from_outside&key=12&key=4&l=%e4%bb%8a%e6%97%a5%e7%89%b9%e5%8d%96\n\nconst getquery = url => {\n    let query = {}\n    if (url.includes(\"?\")) {\n        const str = url.split(\"?\")[1]\n        const params = str.split(\"&\")\n        for(let i = 0; i < params.length; i++) {\n            let key = null, val = null\n            if (params[i].includes(\"=\")) {\n                key = params[i].split(\"=\")[0]\n                val = decodeuricomponent(params[i].split(\"=\")[1])\n            } else {\n                key = params[i]\n                val = null\n            }\n            if (query[key]) {\n                array.isarray(query[key]) ?\n                    query[key].push(val) : query[key] = [query[key], val]\n            } else {\n                query[key] = val\n            }\n        }\n    }\n    return query\n}\n\n\n> 实现如下效果u.console(\"hello\").settimeout(3000).console(\"world\").settimeout(3000).console(\"hah\").settimeout(0).console(\"111\")，首先输出hello，3s后输出world,再间隔3s,再输出\n\n// 考点 this 是立即返回的，settimeout 加入任务队列，时间需要累加计算\nclass u {\n    constructor() {\n        this.time = null\n        this.totaltime = 0\n    }\n\n    console(val) {\n        if (this.time === null) {\n            console.log(val)\n        } else {\n            this.totaltime += this.time\n            settimeout(() => {\n                console.log(val)\n            }, this.totaltime)\n        }\n        return this\n    }\n\n    settimeout(time) {\n        this.time = time\n        return this\n    }\n}\n\nlet u = new u()\nu.console(\"hello\").settimeout(3000).console(\"world\").settimeout(3000).console(\"hah\").settimeout(0).console(\"111\")\n\n\n\n# repeat函数\n\n> 使下面调用代码能正常工作 const repeatfunc = repeat(console.log, 4, 3000); repeatfunc(\"helloworld\") //会输出4次 helloworld, 每次间隔3秒\n\n// 需要实现的函数\nfunction repeat (func, times, wait) {\n    return function() {\n        for (let i = 1; i <= times; i++) {\n            settimeout(() => {\n                func(...arguments)\n            }, wait * i)\n        }\n    }\n}\n\n\n\n# 找k好成绩\n\n> 从一个包含学生成绩数组的中找到成绩第k好的所有学生的id, 学生信息如下：[{score:89,id:1}, {score:23,id:4}]。\n\nconst findk = (arr, k) => {\n    const store = array.from(new array(101), () => new array())\n    for (let i = 0; i < arr.length; i++) {\n        store[arr[i].score].push(arr[i].id)\n    }\n    let count = 0\n    for (let i = 100; i >= 0; i--) {\n        if (!store[i].length) continue\n        count++\n        if (k === count) return store[i]\n    }\n}\n\n// 注：创建二维数组时，千万不要 new array(101).fill([]), [] 指向的都是同一个\n\n\n\n# 进制转换\n\nfunction mulbase(num, base){\n    let str = \"\"\n    while (num !== 0) {\n        str += num % base\n        num = math.floor(num / base)\n    }\n    return str.split('').reverse().join('')\n}\nconsole.log(mulbase(64,8));\n\n\n\n# 随机生成16进制\n\nfunction genehex() {\n  return \"#\" + math.floor((math.random() * 0xffffff)).tostring(16)\n}\n\n\n\n# 16进制颜色转 rgb\n\nfunction hex2rgb(hex) {\n    const str = hex.slice(1),\n        res = []\n    if (str.length === 3) {\n        for (const w of str) {\n            res.push(parseint(w + w, 16))\n        }\n    } else {\n        for (let i = 0; i < 6; i += 2) {\n            res.push(parseint(str[i] + str[i + 1], 16))\n        }\n    }\n    return res\n}\n\n\n\n# 有序数组找数求和\n\n> 输入：[1,2,3,4,5]， 6\n\n * 双指针\n\nfunction foo(arr, target) {\n    let left = 0, right = arr.length - 1\n    while (left < right) {\n        if (arr[left] + arr[right] > target) {\n            right --\n        } else if (arr[left] + arr[right] === target) {\n            return [left, right]\n        } else {\n            left ++\n        }\n    }\n}\n\n\n\n# 判断2的整数次幂\n\n// 2: 10, 4: 100, 8: 1000, 16: 10000\n// 可以发现2的整数次幂都是1后面跟着许多0，如果减1分别对应\n// 1: 01, 3: 011, 7: 0111, 15: 01111\n// 如果作与运算，2 & 1 == 0，4 & 3 == 0\nfunction judge(num) {\n  return (num&(num - 1)) == 0\n}\n\n\n\n# 对象转为数组键值对\n\n{\n  name: 'a',\n\tage: 10\n}\n// 转换为\n[\n  {\n        key: 'name',\n        value: 'a'\n\t},\n\t{\n        key: 'age',\n        value: 10\n  }\n]\n\n\n\n# 开根号\n\n要求位数 0.0001，考虑 0 - 1 开根号越来越大\n\n\n\n\n\n# 并发请求控制\n\nfunction multirequest(urls = [], maxnum) {\n    const len = urls.length\n    const result = new array(len).fill(false)\n    let count = 0\n\n    return new promise((resolve, reject) => {\n        while (count < maxnum) {\n            next()\n        }\n        function next() {\n            let current = count++\n            if (current >= len) {\n                !result.includes(false) && resolve(result)\n                return\n            }\n            const url = urls[current]\n            fetch(url)\n                .then((res) => {\n                    result[current] = res\n                    if (current < len) {\n                        next()\n                    }\n                })\n            .catch((err) => {\n                result[current] = err\n                if (current < len) {\n                    next()\n                }\n            })\n        }\n    })\n}\n\n\n\n# 尝试重新请求\n\nfunction requestretry (url, retrynum) {\n    return request(url).catch(e => {\n        if (retrynum) {\n            return requestretry(url, --retrynum)\n        } else {\n            return promise.reject(e)\n        }\n    })\n}\n\n\n失败测试\n\nfunction tryrequest(request, times = 3) {\n    return request().catch(e => {\n        if (times) {\n            console.log('正在重试')\n            return tryrequest(request, --times)\n        } else {\n            return promise.reject(e)\n        }\n    })\n}\n\nfunction request() {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            reject('error')\n        }, 1000)\n    })\n}\n\ntryrequest(request, 3).then(console.log).catch(console.log)\n\n// 正在重试\n// 正在重试\n// 正在重试\n// error\n\n\n成功测试\n\nfunction tryrequest(request, times = 3) {\n    return request().catch(e => {\n        if (times) {\n            console.log('正在重试')\n            return tryrequest(request, --times)\n        } else {\n            return promise.reject(e)\n        }\n    })\n}\n\nfunction request() {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            resolve('success')\n        }, 1000)\n    })\n}\n\ntryrequest(request, 3).then(console.log).catch(console.log) // success\n\n\n\n# loading动画\n\n> vue项目中：loading控制页面加载动画，sort是一个消耗时间的排序操作，问loading动画会显示吗？\n\nthis.loading = true\nthis.data.sort()\nthis.loading = false\n\n// 答：不会，vue更新视图是异步的，虽然sort消耗时间，还是会把loading数据的改变缓冲为一次\n\nthis.loading = true // 宏\nthis.$nexttick(() => { // 微\n  this.data.sort()\n  this.loading = false\n})\n\n// 还是不会，$nexttick优先使用微任务，宏 => 微 => ui渲染\n\nthis.loading = true\nsettimeout(() => {\n  this.data.sort()\n  this.loading = false\n}, 5000)\n// 会\n\n\n\n# 实现一个cash类\n\n//实现一个 cash 类，期望执行下面代码：\nconst cash1 = new cash(105);\nconst cash2 = new cash(66);\nconst cash3 = cash1.add(cash2);\nconst cash4 = cash.add(cash1, cash2);\nconst cash5 = new cash(cash1 + cash2); // 考虑 valueof\nconsole.log(`${cash3}`, `${cash4}`, `${cash5}`); // 考虑 tostring\n// 1元7角1分 1元7角1分 1元7角1分\n\n\n// 写之前先复习一下 valueof 和 tostring\nconst a = {\n    val: 1,\n    valueof() {\n        console.log('valueof')\n        return this.val\n    },\n    tostring() {\n        console.log('tostring')\n        return this.val\n    }\n}\nconsole.log(a) // {val: 1, valueof: ƒ, tostring: ƒ}\nconsole.log(a + \"\") // valueof 1\nconsole.log(a + 1) // valueof 2\nconsole.log(a + {}) // valueof 1[object object]\nconsole.log(`${a}`) // tostring 1\n\n\nclass cash {\n    constructor(num) {\n        this.num = num\n    }\n    add(c1) {\n        return new cash(this + c1)\n    }\n    static add(c1, c2) {\n        return new cash(c1 + c2)\n    }\n    // valueof 用于处理 new cash(cash1 + cash2)\n    valueof() {\n        return this.num\n    }\n    // tostring 用于处理 cash3 => `${cash3}`\n    tostring() {\n        this.sum=`${this.num}`\n        return `${this.sum[0]}元${this.sum[1]}角${this.sum[2]}元`\n    }\n}\n\n\nclass中static方法中的this指向哪里\n\n\n# 字符串替换\n\n\"ababab\".match(/a.*b/) // \"ababab\"，.是任意字符，贪婪匹配，尽可能多的匹配\n\"ababab\".match(/a.*?b/) // \"ab\"，非贪婪，尽可能少的匹配\n\n\nconst template = \"{{name }}很厉name害，才{{age }}岁\"\nconst context = { name: \"jawil\", age: \"15\" }\n\n// vue 插值表达式\nfunction fn(template, context) {\n    return template.replace(/\\{\\{(.*?)\\}\\}/g, (matchstr, group) => {\n        return context[group.trim()]\n    })\n}\n\n// es6模板字符串\nfunction replacestr(str, obj) {\n    return str.replace(/\\$\\{(.*?)\\}/g, (matchstr, group) => {\n        return obj[group]\n    })\n}\n\n\n\n# 判断对象有没有空值\n\n> 判断一个对象没有空属性（undefined、 null）\n\n// 测试用例\nconst obj1 = {\n  prop1:{\n    subprop1: 0,\n    subporp2: undefined,\n    subprop3: {\n      pp1: 123,\n      pp2: \"\"\n    },\n\t},\n\tprop2:\"test\"\n}\n\n// 递归\nfunction hasemptyprop(obj){\n    for (let key in obj) {\n        if (obj.hasownproperty(key)) {\n            if (obj[key] === null || obj[key] === undefined) {\n                return true\n            } else if (typeof obj[key] === 'object') {\n                if (hasemptyprop(obj[key])) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n// 这种为什么不对？return 是箭头函数内部的 return，所以整体函数会一直返回 false\nfunction hasemptyprop(obj){\n    object.keys(obj).foreach(key => {\n      \tif (obj[key] === null || obj[key] === undefined) {\n          return true\n        } else if (typeof obj[key] === 'object') {\n          if (hasemptyprop(obj[key])) {\n            return true\n          }\n        }\n    })\n    return false\n}\n\n// 非递归，对象可以理解为树，用广度优先的思想\nfunction hasemptyprop(obj){\n    const queue = [obj]\n    while (queue.length) {\n        let prop = queue.shift()\n        if (prop === null || prop === undefined) {\n            return true\n        } else if (typeof prop === 'object') {\n            for (let key in prop) {\n                queue.push(prop[key])\n            }\n        }\n    }\n    return false\n}\n",charsets:{cjk:!0}},{title:"面试题（四）",frontmatter:{title:"面试题（四）",date:"2018-03-09T09:52:01.000Z",categories:"面试"},regularPath:"/interview/interview-4.html",relativePath:"interview/interview-4.md",key:"v-6650d0ff",path:"/interview/interview-4.html",headers:[{level:2,title:"深拷贝与浅拷贝",slug:"深拷贝与浅拷贝",normalizedTitle:"深拷贝与浅拷贝",charIndex:13},{level:2,title:"什么是BFC，BFC的布局规则是什么，如何创建BFC",slug:"什么是bfc-bfc的布局规则是什么-如何创建bfc",normalizedTitle:"什么是bfc，bfc的布局规则是什么，如何创建bfc",charIndex:24},{level:2,title:"隐藏页面中某个元素的方法",slug:"隐藏页面中某个元素的方法",normalizedTitle:"隐藏页面中某个元素的方法",charIndex:54},{level:2,title:"说一下你对JS执行上下文栈和作用域链的理解",slug:"说一下你对js执行上下文栈和作用域链的理解",normalizedTitle:"说一下你对js执行上下文栈和作用域链的理解",charIndex:872},{level:2,title:"防抖函数，节流函数的作用与实现",slug:"防抖函数-节流函数的作用与实现",normalizedTitle:"防抖函数，节流函数的作用与实现",charIndex:94},{level:2,title:"什么是闭包，闭包的作用是什么",slug:"什么是闭包-闭包的作用是什么",normalizedTitle:"什么是闭包，闭包的作用是什么",charIndex:113},{level:2,title:"关于reduce函数",slug:"关于reduce函数",normalizedTitle:"关于reduce函数",charIndex:131},{level:2,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:145},{level:2,title:"时间复杂度和空间复杂度分别对应计算机什么资源",slug:"时间复杂度和空间复杂度分别对应计算机什么资源",normalizedTitle:"时间复杂度和空间复杂度分别对应计算机什么资源",charIndex:156},{level:2,title:"css画三角形和扇形",slug:"css画三角形和扇形",normalizedTitle:"css画三角形和扇形",charIndex:182}],lastUpdated:"3/15/2023, 7:26:00 PM",lastUpdatedTimestamp:167887956e4,headersStr:"深拷贝与浅拷贝 什么是BFC，BFC的布局规则是什么，如何创建BFC 隐藏页面中某个元素的方法 说一下你对JS执行上下文栈和作用域链的理解 防抖函数，节流函数的作用与实现 什么是闭包，闭包的作用是什么 关于reduce函数 数组去重 时间复杂度和空间复杂度分别对应计算机什么资源 css画三角形和扇形",content:'# 面试题（四）\n\n * 深拷贝与浅拷贝\n * 什么是BFC，BFC的布局规则是什么，如何创建BFC\n * 隐藏页面中某个元素的方法\n * 说一下你对JS执行上下文和作用域链的理解\n * 防抖函数，节流函数的作用与实现\n * 什么是闭包，闭包的作用是什么\n * 关于reduce函数\n * 数组去重的方法\n * 时间复杂度和空间复杂度分别对应计算机什么资源\n * css画三角形和扇形\n\n\n# 深拷贝与浅拷贝\n\n * 深拷贝与浅拷贝\n\n\n# 什么是BFC，BFC的布局规则是什么，如何创建BFC\n\n * 盒子模型\n\n\n# 隐藏页面中某个元素的方法\n\n隐藏类型：\n\n * 完全隐藏：元素从渲染树中消失，不占据空间\n * 视觉上隐藏：屏幕中不可见，占据空间\n * 语义上隐藏：读屏软件不可读，但正常占据空间\n\n完全隐藏：\n\n1. display: none;\n2. <div hidden></div>  hidden属性\n\n\n视觉上隐藏：\n\n1.利用poisition和盒模型将元素移出可视区范围\nposition:absolute;\nleft:-9999px;\n\n2.利用transform\n（1）缩放：transform: scale(0);\n（2）移动：transform：translateX(-9999px)\n (3) 旋转：transform: rotateY(90deg);\n \n3.透明度\nopacity: 0;\n\n4.visibility: hidden;\n\n5.层级覆盖， z-index 属性\nz-index: -999;\n\n6.clip-path 裁剪\nclip-path: polygon(00,00,00,00);\n\n\n语义上隐藏\n\n<div aria-hidden="true">\n</div>\n\n\n * display:none 关闭元素的布局，所以元素不被渲染\n * visibility:hidden 隐藏元素，而不改变它们的布局\n * opacity:0 使元素非常透明，但是用户依然可以和元素交互\n\n\n# 说一下你对JS执行上下文栈和作用域链的理解\n\njs执行上下文\n\n> 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行，上下文是在执行阶段才创建的\n> \n> 执行上下文类型分为：\n> \n> 全局执行上下文 / 函数执行上下文 / eval执行上下文\n\n作用域\n\n> 作用域:控制着变量与函数的可见性和生命周期，取决于代码定义的位置。\n> \n> 作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。\n> \n> 分为：\n> \n> 按实际情况分：全局作用域 / 函数作用域 / 块级作用域\n> \n> 按工作模型分：词法作用域 / 动态作用域\n\n执行上下文栈\n\n/**\n\t首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。\n\n当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。\n*/\n\nfunction fun3(){\n    console.log(\'fun3\')\n}\nfunction fun2(){\n    fun3()\n}\nfunction fun1(){\n    fun2()\n}\nfun1()\n\n// 入栈：全局，f1,f2,f3\n// 出栈：f3,f2,f1\n\n\n作用域链\n\n> 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。\n\n函数的阶段分为函数建立阶段和函数执行阶段\n\n * 函数建立阶段：调用函数，还没有执行函数内部的代码\n   \n   * 创建执行上下文对象\n   \n   fn.ExecutionContext = {\n     variableObject: // 函数中的 arguments，局部成员\n     scopeChains: // 作用域链\n     this: {} // 当前函数内部的 this 指向\n   }\n   \n\n * 函数执行阶段：把变量对象转换为活动对象\n\nfn.ExecutionContext = {\n  activationObject: // 函数中的 arguments，局部成员\n  scopeChains: // 作用域链\n  this: {} // 当前函数内部的 this 指向\n}\n\n\n尝试调试以下函数\n\nfunction fn(a, b) {\n  function inner() {\n    console.log(a, b)\n  }\n  console.dir(inner)\n}\nconsole.dir(fn)\nconst f = fn(1, 2)\n\n\n\n# 防抖函数，节流函数的作用与实现\n\n * 手写代码整理\n\n\n# 什么是闭包，闭包的作用是什么\n\n闭包是指有权访问另一个函数作用域中的变量的函数\n\n//创建一个闭包\nfunction foo(){\n    var a=2;\n    return function fn(){\n        console.log(a)\n    }\n}\nlet func = foo()\nfunc()//输出2\n\n\n闭包的作用：\n\n（1）访问另一个函数作用域中的变量\n\n（2）私有化变量\n\nfunction privateVariable() {\n    var value;\n    this.setValue = function(value) {\n        value= value;\n    };\n    this.getValue = function() {\n        return value;\n    };\n}\nvar x = new privateVariable();\nx.setValue("abcd");\nconsole.log(x.value); //undefined\nconsole.log(x.getValue ()); //abcd\n\n\n（3）模拟块级作用域\n\nfor(var i=0;i<10;i++){\n    (function(i){\n        console.log(i)\n    })(i)\n}\n\n\n\n# 关于reduce函数\n\n> reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。\n\n//数组求和\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst sum = arr.reduce(function (prev, current) {\n    return prev+current\n}, 0)\nconsole.log(sum) //55\n\n//合并二维数组\nvar twoArr = [[\'mu\',\'zi\'],[\'dig\',\'big\'],[\'lucky\',\'jiji\']];\nvar oneArr = twoArr.reduce(function(total,currentValue){\n  // console.log(total)\n  return total.concat(currentValue);\n})\nconsole.log(oneArr);//["mu", "zi", "dig", "big", "lucky", "jiji"]\n\n\n\n# 数组去重\n\n（1）reduce + includes\n\nlet arr = [1, 2, 2, 4, null, null].reduce((prev, current) => {\n    return prev.includes(current) ? prev : prev.concat(current);\n}, []);\n\n\n（2）利用ES6的Set数据结构\n\n> set 类似于数组，且成员值不重复都是唯一的，set本身是一个构造函数。\n\nlet arr = [1,2,2,3]\n[...new Set(arr)]  //[1,2,3]\n\n\n（3）for循环+splice\n\nfor(var i=0;i<arr.length;i++){\n    for(var j=i+1;j<arr.length;j++){\n        if(arr[i]==arr[j]){\n            arr.splice(j,1)\n            j--\n        }\n    }\n}\n\n\n（4）利用indexOf\n\nvar array = [];\nfor (var i = 0; i < arr.length; i++) {\n    if (array .indexOf(arr[i]) === -1) {\n            array .push(arr[i])\n     }\n}\n\n\n（5）利用sort\n\narr = arr.sort()\nvar array = []\nfor(var i=0;i<arr.length;i++){\n    if(arr[i]!==arr[i-1]){\n        array.push(arr[i])\n    }\n}\n\n\n（6）利用includes\n\nvar array = []\nfor(var i=0;i<arr.length;i++){\n    if(!array.includes(arr[i])){\n        array.push(arr[i])\n    }\n}\n\n\n\n# 时间复杂度和空间复杂度分别对应计算机什么资源\n\n> 时间复杂度对应的是cpu，cpu就是用来做运算的，每个CPU都有一套自己可以执行的专门的指令集，经过取指，解码，执行的过程构成cpu的一个基本周期，空间复杂度对应的是内存。\n\n\n# css画三角形和扇形\n\n/*扇形*/\n#box1 {\n  width: 0;\n  height: 0;\n  border: 40px solid;\n  border-color: transparent transparent red;\n  border-radius: 50%;\n}\n\n/*三角形*/\n#box2 {\n  width: 0;\n  height: 0;\n  border: 40px solid;\n  border-color: transparent transparent red;\n}\n',normalizedContent:'# 面试题（四）\n\n * 深拷贝与浅拷贝\n * 什么是bfc，bfc的布局规则是什么，如何创建bfc\n * 隐藏页面中某个元素的方法\n * 说一下你对js执行上下文和作用域链的理解\n * 防抖函数，节流函数的作用与实现\n * 什么是闭包，闭包的作用是什么\n * 关于reduce函数\n * 数组去重的方法\n * 时间复杂度和空间复杂度分别对应计算机什么资源\n * css画三角形和扇形\n\n\n# 深拷贝与浅拷贝\n\n * 深拷贝与浅拷贝\n\n\n# 什么是bfc，bfc的布局规则是什么，如何创建bfc\n\n * 盒子模型\n\n\n# 隐藏页面中某个元素的方法\n\n隐藏类型：\n\n * 完全隐藏：元素从渲染树中消失，不占据空间\n * 视觉上隐藏：屏幕中不可见，占据空间\n * 语义上隐藏：读屏软件不可读，但正常占据空间\n\n完全隐藏：\n\n1. display: none;\n2. <div hidden></div>  hidden属性\n\n\n视觉上隐藏：\n\n1.利用poisition和盒模型将元素移出可视区范围\nposition:absolute;\nleft:-9999px;\n\n2.利用transform\n（1）缩放：transform: scale(0);\n（2）移动：transform：translatex(-9999px)\n (3) 旋转：transform: rotatey(90deg);\n \n3.透明度\nopacity: 0;\n\n4.visibility: hidden;\n\n5.层级覆盖， z-index 属性\nz-index: -999;\n\n6.clip-path 裁剪\nclip-path: polygon(00,00,00,00);\n\n\n语义上隐藏\n\n<div aria-hidden="true">\n</div>\n\n\n * display:none 关闭元素的布局，所以元素不被渲染\n * visibility:hidden 隐藏元素，而不改变它们的布局\n * opacity:0 使元素非常透明，但是用户依然可以和元素交互\n\n\n# 说一下你对js执行上下文栈和作用域链的理解\n\njs执行上下文\n\n> 执行上下文就是当前 javascript 代码被解析和执行时所在环境的抽象概念， javascript 中运行任何的代码都是在执行上下文中运行，上下文是在执行阶段才创建的\n> \n> 执行上下文类型分为：\n> \n> 全局执行上下文 / 函数执行上下文 / eval执行上下文\n\n作用域\n\n> 作用域:控制着变量与函数的可见性和生命周期，取决于代码定义的位置。\n> \n> 作用域有两种工作模型：词法作用域和动态作用域，js采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。\n> \n> 分为：\n> \n> 按实际情况分：全局作用域 / 函数作用域 / 块级作用域\n> \n> 按工作模型分：词法作用域 / 动态作用域\n\n执行上下文栈\n\n/**\n\t首次运行javascript代码的时候,会创建一个全局执行的上下文并push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并push当前执行栈的栈顶。\n\n当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。\n*/\n\nfunction fun3(){\n    console.log(\'fun3\')\n}\nfunction fun2(){\n    fun3()\n}\nfunction fun1(){\n    fun2()\n}\nfun1()\n\n// 入栈：全局，f1,f2,f3\n// 出栈：f3,f2,f1\n\n\n作用域链\n\n> 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。\n\n函数的阶段分为函数建立阶段和函数执行阶段\n\n * 函数建立阶段：调用函数，还没有执行函数内部的代码\n   \n   * 创建执行上下文对象\n   \n   fn.executioncontext = {\n     variableobject: // 函数中的 arguments，局部成员\n     scopechains: // 作用域链\n     this: {} // 当前函数内部的 this 指向\n   }\n   \n\n * 函数执行阶段：把变量对象转换为活动对象\n\nfn.executioncontext = {\n  activationobject: // 函数中的 arguments，局部成员\n  scopechains: // 作用域链\n  this: {} // 当前函数内部的 this 指向\n}\n\n\n尝试调试以下函数\n\nfunction fn(a, b) {\n  function inner() {\n    console.log(a, b)\n  }\n  console.dir(inner)\n}\nconsole.dir(fn)\nconst f = fn(1, 2)\n\n\n\n# 防抖函数，节流函数的作用与实现\n\n * 手写代码整理\n\n\n# 什么是闭包，闭包的作用是什么\n\n闭包是指有权访问另一个函数作用域中的变量的函数\n\n//创建一个闭包\nfunction foo(){\n    var a=2;\n    return function fn(){\n        console.log(a)\n    }\n}\nlet func = foo()\nfunc()//输出2\n\n\n闭包的作用：\n\n（1）访问另一个函数作用域中的变量\n\n（2）私有化变量\n\nfunction privatevariable() {\n    var value;\n    this.setvalue = function(value) {\n        value= value;\n    };\n    this.getvalue = function() {\n        return value;\n    };\n}\nvar x = new privatevariable();\nx.setvalue("abcd");\nconsole.log(x.value); //undefined\nconsole.log(x.getvalue ()); //abcd\n\n\n（3）模拟块级作用域\n\nfor(var i=0;i<10;i++){\n    (function(i){\n        console.log(i)\n    })(i)\n}\n\n\n\n# 关于reduce函数\n\n> reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。\n\n//数组求和\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst sum = arr.reduce(function (prev, current) {\n    return prev+current\n}, 0)\nconsole.log(sum) //55\n\n//合并二维数组\nvar twoarr = [[\'mu\',\'zi\'],[\'dig\',\'big\'],[\'lucky\',\'jiji\']];\nvar onearr = twoarr.reduce(function(total,currentvalue){\n  // console.log(total)\n  return total.concat(currentvalue);\n})\nconsole.log(onearr);//["mu", "zi", "dig", "big", "lucky", "jiji"]\n\n\n\n# 数组去重\n\n（1）reduce + includes\n\nlet arr = [1, 2, 2, 4, null, null].reduce((prev, current) => {\n    return prev.includes(current) ? prev : prev.concat(current);\n}, []);\n\n\n（2）利用es6的set数据结构\n\n> set 类似于数组，且成员值不重复都是唯一的，set本身是一个构造函数。\n\nlet arr = [1,2,2,3]\n[...new set(arr)]  //[1,2,3]\n\n\n（3）for循环+splice\n\nfor(var i=0;i<arr.length;i++){\n    for(var j=i+1;j<arr.length;j++){\n        if(arr[i]==arr[j]){\n            arr.splice(j,1)\n            j--\n        }\n    }\n}\n\n\n（4）利用indexof\n\nvar array = [];\nfor (var i = 0; i < arr.length; i++) {\n    if (array .indexof(arr[i]) === -1) {\n            array .push(arr[i])\n     }\n}\n\n\n（5）利用sort\n\narr = arr.sort()\nvar array = []\nfor(var i=0;i<arr.length;i++){\n    if(arr[i]!==arr[i-1]){\n        array.push(arr[i])\n    }\n}\n\n\n（6）利用includes\n\nvar array = []\nfor(var i=0;i<arr.length;i++){\n    if(!array.includes(arr[i])){\n        array.push(arr[i])\n    }\n}\n\n\n\n# 时间复杂度和空间复杂度分别对应计算机什么资源\n\n> 时间复杂度对应的是cpu，cpu就是用来做运算的，每个cpu都有一套自己可以执行的专门的指令集，经过取指，解码，执行的过程构成cpu的一个基本周期，空间复杂度对应的是内存。\n\n\n# css画三角形和扇形\n\n/*扇形*/\n#box1 {\n  width: 0;\n  height: 0;\n  border: 40px solid;\n  border-color: transparent transparent red;\n  border-radius: 50%;\n}\n\n/*三角形*/\n#box2 {\n  width: 0;\n  height: 0;\n  border: 40px solid;\n  border-color: transparent transparent red;\n}\n',charsets:{cjk:!0}},{title:"面试题（一）",frontmatter:{title:"面试题（一）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-1.html",relativePath:"interview/interview-1.md",key:"v-2277ee5f",path:"/interview/interview-1.html",headers:[{level:2,title:"Vue的组件传值的方式（12种）",slug:"vue的组件传值的方式-12种",normalizedTitle:"vue的组件传值的方式（12种）",charIndex:500},{level:2,title:"props的写法",slug:"props的写法",normalizedTitle:"props的写法",charIndex:634},{level:2,title:"打包工具webpack，rollup，parcel分别适用于什么场景？",slug:"打包工具webpack-rollup-parcel分别适用于什么场景",normalizedTitle:"打包工具webpack，rollup，parcel分别适用于什么场景？",charIndex:118},{level:2,title:"如何理解 vue 响应式原理？",slug:"如何理解-vue-响应式原理",normalizedTitle:"如何理解 vue 响应式原理？",charIndex:1862},{level:2,title:"computed和watcher的原理，有什么区别及应用场景？（Watcher，惰性）",slug:"computed和watcher的原理-有什么区别及应用场景-watcher-惰性",normalizedTitle:"computed和watcher的原理，有什么区别及应用场景？（watcher，惰性）",charIndex:185},{level:3,title:"watch的两个参数",slug:"watch的两个参数",normalizedTitle:"watch的两个参数",charIndex:4091},{level:3,title:"三种类型的 Watcher 对象",slug:"三种类型的-watcher-对象",normalizedTitle:"三种类型的 watcher 对象",charIndex:4546},{level:2,title:"为什么 Vue3.0 采用了 proxy，有什么优势？",slug:"为什么-vue3-0-采用了-proxy-有什么优势",normalizedTitle:"为什么 vue3.0 采用了 proxy，有什么优势？",charIndex:232},{level:2,title:"说一下模块化的方案，CommonJs，AMD，CMD，ESModules",slug:"说一下模块化的方案-commonjs-amd-cmd-esmodules",normalizedTitle:"说一下模块化的方案，commonjs，amd，cmd，esmodules",charIndex:5773},{level:2,title:"介绍一下 Vue 的 Virtual DOM 与 Diff 算法",slug:"介绍一下-vue-的-virtual-dom-与-diff-算法",normalizedTitle:"介绍一下 vue 的 virtual dom 与 diff 算法",charIndex:304},{level:2,title:"说一下 $nextTick 的原理",slug:"说一下-nexttick-的原理",normalizedTitle:"说一下 $nexttick 的原理",charIndex:340},{level:2,title:"Vue 组件 data 为什么必须是函数 ?",slug:"vue-组件-data-为什么必须是函数",normalizedTitle:"vue 组件 data 为什么必须是函数 ?",charIndex:361},{level:2,title:"webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗",slug:"webpack插件主要是做什么的-常用的有哪些-自己写过webpack插件吗",normalizedTitle:"webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗",charIndex:387},{level:2,title:"webpack 热更新原理",slug:"webpack-热更新原理",normalizedTitle:"webpack 热更新原理",charIndex:429},{level:2,title:"js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？css会阻塞js吗",slug:"js执行会阻塞dom树的解析和渲染-那么css加载会阻塞dom树的解析和渲染吗-css会阻塞js吗",normalizedTitle:"js执行会阻塞dom树的解析和渲染，那么css加载会阻塞dom树的解析和渲染吗？css会阻塞js吗",charIndex:446}],lastUpdated:"6/25/2025, 8:09:31 PM",lastUpdatedTimestamp:1750853371e3,headersStr:"Vue的组件传值的方式（12种） props的写法 打包工具webpack，rollup，parcel分别适用于什么场景？ 如何理解 vue 响应式原理？ computed和watcher的原理，有什么区别及应用场景？（Watcher，惰性） watch的两个参数 三种类型的 Watcher 对象 为什么 Vue3.0 采用了 proxy，有什么优势？ 说一下模块化的方案，CommonJs，AMD，CMD，ESModules 介绍一下 Vue 的 Virtual DOM 与 Diff 算法 说一下 $nextTick 的原理 Vue 组件 data 为什么必须是函数 ? webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗 webpack 热更新原理 js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？css会阻塞js吗",content:"# 面试题（一）\n\n * Vue的组件传值的方式（8种）\n   * 父传子：数组/对象形式，单向数据流（在子组件中改变prop会出现警告）\n   * 子传父：联系发布订阅模式（$emit,$on）讲一下，怎么实现一个发布订阅模式\n * 打包工具webpack，rollup，parcel分别适用于什么场景？\n * 如何理解 vue 响应式原理（2.0/3.0）？\n * computed和watcher的原理，有什么区别及应用场景？（Watcher，惰性）\n * 为什么 Vue3.0 采用了 proxy，有什么优势？\n * 说一下模块化的方案，CommonJs，AMD，CMD，ES Modules\n * 介绍一下 Vue 的 Virtual DOM 与 Diff 算法\n * 说一下 $nextTick 的原理\n * Vue 组件 data 为什么必须是函数 ?\n * webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗\n * webpack 热更新原理\n * js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？css会阻塞js吗\n\n\n# Vue的组件传值的方式（12种）\n\nprops $emit .sync v-model ref $children / $parent $attrs / $listeners provide / inject EventBus Vuex $root slot\n\n\n# props的写法\n\n * props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n   \n   你可以基于对象的语法使用以下选项：\n   \n   * type：可以是下列原生构造函数中的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。\n   * default：any 为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n   * required：Boolean 定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n   * validator：Function 自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 false 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。\n\nprops: {\n        detail: {\n            type: Object,\n            default: () => {},\n            required: true\n        },\n        age: {\n          type: Number,\n          default: 0,\n          required: true,\n          validator: function (value) {\n            return value >= 0\n          }\n        }\n}\n\n// 子组件向父组件传值时，一个事件可以传递多个参数\n\n// 子组件点击事件\nclick(params1, params2) {\n    this.$emit('selectDay', params1, params2)\n}\n\n// 父组件获取值\n// <child  @selectDay=\"fun\"></child>\nfun (params1, params2) {\n   console.log(params1, params2) \n}\n\n\n\n# 打包工具webpack，rollup，parcel分别适用于什么场景？\n\n> webpack：一般用于大型复杂应用\n> \n> rollup：一般用于开发第三方类库，例如 vue 源码就是用 rollup 打包的\n> \n> parcel：轻量快捷，一般用于自己写一些小的 demo\n\n\n# 如何理解 vue 响应式原理？\n\n * Vue响应式原理详解\n * Vue 3.0响应式原理\n\n\n# computed和watcher的原理，有什么区别及应用场景？（Watcher，惰性）\n\n一、 计算属性（computed）\n\n> computed 是计算属性，它会根据你所依赖的数据动态显示新的计算结果\n\n通过计算出来的属性不需要调用直接可以在 DOM 里使用\n\n<div id='app'>\n  <p>我是原始值: {{ message }}</p>\n  <p>我是计算属性的值: {{ computedMessage }}</p> \n</div>\n\n    <script>\n        let app = new Vue({\n            el:'#app',\n            data: {\n                message: 'hello'\n            },\n            computed: {\n                computedMessage: function () {\n                    return this.message.split('').reverse().join('')\n                }\n            }      \n        })\n    <\/script>\n\n\n计算属性的set操作\n\n// set 操作\ncomputedMessage: {\n  get() {\n\t\treturn\n  }\n  set() {\n\t\treturn\n  }\n}\n\n\n二、methods同样可实现 （没有缓存，会计算多次）\n\n<div id=\"app\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage() }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage() }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage() }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage() }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage() }}\"</p>\n</div>\n\n<script>\nconst app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello'\n  },\n  methods: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // this 指向 Vue 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n<\/script>script>\n\n\n三、监听属性（watch）\n\n> 侦听属性 watch 用来观察和响应数据的变动。\n\n    <div id=\"demodiv\">      \n        <input type=\"text\" v-model=\"text\">\n        {{text}}         \n    </div>\n\n    <script>\n        new Vue({\n            el:\"#demodiv\",\n            data:{\n                    text:\"abcdefg\"\n            },\n            watch:{\n                text(newval,oldval){\n                    console.log(newval+'========'+oldval)\n                }\n            }\n        })\n    <\/script>\n\n\n（1）首先表明，computed 和 watch 都属于 watcher，在initState中初始化，一共有三种还有一种是渲染 Watcher 在 mount 中初始化，本质上都依赖于 Vue 的响应式原理。\n\n（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，其内部通过dirty属性标记计算属性是否需要重新求值。而 watch 则是当数据发生变化便会调用执行函数。\n\n（3）computed: 当某个数据需要随着（依赖于）另一个数据的变动而作出改变时，这时候你需要使用计算属性。 watch: 当某个数据发生变化时，需要对这个数据的变化进行反应（进行一系列操作），这时候你需要使用侦听属性。methods: 与计算属性不同的是，每次读取数据时，都是计算一遍，除非你不需要缓存，否则这样做需要大量的性能开销。\n\n\n# watch的两个参数\n\n * immediate：代表立即执行，而不是等监听对象改变再执行\n * deep：深度监听，对象的属性改变也可以监听的到\n\n可以参考这篇文章\n\n// 两种写法\nwatch: {\n    'user.firstName': function (newValue, oldValue) {\n        this.user.fullName = this.user.firstName + '' + this.user.lastName\n    }\n}\n\nwatch: {\n    'user': {\n        handler: function (newValue, oldValue) {\n        \tthis.user.fullName = this.user.firstName + '' + this.user.lastName\n    \t  },\n        deep: true,\n        immediate: true\n    }\n}\n\n\n\n# 三种类型的 Watcher 对象\n\n * 没有静态方法，因为 $watch 方法中要使用 Vue 的实例\n\n * Watcher 分三种：计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher\n   \n   * 计算属性 Watcher 在 initComputd 中创建\n   * 用户 Watcher (侦听器) 在 Vue.$watch 中创建\n   * 渲染 Watcher 在 mountComponent 中创建\n\n * Watcher内部实现是一样的，src/core/observer/watcher.js中，并且每一个Watcher都有一个id\n\n * 创建顺序：计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher\n\n * vm.$watch()\n   \n   * src\\core\\instance\\state.js\n\nVue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    // 获取 Vue 实例 this\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      // 判断如果 cb 是对象执行 createWatcher\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    // 创建用户 watcher 对象\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    // 判断 immediate 如果为 true\n    if (options.immediate) {\n      // 立即执行一次 cb 回调，并且把当前值传入\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    // 返回取消监听的方法\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n\n\n\n# 为什么 Vue3.0 采用了 proxy，有什么优势？\n\n * Vue响应式原理详解\n\n\n# 说一下模块化的方案，CommonJs，AMD，CMD，ESModules\n\n * 模块化\n\n\n# 介绍一下 Vue 的 Virtual DOM 与 Diff 算法\n\n * Virtual DOM 与 Diff 算法\n\n\n# 说一下 $nextTick 的原理\n\n * nextTick\n\n\n# Vue 组件 data 为什么必须是函数 ?\n\n> vue中data 是可以直接写成一个对象的,但这是保证这个组件不会被复用的情况下\n> \n> 由于组价的复用,其实是创建多个vue实例,如果data中仍然是只是一个对象,那么其实创建出来的实例保持的都是对同一个对象的引用。\n> \n> 所以我们通过 一个 函数执行返回了一个新的全新的数据对象。\n\n\n# webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗\n\n * webpack插件\n\n\n# webpack 热更新原理\n\n * 从零实现webpack热更新HMR\n\n\n# js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？css会阻塞js吗\n\n * css加载不会阻塞DOM树的解析\n * css加载会阻塞DOM树的渲染\n * css加载会阻塞后面js语句的执行",normalizedContent:"# 面试题（一）\n\n * vue的组件传值的方式（8种）\n   * 父传子：数组/对象形式，单向数据流（在子组件中改变prop会出现警告）\n   * 子传父：联系发布订阅模式（$emit,$on）讲一下，怎么实现一个发布订阅模式\n * 打包工具webpack，rollup，parcel分别适用于什么场景？\n * 如何理解 vue 响应式原理（2.0/3.0）？\n * computed和watcher的原理，有什么区别及应用场景？（watcher，惰性）\n * 为什么 vue3.0 采用了 proxy，有什么优势？\n * 说一下模块化的方案，commonjs，amd，cmd，es modules\n * 介绍一下 vue 的 virtual dom 与 diff 算法\n * 说一下 $nexttick 的原理\n * vue 组件 data 为什么必须是函数 ?\n * webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗\n * webpack 热更新原理\n * js执行会阻塞dom树的解析和渲染，那么css加载会阻塞dom树的解析和渲染吗？css会阻塞js吗\n\n\n# vue的组件传值的方式（12种）\n\nprops $emit .sync v-model ref $children / $parent $attrs / $listeners provide / inject eventbus vuex $root slot\n\n\n# props的写法\n\n * props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n   \n   你可以基于对象的语法使用以下选项：\n   \n   * type：可以是下列原生构造函数中的一种：string、number、boolean、array、object、date、function、symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。\n   * default：any 为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n   * required：boolean 定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n   * validator：function 自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 false 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。\n\nprops: {\n        detail: {\n            type: object,\n            default: () => {},\n            required: true\n        },\n        age: {\n          type: number,\n          default: 0,\n          required: true,\n          validator: function (value) {\n            return value >= 0\n          }\n        }\n}\n\n// 子组件向父组件传值时，一个事件可以传递多个参数\n\n// 子组件点击事件\nclick(params1, params2) {\n    this.$emit('selectday', params1, params2)\n}\n\n// 父组件获取值\n// <child  @selectday=\"fun\"></child>\nfun (params1, params2) {\n   console.log(params1, params2) \n}\n\n\n\n# 打包工具webpack，rollup，parcel分别适用于什么场景？\n\n> webpack：一般用于大型复杂应用\n> \n> rollup：一般用于开发第三方类库，例如 vue 源码就是用 rollup 打包的\n> \n> parcel：轻量快捷，一般用于自己写一些小的 demo\n\n\n# 如何理解 vue 响应式原理？\n\n * vue响应式原理详解\n * vue 3.0响应式原理\n\n\n# computed和watcher的原理，有什么区别及应用场景？（watcher，惰性）\n\n一、 计算属性（computed）\n\n> computed 是计算属性，它会根据你所依赖的数据动态显示新的计算结果\n\n通过计算出来的属性不需要调用直接可以在 dom 里使用\n\n<div id='app'>\n  <p>我是原始值: {{ message }}</p>\n  <p>我是计算属性的值: {{ computedmessage }}</p> \n</div>\n\n    <script>\n        let app = new vue({\n            el:'#app',\n            data: {\n                message: 'hello'\n            },\n            computed: {\n                computedmessage: function () {\n                    return this.message.split('').reverse().join('')\n                }\n            }      \n        })\n    <\/script>\n\n\n计算属性的set操作\n\n// set 操作\ncomputedmessage: {\n  get() {\n\t\treturn\n  }\n  set() {\n\t\treturn\n  }\n}\n\n\n二、methods同样可实现 （没有缓存，会计算多次）\n\n<div id=\"app\">\n  <p>original message: \"{{ message }}\"</p>\n  <p>computed reversed message: \"{{ reversedmessage() }}\"</p>\n  <p>computed reversed message: \"{{ reversedmessage() }}\"</p>\n  <p>computed reversed message: \"{{ reversedmessage() }}\"</p>\n  <p>computed reversed message: \"{{ reversedmessage() }}\"</p>\n  <p>computed reversed message: \"{{ reversedmessage() }}\"</p>\n</div>\n\n<script>\nconst app = new vue({\n  el: '#app',\n  data: {\n    message: 'hello'\n  },\n  methods: {\n    // 计算属性的 getter\n    reversedmessage: function () {\n      // this 指向 vue 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n<\/script>script>\n\n\n三、监听属性（watch）\n\n> 侦听属性 watch 用来观察和响应数据的变动。\n\n    <div id=\"demodiv\">      \n        <input type=\"text\" v-model=\"text\">\n        {{text}}         \n    </div>\n\n    <script>\n        new vue({\n            el:\"#demodiv\",\n            data:{\n                    text:\"abcdefg\"\n            },\n            watch:{\n                text(newval,oldval){\n                    console.log(newval+'========'+oldval)\n                }\n            }\n        })\n    <\/script>\n\n\n（1）首先表明，computed 和 watch 都属于 watcher，在initstate中初始化，一共有三种还有一种是渲染 watcher 在 mount 中初始化，本质上都依赖于 vue 的响应式原理。\n\n（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，其内部通过dirty属性标记计算属性是否需要重新求值。而 watch 则是当数据发生变化便会调用执行函数。\n\n（3）computed: 当某个数据需要随着（依赖于）另一个数据的变动而作出改变时，这时候你需要使用计算属性。 watch: 当某个数据发生变化时，需要对这个数据的变化进行反应（进行一系列操作），这时候你需要使用侦听属性。methods: 与计算属性不同的是，每次读取数据时，都是计算一遍，除非你不需要缓存，否则这样做需要大量的性能开销。\n\n\n# watch的两个参数\n\n * immediate：代表立即执行，而不是等监听对象改变再执行\n * deep：深度监听，对象的属性改变也可以监听的到\n\n可以参考这篇文章\n\n// 两种写法\nwatch: {\n    'user.firstname': function (newvalue, oldvalue) {\n        this.user.fullname = this.user.firstname + '' + this.user.lastname\n    }\n}\n\nwatch: {\n    'user': {\n        handler: function (newvalue, oldvalue) {\n        \tthis.user.fullname = this.user.firstname + '' + this.user.lastname\n    \t  },\n        deep: true,\n        immediate: true\n    }\n}\n\n\n\n# 三种类型的 watcher 对象\n\n * 没有静态方法，因为 $watch 方法中要使用 vue 的实例\n\n * watcher 分三种：计算属性 watcher、用户 watcher (侦听器)、渲染 watcher\n   \n   * 计算属性 watcher 在 initcomputd 中创建\n   * 用户 watcher (侦听器) 在 vue.$watch 中创建\n   * 渲染 watcher 在 mountcomponent 中创建\n\n * watcher内部实现是一样的，src/core/observer/watcher.js中，并且每一个watcher都有一个id\n\n * 创建顺序：计算属性 watcher、用户 watcher (侦听器)、渲染 watcher\n\n * vm.$watch()\n   \n   * src\\core\\instance\\state.js\n\nvue.prototype.$watch = function (\n    exporfn: string | function,\n    cb: any,\n    options?: object\n  ): function {\n    // 获取 vue 实例 this\n    const vm: component = this\n    if (isplainobject(cb)) {\n      // 判断如果 cb 是对象执行 createwatcher\n      return createwatcher(vm, exporfn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    // 创建用户 watcher 对象\n    const watcher = new watcher(vm, exporfn, cb, options)\n    // 判断 immediate 如果为 true\n    if (options.immediate) {\n      // 立即执行一次 cb 回调，并且把当前值传入\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleerror(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    // 返回取消监听的方法\n    return function unwatchfn () {\n      watcher.teardown()\n    }\n  }\n\n\n\n# 为什么 vue3.0 采用了 proxy，有什么优势？\n\n * vue响应式原理详解\n\n\n# 说一下模块化的方案，commonjs，amd，cmd，esmodules\n\n * 模块化\n\n\n# 介绍一下 vue 的 virtual dom 与 diff 算法\n\n * virtual dom 与 diff 算法\n\n\n# 说一下 $nexttick 的原理\n\n * nexttick\n\n\n# vue 组件 data 为什么必须是函数 ?\n\n> vue中data 是可以直接写成一个对象的,但这是保证这个组件不会被复用的情况下\n> \n> 由于组价的复用,其实是创建多个vue实例,如果data中仍然是只是一个对象,那么其实创建出来的实例保持的都是对同一个对象的引用。\n> \n> 所以我们通过 一个 函数执行返回了一个新的全新的数据对象。\n\n\n# webpack插件主要是做什么的，常用的有哪些，自己写过webpack插件吗\n\n * webpack插件\n\n\n# webpack 热更新原理\n\n * 从零实现webpack热更新hmr\n\n\n# js执行会阻塞dom树的解析和渲染，那么css加载会阻塞dom树的解析和渲染吗？css会阻塞js吗\n\n * css加载不会阻塞dom树的解析\n * css加载会阻塞dom树的渲染\n * css加载会阻塞后面js语句的执行",charsets:{cjk:!0}},{title:"面试题（二）",frontmatter:{title:"面试题（二）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-2.html",relativePath:"interview/interview-2.md",key:"v-39158f3f",path:"/interview/interview-2.html",headers:[{level:2,title:"使用正则判断邮箱是否合法",slug:"使用正则判断邮箱是否合法",normalizedTitle:"使用正则判断邮箱是否合法",charIndex:13},{level:2,title:"Cooike,sessionStorge,localStorge的区别",slug:"cooike-sessionstorge-localstorge的区别",normalizedTitle:"cooike,sessionstorge,localstorge的区别",charIndex:29},{level:2,title:"http 和 https",slug:"http-和-https",normalizedTitle:"http 和 https",charIndex:68},{level:2,title:"怎么解决跨域问题",slug:"怎么解决跨域问题",normalizedTitle:"怎么解决跨域问题",charIndex:84},{level:2,title:"输入域名到展示页面发生了什么",slug:"输入域名到展示页面发生了什么",normalizedTitle:"输入域名到展示页面发生了什么",charIndex:96},{level:2,title:"常见的状态码",slug:"常见的状态码",normalizedTitle:"常见的状态码",charIndex:114},{level:2,title:"get与post的区别",slug:"get与post的区别",normalizedTitle:"get与post的区别",charIndex:124},{level:2,title:"垃圾回收机制（GC算法）",slug:"垃圾回收机制-gc算法",normalizedTitle:"垃圾回收机制（gc算法）",charIndex:139},{level:2,title:"JS隐式转换与显示转换",slug:"js隐式转换与显示转换",normalizedTitle:"js隐式转换与显示转换",charIndex:155},{level:3,title:"隐式转换",slug:"隐式转换",normalizedTitle:"隐式转换",charIndex:157},{level:3,title:"显式转换",slug:"显式转换",normalizedTitle:"显式转换",charIndex:6494},{level:3,title:"几道小题",slug:"几道小题",normalizedTitle:"几道小题",charIndex:6947},{level:2,title:"对象的键支持什么类型",slug:"对象的键支持什么类型",normalizedTitle:"对象的键支持什么类型",charIndex:170}],lastUpdated:"7/14/2022, 8:08:21 PM",lastUpdatedTimestamp:1657800501e3,headersStr:"使用正则判断邮箱是否合法 Cooike,sessionStorge,localStorge的区别 http 和 https 怎么解决跨域问题 输入域名到展示页面发生了什么 常见的状态码 get与post的区别 垃圾回收机制（GC算法） JS隐式转换与显示转换 隐式转换 显式转换 几道小题 对象的键支持什么类型",content:'# 面试题（二）\n\n * 使用正则判断邮箱是否合法\n * Cooike,sessionStorge,localStorge的区别\n * http 和 https\n * 怎么解决跨域问题\n * 输入域名到展示页面发生了什么\n * 常见的状态码\n * get与post的区别\n * 垃圾回收机制（GC算法）\n * JS隐式转换与显示转换\n * 对象的键支持什么类型\n\n\n# 使用正则判断邮箱是否合法\n\nconst pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n//字符+@+字符+.+字母\npattern.test(str) // true or false\n\n\n> 正则基本知识\n\n//1.横向模糊匹配,一个正则可匹配的字符串的长度不是固定的\n//比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”\nvar regex = /ab{2,5}c/g;\nvar string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";\nconsole.log( string.match(regex) ); \n// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]\n\n//2.纵向模糊匹配，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符\n//比如/a[123]b/可以匹配如下三种字符串："a1b"、"a2b"、"a3b"。测试如下：\nvar regex = /a[123]b/g;\nvar string = "a0b a1b a2b a3b a4b";\nconsole.log( string.match(regex) ); \n// => ["a1b", "a2b", "a3b"]\n\n//3.范围表示法，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]\n//要匹配“a”、“-”、“z”这三者中任意一个字符，不能写成[a-z]，可以写成如下的方式：[-az]或[az-]或[a\\-z]\n\n//4.排除字符组\nvar regex = = /[^abc]/\n\n//5.常见简写\n/*\n\\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。\n\\D就是[^0-9]。表示除数字外的任意字符。\n\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\n\\W是[^0-9a-zA-Z_]。非单词字符。\n\\s是[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。\n\\S是[^ \\t\\v\\n\\r\\f]。 非空白符。\n.通配符，表示几乎任意字符。\n*/\n\n//6.多选分支\nvar regex = /good|nice/g;\nvar string = "good idea, nice try.";\nconsole.log( string.match(regex) ); \n// => ["good", "nice"]\n\n//7. ^代表开头，$代表结尾\n\n\n\n# Cooike,sessionStorge,localStorge的区别\n\n> Cooike始终在同源的HTTP请求中携带，会在浏览器和服务器之间传递。 sessionStorge和localStorge不会发送给服务器，仅在本地保存 Cooike不能超过4k，session和local一般小于5M localStorge存储的是持久数据，浏览器关闭不丢失。SessionStorge在关闭窗口后会自动删除。\n\n\n# http 和 https\n\n> https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。 SSL和TLS都是加密协议 通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。 所谓https，其实就是身披ssl协议这层外壳的http。（回忆一下osi7层,TCP/IP4层，我们学的是5层）\n> \n> SSL协议采用的是非对称加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密.\n> \n> RSA算法：两个大素数p,q，n=pq,f(n)=(p-1)(q-1),1<b<f(n),a=b^-1modf(n),公钥n,b,私钥p,q,a\n> \n> 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ Certificate Authority, CA）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥与 CA 用私钥生成的数字签名等信息写成证书颁发给申请者。\n\n\n# 怎么解决跨域问题\n\nhttp://www.a.com/a.js 访问以下URL的结果\n\nURL                            说明            是否允许通信\nhttp://www.a.com/b.js          同一域名下         允许\nhttp://www.a.com/script/b.js   同一域名下不同文件     允许\nhttp://www.a.com:8000/b.js     同一域名，不同端口     不允许\nhttps://www.a.com/b.js         同一域名，不同协议     不允许\nhttp://70.32.92.74/b.js        域名和域名对应IP     不允许\nhttp://script.a.com/b.js       主域相同子域不同      不允许\nhttp://a.com/b.js              同一域名，不同二级域名   不允许\nhttp://www.b.com/b.js          不同域名          不允许\n\n> 1、 通过jsonp跨域: 直接请求文件不行，请求JS可以，我们就把数据以JSON格式装进JS文件里，其实jsonp是前后端共同约定的一种结果。\n\n// jsonp原理(只支持get请求)\n// 1. 创建一个动态script节点\nlet jsonp = document.createElement(\'script\');\n// 2. 声明接收数据的回调函数\nfunction res(ev) {\n  // ev接收的就是服务端回复的数据\n  console.log(ev)\n}\n// 3. 为节点设置src属性, src属性为get请求, 后面拼接一个回调函数\njsonp.src = \'http://www.ceshi.com/api/jsonp?callback=res\';\n// 4. 将节点插入页面\nlet head = document.querySelector(\'head\');\nhead.appendChild(jsonp);\n// 5. 获取完数据删除节点\nhead.removeChild(jsonp);\n\n\n接收到的服务端返回内容为:\n\nres({"message":"JSONP请求测试成功","data":{}})\n\n\n可以看的返回的内容, 是我们之前传入的参数res, res被作为一个函数调用了, 而传递的数据作为该回调函数的实参传递了进来, 在script标签执行的时候, 就相当于执行了res()这个函数, 括号内部的数据也就变成了参数, 可以直接被函数接收处理, 如此便实现了跨域获取数据。\n\n> 2、 document.domain + iframe跨域: news.baidu.com和map.baidu.com的一级域名相同，故可以设置document.domain = “baidu.com”;就可以跨域\n> \n> 3、 location.hash + iframe\n> \n> 4、 window.name + iframe跨域\n> \n> 5、 postMessage跨域\n> \n> 6、 跨域资源共享（CORS） Access-Control-Allow-Origin: *\n> \n> 主要通过后端来配置，CORS规范将请求分为两种类型，一种是简单请求，一种是带预检的非简单请求。 如果是简单请求，就先执行服务端程序，然后浏览器才会判断是否跨域；GET HEAD,POST 而对于非简单请求，浏览器会在发送实际请求之前先发送一个OPTIONS的HTTP请求来判断服务器是否能接受该跨域 请求；如果不能接受的话，浏览器会直接阻止接下来实际请求的发生。 服务端可以设置携带cooike\n> \n> 7、 nginx代理跨域\n> \n> 正向代理：我们将请求发送给代理服务器，代理服务器去访问，然后将访问到的数据传递给我们。隐藏了客户端\n> \n> 反向代理：在服务器端，有很多服务器处理请求，nginx扮演的就是一个反向代理角色，隐藏了服务器。 启动nginx服务器把server_name设置成前端的域名，此时前端发起的请求相当于是localhost对localhost发 起，这样是不会引起跨域的。\n> \n> 8、 nodejs中间件代理跨域 与nginx代理跨域类似\n> \n> 9、 WebSocket协议跨域 WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯\n> \n> 10、webpack的proxy，webpack的dev-server模块会启动一个服务器，这个服务器不止帮我们做了自动更新，同时也可以做到反向代理。就是我们把请求发送给webpack-dev-server, 然后webpack-dev-server再去请求后端服务器，服务之间的请求是没有跨域问题的\n\n正向代理&反向代理\n\n\n# 输入域名到展示页面发生了什么\n\n(超详细）从输入url到页面展示发生了什么？\n\n> DNS（Domain Name System，域名系统），简单的说：就是把我们输入的网站域名翻译成IP地址的系统.\n> \n> 1.在浏览器中输入url\n> \n> 2.客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到\n> \n> 3.有了服务器的IP， 浏览器就要可以发起HTTP请求了,联系之前的HTTP和HTTPS\n> \n> 4.Http会基于TCP建立起一个到服务器的连接通道，TCP是面向连接可靠的服务，联系三次握手四次握手 Udp是无连接的，想发就发，不会对数据进行封装。适用于实时应用，就比如视频面试。TCP可靠，用于文件传输。\n> \n> 5.传输层下面是网络层，作用是把TCP分割好的各种数据包传送给接收方，这里需要用到mac地址，一个网络设备的IP地 址可以更换，但是MAC地址一般是固定不变的.ARP协议可以将IP地址解析成对应的MAC地址。\n> \n> 6.在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束\n> \n> 7.接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文,返回响应报文，联系返回码。\n> \n> 8.请求成功之后，服务器会返回响应的HTML文件，接下来就到页面渲染了，联系到渲染引擎。\n> \n> 9.构建dom树->计算DOM树每个结点的样式->页面布局->生成分层树->栅格化（转化为位图，GPU可以处理）->显示\n\n\n# 常见的状态码\n\n状态码\n\n\n# get与post的区别\n\n> GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接，传输数据会受URL长度限制 POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中，数据不受限制，数据不暴露会更安全\n\n * GET 方法参数写法是固定的吗？\n\n在约定中，我们的参数是写在 ? 后面，用 & 分割。\n\n我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。\n\n也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行。\n\n * POST 方法比 GET 方法安全？\n\n按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。\n\n然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。\n\n要想安全传输，就只有加密，也就是 HTTPS。\n\n * GET 方法的长度限制是怎么回事？\n\n在网上看到很多关于两者区别的文章都有这一条，提到浏览器地址栏输入的参数是有限的。\n\n首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。\n\n浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。\n\n * POST 方法会产生两个 TCP 数据包？\n\n有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。\n\nHTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为\n\n\n# 垃圾回收机制（GC算法）\n\nGC算法，V8引擎\n\n\n# JS隐式转换与显示转换\n\n\n# 隐式转换\n\n> 1.undefined与null相等，但不恒等（===） 2.一个是number一个是string时，会尝试将string转换为number 3.隐式转换将boolean转换为number，0或1 4.隐式转换将Object转换成number或string，取决于另外一个对比量的类型 5.对于0、空字符串的判断，建议使用 “===” 。 6.“==”会对不同类型值进行类型转换再判断，“===”则不会。它会先判断两边的值类型，类型不匹配时直接为false。\n\nundefined == null;  // true   \n== true;  // true  \n== true;  // false  \n== false;  // true\n== \'\';  // true   \nNaN == NaN;  // false  NaN不等于任何值\n[] == false;  // true  \n[] == ![];  // true           !会将其转为布尔值，![]的值为false，==操作符将false转为0，[]==0\n\'6\' - \'3\'  // 3               []也会转为数字0   0==0\n{} == !{}  //false           {} == false  ->  {} == 0  ->   NaN == 0    ->  false\n1234 + \'abcd\' // "1234abcd"\n\n\n\n# 显式转换\n\n> 显示转换一般指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n\nNumber(\'1234\') // 1234\nNumber(\'1234abcd\') // NaN\nNumber(\'\') // 0\nNumber(true) // 1\nNumber(null) // 0\nNumber(undefined) // NaN\nString(1234)  // "1234"\nString(\'abcd\')  // "abcd"\nString(true)  // "true"\nString(undefined) // "undefined"\nString(null)  // "null"\nBoolean(0)  // false\nBoolean(undefined)  // false\nBoolean(null)  // false\nBoolean(NaN)  // false\nBoolean(\'\')  // false\n\n\n\n# 几道小题\n\n[]+{}     //"[object Object]"\n{}+[]     //0\n1+-\'1\'+1  //1\n\'A\'-\'B\'   //NaN\n\n\n\n# 对象的键支持什么类型\n\n字符串或symbol\n\nconst person = {\n   \tname: \'yd\',\n    [Symbol()]: 18\n}\n',normalizedContent:'# 面试题（二）\n\n * 使用正则判断邮箱是否合法\n * cooike,sessionstorge,localstorge的区别\n * http 和 https\n * 怎么解决跨域问题\n * 输入域名到展示页面发生了什么\n * 常见的状态码\n * get与post的区别\n * 垃圾回收机制（gc算法）\n * js隐式转换与显示转换\n * 对象的键支持什么类型\n\n\n# 使用正则判断邮箱是否合法\n\nconst pattern = /^([a-za-z0-9_\\-\\.])+\\@([a-za-z0-9_\\-\\.])+\\.([a-za-z]{2,4})$/;\n//字符+@+字符+.+字母\npattern.test(str) // true or false\n\n\n> 正则基本知识\n\n//1.横向模糊匹配,一个正则可匹配的字符串的长度不是固定的\n//比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”\nvar regex = /ab{2,5}c/g;\nvar string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";\nconsole.log( string.match(regex) ); \n// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]\n\n//2.纵向模糊匹配，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符\n//比如/a[123]b/可以匹配如下三种字符串："a1b"、"a2b"、"a3b"。测试如下：\nvar regex = /a[123]b/g;\nvar string = "a0b a1b a2b a3b a4b";\nconsole.log( string.match(regex) ); \n// => ["a1b", "a2b", "a3b"]\n\n//3.范围表示法，比如[123456abcdefghijklm]，可以写成[1-6a-fg-m]\n//要匹配“a”、“-”、“z”这三者中任意一个字符，不能写成[a-z]，可以写成如下的方式：[-az]或[az-]或[a\\-z]\n\n//4.排除字符组\nvar regex = = /[^abc]/\n\n//5.常见简写\n/*\n\\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。\n\\d就是[^0-9]。表示除数字外的任意字符。\n\\w就是[0-9a-za-z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\n\\w是[^0-9a-za-z_]。非单词字符。\n\\s是[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。\n\\s是[^ \\t\\v\\n\\r\\f]。 非空白符。\n.通配符，表示几乎任意字符。\n*/\n\n//6.多选分支\nvar regex = /good|nice/g;\nvar string = "good idea, nice try.";\nconsole.log( string.match(regex) ); \n// => ["good", "nice"]\n\n//7. ^代表开头，$代表结尾\n\n\n\n# cooike,sessionstorge,localstorge的区别\n\n> cooike始终在同源的http请求中携带，会在浏览器和服务器之间传递。 sessionstorge和localstorge不会发送给服务器，仅在本地保存 cooike不能超过4k，session和local一般小于5m localstorge存储的是持久数据，浏览器关闭不丢失。sessionstorge在关闭窗口后会自动删除。\n\n\n# http 和 https\n\n> https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。 ssl和tls都是加密协议 通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。 所谓https，其实就是身披ssl协议这层外壳的http。（回忆一下osi7层,tcp/ip4层，我们学的是5层）\n> \n> ssl协议采用的是非对称加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密.\n> \n> rsa算法：两个大素数p,q，n=pq,f(n)=(p-1)(q-1),1<b<f(n),a=b^-1modf(n),公钥n,b,私钥p,q,a\n> \n> 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ certificate authority, ca）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥与 ca 用私钥生成的数字签名等信息写成证书颁发给申请者。\n\n\n# 怎么解决跨域问题\n\nhttp://www.a.com/a.js 访问以下url的结果\n\nurl                            说明            是否允许通信\nhttp://www.a.com/b.js          同一域名下         允许\nhttp://www.a.com/script/b.js   同一域名下不同文件     允许\nhttp://www.a.com:8000/b.js     同一域名，不同端口     不允许\nhttps://www.a.com/b.js         同一域名，不同协议     不允许\nhttp://70.32.92.74/b.js        域名和域名对应ip     不允许\nhttp://script.a.com/b.js       主域相同子域不同      不允许\nhttp://a.com/b.js              同一域名，不同二级域名   不允许\nhttp://www.b.com/b.js          不同域名          不允许\n\n> 1、 通过jsonp跨域: 直接请求文件不行，请求js可以，我们就把数据以json格式装进js文件里，其实jsonp是前后端共同约定的一种结果。\n\n// jsonp原理(只支持get请求)\n// 1. 创建一个动态script节点\nlet jsonp = document.createelement(\'script\');\n// 2. 声明接收数据的回调函数\nfunction res(ev) {\n  // ev接收的就是服务端回复的数据\n  console.log(ev)\n}\n// 3. 为节点设置src属性, src属性为get请求, 后面拼接一个回调函数\njsonp.src = \'http://www.ceshi.com/api/jsonp?callback=res\';\n// 4. 将节点插入页面\nlet head = document.queryselector(\'head\');\nhead.appendchild(jsonp);\n// 5. 获取完数据删除节点\nhead.removechild(jsonp);\n\n\n接收到的服务端返回内容为:\n\nres({"message":"jsonp请求测试成功","data":{}})\n\n\n可以看的返回的内容, 是我们之前传入的参数res, res被作为一个函数调用了, 而传递的数据作为该回调函数的实参传递了进来, 在script标签执行的时候, 就相当于执行了res()这个函数, 括号内部的数据也就变成了参数, 可以直接被函数接收处理, 如此便实现了跨域获取数据。\n\n> 2、 document.domain + iframe跨域: news.baidu.com和map.baidu.com的一级域名相同，故可以设置document.domain = “baidu.com”;就可以跨域\n> \n> 3、 location.hash + iframe\n> \n> 4、 window.name + iframe跨域\n> \n> 5、 postmessage跨域\n> \n> 6、 跨域资源共享（cors） access-control-allow-origin: *\n> \n> 主要通过后端来配置，cors规范将请求分为两种类型，一种是简单请求，一种是带预检的非简单请求。 如果是简单请求，就先执行服务端程序，然后浏览器才会判断是否跨域；get head,post 而对于非简单请求，浏览器会在发送实际请求之前先发送一个options的http请求来判断服务器是否能接受该跨域 请求；如果不能接受的话，浏览器会直接阻止接下来实际请求的发生。 服务端可以设置携带cooike\n> \n> 7、 nginx代理跨域\n> \n> 正向代理：我们将请求发送给代理服务器，代理服务器去访问，然后将访问到的数据传递给我们。隐藏了客户端\n> \n> 反向代理：在服务器端，有很多服务器处理请求，nginx扮演的就是一个反向代理角色，隐藏了服务器。 启动nginx服务器把server_name设置成前端的域名，此时前端发起的请求相当于是localhost对localhost发 起，这样是不会引起跨域的。\n> \n> 8、 nodejs中间件代理跨域 与nginx代理跨域类似\n> \n> 9、 websocket协议跨域 websocket protocol是html5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯\n> \n> 10、webpack的proxy，webpack的dev-server模块会启动一个服务器，这个服务器不止帮我们做了自动更新，同时也可以做到反向代理。就是我们把请求发送给webpack-dev-server, 然后webpack-dev-server再去请求后端服务器，服务之间的请求是没有跨域问题的\n\n正向代理&反向代理\n\n\n# 输入域名到展示页面发生了什么\n\n(超详细）从输入url到页面展示发生了什么？\n\n> dns（domain name system，域名系统），简单的说：就是把我们输入的网站域名翻译成ip地址的系统.\n> \n> 1.在浏览器中输入url\n> \n> 2.客户端先检查本地是否有对应的ip地址，若找到则返回响应的ip地址。若没找到则请求上级dns服务器，直至找到\n> \n> 3.有了服务器的ip， 浏览器就要可以发起http请求了,联系之前的http和https\n> \n> 4.http会基于tcp建立起一个到服务器的连接通道，tcp是面向连接可靠的服务，联系三次握手四次握手 udp是无连接的，想发就发，不会对数据进行封装。适用于实时应用，就比如视频面试。tcp可靠，用于文件传输。\n> \n> 5.传输层下面是网络层，作用是把tcp分割好的各种数据包传送给接收方，这里需要用到mac地址，一个网络设备的ip地 址可以更换，但是mac地址一般是固定不变的.arp协议可以将ip地址解析成对应的mac地址。\n> \n> 6.在找到对方的mac地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束\n> \n> 7.接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过tcp协议讲分段的数据包重新组成原来的http请求报文,返回响应报文，联系返回码。\n> \n> 8.请求成功之后，服务器会返回响应的html文件，接下来就到页面渲染了，联系到渲染引擎。\n> \n> 9.构建dom树->计算dom树每个结点的样式->页面布局->生成分层树->栅格化（转化为位图，gpu可以处理）->显示\n\n\n# 常见的状态码\n\n状态码\n\n\n# get与post的区别\n\n> get请求，请求的数据会附加在url之后，以?分割url和传输数据，多个参数用&连接，传输数据会受url长度限制 post请求：post请求会把请求的数据放置在http请求包的包体中，数据不受限制，数据不暴露会更安全\n\n * get 方法参数写法是固定的吗？\n\n在约定中，我们的参数是写在 ? 后面，用 & 分割。\n\n我们知道，解析报文的过程是通过获取 tcp 数据，用正则等工具从数据中获取 header 和 body，从而提取参数。\n\n也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行。\n\n * post 方法比 get 方法安全？\n\n按照网上大部分文章的解释，post 比 get 安全，因为数据在地址栏上不可见。\n\n然而，从传输的角度来说，他们都是不安全的，因为 http 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。\n\n要想安全传输，就只有加密，也就是 https。\n\n * get 方法的长度限制是怎么回事？\n\n在网上看到很多关于两者区别的文章都有这一条，提到浏览器地址栏输入的参数是有限的。\n\n首先说明一点，http 协议没有 body 和 url 的长度限制，对 url 限制的大多是浏览器和服务器的原因。\n\n浏览器原因就不说了，服务器是因为处理长 url 要消耗比较多的资源，为了性能和安全（防止恶意构造长 url 来攻击）考虑，会给 url 长度加限制。\n\n * post 方法会产生两个 tcp 数据包？\n\n有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。\n\nhttp 协议中没有明确说明 post 会产生两个 tcp 数据包，而且实际测试(chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为\n\n\n# 垃圾回收机制（gc算法）\n\ngc算法，v8引擎\n\n\n# js隐式转换与显示转换\n\n\n# 隐式转换\n\n> 1.undefined与null相等，但不恒等（===） 2.一个是number一个是string时，会尝试将string转换为number 3.隐式转换将boolean转换为number，0或1 4.隐式转换将object转换成number或string，取决于另外一个对比量的类型 5.对于0、空字符串的判断，建议使用 “===” 。 6.“==”会对不同类型值进行类型转换再判断，“===”则不会。它会先判断两边的值类型，类型不匹配时直接为false。\n\nundefined == null;  // true   \n== true;  // true  \n== true;  // false  \n== false;  // true\n== \'\';  // true   \nnan == nan;  // false  nan不等于任何值\n[] == false;  // true  \n[] == ![];  // true           !会将其转为布尔值，![]的值为false，==操作符将false转为0，[]==0\n\'6\' - \'3\'  // 3               []也会转为数字0   0==0\n{} == !{}  //false           {} == false  ->  {} == 0  ->   nan == 0    ->  false\n1234 + \'abcd\' // "1234abcd"\n\n\n\n# 显式转换\n\n> 显示转换一般指使用number、string和boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n\nnumber(\'1234\') // 1234\nnumber(\'1234abcd\') // nan\nnumber(\'\') // 0\nnumber(true) // 1\nnumber(null) // 0\nnumber(undefined) // nan\nstring(1234)  // "1234"\nstring(\'abcd\')  // "abcd"\nstring(true)  // "true"\nstring(undefined) // "undefined"\nstring(null)  // "null"\nboolean(0)  // false\nboolean(undefined)  // false\nboolean(null)  // false\nboolean(nan)  // false\nboolean(\'\')  // false\n\n\n\n# 几道小题\n\n[]+{}     //"[object object]"\n{}+[]     //0\n1+-\'1\'+1  //1\n\'a\'-\'b\'   //nan\n\n\n\n# 对象的键支持什么类型\n\n字符串或symbol\n\nconst person = {\n   \tname: \'yd\',\n    [symbol()]: 18\n}\n',charsets:{cjk:!0}},{title:"面试题（六）",frontmatter:{title:"面试题（六）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-6.html",relativePath:"interview/interview-6.md",key:"v-d8e7da82",path:"/interview/interview-6.html",headers:[{level:2,title:"什么是脱离文档流，定位与浮动",slug:"什么是脱离文档流-定位与浮动",normalizedTitle:"什么是脱离文档流，定位与浮动",charIndex:13},{level:2,title:"值类型与引用类型，堆和栈",slug:"值类型与引用类型-堆和栈",normalizedTitle:"值类型与引用类型，堆和栈",charIndex:31},{level:2,title:"MVC与MVVM",slug:"mvc与mvvm",normalizedTitle:"mvc与mvvm",charIndex:47},{level:2,title:"cookie和session的区别",slug:"cookie和session的区别",normalizedTitle:"cookie和session的区别",charIndex:59},{level:3,title:"Cookie和Session关系",slug:"cookie和session关系",normalizedTitle:"cookie和session关系",charIndex:1393},{level:3,title:"Cookie带来的安全性问题",slug:"cookie带来的安全性问题",normalizedTitle:"cookie带来的安全性问题",charIndex:1526},{level:3,title:"如何防御",slug:"如何防御",normalizedTitle:"如何防御",charIndex:1561},{level:2,title:"html5的标签",slug:"html5的标签",normalizedTitle:"html5的标签",charIndex:80},{level:2,title:"数组和链表的对比",slug:"数组和链表的对比",normalizedTitle:"数组和链表的对比",charIndex:92},{level:2,title:"怎么实现轮播图",slug:"怎么实现轮播图",normalizedTitle:"怎么实现轮播图",charIndex:104},{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:122},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:133},{level:2,title:"数组扁平化带深度参数",slug:"数组扁平化带深度参数",normalizedTitle:"数组扁平化带深度参数",charIndex:147},{level:2,title:"for 循环的问题怎么解决",slug:"for-循环的问题怎么解决",normalizedTitle:"for 循环的问题怎么解决",charIndex:161}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"什么是脱离文档流，定位与浮动 值类型与引用类型，堆和栈 MVC与MVVM cookie和session的区别 Cookie和Session关系 Cookie带来的安全性问题 如何防御 html5的标签 数组和链表的对比 怎么实现轮播图 原型链 instanceof 数组扁平化带深度参数 for 循环的问题怎么解决",content:'# 面试题（六）\n\n * 什么是脱离文档流，定位与浮动\n * 值类型与引用类型，堆和栈\n * MVC与MVVM\n * cookie和session的区别\n * html5的标签\n * 数组和链表的对比\n * 怎么实现轮播图\n * 口述一下什么是原型链\n * 详细理解instanceof\n * 数组扁平化带深度参数\n * for 循环的问题怎么解决\n\n\n# 什么是脱离文档流，定位与浮动\n\n所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。\n\n脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。\n\n浮动 ( float ) 和绝对定位 ( position:absolute )\n\n（1）均脱离文档流\n\n（2）均不占位\n\n（3）浮动情况下，其他元素会自动在其右边排列。绝对定位会完全忽视其存在。\n\n * 盒子模型\n\n\n# 值类型与引用类型，堆和栈\n\n * undefined null number string boolean symbol 属于值类型，object array function 属于引用类型\n\n * 值类型存储在栈中，引用类型存储在堆中。\n\n * 值类型有固定的大小和值，存放在栈中，而引用类型不确定大小，但是其引用地址是固定的，因此，它的地址存在栈中，指向存在堆中的对象。\n\n * 值类型不可添加属性和方法，而引用类型可以添加属性和方法\n\n * 值类型比较只要相等，就可以用==或者===来比较，但是引用类型，即使let s = {};let s1 = {};但他们的内存地址不一样，比较依然不相等。\n\n * stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。\n\n * 图示\n\n\n# MVC与MVVM\n\n（1）MVC的定义：MVC是Model-View- Controller的简写。即模型-视图-控制器。\n\n * Model（模型）表示应用程序核心（如数据库）。\n * View（视图）显示效果（HTML页面）。\n * Controller（控制器）处理输入（业务逻辑）。\n\n（2）MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。是MVC的升级版\n\n * 【模型】指的是后端传递的数据。\n * 【视图】指的是所看到的页面。\n * 【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向，也就是常说的双向绑定。\n\n（3）在以前传统的开发模式当中即MVC模式，前端人员只负责MVC当中的View（视图）部分，写好页面交由后端创建渲染模板并提供数据，随着MVVM模式的出现前端已经可以自己写业务逻辑以及渲染模板，后端只负责数据即可，前端所能做的事情越来越多。\n\n\n# cookie和session的区别\n\n> Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了 。\n\n * Cookie 和 Session 关系和区别\n\n\n# Cookie和Session关系\n\n 1. 都是为了实现客户端与服务端交互而产出\n 2. Cookie是保存在客户端，缺点易伪造、不安全\n 3. Session是保存在服务端，会消耗服务器资源\n 4. Session实现有两种方式：Cookie和URL重写\n\n\n# Cookie带来的安全性问题\n\n * CSRF\n * XSS\n\n\n# 如何防御\n\n\n# html5的标签\n\n<footer>:定义区段或页面的页脚.(足部)\n<section>:定义文档中的区段.\n<article>:定义文章.\n<aside>:定义页面内容之外的内容.\n<details>:定义元素的细节.\n<audio>:定义声音内容.\n<video>:定义视频.\n<iframe>:内联框架.\n\n\n\n# 数组和链表的对比\n\n数组存储方式采用线性结构，声明数组时需要声明类型，并且大小也会固定：\n\n * 优点：\n\n因此访问数组元素可根据数组下标随机访问，O(1).\n\n * 缺点：\n\n大小固定，可能会造成空间浪费，或空间不够影响程序运行；\n\n插入和删除元素却比较麻烦，可能需要移动部分数组元素以保证数组元素的物理位置保持连续。\n\n链表采用链式存储结构，在声明时只需声明结构类型，：\n\n * 优点：\n\n链表大小在实际使用中可以动态增大和减小；\n\n插入和删除操作就很方便，只需修改该元素节点邻接元素即可O(1).\n\n * 缺点：\n\n访问元素比较费时，需要逐个节点进行查看或能找到目标元素。\n\n\n# 怎么实现轮播图\n\n// 若果有在等待的定时器，则清掉\nif (timer) {\n    clearInterval(timer);\n    timer = null;\n}\n//自动切换\ntimer = setInterval(autoPlay, 4000);\n\n//定义自动播放函数\nfunction autoPlay() {\n    index++;\n    if (list.length <=index) {\n        index = 0;\n    }\n\n    changeImg(index);\n    // alert("我正在autoplay");\n}\n\n// 定义图片切换函数（根据当前的index值也就是curindex）\nfunction changeImg(curIndex) {\n    for (var j = 0; j < list.length; j++) {\n        list[j].className = "";\n    }\n    // 改变当前显示索引\n    list[curIndex].className = "on";\n    pic.style.marginLeft = -1920 * curIndex + "px";\n    index = curIndex;\n}\n\n// 鼠标划过整个容器时停止自动播放\nwrap.onmouseover = function(curIndex) {\n    clearInterval(timer);\n    //点击右按钮\n}\n\n// 鼠标离开整个容器时继续播放至下一张\nwrap.onmouseout = function() {\n    timer = setInterval(autoPlay, 4000);\n    // alert("鼠标移走了");\n}\n\n// 遍历所有数字导航实现划过切换至对应的图片\nfor (var i = 0; i < list.length; i++) {\n    list[i].id = i;\n    list[i].onmouseover = function() {\n        clearInterval(timer);\n        changeImg(this.id);\n    }\n}\n\n\n\n# 原型链\n\n> 每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。\n\n * 原型和原型链\n\n\n# instanceof\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 A instanceof B //判断 B 的 prototype 属性指向的原型对象(B.prototype)是否在对象 A 的原型链上。\n\nfunction _instanceof(L, R) { //L为instanceof左表达式，R为右表达式\n  let Ro = R.prototype //原型\n  L = L.__proto__ //隐式原型\n  while (true) {\n    if (L === null) { //当到达L原型链顶端还未匹配，返回false\n      return false\n    }\n    if (L === Ro) { //全等时，返回true\n      return true\n    }\n    L = L.__proto__\n  }\n}\n\nlet num = 1\nnum.__proto__ === Number.prototype // true\nnum instanceof Number // false\n\nnum = new Number(1)\nnum.__proto__ === Number.prototype // true\nnum instanceof Number // true\n\nnum.__proto__ === (new Number(1)).__proto__ // true\n\n\nObject instanceof Object // true\nFunction instanceof Function // true\nFunction instanceof Object // true\n\nNumber instanceof Number // false\nString instanceof String // false\n\n// Object和Function都是构造函数，而所有的构造函数都是Function的实例，因此，Object是Function的实例对象。\n\nconsole.log(Object instanceof Function)\nconsole.log(Number instanceof Function) \nconsole.log(String instanceof Function)\nconsole.log(Function instanceof Function)\n\nconsole.log(Function instanceof Object)\n\nconsole.log(Object instanceof Object)\nconsole.log(Number instanceof Object) \nconsole.log(String instanceof Object)\nconsole.log(Function instanceof Object)\n\n// 均为 true\n\n\n * Object和Function图示\n\n\n# 数组扁平化带深度参数\n\nfunction flattern(list,depth){\n    let res = []\n    for(let item of list){\n        if(Array.isArray(item)&&depth>0){\n            res = res.concat(flattern(item,depth-1))\n        }else{\n            res.push(item)\n        }\n    }\n    return res\n}\n\n// 写一个函数，将传进去的数组按深度展开\nlist = [1,2,[3,4],[5,6,[7,8],9],10,11]\n// depth 等于 1 时输出\n//depth = 1 :[1,2,3,4,5,6,[7,8],9,10,11]\n// depth 等于 2 时输出\n//depth = 2 :[1,2,3,4,5,6,7,8,9,10,11]\n\nconsole.log(flattern(list,1))\nconsole.log(flattern(list,2))\n\n\n\n# for 循环的问题怎么解决\n\n<ul>\n    <li>第一个</li>\n    <li>第二个</li>\n    <li>第三个</li>\n    <li>第四个</li>\n</ul>\n\n<script>\n    let oli = document.getElementsByTagName("li")\n    for(var i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // //相当于\n    var i\n    i=0\n    oli[0].onclick = function(){\n        console.log(i)\n    }\n    i=1\n    oli[1].onclick = function(){\n        console.log(i)\n    }\n    i=2\n    oli[2].onclick = function(){\n        console.log(i)\n    }\n    i=3\n    oli[3].onclick = function(){\n        console.log(i)\n    }\n    //按照词法作用域查找，会每次都找到全局的i\n\n\n    //方法一：改为let\n    for(let i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    //let声明了一个块级作用域，以上相当于\n    for(let i=0;i<4;i++){\n        let i = //隐藏作用域里的i\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        }\n    //这个时候在执行点击事件时，i会在for循环的第一行找到i的值\n\n    //方法二：闭包\n    for(var i=0;i<4;i++){\n        (function(i){\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        })(i)\n    }\n\n    //方法三：暂存数据,和let原理类似\n    for(var i=0;i<4;i++){\n        oli[i].index = i\n        oli[i].onclick = function(){\n            console.log(this.index)\n        }\n    }\n\n    //方法四：事件委托\n    var oul = document.getElementsByTagName("ul")[0];\n    oul.onclick = function(e){\n        var e = e || window.event\n        var target = e.target || e.srcElement\n        if(target.nodeName.toLowerCase() == \'li\'){\n            var li=this.querySelectorAll("li");\n            var index = Array.prototype.indexOf.call(li,target);\n            console.log(index);\n        }\n    }\n\n\nfor (let i = 0; i < 3; i++) {\n    let i = \'foo\'\n    console.log(i) //foo foo foo\n}\n',normalizedContent:'# 面试题（六）\n\n * 什么是脱离文档流，定位与浮动\n * 值类型与引用类型，堆和栈\n * mvc与mvvm\n * cookie和session的区别\n * html5的标签\n * 数组和链表的对比\n * 怎么实现轮播图\n * 口述一下什么是原型链\n * 详细理解instanceof\n * 数组扁平化带深度参数\n * for 循环的问题怎么解决\n\n\n# 什么是脱离文档流，定位与浮动\n\n所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。\n\n脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。\n\n浮动 ( float ) 和绝对定位 ( position:absolute )\n\n（1）均脱离文档流\n\n（2）均不占位\n\n（3）浮动情况下，其他元素会自动在其右边排列。绝对定位会完全忽视其存在。\n\n * 盒子模型\n\n\n# 值类型与引用类型，堆和栈\n\n * undefined null number string boolean symbol 属于值类型，object array function 属于引用类型\n\n * 值类型存储在栈中，引用类型存储在堆中。\n\n * 值类型有固定的大小和值，存放在栈中，而引用类型不确定大小，但是其引用地址是固定的，因此，它的地址存在栈中，指向存在堆中的对象。\n\n * 值类型不可添加属性和方法，而引用类型可以添加属性和方法\n\n * 值类型比较只要相等，就可以用==或者===来比较，但是引用类型，即使let s = {};let s1 = {};但他们的内存地址不一样，比较依然不相等。\n\n * stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。\n\n * 图示\n\n\n# mvc与mvvm\n\n（1）mvc的定义：mvc是model-view- controller的简写。即模型-视图-控制器。\n\n * model（模型）表示应用程序核心（如数据库）。\n * view（视图）显示效果（html页面）。\n * controller（控制器）处理输入（业务逻辑）。\n\n（2）mvvm是model-view-viewmodel的简写。即模型-视图-视图模型。是mvc的升级版\n\n * 【模型】指的是后端传递的数据。\n * 【视图】指的是所看到的页面。\n * 【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向，也就是常说的双向绑定。\n\n（3）在以前传统的开发模式当中即mvc模式，前端人员只负责mvc当中的view（视图）部分，写好页面交由后端创建渲染模板并提供数据，随着mvvm模式的出现前端已经可以自己写业务逻辑以及渲染模板，后端只负责数据即可，前端所能做的事情越来越多。\n\n\n# cookie和session的区别\n\n> session是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了 。\n\n * cookie 和 session 关系和区别\n\n\n# cookie和session关系\n\n 1. 都是为了实现客户端与服务端交互而产出\n 2. cookie是保存在客户端，缺点易伪造、不安全\n 3. session是保存在服务端，会消耗服务器资源\n 4. session实现有两种方式：cookie和url重写\n\n\n# cookie带来的安全性问题\n\n * csrf\n * xss\n\n\n# 如何防御\n\n\n# html5的标签\n\n<footer>:定义区段或页面的页脚.(足部)\n<section>:定义文档中的区段.\n<article>:定义文章.\n<aside>:定义页面内容之外的内容.\n<details>:定义元素的细节.\n<audio>:定义声音内容.\n<video>:定义视频.\n<iframe>:内联框架.\n\n\n\n# 数组和链表的对比\n\n数组存储方式采用线性结构，声明数组时需要声明类型，并且大小也会固定：\n\n * 优点：\n\n因此访问数组元素可根据数组下标随机访问，o(1).\n\n * 缺点：\n\n大小固定，可能会造成空间浪费，或空间不够影响程序运行；\n\n插入和删除元素却比较麻烦，可能需要移动部分数组元素以保证数组元素的物理位置保持连续。\n\n链表采用链式存储结构，在声明时只需声明结构类型，：\n\n * 优点：\n\n链表大小在实际使用中可以动态增大和减小；\n\n插入和删除操作就很方便，只需修改该元素节点邻接元素即可o(1).\n\n * 缺点：\n\n访问元素比较费时，需要逐个节点进行查看或能找到目标元素。\n\n\n# 怎么实现轮播图\n\n// 若果有在等待的定时器，则清掉\nif (timer) {\n    clearinterval(timer);\n    timer = null;\n}\n//自动切换\ntimer = setinterval(autoplay, 4000);\n\n//定义自动播放函数\nfunction autoplay() {\n    index++;\n    if (list.length <=index) {\n        index = 0;\n    }\n\n    changeimg(index);\n    // alert("我正在autoplay");\n}\n\n// 定义图片切换函数（根据当前的index值也就是curindex）\nfunction changeimg(curindex) {\n    for (var j = 0; j < list.length; j++) {\n        list[j].classname = "";\n    }\n    // 改变当前显示索引\n    list[curindex].classname = "on";\n    pic.style.marginleft = -1920 * curindex + "px";\n    index = curindex;\n}\n\n// 鼠标划过整个容器时停止自动播放\nwrap.onmouseover = function(curindex) {\n    clearinterval(timer);\n    //点击右按钮\n}\n\n// 鼠标离开整个容器时继续播放至下一张\nwrap.onmouseout = function() {\n    timer = setinterval(autoplay, 4000);\n    // alert("鼠标移走了");\n}\n\n// 遍历所有数字导航实现划过切换至对应的图片\nfor (var i = 0; i < list.length; i++) {\n    list[i].id = i;\n    list[i].onmouseover = function() {\n        clearinterval(timer);\n        changeimg(this.id);\n    }\n}\n\n\n\n# 原型链\n\n> 每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。\n\n * 原型和原型链\n\n\n# instanceof\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 a instanceof b //判断 b 的 prototype 属性指向的原型对象(b.prototype)是否在对象 a 的原型链上。\n\nfunction _instanceof(l, r) { //l为instanceof左表达式，r为右表达式\n  let ro = r.prototype //原型\n  l = l.__proto__ //隐式原型\n  while (true) {\n    if (l === null) { //当到达l原型链顶端还未匹配，返回false\n      return false\n    }\n    if (l === ro) { //全等时，返回true\n      return true\n    }\n    l = l.__proto__\n  }\n}\n\nlet num = 1\nnum.__proto__ === number.prototype // true\nnum instanceof number // false\n\nnum = new number(1)\nnum.__proto__ === number.prototype // true\nnum instanceof number // true\n\nnum.__proto__ === (new number(1)).__proto__ // true\n\n\nobject instanceof object // true\nfunction instanceof function // true\nfunction instanceof object // true\n\nnumber instanceof number // false\nstring instanceof string // false\n\n// object和function都是构造函数，而所有的构造函数都是function的实例，因此，object是function的实例对象。\n\nconsole.log(object instanceof function)\nconsole.log(number instanceof function) \nconsole.log(string instanceof function)\nconsole.log(function instanceof function)\n\nconsole.log(function instanceof object)\n\nconsole.log(object instanceof object)\nconsole.log(number instanceof object) \nconsole.log(string instanceof object)\nconsole.log(function instanceof object)\n\n// 均为 true\n\n\n * object和function图示\n\n\n# 数组扁平化带深度参数\n\nfunction flattern(list,depth){\n    let res = []\n    for(let item of list){\n        if(array.isarray(item)&&depth>0){\n            res = res.concat(flattern(item,depth-1))\n        }else{\n            res.push(item)\n        }\n    }\n    return res\n}\n\n// 写一个函数，将传进去的数组按深度展开\nlist = [1,2,[3,4],[5,6,[7,8],9],10,11]\n// depth 等于 1 时输出\n//depth = 1 :[1,2,3,4,5,6,[7,8],9,10,11]\n// depth 等于 2 时输出\n//depth = 2 :[1,2,3,4,5,6,7,8,9,10,11]\n\nconsole.log(flattern(list,1))\nconsole.log(flattern(list,2))\n\n\n\n# for 循环的问题怎么解决\n\n<ul>\n    <li>第一个</li>\n    <li>第二个</li>\n    <li>第三个</li>\n    <li>第四个</li>\n</ul>\n\n<script>\n    let oli = document.getelementsbytagname("li")\n    for(var i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // //相当于\n    var i\n    i=0\n    oli[0].onclick = function(){\n        console.log(i)\n    }\n    i=1\n    oli[1].onclick = function(){\n        console.log(i)\n    }\n    i=2\n    oli[2].onclick = function(){\n        console.log(i)\n    }\n    i=3\n    oli[3].onclick = function(){\n        console.log(i)\n    }\n    //按照词法作用域查找，会每次都找到全局的i\n\n\n    //方法一：改为let\n    for(let i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    //let声明了一个块级作用域，以上相当于\n    for(let i=0;i<4;i++){\n        let i = //隐藏作用域里的i\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        }\n    //这个时候在执行点击事件时，i会在for循环的第一行找到i的值\n\n    //方法二：闭包\n    for(var i=0;i<4;i++){\n        (function(i){\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        })(i)\n    }\n\n    //方法三：暂存数据,和let原理类似\n    for(var i=0;i<4;i++){\n        oli[i].index = i\n        oli[i].onclick = function(){\n            console.log(this.index)\n        }\n    }\n\n    //方法四：事件委托\n    var oul = document.getelementsbytagname("ul")[0];\n    oul.onclick = function(e){\n        var e = e || window.event\n        var target = e.target || e.srcelement\n        if(target.nodename.tolowercase() == \'li\'){\n            var li=this.queryselectorall("li");\n            var index = array.prototype.indexof.call(li,target);\n            console.log(index);\n        }\n    }\n\n\nfor (let i = 0; i < 3; i++) {\n    let i = \'foo\'\n    console.log(i) //foo foo foo\n}\n',charsets:{cjk:!0}},{title:"面试题（五）",frontmatter:{title:"面试题（五）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-5.html",relativePath:"interview/interview-5.md",key:"v-7cee71df",path:"/interview/interview-5.html",headers:[{level:2,title:"什么是事件冒泡，事件捕获，事件委托",slug:"什么是事件冒泡-事件捕获-事件委托",normalizedTitle:"什么是事件冒泡，事件捕获，事件委托",charIndex:13},{level:3,title:"如何阻止冒泡和默认事件",slug:"如何阻止冒泡和默认事件",normalizedTitle:"如何阻止冒泡和默认事件",charIndex:2553},{level:2,title:"重绘和回流",slug:"重绘和回流",normalizedTitle:"重绘和回流",charIndex:34},{level:3,title:"什么是回流",slug:"什么是回流",normalizedTitle:"什么是回流",charIndex:4088},{level:3,title:"什么是重绘",slug:"什么是重绘",normalizedTitle:"什么是重绘",charIndex:4291},{level:3,title:"区别：",slug:"区别",normalizedTitle:"区别：",charIndex:4382},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",normalizedTitle:"浏览器的优化机制",charIndex:4517},{level:3,title:"如何减少回流，重绘",slug:"如何减少回流-重绘",normalizedTitle:"如何减少回流，重绘",charIndex:4622},{level:2,title:"requestAnimationFrame 和 setTimeout",slug:"requestanimationframe-和-settimeout",normalizedTitle:"requestanimationframe 和 settimeout",charIndex:43},{level:3,title:"（1）seTimeout实现动画：",slug:"_1-setimeout实现动画",normalizedTitle:"（1）setimeout实现动画：",charIndex:4816},{level:3,title:"（2）requestAnimationFrame实现动画：",slug:"_2-requestanimationframe实现动画",normalizedTitle:"（2）requestanimationframe实现动画：",charIndex:5319},{level:2,title:"介绍一下前端路由",slug:"介绍一下前端路由",normalizedTitle:"介绍一下前端路由",charIndex:81},{level:2,title:"for in 和 for of",slug:"for-in-和-for-of",normalizedTitle:"for in 和 for of",charIndex:93},{level:3,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:6658},{level:2,title:"场景题：参数拼接",slug:"场景题-参数拼接",normalizedTitle:"场景题：参数拼接",charIndex:112},{level:2,title:"css可继承的属性",slug:"css可继承的属性",normalizedTitle:"css可继承的属性",charIndex:124},{level:2,title:"git有几种状态",slug:"git有几种状态",normalizedTitle:"git有几种状态",charIndex:137},{level:2,title:"简述 new 一个对象的过程",slug:"简述-new-一个对象的过程",normalizedTitle:"简述 new 一个对象的过程",charIndex:149},{level:3,title:"一道面试题",slug:"一道面试题",normalizedTitle:"一道面试题",charIndex:10456},{level:2,title:"数据属性与访问器属性",slug:"数据属性与访问器属性",normalizedTitle:"数据属性与访问器属性",charIndex:167}],lastUpdated:"6/20/2025, 5:49:03 PM",lastUpdatedTimestamp:1750412943e3,headersStr:"什么是事件冒泡，事件捕获，事件委托 如何阻止冒泡和默认事件 重绘和回流 什么是回流 什么是重绘 区别： 浏览器的优化机制 如何减少回流，重绘 requestAnimationFrame 和 setTimeout （1）seTimeout实现动画： （2）requestAnimationFrame实现动画： 介绍一下前端路由 for in 和 for of 迭代器 场景题：参数拼接 css可继承的属性 git有几种状态 简述 new 一个对象的过程 一道面试题 数据属性与访问器属性",content:"# 面试题（五）\n\n * 什么是事件冒泡，事件捕获，事件委托\n * 重绘和回流\n * requestAnimationFrame 和 setTimeout\n * 介绍一下前端路由\n * for in 和 for of\n * 场景题：参数拼接\n * css可继承的属性\n * git有几种状态\n * 简述 new 一个对象的过程\n * 数据属性与访问器属性\n\n\n# 什么是事件冒泡，事件捕获，事件委托\n\n * 事件冒泡\n\n> 当给父子元素的同一事件绑定方法的时候，触发子元素身上的事件，执行完毕之后，也会触发父级元素相同的事件，这种机制叫事件冒泡\n\n * 事件捕获\n\n> 给父子元素用绑定同一事件时，当触发子元素身上的事件时，先触发父元素，然后在传递给子元素，这种传播机制叫事件捕获；\n\n实际操作中，我们可以通过 element.addEventListener() 设置一个元素的事件模型为冒泡事件或者捕获事件。 先来看一下 addEventListener 函数的语法：\n\nelement.addEventListener(type, listener, useCapture)\n\n\n * type 监听事件类型的字符串\n * listener 事件监听回调函数，即事件触发后要处理的函数\n * useCapture 默认值false，表示事件冒泡；设为true时，表示事件捕获\n\n       <div id=\"box1\">\n            <div id=\"box2\">\n                <div id=\"box3\"></div>\n            </div>\n        </div>\n\n        <script>\n            function sayBox3() {\n                console.log('你点了最里面的box');\n            }\n            function sayBox2() {\n                console.log('你点了最中间的box');\n            }\n            function sayBox1() {\n                console.log('你点了最外面的box');\n            }\n            // 事件监听，第三个参数是布尔值，默认false，false是事件冒泡，true是事件捕获\n            document.getElementById('box3').addEventListener('click', sayBox3, false);\n            document.getElementById('box2').addEventListener('click', sayBox2, false);\n            document.getElementById('box1').addEventListener('click', sayBox1, false);\n\n        <\/script>\n\n\n * 事件委托\n\n事件委托就是只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n为什么要用事件委托\n\n一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？\n\n在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；\n\n每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，比如上面的100个li，就要占用100个内存空间，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。\n\n如何实现呢？\n\ne.target可以用来实现事件委托，该原理是通过事件冒泡（或者事件捕获）给父元素添加事件监听，e.target指向引发触发事件的元素，如例子中，e.target指向用户点击的li，由于事件冒泡，li的点击事件冒泡到了ul上，通过给ul添加监听事件而达到了给每一个li添加监听事件的效果，而e.currentTarget指向的是给绑定事件监听的那个对象，即ul，从这里可以发现，e.currentTarget===this返回true，而e.target===this返回false。e.currenttarget和e.target是不相等的。\n\n<ul id=\"item-list\">\n\t<li>item1</li>\n\t<li>item2</li>\n\t<li>item3</li>\n\t<li>item4</li>\n</ul>\n\n<script>\nvar items = document.getElementById('item-list');\n  \n//事件捕获实现事件代理\nitems.addEventListener('click', (e) => {console.log('捕获：click ',e.target.innerHTML)}, true);\n  \n//事件冒泡实现事件代理\nitems.addEventListener('click', (e) => {console.log('冒泡：click ',e.target.innerHTML)}, false);\n<\/script>\n\n\n\n# 如何阻止冒泡和默认事件\n\n什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发\n\n    <div id='div'>\n        <ul>\n            <li>test</li>\n        </ul>\n    </div>\n    <script>\n        let div = document.getElementById('div')\n        let ul = document.getElementsByTagName('ul')[0]\n        let li = document.getElementsByTagName('li')[0]\n\n        div.onclick = function(){\n            alert(\"div\")\n        }\n        ul.onclick = function(){\n            alert(\"ul\")\n        }\n        li.onclick = function(){\n            // window.event? window.event.cancelBubble = true : e.stopPropagation();\n            alert(\"li\")\n        }\n    <\/script>\n\n\n阻止冒泡\n\nw3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true ，兼容性写法如上，只会输出li\n\n阻止默认事件\n\nw3c的方法是e.preventDefault()，IE则是使用window.event.returnValue = false;\n\njavascript的return false只会阻止默认行为\n\n<a href=\"http://caibaojian.com/\" id=\"testA\" >caibaojian.com</a>\n    <script>\n        var a = document.getElementById(\"testA\");\n            a.onclick =function(e){\n                if(e.preventDefault){\n                    e.preventDefault();\n                }else{\n                    window.event.returnValue == false;\n                }\n        }\n <\/script>\n\n\n * DOM事件流有3个阶段：捕获阶段，目标阶段，冒泡阶段；三个阶段的顺序为：捕获阶段——目标阶段——冒泡阶段，这个顺序是固定的，我们上面实现的事件捕获或者事件冒泡，只是在这三个阶段的某个阶段去执行而已\n * 当某个类型的事件A发生后，DOM会以--从Window对象开始依次降级，找到目标DOM对象，再从目标对象依次升级至Window--这样一个顺序，寻找各级的该事件(事件A)的事件监听。\n\n\n# 重绘和回流\n\n在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树。 DOM Tree 和样式结构体组合后构建render tree，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点，因为这些节点不会用于呈现，而且不会影响呈现的。\n\n * 图示\n\n\n# 什么是回流\n\n当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。\n\n\n# 什么是重绘\n\n当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n\n\n# 区别：\n\n * 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流\n * 当页面布局和几何属性改变时就需要回流。比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变\n\n\n# 浏览器的优化机制\n\n由于每次回流都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化回流过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。\n\n\n# 如何减少回流，重绘\n\n * 直接避免：采用transform,opacity可以直接跳过主线程，用compositer线程完成\n * 合并多次对DOM和样式的修改\n * 将复杂的元素绝对定位，脱离文档流，否则回流的代价很高。\n\n * 浏览器渲染相关\n * 字节前端提前批面试题：触发了几次回流几次重绘\n\n\n# requestAnimationFrame 和 setTimeout\n\n\n# （1）seTimeout实现动画：\n\n利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象\n\n原因一、setTimeout的执行时间并不是确定的。当调用 setTimeout(fn, 0) 时：fn 会被推入宏任务队列。但当前执行栈（同步代码）必须先完全清空。清空后，引擎会先处理所有微任务（如 Promise.then 的回调）。微任务队列清空后，才会从宏任务队列中取出 fn 执行。因此，即使 setTimeout 的延迟设为 0，它仍需等待当前代码执行完毕 + 所有微任务执行完毕，导致实际执行时间稍晚。\n\n原因二、刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。\n\n上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。\n\nsetTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。\n\n\n# （2）requestAnimationFrame实现动画：\n\nrequestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。\n\n如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\njs\n\nvar num = 0;\nanimation = null;\n\nfunction fn(){\n    console.log( num++ );\n    animation = requestAnimationFrame(fn);//异步\n}\nfn();\n\ndocument.onclick = function(){\n    cancelAnimation( animation );\n}\n\n\n\n# 介绍一下前端路由\n\n * history模式和hash模式\n\n\n# for in 和 for of\n\n最直接的区别是：\n\n * for...in 语句以任意顺序迭代对象的可枚举属性。\n * for...of 语句遍历可迭代对象定义要迭代的数据。\n   * 包括 Array，Map，Set，String，TypedArray，arguments 对象等等\n\n除此之外，对于for in的缺点\n\n 1. 索引是字符串型的数字，因而不能直接进行几何运算\n 2. 遍历顺序可能不是实际的内部顺序\n 3. for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性\n\n> 此外，for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of\n\narr = [1,2,3,4]\nfor(let i in arr){\n    console.log(i + 1)\n}\n// 输出\n// 01\n// 11\n// 21\n// 31\n\n\n相对于for of的缺点：\n\nArray.prototype.method=function(){}\nvar myArray=[1,2,4];\nmyArray.name=\"数组\";\n\nfor (var index in myArray)\n    console.log(myArray[index]);    //0,1,2,method,name\n\nfor (var value of myArray) \n    console.log(value);    //1,2,4\n\nvar obj = {\n    a:1,\n    b:2\n}\nfor(var i in obj){\n    console.log(obj[i])   //1,2\n}\nfor(var j of obj){\n    console.log(j)        //报错obj[Symbol.iterator] is not a function\n}\n\n\n\n# 迭代器\n\n当我们用for…of遍历对象时\n\nconst obj = { foo: 123, bar: 456 }\n\nfor(const item of obj) {\n    console.log(item)\n}\n// 报错 obj is not iterable\n\n\nArray,Set,Map都有Iterator属性，所以可以用for…of遍历\n\nconst arr = [1, 2, 3]\narr[Symbol.iterator]()\n\n// Array Iterator {} 其中还有next方法\n\nconst iterator = arr[Symbol.iterator]()\niterator.next() // {value: 1, done: false}\niterator.next() // {value: 2, done: false}\niterator.next() // {value: 3, done: false}\niterator.next() // {value: undefined, done: true}\n\n\nfor..of其实就是去调用iterator接口\n\n// 迭代器模式\n\n// 场景：协同开发一个任务清单\n\n// a的代码\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶']\n}\n\n// b的代码,需要知道对象结构\nfor (const item of todos.life) {\n    console.log(item)\n}\nfor (const item of todos.learn) {\n    console.log(item)\n}\nfor (const item of todos.work) {\n    console.log(item)\n}\n\n// 这时如果我在a代码的todos对象中加一个接口\neach: function (callback) {\n    const all = [].concat(this.life, this.learn, this.work)\n    for(const item of all) {\n        callback(item)\n    }\n}\n\n// b中就可以这样调用\ntodo.each(item => console.log(item))\n\n\n迭代器实现：对外提供统一遍历接口\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [Symbol.iterator]: function () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        let index = 0\n        return {\n            next: function () {\n                return {\n                    value: all[index]\n                    done: index++ >= all.length\n                }\n            }\n        }\n    }\n}\n\nfor(const item of todos) {\n    console.log(item)\n}\n\n\n生成器实现迭代器\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [Symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor(const item of todos) {\n    console.log(item)\n}\n\n\n\n# 场景题：参数拼接\n\n * 如何保证有这个参数时拼接，没有的时候不拼接呢\n\n    let options = {\n        'name': this.name,\n        'age': this.age,\n        'sex': this.sex\n      }\n      let paramsurl = ''\n      for(const key in options) {\n        const value = options[key]\n        value &&\n          (paramsurl += paramsurl ? `&${key}=${value}` : `${key}=${value}`)\n      }\n\n\n\n# css可继承的属性\n\n * 字体系列属性\n\n> font-family：字体系列\n> \n> font-weight：字体的粗细\n> \n> font-size：字体的大小\n> \n> font-style：字体的风格\n\n * 文本系列属性\n\n> text-indent：文本缩进\n> \n> text-align：文本水平对齐\n> \n> line-height：行高\n> \n> word-spacing：单词之间的间距\n> \n> letter-spacing：中文或者字母之间的间距\n> \n> text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n> \n> color：文本颜色\n\n * 元素可见性\n\n> visibility：控制元素显示隐藏\n\n * 列表布局属性\n\n> list-style：列表风格，包括list-style-type、list-style-image等\n\n * 光标属性\n\n> cursor：光标显示为何种形态\n\n\n# git有几种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n * 已提交（committed）：数据已经安全的保存在本地数据库中。\n * 已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。\n * 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：\n\n * Git 仓库(.git directoty)\n * 工作目录(Working Directory)\n * 暂存区域(Staging Area)\n\n# 基本的 Git 工作流程如下：\n\n * 在工作目录中修改文件。\n * 暂存文件，将文件的快照放入暂存区域。\n * 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录\n\n----------------------------------------\n\n * Workspace：工作区\n * Index / Stage：暂存区\n * Repository：仓库区（或本地仓库）\n * Remote：远程仓库\n\n\n# 简述 new 一个对象的过程\n\n简述new一个对象的过程：\n\n> 创造一个新的空对象 新对象的_proto_指向构造函数的原型对象 构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。 返回新对象地址\n\n        function book(name,value){\n            this.name = name\n            this.value = value\n        }\n\n        let book1 = new book(\"abc\",\"100\")\n        console.log(book1)\n\n        function myNew(constructor,...args){\n            let obj = new Object()\n            constructor.call(obj,...args)\n            obj.__proto__ = constructor.prototype\n            return obj\n        }\n        let book2 = myNew(book,\"def\",\"200\")\n        console.log(book2)\n\n        console.log(book2 instanceof book) //true\n\n\n\n# 一道面试题\n\nfunction ClassA()\n{\n    this.name = 'classA'\n}\nconst classA = new ClassA ()\nClassA.prototype =\nclassA.__proto__ =\nclassA instanceof ClassA\n\n\n * new 出来的实例 this 指向哪 (新实例)\n * 怎么修改 new 出来的 this 的指向（return一个新对象）\n * ClassA.prototype == classA.proto\n * 原型链讲一下\n * instanceof 什么时候返回 true，什么时候返回 false\n * 怎么让 classA instanceof ClassA 返回 false ( 改变ClassA.prototype或classA.proto)\n\n\n# 数据属性与访问器属性\n\n首先明确，这两个概念是针对数据来定义的。\n\n# 数据属性\n\n数据属性（property）用于实现JavaScript引擎，是属性(property)的内部值，它包含一个数据值的位置。有如下4种行为特性。\n\n * [[Configurable]]：能否被delete删除属性重新定义\n * [[Enumerable]]：能否被for-in枚举\n * [[Writable]]：能否修改属性值\n * [[Value]]：数据的数据值\n\nlet person = {}\nObject.defineProperty(person,\"name\",{\n    writable:false   //不可修改属性\n    value:\"abc\"\n})\n\nconsole.log(person.name) //abc\nperson.name = bcd\nconsole.log(person.name) //abc\n\n\n# 访问器属性\n\n访问器属性主要由setter和getter函数组成，包含如下4个特性：\n\n * [[Configurable]]：能否被delete删除属性重新定义。默认值：true\n * [[Enumerable]]：能否被for-in枚举。默认值：true\n * [[Get]]：读取属性值。默认值：undefined\n * [[Set]]：写入属性值。默认值：undefined\n\nlet book = {\n    _year:2004, //_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。\n    edition:1\n}\nObject.defineProperty(book,\"year\",{\n    get:function(){\n        return this._year\n    },\n    set:function(newValue){\n        if(newValue>2004){\n            this._year = newValue\n            this.edition += newValue-2004\n        }\n    }\n})\n\nbook.year = 2005\nconsole.log(book.edition)\n\n\n其实_year和year是两个属性，_year是数据属性，year是访问器属性，_year为内部使用的，year为外部使用的。\n\n如果都改为year，调用book.year会报错，因为这句话既可以输出数据属性，也可以调用访问器属性，产生冲突。",normalizedContent:"# 面试题（五）\n\n * 什么是事件冒泡，事件捕获，事件委托\n * 重绘和回流\n * requestanimationframe 和 settimeout\n * 介绍一下前端路由\n * for in 和 for of\n * 场景题：参数拼接\n * css可继承的属性\n * git有几种状态\n * 简述 new 一个对象的过程\n * 数据属性与访问器属性\n\n\n# 什么是事件冒泡，事件捕获，事件委托\n\n * 事件冒泡\n\n> 当给父子元素的同一事件绑定方法的时候，触发子元素身上的事件，执行完毕之后，也会触发父级元素相同的事件，这种机制叫事件冒泡\n\n * 事件捕获\n\n> 给父子元素用绑定同一事件时，当触发子元素身上的事件时，先触发父元素，然后在传递给子元素，这种传播机制叫事件捕获；\n\n实际操作中，我们可以通过 element.addeventlistener() 设置一个元素的事件模型为冒泡事件或者捕获事件。 先来看一下 addeventlistener 函数的语法：\n\nelement.addeventlistener(type, listener, usecapture)\n\n\n * type 监听事件类型的字符串\n * listener 事件监听回调函数，即事件触发后要处理的函数\n * usecapture 默认值false，表示事件冒泡；设为true时，表示事件捕获\n\n       <div id=\"box1\">\n            <div id=\"box2\">\n                <div id=\"box3\"></div>\n            </div>\n        </div>\n\n        <script>\n            function saybox3() {\n                console.log('你点了最里面的box');\n            }\n            function saybox2() {\n                console.log('你点了最中间的box');\n            }\n            function saybox1() {\n                console.log('你点了最外面的box');\n            }\n            // 事件监听，第三个参数是布尔值，默认false，false是事件冒泡，true是事件捕获\n            document.getelementbyid('box3').addeventlistener('click', saybox3, false);\n            document.getelementbyid('box2').addeventlistener('click', saybox2, false);\n            document.getelementbyid('box1').addeventlistener('click', saybox1, false);\n\n        <\/script>\n\n\n * 事件委托\n\n事件委托就是只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n为什么要用事件委托\n\n一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？\n\n在javascript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少dom操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；\n\n每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，比如上面的100个li，就要占用100个内存空间，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。\n\n如何实现呢？\n\ne.target可以用来实现事件委托，该原理是通过事件冒泡（或者事件捕获）给父元素添加事件监听，e.target指向引发触发事件的元素，如例子中，e.target指向用户点击的li，由于事件冒泡，li的点击事件冒泡到了ul上，通过给ul添加监听事件而达到了给每一个li添加监听事件的效果，而e.currenttarget指向的是给绑定事件监听的那个对象，即ul，从这里可以发现，e.currenttarget===this返回true，而e.target===this返回false。e.currenttarget和e.target是不相等的。\n\n<ul id=\"item-list\">\n\t<li>item1</li>\n\t<li>item2</li>\n\t<li>item3</li>\n\t<li>item4</li>\n</ul>\n\n<script>\nvar items = document.getelementbyid('item-list');\n  \n//事件捕获实现事件代理\nitems.addeventlistener('click', (e) => {console.log('捕获：click ',e.target.innerhtml)}, true);\n  \n//事件冒泡实现事件代理\nitems.addeventlistener('click', (e) => {console.log('冒泡：click ',e.target.innerhtml)}, false);\n<\/script>\n\n\n\n# 如何阻止冒泡和默认事件\n\n什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发\n\n    <div id='div'>\n        <ul>\n            <li>test</li>\n        </ul>\n    </div>\n    <script>\n        let div = document.getelementbyid('div')\n        let ul = document.getelementsbytagname('ul')[0]\n        let li = document.getelementsbytagname('li')[0]\n\n        div.onclick = function(){\n            alert(\"div\")\n        }\n        ul.onclick = function(){\n            alert(\"ul\")\n        }\n        li.onclick = function(){\n            // window.event? window.event.cancelbubble = true : e.stoppropagation();\n            alert(\"li\")\n        }\n    <\/script>\n\n\n阻止冒泡\n\nw3c的方法是e.stoppropagation()，ie则是使用e.cancelbubble = true ，兼容性写法如上，只会输出li\n\n阻止默认事件\n\nw3c的方法是e.preventdefault()，ie则是使用window.event.returnvalue = false;\n\njavascript的return false只会阻止默认行为\n\n<a href=\"http://caibaojian.com/\" id=\"testa\" >caibaojian.com</a>\n    <script>\n        var a = document.getelementbyid(\"testa\");\n            a.onclick =function(e){\n                if(e.preventdefault){\n                    e.preventdefault();\n                }else{\n                    window.event.returnvalue == false;\n                }\n        }\n <\/script>\n\n\n * dom事件流有3个阶段：捕获阶段，目标阶段，冒泡阶段；三个阶段的顺序为：捕获阶段——目标阶段——冒泡阶段，这个顺序是固定的，我们上面实现的事件捕获或者事件冒泡，只是在这三个阶段的某个阶段去执行而已\n * 当某个类型的事件a发生后，dom会以--从window对象开始依次降级，找到目标dom对象，再从目标对象依次升级至window--这样一个顺序，寻找各级的该事件(事件a)的事件监听。\n\n\n# 重绘和回流\n\n在页面加载时，浏览器把获取到的html代码解析成1个dom树。 dom tree 和样式结构体组合后构建render tree，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点，因为这些节点不会用于呈现，而且不会影响呈现的。\n\n * 图示\n\n\n# 什么是回流\n\n当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。\n\n\n# 什么是重绘\n\n当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。\n\n\n# 区别：\n\n * 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流\n * 当页面布局和几何属性改变时就需要回流。比如：添加或者删除可见的dom元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变\n\n\n# 浏览器的优化机制\n\n由于每次回流都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化回流过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。\n\n\n# 如何减少回流，重绘\n\n * 直接避免：采用transform,opacity可以直接跳过主线程，用compositer线程完成\n * 合并多次对dom和样式的修改\n * 将复杂的元素绝对定位，脱离文档流，否则回流的代价很高。\n\n * 浏览器渲染相关\n * 字节前端提前批面试题：触发了几次回流几次重绘\n\n\n# requestanimationframe 和 settimeout\n\n\n# （1）setimeout实现动画：\n\n利用setimeout实现的动画在某些低端机上会出现卡顿、抖动的现象\n\n原因一、settimeout的执行时间并不是确定的。当调用 settimeout(fn, 0) 时：fn 会被推入宏任务队列。但当前执行栈（同步代码）必须先完全清空。清空后，引擎会先处理所有微任务（如 promise.then 的回调）。微任务队列清空后，才会从宏任务队列中取出 fn 执行。因此，即使 settimeout 的延迟设为 0，它仍需等待当前代码执行完毕 + 所有微任务执行完毕，导致实际执行时间稍晚。\n\n原因二、刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 settimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。\n\n上两种情况都会导致settimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。\n\nsettimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。\n\n\n# （2）requestanimationframe实现动画：\n\nrequestanimationframe最大的优势是由系统来决定回调函数的执行时机。\n\n如果屏幕刷新率是60hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestanimationframe的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\njs\n\nvar num = 0;\nanimation = null;\n\nfunction fn(){\n    console.log( num++ );\n    animation = requestanimationframe(fn);//异步\n}\nfn();\n\ndocument.onclick = function(){\n    cancelanimation( animation );\n}\n\n\n\n# 介绍一下前端路由\n\n * history模式和hash模式\n\n\n# for in 和 for of\n\n最直接的区别是：\n\n * for...in 语句以任意顺序迭代对象的可枚举属性。\n * for...of 语句遍历可迭代对象定义要迭代的数据。\n   * 包括 array，map，set，string，typedarray，arguments 对象等等\n\n除此之外，对于for in的缺点\n\n 1. 索引是字符串型的数字，因而不能直接进行几何运算\n 2. 遍历顺序可能不是实际的内部顺序\n 3. for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性\n\n> 此外，for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用array.prototype.foreach()和for ... of\n\narr = [1,2,3,4]\nfor(let i in arr){\n    console.log(i + 1)\n}\n// 输出\n// 01\n// 11\n// 21\n// 31\n\n\n相对于for of的缺点：\n\narray.prototype.method=function(){}\nvar myarray=[1,2,4];\nmyarray.name=\"数组\";\n\nfor (var index in myarray)\n    console.log(myarray[index]);    //0,1,2,method,name\n\nfor (var value of myarray) \n    console.log(value);    //1,2,4\n\nvar obj = {\n    a:1,\n    b:2\n}\nfor(var i in obj){\n    console.log(obj[i])   //1,2\n}\nfor(var j of obj){\n    console.log(j)        //报错obj[symbol.iterator] is not a function\n}\n\n\n\n# 迭代器\n\n当我们用for…of遍历对象时\n\nconst obj = { foo: 123, bar: 456 }\n\nfor(const item of obj) {\n    console.log(item)\n}\n// 报错 obj is not iterable\n\n\narray,set,map都有iterator属性，所以可以用for…of遍历\n\nconst arr = [1, 2, 3]\narr[symbol.iterator]()\n\n// array iterator {} 其中还有next方法\n\nconst iterator = arr[symbol.iterator]()\niterator.next() // {value: 1, done: false}\niterator.next() // {value: 2, done: false}\niterator.next() // {value: 3, done: false}\niterator.next() // {value: undefined, done: true}\n\n\nfor..of其实就是去调用iterator接口\n\n// 迭代器模式\n\n// 场景：协同开发一个任务清单\n\n// a的代码\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶']\n}\n\n// b的代码,需要知道对象结构\nfor (const item of todos.life) {\n    console.log(item)\n}\nfor (const item of todos.learn) {\n    console.log(item)\n}\nfor (const item of todos.work) {\n    console.log(item)\n}\n\n// 这时如果我在a代码的todos对象中加一个接口\neach: function (callback) {\n    const all = [].concat(this.life, this.learn, this.work)\n    for(const item of all) {\n        callback(item)\n    }\n}\n\n// b中就可以这样调用\ntodo.each(item => console.log(item))\n\n\n迭代器实现：对外提供统一遍历接口\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [symbol.iterator]: function () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        let index = 0\n        return {\n            next: function () {\n                return {\n                    value: all[index]\n                    done: index++ >= all.length\n                }\n            }\n        }\n    }\n}\n\nfor(const item of todos) {\n    console.log(item)\n}\n\n\n生成器实现迭代器\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor(const item of todos) {\n    console.log(item)\n}\n\n\n\n# 场景题：参数拼接\n\n * 如何保证有这个参数时拼接，没有的时候不拼接呢\n\n    let options = {\n        'name': this.name,\n        'age': this.age,\n        'sex': this.sex\n      }\n      let paramsurl = ''\n      for(const key in options) {\n        const value = options[key]\n        value &&\n          (paramsurl += paramsurl ? `&${key}=${value}` : `${key}=${value}`)\n      }\n\n\n\n# css可继承的属性\n\n * 字体系列属性\n\n> font-family：字体系列\n> \n> font-weight：字体的粗细\n> \n> font-size：字体的大小\n> \n> font-style：字体的风格\n\n * 文本系列属性\n\n> text-indent：文本缩进\n> \n> text-align：文本水平对齐\n> \n> line-height：行高\n> \n> word-spacing：单词之间的间距\n> \n> letter-spacing：中文或者字母之间的间距\n> \n> text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n> \n> color：文本颜色\n\n * 元素可见性\n\n> visibility：控制元素显示隐藏\n\n * 列表布局属性\n\n> list-style：列表风格，包括list-style-type、list-style-image等\n\n * 光标属性\n\n> cursor：光标显示为何种形态\n\n\n# git有几种状态\n\ngit 有三种状态，你的文件可能处于其中之一：\n\n * 已提交（committed）：数据已经安全的保存在本地数据库中。\n * 已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。\n * 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 git 项目的三个工作区域的概念：\n\n * git 仓库(.git directoty)\n * 工作目录(working directory)\n * 暂存区域(staging area)\n\n# 基本的 git 工作流程如下：\n\n * 在工作目录中修改文件。\n * 暂存文件，将文件的快照放入暂存区域。\n * 提交更新，找到暂存区域的文件，将快照永久性存储到 git 仓库目录\n\n----------------------------------------\n\n * workspace：工作区\n * index / stage：暂存区\n * repository：仓库区（或本地仓库）\n * remote：远程仓库\n\n\n# 简述 new 一个对象的过程\n\n简述new一个对象的过程：\n\n> 创造一个新的空对象 新对象的_proto_指向构造函数的原型对象 构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。 返回新对象地址\n\n        function book(name,value){\n            this.name = name\n            this.value = value\n        }\n\n        let book1 = new book(\"abc\",\"100\")\n        console.log(book1)\n\n        function mynew(constructor,...args){\n            let obj = new object()\n            constructor.call(obj,...args)\n            obj.__proto__ = constructor.prototype\n            return obj\n        }\n        let book2 = mynew(book,\"def\",\"200\")\n        console.log(book2)\n\n        console.log(book2 instanceof book) //true\n\n\n\n# 一道面试题\n\nfunction classa()\n{\n    this.name = 'classa'\n}\nconst classa = new classa ()\nclassa.prototype =\nclassa.__proto__ =\nclassa instanceof classa\n\n\n * new 出来的实例 this 指向哪 (新实例)\n * 怎么修改 new 出来的 this 的指向（return一个新对象）\n * classa.prototype == classa.proto\n * 原型链讲一下\n * instanceof 什么时候返回 true，什么时候返回 false\n * 怎么让 classa instanceof classa 返回 false ( 改变classa.prototype或classa.proto)\n\n\n# 数据属性与访问器属性\n\n首先明确，这两个概念是针对数据来定义的。\n\n# 数据属性\n\n数据属性（property）用于实现javascript引擎，是属性(property)的内部值，它包含一个数据值的位置。有如下4种行为特性。\n\n * [[configurable]]：能否被delete删除属性重新定义\n * [[enumerable]]：能否被for-in枚举\n * [[writable]]：能否修改属性值\n * [[value]]：数据的数据值\n\nlet person = {}\nobject.defineproperty(person,\"name\",{\n    writable:false   //不可修改属性\n    value:\"abc\"\n})\n\nconsole.log(person.name) //abc\nperson.name = bcd\nconsole.log(person.name) //abc\n\n\n# 访问器属性\n\n访问器属性主要由setter和getter函数组成，包含如下4个特性：\n\n * [[configurable]]：能否被delete删除属性重新定义。默认值：true\n * [[enumerable]]：能否被for-in枚举。默认值：true\n * [[get]]：读取属性值。默认值：undefined\n * [[set]]：写入属性值。默认值：undefined\n\nlet book = {\n    _year:2004, //_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。\n    edition:1\n}\nobject.defineproperty(book,\"year\",{\n    get:function(){\n        return this._year\n    },\n    set:function(newvalue){\n        if(newvalue>2004){\n            this._year = newvalue\n            this.edition += newvalue-2004\n        }\n    }\n})\n\nbook.year = 2005\nconsole.log(book.edition)\n\n\n其实_year和year是两个属性，_year是数据属性，year是访问器属性，_year为内部使用的，year为外部使用的。\n\n如果都改为year，调用book.year会报错，因为这句话既可以输出数据属性，也可以调用访问器属性，产生冲突。",charsets:{cjk:!0}},{title:"面试题（七）",frontmatter:{title:"面试题（七）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-7.html",relativePath:"interview/interview-7.md",key:"v-abac98c2",path:"/interview/interview-7.html",headers:[{level:2,title:"原生ajax",slug:"原生ajax",normalizedTitle:"原生ajax",charIndex:13},{level:2,title:"display有哪些属性",slug:"display有哪些属性",normalizedTitle:"display有哪些属性",charIndex:23},{level:2,title:"position有哪些属性",slug:"position有哪些属性",normalizedTitle:"position有哪些属性",charIndex:39},{level:2,title:"transform有哪些属性",slug:"transform有哪些属性",normalizedTitle:"transform有哪些属性",charIndex:56},{level:2,title:"input标签的属性",slug:"input标签的属性",normalizedTitle:"input标签的属性",charIndex:74},{level:2,title:"如何给一个页面添加10000个div",slug:"如何给一个页面添加10000个div",normalizedTitle:"如何给一个页面添加10000个div",charIndex:88},{level:2,title:"原生js操作DOM的API",slug:"原生js操作dom的api",normalizedTitle:"原生js操作dom的api",charIndex:110},{level:2,title:"伪类和伪元素",slug:"伪类和伪元素",normalizedTitle:"伪类和伪元素",charIndex:127},{level:3,title:"结构性伪类元素",slug:"结构性伪类元素",normalizedTitle:"结构性伪类元素",charIndex:6565},{level:2,title:"变量提升的一道题",slug:"变量提升的一道题",normalizedTitle:"变量提升的一道题",charIndex:137},{level:2,title:"正则将手机号中间四位变为*",slug:"正则将手机号中间四位变为",normalizedTitle:"正则将手机号中间四位变为*",charIndex:149},{level:2,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:166},{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:175},{level:2,title:"promise能封装setInterval吗",slug:"promise能封装setinterval吗",normalizedTitle:"promise能封装setinterval吗",charIndex:183}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"原生ajax display有哪些属性 position有哪些属性 transform有哪些属性 input标签的属性 如何给一个页面添加10000个div 原生js操作DOM的API 伪类和伪元素 结构性伪类元素 变量提升的一道题 正则将手机号中间四位变为* 图片懒加载 二分查找 promise能封装setInterval吗",content:'# 面试题（七）\n\n * 原生ajax\n * display有哪些属性\n * position有哪些属性\n * transform有哪些属性\n * input标签的属性\n * 如何给一个页面添加10000个div\n * 原生js操作DOM的API\n * 伪类和伪元素\n * 变量提升的一道题\n * 正则将手机号中间四位变为*\n * 图片懒加载\n * 二分查找\n * promise能封装setInterval吗\n\n\n# 原生ajax\n\n// 原生ajax实现\nfunction ajax() {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\'method\', \'url\');\n    xhr.send();\n    xhr.onreadystatechange = function() {\n        if ( xhr.readyState==4 && xhr.status==200) {\n            console.log(\'success\', xhr.responseText);\n        } else {\n            console.log(\'error\', xhr.responseText);\n        }\n    }\n}\n\n//readyState\n//0：初始化，XMLHttpRequest对象还没有完成初始化\n//1：载入，XMLHttpRequest对象开始发送请求\n//2：载入完成，XMLHttpRequest对象的请求发送完成\n//3：解析，XMLHttpRequest对象开始读取服务器的响应\n//4：完成，XMLHttpRequest对象读取服务器响应结束\n\n\n\n# display有哪些属性\n\n * display: none;表示此元素将不被显示。\n * display: block;将元素显示为块元素。（又叫块级元素）\n * display: inline;将元素显示为内联元素。（又叫行内元素）\n\n> 内联元素不可以设置高度、宽度 只能设置左右的margin值和左右的padding值，而不能设置上下的margin值和上下的padding值 常见：span、img、input、a、label、button\n\n * display: inline-block;将元素显示为内联块元素。\n\n> 不换行，但可以设置宽高\n\n * display: inherit;规定应该从父元素继承 display 属性的值。\n * display: table，display: table-cell\n\n\n# position有哪些属性\n\n * position:static，出现在文档流中，不受top，left影响\n * position:relative，相对定位，根据元素原来位置定位，在文档流中\n * position:absolute，绝对定位，根据relative的父元素定位，脱离文档流\n * positoin:fixed，相对于浏览器窗口固定位置，脱离文档流。\n * position:inherit,继承\n * position:initial\n * position:sticky，\n\n> position: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。\n\n在目标区域以内，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。\n\n<style>\n    .top,\n    .middle,\n    .bottom {\n        position: relative;\n        background: lightblue;\n        height: 200px;\n    }\n    .middle {\n        background: yellow;\n    }\n    .bottom {\n        background: pink;\n    }\n    .fixed {\n        width: 100px;\n        height: 100px;\n        position: fixed;\n        background: red;\n    }\n</style>\n\n<div class="top"></div>\n<div class="middle"></div>\n<div class="fixed"></div>\n<div class="bottom"></div>\n\n\x3c!--fixed在bottom的左上角，脱离文档流后被覆盖了--\x3e\n\n\n\n# transform有哪些属性\n\ntransform: rotate | scale | skew | translate |matrix;\n\n * transform:rotate(30deg)\n\n * scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；\n   \n   scaleX(x)元素仅水平方向缩放（X轴缩放）；\n   \n   scaleY(y)元素仅垂直方向缩放（Y轴缩放）\n\n * skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；\n   \n   skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；\n   \n   skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形），\n\n * translate:同样有三种方法\n\n * matrix\n\n\n# input标签的属性\n\n\x3c!-- maxlength 属性规定输入字段的最大长度--\x3e\n<input maxlength="value">\n\n\x3c!-- autocomplete 属性规定输入字段是否应该启用自动完成功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 开启为默认--\x3e\n\n<input autocomplete="on/off">\n\n\n\n# 如何给一个页面添加10000个div\n\n<!DOCTYPE html>\n<html lang="zh-cn">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        body div {\n            width: 30px;\n            height: 2px;\n            border: 1px solid #ee3333;\n        }\n    </style>\n</head>\n<body>\n\n\n<script>\n    // 利用 innerHTML 拼接字符串的方式     (添加10000个div)  (耗时约900ms） 最慢\n    // function f() {\n    //     var date = +new Date();\n    //     for (var i = 1; i <= 10000; i++) {\n    //         document.body.innerHTML += "<div></div>"\n    //     }\n    //     var date1 = +new Date();\n    //     console.log(date1-date);\n    // }\n    // f();\n\n    // 利用 innerHTML 数组赋值的方式  结构稍微复杂  （添加10000个div)   （耗时约15ms)  最快\n    function f() {\n        var date = +new Date();\n        var str = [];\n        for (var i = 1; i <= 10000; i++) {\n            str.push(\'<div></div>\');\n        }\n        str = str.join(\'\');\n        document.body.innerHTML = str;\n        var date1 = +new Date();\n        console.log(date1 - date);\n    }\n\n    f();\n\n    // 利用 createElement    结构清晰简单          (添加10000个div)   (耗时约20ms) 比最快慢一丢丢\n    // function f() {\n    //     var date = +new Date();\n    //     for (var i = 1; i <= 10000; i++) {\n    //         var div = document.createElement(\'div\');\n    //         document.body.appendChild(div);\n    //     }\n    //     var date1 = +new Date();\n    //     console.log(date1 - date);\n    // }\n    // f();\n\n<\/script>\n</body>\n</html>\n\n\n\n# 原生js操作DOM的API\n\n# 创建型API总结\n\n> 创建型API包括createElement,createTextNode,cloneNode和createDocumentFragment四个方法，需要注意下面几点: (1) 它们创建的节点，只是一个孤立的节点，需要通过appendChild添加到文档中。 (2) cloneNode要注意，如果被复制，是否包含子节点以及事件绑定等问题。 (3) 使用createDocumentFragment来解决添加大量节点时的性能问题 。\n\n----------------------------------------\n\n# 页面修改型API总结\n\n> 修改页面内容的API主要包括：appendChild,removeChild,insertBefore,replaceChild 需要注意几点： (1) 不管是新增还是替换节点，如果新增或者替换的节点原本是存在于页面上的，则其原来位置的节点将被移除，也就是说同一个节点，不能存在于页面上的多个位置。 (2) 节点本身绑定的事件不会消失，会一直保留。\n\n----------------------------------------\n\n# 节点查询型API总结\n\n> document.getElementById document.getElementByName document.getElementByTagName document.getElementByClassName document.querySelector和document.querySelectorAll：通过CSS选择器来查找元素，注意选择器要复合CSS选择器的规则。使用深度优先搜索来获取元素。\n\n----------------------------------------\n\n# 节点关系型API总结\n\n父关系型API\n\n * parentNode: Element的父节点可能是Element,Document和DocumentFragment\n * parentElement:与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null。\n\n兄弟关系型API\n\n * previousSibling: 节点的前一个节点，如果该节点是第一个节点，则为null.注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。\n * previousElementSibling:返回前一个元素节点，前一个节点必须是Element,注意IE9以下浏览器不支持。\n * nextSibling: 节点的后一个节点，如果该节点是最后一个节点，则为null. 注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。\n * nextElementSibling: 返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。\n\n子关系型API\n\n * childNodes :返回一个即时的nodeList,表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。\n * children: 一个即时的HTMLCollection,子节点都是Element，IE9以下浏览器不支持。\n * firstNode: 第一个子节点\n * lastNode: 最后一个子节点\n * hasChildNodes方法：可以用来判断是否包含子节点\n\n----------------------------------------\n\n# 元素属性型API\n\n> setAttribute: 根据名称和值修改元素的特性，eg:element.setAttribute(name,value); getAttribute: 返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。\n\n# 元素样式型API\n\nwindow.getComutedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度，而是通过其内容将其高度撑开，这时候要获取它的高度，就要用到getComutedStyle，用法如下：\n\nvar style = window.getComputedStyle(element[, pseudoElt]);\n\n\n> element是要获取的元素，pseudoElt指定一个伪元素进行匹配。 返回的style是一个CSSStyleDeclaration对象。 通过style可以访问到元素计算后的样式 clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据；\n\n\n# 伪类和伪元素\n\n伪类：:focus,:hover以及<a>标签的:link、visited等，\n\n伪元素：较常见的比如:before、:after等。\n\n（1）伪类的功能\n\n1.获取不存在与DOM树中的信息 。比如： <a> 标签的:link、:visited 等。这些信息不存在于DOM树中。\n\n2.获取 不能被常规CSS选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。\n\n> 伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息。\n\n（2）伪元素的功能\n\n> 而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。\n\n（3）冒号区别\n\n> 伪元素的由两个冒号::开头，然后是伪元素的名称。\n\n> 使用两个冒号::是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是CSS3中新增的伪元素必须使用两个冒号::\n\ndiv:after\ndiv::after\ndiv:first-child\ndiv::first-child //错\n\n\n\n# 结构性伪类元素\n\n结构性伪类选择器的公共特征是允许开发者根据文档结构来指定元素的样式。\n\n（1）nth-child和nth-last-child\n\n \t  p:nth-child(n){background:red}  表示E父元素中的第n个字节点\n      p:nth-child(odd){background:red}/*匹配奇数行*/\n      p:nth-child(even){background:red}/*匹配偶数行*/\n      p:nth-child(2n){background:red}/*其中n是从0开始计算*/\n\n\n（2）E:first-child和E:last-child\n\n（3）nth-of-type(n) 和E:nth-last-of-type(n)\n\n（4））E:root（根节点）、E:only-child（独子元素）、E:only-of-type（独子类型元素）和E:empty（孤节点）\n\n\n# 变量提升的一道题\n\n\t   setTimeout(() => console.log(\'1\', a));\n\n        new Promise(resolve => resolve()).then(() => console.log(\'2\', a));\n\n        console.log(\'3\', a);\n        var a = \'哈哈\'\n        console.log(\'4\', a);\n        function a() {};\n\n//3,f\n//4,哈哈\n//2，哈哈\n//1，哈哈\n\n\n\n# 正则将手机号中间四位变为*\n\nfunction replacePhone(str){\n    let reg = /^(\\d{3})(\\d{4})(\\d{4})$/\n   \treturn  str.replace(reg,\'$1****$3\')\n}\n\n\n\n# 图片懒加载\n\n一张图片就是一个标签，而图片的来源主要是src属性。浏览器是否发起亲求就是根据是否有src属性决定的。\n\n既然这样，那么我们就要对标签的src属性下手了，在没进入可视区域的时候，我们先不给这个标签赋src属性，这样岂不是浏览器就不会发送请求了。\n\ndocument.documentElement.clientHeight//获取屏幕可视区域的高度\nelement.offsetTop//获取元素相对于文档顶部的高度\ndocument.documentElement.scrollTop//获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离\n\n\n\n\n如果：offsetTop-scroolTop<clientHeight，则图片进入了可视区内，则被请求。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>图片懒加载</title>\n    <style>\n        img {\n            display: block;\n            width: 100%;\n            height: 300px;\n            margin-bottom: 20px;\n        }\n    </style>\n</head>\n<body>\n    <img data-src="./images/1.jpg" alt="">\n    <img data-src="./images/2.jpg" alt="">\n    <img data-src="./images/3.jpg" alt="">\n    <img data-src="./images/4.jpg" alt="">\n    <img data-src="./images/5.jpg" alt="">\n    <img data-src="./images/6.jpg" alt="">\n    <img data-src="./images/7.jpg" alt="">\n    <img data-src="./images/8.jpg" alt="">\n    <img data-src="./images/9.jpg" alt="">\n    <img data-src="./images/10.jpg" alt="">\n    <img data-src="./images/1.jpg" alt="">\n    <img data-src="./images/2.jpg" alt="">\n</body>\n<script>\n        var imgs = document.querySelectorAll(\'img\');\n\n        //offsetTop是元素与offsetParent的距离，循环获取直到页面顶部\n        function getTop(e) {\n            var T = e.offsetTop;\n            while(e = e.offsetParent) {\n                T += e.offsetTop;\n            }\n            return T;\n        }\n\n        function lazyLoad(imgs) {\n            var H = document.documentElement.clientHeight;//获取可视区域高度\n            var S = document.documentElement.scrollTop || document.body.scrollTop;\n            for (var i = 0; i < imgs.length; i++) {\n                if (H > getTop(imgs[i])-S) {\n                    imgs[i].src = imgs[i].getAttribute(\'data-src\');\n                }\n            }\n        }\n\n        window.onload = window.onscroll = function () { //onscroll()在滚动条滚动的时候触发\n            lazyLoad(imgs);\n        }\n<\/script>\n</html>\n\n\n\n# 二分查找\n\nfunction binary_search(arr, key) {\n    var low = 0,\n        high = arr.length - 1;\n\n    while (low <= high) {\n        var mid = parseInt((high + low) / 2);\n        if (key == arr[mid]) {\n            return mid;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else if (key < arr[mid]) {\n            high = mid - 1;\n        } else {\n            return -1;\n        }\n    }\n}\n\n\n\n# promise能封装setInterval吗\n\n不能，因为promise只能执行一次\n\n\t\t  new Promise(function(resolve,reject){\n                setTimeout(function(){\n                    resolve()\n                },1000)\n            }).then(function(){\n                console.log(1)\n            })\n\n            new Promise(function(resolve,reject){\n                setInterval(function(){\n                    resolve()\n                },1000)\n            }).then(function(){\n                console.log(2)\n            })\n\n\n解决办法\n\n\t\t   function p(){\n                return new Promise(function(resolve,reject){\n                    setTimeout(function(){\n                        resolve()\n                    },1000)\n                }).then(function(){\n                    console.log("1")\n                })\n            }\n            setInterval(p,1000)\n',normalizedContent:'# 面试题（七）\n\n * 原生ajax\n * display有哪些属性\n * position有哪些属性\n * transform有哪些属性\n * input标签的属性\n * 如何给一个页面添加10000个div\n * 原生js操作dom的api\n * 伪类和伪元素\n * 变量提升的一道题\n * 正则将手机号中间四位变为*\n * 图片懒加载\n * 二分查找\n * promise能封装setinterval吗\n\n\n# 原生ajax\n\n// 原生ajax实现\nfunction ajax() {\n    var xhr = new xmlhttprequest();\n    xhr.open(\'method\', \'url\');\n    xhr.send();\n    xhr.onreadystatechange = function() {\n        if ( xhr.readystate==4 && xhr.status==200) {\n            console.log(\'success\', xhr.responsetext);\n        } else {\n            console.log(\'error\', xhr.responsetext);\n        }\n    }\n}\n\n//readystate\n//0：初始化，xmlhttprequest对象还没有完成初始化\n//1：载入，xmlhttprequest对象开始发送请求\n//2：载入完成，xmlhttprequest对象的请求发送完成\n//3：解析，xmlhttprequest对象开始读取服务器的响应\n//4：完成，xmlhttprequest对象读取服务器响应结束\n\n\n\n# display有哪些属性\n\n * display: none;表示此元素将不被显示。\n * display: block;将元素显示为块元素。（又叫块级元素）\n * display: inline;将元素显示为内联元素。（又叫行内元素）\n\n> 内联元素不可以设置高度、宽度 只能设置左右的margin值和左右的padding值，而不能设置上下的margin值和上下的padding值 常见：span、img、input、a、label、button\n\n * display: inline-block;将元素显示为内联块元素。\n\n> 不换行，但可以设置宽高\n\n * display: inherit;规定应该从父元素继承 display 属性的值。\n * display: table，display: table-cell\n\n\n# position有哪些属性\n\n * position:static，出现在文档流中，不受top，left影响\n * position:relative，相对定位，根据元素原来位置定位，在文档流中\n * position:absolute，绝对定位，根据relative的父元素定位，脱离文档流\n * positoin:fixed，相对于浏览器窗口固定位置，脱离文档流。\n * position:inherit,继承\n * position:initial\n * position:sticky，\n\n> position: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。\n\n在目标区域以内，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。\n\n<style>\n    .top,\n    .middle,\n    .bottom {\n        position: relative;\n        background: lightblue;\n        height: 200px;\n    }\n    .middle {\n        background: yellow;\n    }\n    .bottom {\n        background: pink;\n    }\n    .fixed {\n        width: 100px;\n        height: 100px;\n        position: fixed;\n        background: red;\n    }\n</style>\n\n<div class="top"></div>\n<div class="middle"></div>\n<div class="fixed"></div>\n<div class="bottom"></div>\n\n\x3c!--fixed在bottom的左上角，脱离文档流后被覆盖了--\x3e\n\n\n\n# transform有哪些属性\n\ntransform: rotate | scale | skew | translate |matrix;\n\n * transform:rotate(30deg)\n\n * scale(x,y)使元素水平方向和垂直方向同时缩放（也就是x轴和y轴同时缩放）；\n   \n   scalex(x)元素仅水平方向缩放（x轴缩放）；\n   \n   scaley(y)元素仅垂直方向缩放（y轴缩放）\n\n * skew(x,y)使元素在水平和垂直方向同时扭曲（x轴和y轴同时按一定的角度值进行扭曲变形）；\n   \n   skewx(x)仅使元素在水平方向扭曲变形（x轴扭曲变形）；\n   \n   skewy(y)仅使元素在垂直方向扭曲变形（y轴扭曲变形），\n\n * translate:同样有三种方法\n\n * matrix\n\n\n# input标签的属性\n\n\x3c!-- maxlength 属性规定输入字段的最大长度--\x3e\n<input maxlength="value">\n\n\x3c!-- autocomplete 属性规定输入字段是否应该启用自动完成功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 开启为默认--\x3e\n\n<input autocomplete="on/off">\n\n\n\n# 如何给一个页面添加10000个div\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <style>\n        body div {\n            width: 30px;\n            height: 2px;\n            border: 1px solid #ee3333;\n        }\n    </style>\n</head>\n<body>\n\n\n<script>\n    // 利用 innerhtml 拼接字符串的方式     (添加10000个div)  (耗时约900ms） 最慢\n    // function f() {\n    //     var date = +new date();\n    //     for (var i = 1; i <= 10000; i++) {\n    //         document.body.innerhtml += "<div></div>"\n    //     }\n    //     var date1 = +new date();\n    //     console.log(date1-date);\n    // }\n    // f();\n\n    // 利用 innerhtml 数组赋值的方式  结构稍微复杂  （添加10000个div)   （耗时约15ms)  最快\n    function f() {\n        var date = +new date();\n        var str = [];\n        for (var i = 1; i <= 10000; i++) {\n            str.push(\'<div></div>\');\n        }\n        str = str.join(\'\');\n        document.body.innerhtml = str;\n        var date1 = +new date();\n        console.log(date1 - date);\n    }\n\n    f();\n\n    // 利用 createelement    结构清晰简单          (添加10000个div)   (耗时约20ms) 比最快慢一丢丢\n    // function f() {\n    //     var date = +new date();\n    //     for (var i = 1; i <= 10000; i++) {\n    //         var div = document.createelement(\'div\');\n    //         document.body.appendchild(div);\n    //     }\n    //     var date1 = +new date();\n    //     console.log(date1 - date);\n    // }\n    // f();\n\n<\/script>\n</body>\n</html>\n\n\n\n# 原生js操作dom的api\n\n# 创建型api总结\n\n> 创建型api包括createelement,createtextnode,clonenode和createdocumentfragment四个方法，需要注意下面几点: (1) 它们创建的节点，只是一个孤立的节点，需要通过appendchild添加到文档中。 (2) clonenode要注意，如果被复制，是否包含子节点以及事件绑定等问题。 (3) 使用createdocumentfragment来解决添加大量节点时的性能问题 。\n\n----------------------------------------\n\n# 页面修改型api总结\n\n> 修改页面内容的api主要包括：appendchild,removechild,insertbefore,replacechild 需要注意几点： (1) 不管是新增还是替换节点，如果新增或者替换的节点原本是存在于页面上的，则其原来位置的节点将被移除，也就是说同一个节点，不能存在于页面上的多个位置。 (2) 节点本身绑定的事件不会消失，会一直保留。\n\n----------------------------------------\n\n# 节点查询型api总结\n\n> document.getelementbyid document.getelementbyname document.getelementbytagname document.getelementbyclassname document.queryselector和document.queryselectorall：通过css选择器来查找元素，注意选择器要复合css选择器的规则。使用深度优先搜索来获取元素。\n\n----------------------------------------\n\n# 节点关系型api总结\n\n父关系型api\n\n * parentnode: element的父节点可能是element,document和documentfragment\n * parentelement:与parentnode的区别在于，其父节点必须是一个element，如果不是，则返回null。\n\n兄弟关系型api\n\n * previoussibling: 节点的前一个节点，如果该节点是第一个节点，则为null.注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。\n * previouselementsibling:返回前一个元素节点，前一个节点必须是element,注意ie9以下浏览器不支持。\n * nextsibling: 节点的后一个节点，如果该节点是最后一个节点，则为null. 注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。\n * nextelementsibling: 返回后一个元素节点，后一个节点必须是element，注意ie9以下浏览器不支持。\n\n子关系型api\n\n * childnodes :返回一个即时的nodelist,表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。\n * children: 一个即时的htmlcollection,子节点都是element，ie9以下浏览器不支持。\n * firstnode: 第一个子节点\n * lastnode: 最后一个子节点\n * haschildnodes方法：可以用来判断是否包含子节点\n\n----------------------------------------\n\n# 元素属性型api\n\n> setattribute: 根据名称和值修改元素的特性，eg:element.setattribute(name,value); getattribute: 返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。\n\n# 元素样式型api\n\nwindow.getcomutedstyle是用来获取应用到元素后的样式，假设某个元素并未设置高度，而是通过其内容将其高度撑开，这时候要获取它的高度，就要用到getcomutedstyle，用法如下：\n\nvar style = window.getcomputedstyle(element[, pseudoelt]);\n\n\n> element是要获取的元素，pseudoelt指定一个伪元素进行匹配。 返回的style是一个cssstyledeclaration对象。 通过style可以访问到元素计算后的样式 clientrect是一个domrect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了ie9以下浏览器，还包含元素的height和width等数据；\n\n\n# 伪类和伪元素\n\n伪类：:focus,:hover以及<a>标签的:link、visited等，\n\n伪元素：较常见的比如:before、:after等。\n\n（1）伪类的功能\n\n1.获取不存在与dom树中的信息 。比如： <a> 标签的:link、:visited 等。这些信息不存在于dom树中。\n\n2.获取 不能被常规css选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的css选择器获取，但可以通过 :first-child 来获取到。\n\n> 伪类其实是弥补了css选择器的不足，用来更方便地获取信息。\n\n（2）伪元素的功能\n\n> 而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。\n\n（3）冒号区别\n\n> 伪元素的由两个冒号::开头，然后是伪元素的名称。\n\n> 使用两个冒号::是为了区别伪类和伪元素（css2中并没有区别）。当然，考虑到兼容性，css2中已存的伪元素仍然可以使用一个冒号:的语法，但是css3中新增的伪元素必须使用两个冒号::\n\ndiv:after\ndiv::after\ndiv:first-child\ndiv::first-child //错\n\n\n\n# 结构性伪类元素\n\n结构性伪类选择器的公共特征是允许开发者根据文档结构来指定元素的样式。\n\n（1）nth-child和nth-last-child\n\n \t  p:nth-child(n){background:red}  表示e父元素中的第n个字节点\n      p:nth-child(odd){background:red}/*匹配奇数行*/\n      p:nth-child(even){background:red}/*匹配偶数行*/\n      p:nth-child(2n){background:red}/*其中n是从0开始计算*/\n\n\n（2）e:first-child和e:last-child\n\n（3）nth-of-type(n) 和e:nth-last-of-type(n)\n\n（4））e:root（根节点）、e:only-child（独子元素）、e:only-of-type（独子类型元素）和e:empty（孤节点）\n\n\n# 变量提升的一道题\n\n\t   settimeout(() => console.log(\'1\', a));\n\n        new promise(resolve => resolve()).then(() => console.log(\'2\', a));\n\n        console.log(\'3\', a);\n        var a = \'哈哈\'\n        console.log(\'4\', a);\n        function a() {};\n\n//3,f\n//4,哈哈\n//2，哈哈\n//1，哈哈\n\n\n\n# 正则将手机号中间四位变为*\n\nfunction replacephone(str){\n    let reg = /^(\\d{3})(\\d{4})(\\d{4})$/\n   \treturn  str.replace(reg,\'$1****$3\')\n}\n\n\n\n# 图片懒加载\n\n一张图片就是一个标签，而图片的来源主要是src属性。浏览器是否发起亲求就是根据是否有src属性决定的。\n\n既然这样，那么我们就要对标签的src属性下手了，在没进入可视区域的时候，我们先不给这个标签赋src属性，这样岂不是浏览器就不会发送请求了。\n\ndocument.documentelement.clientheight//获取屏幕可视区域的高度\nelement.offsettop//获取元素相对于文档顶部的高度\ndocument.documentelement.scrolltop//获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离\n\n\n\n\n如果：offsettop-scrooltop<clientheight，则图片进入了可视区内，则被请求。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>图片懒加载</title>\n    <style>\n        img {\n            display: block;\n            width: 100%;\n            height: 300px;\n            margin-bottom: 20px;\n        }\n    </style>\n</head>\n<body>\n    <img data-src="./images/1.jpg" alt="">\n    <img data-src="./images/2.jpg" alt="">\n    <img data-src="./images/3.jpg" alt="">\n    <img data-src="./images/4.jpg" alt="">\n    <img data-src="./images/5.jpg" alt="">\n    <img data-src="./images/6.jpg" alt="">\n    <img data-src="./images/7.jpg" alt="">\n    <img data-src="./images/8.jpg" alt="">\n    <img data-src="./images/9.jpg" alt="">\n    <img data-src="./images/10.jpg" alt="">\n    <img data-src="./images/1.jpg" alt="">\n    <img data-src="./images/2.jpg" alt="">\n</body>\n<script>\n        var imgs = document.queryselectorall(\'img\');\n\n        //offsettop是元素与offsetparent的距离，循环获取直到页面顶部\n        function gettop(e) {\n            var t = e.offsettop;\n            while(e = e.offsetparent) {\n                t += e.offsettop;\n            }\n            return t;\n        }\n\n        function lazyload(imgs) {\n            var h = document.documentelement.clientheight;//获取可视区域高度\n            var s = document.documentelement.scrolltop || document.body.scrolltop;\n            for (var i = 0; i < imgs.length; i++) {\n                if (h > gettop(imgs[i])-s) {\n                    imgs[i].src = imgs[i].getattribute(\'data-src\');\n                }\n            }\n        }\n\n        window.onload = window.onscroll = function () { //onscroll()在滚动条滚动的时候触发\n            lazyload(imgs);\n        }\n<\/script>\n</html>\n\n\n\n# 二分查找\n\nfunction binary_search(arr, key) {\n    var low = 0,\n        high = arr.length - 1;\n\n    while (low <= high) {\n        var mid = parseint((high + low) / 2);\n        if (key == arr[mid]) {\n            return mid;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else if (key < arr[mid]) {\n            high = mid - 1;\n        } else {\n            return -1;\n        }\n    }\n}\n\n\n\n# promise能封装setinterval吗\n\n不能，因为promise只能执行一次\n\n\t\t  new promise(function(resolve,reject){\n                settimeout(function(){\n                    resolve()\n                },1000)\n            }).then(function(){\n                console.log(1)\n            })\n\n            new promise(function(resolve,reject){\n                setinterval(function(){\n                    resolve()\n                },1000)\n            }).then(function(){\n                console.log(2)\n            })\n\n\n解决办法\n\n\t\t   function p(){\n                return new promise(function(resolve,reject){\n                    settimeout(function(){\n                        resolve()\n                    },1000)\n                }).then(function(){\n                    console.log("1")\n                })\n            }\n            setinterval(p,1000)\n',charsets:{cjk:!0}},{title:"面试题（九）",frontmatter:{title:"面试题（九）",date:"2018-03-09T09:52:01.000Z",categories:"面试"},regularPath:"/interview/interview-9.html",relativePath:"interview/interview-9.md",key:"v-51361542",path:"/interview/interview-9.html",headers:[{level:2,title:"content-type是什么",slug:"content-type是什么",normalizedTitle:"content-type是什么",charIndex:13},{level:2,title:"什么是预检请求",slug:"什么是预检请求",normalizedTitle:"什么是预检请求",charIndex:32},{level:2,title:"逗号运算符",slug:"逗号运算符",normalizedTitle:"逗号运算符",charIndex:43},{level:2,title:"(0,function)",slug:"_0-function",normalizedTitle:"(0,function)",charIndex:590},{level:2,title:"parseInt有什么用",slug:"parseint有什么用",normalizedTitle:"parseint有什么用",charIndex:52},{level:2,title:"setTimeout倒计时为什么会出现误差",slug:"settimeout倒计时为什么会出现误差",normalizedTitle:"settimeout倒计时为什么会出现误差",charIndex:68},{level:2,title:"前端登陆",slug:"前端登陆",normalizedTitle:"前端登陆",charIndex:95},{level:2,title:"请详细介绍一下从输入 URL 到页面加载完成的过程？",slug:"请详细介绍一下从输入-url-到页面加载完成的过程",normalizedTitle:"请详细介绍一下从输入 url 到页面加载完成的过程？",charIndex:103},{level:2,title:"fetch/Body.json()",slug:"fetch-body-json",normalizedTitle:"fetch/body.json()",charIndex:133},{level:2,title:"Object.prototype.hasOwnProperty()",slug:"object-prototype-hasownproperty",normalizedTitle:"object.prototype.hasownproperty()",charIndex:154}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"content-type是什么 什么是预检请求 逗号运算符 (0,function) parseInt有什么用 setTimeout倒计时为什么会出现误差 前端登陆 请详细介绍一下从输入 URL 到页面加载完成的过程？ fetch/Body.json() Object.prototype.hasOwnProperty()",content:'# 面试题（九）\n\n * content-type是什么\n * 什么是预检请求\n * 逗号运算符\n * parseInt有什么用\n * setTimeout倒计时为什么会出现误差\n * 聊聊前端登陆\n * 请详细介绍一下从输入 URL 到页面加载完成的过程？\n * fetch/Body.json()\n * Object.prototype.hasOwnProperty()\n\n\n# content-type是什么\n\n * application/x-www-form-urlencoded\n   * HTTP会将请求参数用key1=val1&key2=val2的方式进行组织，并放到请求实体里面\n * application/json\n   * JSON 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。这个使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。\n * 可以参考Content-Type 详解\n\n\n# 什么是预检请求\n\n * 预检请求会向服务器确认跨域是否允许，服务返回的响应头里有对应字段Access-Control-Allow-Origin来给浏览器判断：如果允许，浏览器紧接着发送实际请求；不允许，报错并禁止客户端脚本读取响应相关的任何东西。\n * 参考预检请求 OPTIONS\n\n\n# 逗号运算符\n\n\n# (0,function)\n\n> 逗号运算符，它将先计算左边的参数，再计算右边的参数值。然后返回最右边参数的值。\n\nvar a = {\n  foo: function() {\n    console.log(this === window);\n  }\n};\n \na.foo(); // Returns \'false\' in console\n(0, a.foo)(); // Returns \'true\' in console\n\n\nBut, if you were call (0, a.foo)(). The expression (0, a.foo) will evaluate each of its operands (from left to right) and returns the value of the last operand. In other words, (0, a.foo) is equivalent to\n\nfunction() {\n  console.log(this === window);\n} \n\n\n\n# parseInt有什么用\n\nparseInt("10");\t\t\t//返回 10\nparseInt("19",10);\t\t//返回 19 (10+9)\nparseInt("11",2);\t\t//返回 3 (2+1)\nparseInt("17",8);\t\t//返回 15 (8+7)\nparseInt("1f",16);\t\t//返回 31 (16+15)\nparseInt("010");\t\t//未定：返回 10 或 8\n\n//BigInt也有转换进制的功能\nBigInt("0b"+"10") //2\nBigInt("0o"+"10") //8\nBigInt("0x"+"10") //16\n\n//那么10进制怎么转换成2进制呢\nNumberObject.toString(radix);\n\n//parseInt还具有向下取整的功能\nparseInt(2.5) //2\n\n\n\n# setTimeout倒计时为什么会出现误差\n\n> setTimeout() 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout() 指定的时间执行。所以， setTimeout() 的第二个参数表示的是最少时间，并非是确切时间。\n> \n> HTML5标准规定了 setTimeout() 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前。老版本的浏览器都将最短时间设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常是间隔16毫秒执行。这时使用 requestAnimationFrame() 的效果要好于 setTimeout();\n\nsetTimeout(() => {\n    console.log(\'setTimeout\', 10)\n})\n\nfor (let i = 0; i < 10000; i++) {\n    console.log(i)\n}\n\n\nwindow.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\n\n# 前端登陆\n\n * Cookie + Session 登录\n   * 服务端存储 session ，客户端存储 cookie，其中 cookie 保存的为 sessionID\n   * 可以灵活 revoke 权限，更新信息后可以方便的同步 session 中相应内容\n   * 分布式 session 一般使用 redis(或其他KV) 存储\n   * 适合传统系统独立鉴权\n * Token 登录\n * SSO 单点登录\n * OAuth 第三方登录\n\n前端登录，这一篇就够了\n\n\n# 请详细介绍一下从输入 URL 到页面加载完成的过程？\n\n一道面试题是如何引发深层次的灵魂拷问\n\n\n# fetch/Body.json()\n\n使用 Fetch\n\nBody.json()\n\n\n# Object.prototype.hasOwnProperty()\n\n> hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。\n\nconst object1 = {};\nobject1.property1 = 42;\n\nconsole.log(object1.hasOwnProperty(\'property1\'));\n// expected output: true\n\nconsole.log(object1.hasOwnProperty(\'toString\'));\n// expected output: false\n\nconsole.log(object1.hasOwnProperty(\'hasOwnProperty\'));\n// expected output: false\n\n\n> 所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\n> \n> 即使属性的值是 null 或 undefined，只要属性存在，hasOwnProperty 依旧会返回 true。\n\no = new Object();\no.propOne = null;\no.hasOwnProperty(\'propOne\'); // 返回 true\no.propTwo = undefined;\no.hasOwnProperty(\'propTwo\'); // 返回 true\n',normalizedContent:'# 面试题（九）\n\n * content-type是什么\n * 什么是预检请求\n * 逗号运算符\n * parseint有什么用\n * settimeout倒计时为什么会出现误差\n * 聊聊前端登陆\n * 请详细介绍一下从输入 url 到页面加载完成的过程？\n * fetch/body.json()\n * object.prototype.hasownproperty()\n\n\n# content-type是什么\n\n * application/x-www-form-urlencoded\n   * http会将请求参数用key1=val1&key2=val2的方式进行组织，并放到请求实体里面\n * application/json\n   * json 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。这个使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。\n * 可以参考content-type 详解\n\n\n# 什么是预检请求\n\n * 预检请求会向服务器确认跨域是否允许，服务返回的响应头里有对应字段access-control-allow-origin来给浏览器判断：如果允许，浏览器紧接着发送实际请求；不允许，报错并禁止客户端脚本读取响应相关的任何东西。\n * 参考预检请求 options\n\n\n# 逗号运算符\n\n\n# (0,function)\n\n> 逗号运算符，它将先计算左边的参数，再计算右边的参数值。然后返回最右边参数的值。\n\nvar a = {\n  foo: function() {\n    console.log(this === window);\n  }\n};\n \na.foo(); // returns \'false\' in console\n(0, a.foo)(); // returns \'true\' in console\n\n\nbut, if you were call (0, a.foo)(). the expression (0, a.foo) will evaluate each of its operands (from left to right) and returns the value of the last operand. in other words, (0, a.foo) is equivalent to\n\nfunction() {\n  console.log(this === window);\n} \n\n\n\n# parseint有什么用\n\nparseint("10");\t\t\t//返回 10\nparseint("19",10);\t\t//返回 19 (10+9)\nparseint("11",2);\t\t//返回 3 (2+1)\nparseint("17",8);\t\t//返回 15 (8+7)\nparseint("1f",16);\t\t//返回 31 (16+15)\nparseint("010");\t\t//未定：返回 10 或 8\n\n//bigint也有转换进制的功能\nbigint("0b"+"10") //2\nbigint("0o"+"10") //8\nbigint("0x"+"10") //16\n\n//那么10进制怎么转换成2进制呢\nnumberobject.tostring(radix);\n\n//parseint还具有向下取整的功能\nparseint(2.5) //2\n\n\n\n# settimeout倒计时为什么会出现误差\n\n> settimeout() 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 settimeout() 指定的时间执行。所以， settimeout() 的第二个参数表示的是最少时间，并非是确切时间。\n> \n> html5标准规定了 settimeout() 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前。老版本的浏览器都将最短时间设为10毫秒。另外，对于那些dom的变动（尤其是涉及页面重新渲染的部分），通常是间隔16毫秒执行。这时使用 requestanimationframe() 的效果要好于 settimeout();\n\nsettimeout(() => {\n    console.log(\'settimeout\', 10)\n})\n\nfor (let i = 0; i < 10000; i++) {\n    console.log(i)\n}\n\n\nwindow.requestanimationframe() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\n\n# 前端登陆\n\n * cookie + session 登录\n   * 服务端存储 session ，客户端存储 cookie，其中 cookie 保存的为 sessionid\n   * 可以灵活 revoke 权限，更新信息后可以方便的同步 session 中相应内容\n   * 分布式 session 一般使用 redis(或其他kv) 存储\n   * 适合传统系统独立鉴权\n * token 登录\n * sso 单点登录\n * oauth 第三方登录\n\n前端登录，这一篇就够了\n\n\n# 请详细介绍一下从输入 url 到页面加载完成的过程？\n\n一道面试题是如何引发深层次的灵魂拷问\n\n\n# fetch/body.json()\n\n使用 fetch\n\nbody.json()\n\n\n# object.prototype.hasownproperty()\n\n> hasownproperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。\n\nconst object1 = {};\nobject1.property1 = 42;\n\nconsole.log(object1.hasownproperty(\'property1\'));\n// expected output: true\n\nconsole.log(object1.hasownproperty(\'tostring\'));\n// expected output: false\n\nconsole.log(object1.hasownproperty(\'hasownproperty\'));\n// expected output: false\n\n\n> 所有继承了 object 的对象都会继承到 hasownproperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\n> \n> 即使属性的值是 null 或 undefined，只要属性存在，hasownproperty 依旧会返回 true。\n\no = new object();\no.propone = null;\no.hasownproperty(\'propone\'); // 返回 true\no.proptwo = undefined;\no.hasownproperty(\'proptwo\'); // 返回 true\n',charsets:{cjk:!0}},{title:"面试题（三）",frontmatter:{title:"面试题（三）",date:"2018-08-04T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-3.html",relativePath:"interview/interview-3.md",key:"v-4fb3301f",path:"/interview/interview-3.html",headers:[{level:2,title:"== 和 === 的区别",slug:"和-的区别",normalizedTitle:"== 和 === 的区别",charIndex:13},{level:2,title:"讲讲 js 的继承方式",slug:"讲讲-js-的继承方式",normalizedTitle:"讲讲 js 的继承方式",charIndex:29},{level:2,title:"介绍一下箭头函数",slug:"介绍一下箭头函数",normalizedTitle:"介绍一下箭头函数",charIndex:44},{level:2,title:"this 的指向",slug:"this-的指向",normalizedTitle:"this 的指向",charIndex:56},{level:2,title:"简述CSS选择器的优先级规则",slug:"简述css选择器的优先级规则",normalizedTitle:"简述css选择器的优先级规则",charIndex:68},{level:2,title:"简述居中一个元素的方法",slug:"简述居中一个元素的方法",normalizedTitle:"简述居中一个元素的方法",charIndex:86},{level:2,title:"浏览器缓存和webpack缓存配置",slug:"浏览器缓存和webpack缓存配置",normalizedTitle:"浏览器缓存和webpack缓存配置",charIndex:101},{level:3,title:"Etag和Last-Modified区别",slug:"etag和last-modified区别",normalizedTitle:"etag和last-modified区别",charIndex:6698},{level:3,title:"cache control 参数",slug:"cache-control-参数",normalizedTitle:"cache control 参数",charIndex:7534},{level:2,title:"meta标签与视口",slug:"meta标签与视口",normalizedTitle:"meta标签与视口",charIndex:122},{level:2,title:"margin 写 3 个值",slug:"margin-写-3-个值",normalizedTitle:"margin 写 3 个值",charIndex:9363},{level:2,title:"background-size",slug:"background-size",normalizedTitle:"background-size",charIndex:150},{level:2,title:"浏览器标签页通信",slug:"浏览器标签页通信",normalizedTitle:"浏览器标签页通信",charIndex:169},{level:3,title:"cookie + setInterval",slug:"cookie-setinterval",normalizedTitle:"cookie + setinterval",charIndex:10149},{level:3,title:"localStorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:189},{level:3,title:"webworker",slug:"webworker",normalizedTitle:"webworker",charIndex:10511},{level:3,title:"websocket",slug:"websocket",normalizedTitle:"websocket",charIndex:10829},{level:2,title:"cookie, localStorage, sessionStorage",slug:"cookie-localstorage-sessionstorage",normalizedTitle:"cookie, localstorage, sessionstorage",charIndex:181}],lastUpdated:"2/9/2023, 7:49:33 PM",lastUpdatedTimestamp:1675943373e3,headersStr:"== 和 === 的区别 讲讲 js 的继承方式 介绍一下箭头函数 this 的指向 简述CSS选择器的优先级规则 简述居中一个元素的方法 浏览器缓存和webpack缓存配置 Etag和Last-Modified区别 cache control 参数 meta标签与视口 margin 写 3 个值 background-size 浏览器标签页通信 cookie + setInterval localStorage webworker websocket cookie, localStorage, sessionStorage",content:"# 面试题（三）\n\n * == 和 === 的区别\n * 讲讲 js 的继承方式\n * 介绍一下箭头函数\n * this 的指向\n * 简述CSS选择器的优先级规则\n * 简述居中一个元素的方法\n * 浏览器缓存和webpack缓存配置\n * meta标签与视口\n * margin 写3个值\n * background-size\n * 浏览器标签页通信\n * cookie, localStorage, sessionStorage\n\n\n# == 和 === 的区别\n\n> == 代表相同， ===代表严格相同\n> \n> 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.\n> \n> null == undefined // true，是一种规定 null === undefined // false\n> \n> typeof null // object typeof undefined // undefined\n> \n> [1] == [1] // false，地址不同\n> \n> [1] == \"1\" //true，隐式类型转换\n\n\n# 讲讲 js 的继承方式\n\n（1）原型链继承：子类原型是对父类的实例化\n\nfunction Father(){}\nfunction Son(){}\nSon.prototype = new Father()   //实例化对象会指向父类的原型，如图\n\n// 或者使用 Object.create()\nSon.prototype = Object.create(Father.prototype);\n\nlet son = new Son()\nson instanceof Son // true\nson instanceof Father // true\n\n// Object.create 实现\nlet o = Object.create(obj) // o.__proto__ === obj\nObject.create = function (obj) {\n    function F() {}\n    F.prototype = obj;\n    return new F();\n};\n\n\n\n\n缺点：\n\n1.父类的共有属性会被子类实例共享\n\n2.创建子类对象无法传参，因为只有Son.prototype = new Father()可以传，但是会对所有子类有效。\n\n（2）构造函数继承\n\nfunction Father(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction Son(name,age,sex){\n    this.sex = sex;\n    Father.call(this,name,age)\n}\nvar son1 = new Son('张三','30','男')\n\n//简述new一个对象的过程\n//1.创造一个新的空对象\n//2.新对象的_proto_指向构造函数的原型对象\n//3.构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。\n//4.返回新对象地址\n\n//讲一下_proto_和prototype的区别\n//1.__proto__是 对象实例 都有的，而 prototype 是函数对象特有的\n//2.prototype 原型对象 有 constructor 属性，又指回 构造函数\n//3.对象实例的 __proto__ 均默认指向 它们的 构造函数的 prototype\n\n\n缺点：\n\n1.父类的原型方法不会被子类继承，如果全放到构造函数中，每个子类实例都单独拥有一份，违反复用性。\n\n2.不能通过 son instanceof Father\n\n（3）组合继承\n\nfunction Father(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction Son(name,age,sex){\n    this.sex = sex;\n    Father.call(this,name,age)\n}\nSon.prototype = new Father()\n\n\n缺点：父类的构造函数执行了两遍\n\n（4）原型式继承：对原型链继承的封装\n\nfunction inheritObject(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nvar book = {\n    name:'js book'\n}\nvar newBook = inheritObject(book)\nvar newBook.name = 'ajax book'\n\n\n缺点：仍存在原型链继承的缺点\n\n优点：F中无内容，开销比较小。\n\n（5）寄生式继承：对原型继承的二次封装并进行了扩展\n\nvar book = {\n    name:'js book'\n}\nfunction creteBook(obj){\n    var o = inheritObject(obj); //不仅有父类中的属性和方法\n    //扩展新对象\n    o.getName = function(){     //还添加了新的属性和方法\n        console.log(name)\n    }\n    return o\n}\n\n\n缺点：方法在函数中定义，无法得到复用\n\n（6）寄生组合继承（最理想）\n\n组合继承= 原型链继承 + 构造函数继承\n\n寄生组合式继承=寄生式继承+构造函数继承\n\nfunction inheritObject(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(subClass,superClass){\n    var p = inheritObject(superClass.prototype)\n    p.constructor = subClass\n    subClass.prototype = p\n}\n//父类\nfunction SuperClass(name){\n    this.name = name\n}\n//子类\nfunction SubClass(name,time){\n    //构造函数式继承\n    SuperClass.call(this,name)\n    this.time = time\n}\n//寄生式继承父类原型\ninheritPrototype(subClass,superClass)\n\n\n\n# 介绍一下箭头函数\n\n箭头函数的含义\n\nx => x * x  // 相当于\nfunction (x) {\n    return x * x;\n}\n\n\n * 说一下箭头函数和普通函数的区别\n\n（1）箭头函数是匿名函数，不能作为构造函数，不能使用new （2）箭头函数不绑定arguments，取而代之用rest参数…解决\n\nlet B = (b)=>{\n\tconsole.log(arguments);\n}\nB(2,92,32,32); // Uncaught ReferenceError: arguments is not defined\n\nlet C = (...c) => {\n  console.log(c);\n}\nC(3,82,32,11323);  // [3, 82, 32, 11323]   \n\n\n（3）箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 （4）箭头函数通过 call() 或 apply() 方法调用一个函数时，对 this 并没有影响。 （5）箭头函数没有原型属性\n\n\n# this 的指向\n\n * 普通函数指向函数调用者（执行的时候才确定）\n * 箭头函数指向函数所在的作用域（对象的{}和if(){}都构不成作用域）\n\nconst obj = {\n    name:'objName',\n    say:function(){console.log(this.name)},\n    read:()=>{console.log(this.name)}\n}\nobj.say();  //objName     指向的是调用者\nobj.read(); //undefined   指向的是window.name\n\n\n怎么答：\n\n 1. 全局环境中的this指向全局对象window\n 2. new绑定，并且构造函数没有返回其他对象，this指向这个新对象\n 3. 通过call，apply，bind，并且第一个参数值不是Null,undefined，那么this绑定的就是指定的对象\n 4. 普通函数指向函数调用者（执行的时候才确定）\n 5. 箭头函数指向函数所在的作用域，根据上下文确定\n\n关于第二条\n\nfunction fn()  \n{  \n    this.user = '追梦子';  \n    return {};  \n}\nvar a = new fn;  \nconsole.log(a.user); //undefined\n\n\n\n# 简述CSS选择器的优先级规则\n\n> 优先级不同，高优先级属性覆盖低优先级属性 优先级相同，定义在后覆盖定义在先\n> \n> 内联 > ID选择器 > 类选择器 > 标签选择器，伪类>元素标记 !important最高，但是在低版本IE有兼容性问题\n> \n> 如果link引入外部样式表，而本身又有内部样式表，则行内样式依旧优先级最高，内部样式表和外部样式表的优先级和定义先后顺序有关，定义在后的优先级更高。\n\n\n# 简述居中一个元素的方法\n\n考虑：水平还是垂直，块还是行内，是否需要知道宽高，兼容性\n\n（1）水平：\n\n1. margin: 0 auto; // 对于 block 生效\n2. text-align: center; // 对于 inline 和 inline-block 均生效\n\n\n（2）垂直：\n\n3. line-height：xxpx\n4. vertical-align：middle // 还有两个值text-top / text-bottom，常用于图片对齐文字\n5. align-items: center; // flex布局的居中方法\n\n\n（3）水平竖直同时居中\n\nabsolute方法：\n\n 5. 已知宽高：负数margin\n\n.parent{\n    position: relative;\n}\n.child{\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 80px;\n    height: 60px;\n    margin-left: -40px;\n    margin-top: -30px;\n}\n\n\n 6. 已知宽高：calc\n\n.parent{\n    position:relative;\n}\n.child{\n    position:absolute;\n    width: 80px;\n    height: 60px;\n    top:calc(50% - 30px);\n    left:calc(50% - 40px);\n}\n\n\n 7. 需要设定宽高：margin auto\n\n    .f14 .parent{\n        position: relative;\n    }\n    .f14 .child{\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        height: 50px;\n        width: 80px;\n        margin: auto;\n    }\n\n\n 8. 不需要设定宽高：transform(css3,IE8及以下不支持)\n\n    .f15 .parent{\n        position: relative;\n    }\n    .f15 .child{\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%,-50%);  自身偏移\n    }\n\n\n 9. flex布局\n\n.main{\n     display: flex;\n     justify-content: center;\n     align-items: center;\n }\n\n\n 10. table-cell + inline-block\n\ncss新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中，这个属性和table标签一样的居中原理。\n\n.parent{\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n.child{\n    display: inline-block;\n}\n\n\n\n# 浏览器缓存和webpack缓存配置\n\n我们经常谈论的浏览器缓存（强缓存，协商缓存）指的都是HTTP缓存\n\n * 浏览器缓存: 重点看\n * hash、chunkhash和contenthash区别\n * HTTP缓存、浏览器缓存、应用程序缓存\n\n> 当浏览器再次访问一个已经访问过的资源时，它会这样做：\n> \n>  1. 看看是否命中强缓存，如果命中，就直接使用缓存了。\n>  2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存（Etag, Last-modified）。\n>  3. 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。\n>  4. 否则，请求网络返回最新的资源。\n> \n> 浏览器缓存的位置：\n> \n>  1. Service Worker： 是运行在浏览器背后的独立线程，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。\n>  2. Memory Cache： 内存缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。\n>  3. Disk Cache: Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。\n\n> HTTP缓存的基本目的就是使应用执行的更快，更易扩展，但是HTTP缓存通常只适用于idempotent request（可以理解为查询请求，也就是不更新服务端数据的请求），这也就导致了在HTTP的世界里，一般都是对GET请求做缓存，POST请求很少有缓存。\n> \n> GET多用来直接获取数据，不修改数据，主要目的就是database的search语句的感觉。用缓存（有个代理服务器的概念）的目的就是查db的速度变快。\n> \n> POST则是发送数据到服务器端去存储。类似db里的update delete和insert语句的感觉。更新db的意思。数据必须放在数据库，所以一般都得去访问服务器端，而极少需要缓存。\n\n缓存的实现： 强缓存和协商缓存都是根据 HTTP Header 来实现的，就看 response 中 Cache-Control 的值，如果有max-age=xxx秒，则命中强缓存。如果Cache-Control的值是no-cache，说明没命中强缓存，走协商缓存。\n\n\n# Etag和Last-Modified区别\n\nLast-Modified包含了上次更改文档的日期。事实证明，在尝试确定文档是否已更改时，Last-Modified日期并不很可靠。**有时开发人员会在修复某些内容后将所有文件上传到服务器，即使内容仅在子集上更改，也会重置所有文件的Last-Modified日期。**为了适应这种情况，大多数服务器也会发送一个ETag。 ETag代表实体标记，并且是唯一的标识符，其仅根据文件的内容而改变。大多数服务器实际上使用像SHA256这样的散列函数来计算ETag。\n\nLast-Modified与Etag类似。不过Last-Modified表示响应资源在服务器最后修改时间而已。与Etag相比，不足为：\n\n 1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。如果1s内文件被修改了，但是Last-Modified没变，此时不能根据Last-Modified判断文件是否被修改过。\n 2. 如果某些文件会被定期生成，有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存；\n 3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。\n\n然而，Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。\n\nETag生成的常用方法包括使用资源内容的抗冲突散列函数生成的哈希值、最后修改时间戳的散列或甚至仅使用资源的版本号。 即 ETag 就是服务器生成的一个标记，用来标识返回值是否有变化，且Etag的优先级高于Last-Modified。\n\n> 总结就是一般情况下Last-Modified已经足够，ETag只在特定情况下才更有用，前端发布文件不可能一秒发布好多次，而且ETag可能会给服务器带来更大的开销，所以一般就用Last-Modified就行\n\n\n# cache control 参数\n\npublic\n\n> 代表 http 请求返回的内容所经过的任何路径当中（包括中间一些http代理服务器以及发出请求的客户端浏览器），都可以对返回内容进行缓存操作\n\nprivate\n\n> 代表只有发起请求的浏览器才可以进行缓存\n\nno-cache\n\n> 不走强缓存，必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。\n\nno-store\n\n> 所有内容都不会被缓存到缓存或 Internet 临时文件中\n\nmust-revalidation/proxy-revalidation\n\n> 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证\n\nmax-age=xxx\n\n> 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高\n\ns-maxage=xxx\n\n> 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。\n\nimmutable\n\n> immutable表示响应内容将一直不会改变，它和max-age是对缓存生命周期控制的互补性属性，具体举例如下：cache-control: public, max-age=31536000, s-maxage=31536000, immutable\n\n\n# meta标签与视口\n\n首先介绍3个视口的概念\n\n * **layout viewport(布局视口)：**在PC端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。js获取布局视口：document.documentElement.clientWidth | document.body.clientWidth；\n * **visual viewport(视觉视口)：**用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。js获取视觉视口：window.innerWidth；\n * **ideal viewport(理想视口)：**布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。js获取理想视口：window.screen.width；\n * 页面的滚动条取决于视觉视口和布局视口，页面元素宽度取决于布局视口大小\n\n我们在开发时，常常加入这样一行代码\n\n<meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\">\n\n\n * width=device-width，这句代码的意思就是把布局视口 = 理想视口。\n * initial-scale指的是缩放系数。其中有这样的公式：\n\n视觉视口宽度 = 理想视口宽度 / 缩放系数 \n\n比如iphone加入这段代码时：\n视觉视口 = 320/1.0 = 320\n布局视口 = 320\n当视觉视口= 布局视口，页面无滚动条。\n\n当改变initial-scale时：\n\ninitial-scale = 0.5 \n视觉视口宽度 = 320 / 0.5 = 640\n布局视口宽度 = 320\n又因为：视觉视口不能大于布局视口，所以此时，将布局视口的宽度提高等于640\n总结：视觉视口 = 布局视口 = 640\n\ninitial-scale = 2 「 div宽度320，页面有滚动条 」\n视觉视口宽度 = 320 / 2 = 160\n布局视口宽度 = 320\n总结：视觉视口 < 布局视口 页面出现了滚动条。\n\n\n\n# margin 写 3 个值\n\n> margin: 20px 40px 60px;（上20px；左、右40px；下60px）\n\n\n# background-size\n\n正常一个竖屏的封面图，怎么截取中间部分作为封面呢？\n\n采用background属性设置\n\n <div class=\"imagecover\" \n      :style=\"{'background-image': 'url(' + CoverUrl ')'}\"></div>\n\n<style>\n\t.imagecover {              \n        width: 345px;\n        height: 194px;\n        overflow: hidden;\n        background-size: cover;\n        background-position: center;\n        background-repeat: no-repeat;\n    }\n</style>\n\n\n * background-size属性\n\n> cover\n\n缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。\n\n> contain\n\n缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n\n\n# 浏览器标签页通信\n\n\n# cookie + setInterval\n\n> 想在所有的标签页中实现通信，我们必须将数据存放到一个公共的存储空间，所有的标签页都能获取并且还能进行修改；我们知道，cookie在用户所有浏览器标签页中都是共享的，因此，我们可以尝试把选中的数据存放到cookie中去，由于更新cookie并不能触发任何事件，因此我们需要通过定时器setInterval来主动监听cookie中的值是否改变。\n> \n> 缺点：定时器存在延时情况\n\n\n# localStorage\n\n> localStorage也是浏览器多个页面共用的存储空间；而且localStorage在一个页面中添加、修改或者删除时，都会在非当前页面中被动触发一个storage事件，我们通过在其他页面中监听storage事件，即可拿到storage更新前后的值\n\n\n# webworker\n\n> HTML5引入了一个**工作线程（webWorker）**的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。\n> \n> 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。\n> \n> **从而，**可以用webWorker来处理一些比较耗时的计算。\n> \n> webworker也分为Worker和SharedWorker，普通的worker可以直接使用new Worker()创建，只在当前页面中使用；而SharedWorker通过名字我们也能看出，是可以在多个标签页面中数据是共享的；\n\n\n# websocket\n\n> websocket作为全双工通信，自然可以实现多个标签页之间的通信；WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道。\n\n\n# cookie, localStorage, sessionStorage\n\n> cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\n> \n> cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n> \n> sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n\n> cookie数据大小不能超过4k。\n> \n> sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n\n有效时间：\n\n> localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n> \n> sessionStorage 数据在当前浏览器窗口关闭后自动删除。\n> \n> cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭",normalizedContent:"# 面试题（三）\n\n * == 和 === 的区别\n * 讲讲 js 的继承方式\n * 介绍一下箭头函数\n * this 的指向\n * 简述css选择器的优先级规则\n * 简述居中一个元素的方法\n * 浏览器缓存和webpack缓存配置\n * meta标签与视口\n * margin 写3个值\n * background-size\n * 浏览器标签页通信\n * cookie, localstorage, sessionstorage\n\n\n# == 和 === 的区别\n\n> == 代表相同， ===代表严格相同\n> \n> 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.\n> \n> null == undefined // true，是一种规定 null === undefined // false\n> \n> typeof null // object typeof undefined // undefined\n> \n> [1] == [1] // false，地址不同\n> \n> [1] == \"1\" //true，隐式类型转换\n\n\n# 讲讲 js 的继承方式\n\n（1）原型链继承：子类原型是对父类的实例化\n\nfunction father(){}\nfunction son(){}\nson.prototype = new father()   //实例化对象会指向父类的原型，如图\n\n// 或者使用 object.create()\nson.prototype = object.create(father.prototype);\n\nlet son = new son()\nson instanceof son // true\nson instanceof father // true\n\n// object.create 实现\nlet o = object.create(obj) // o.__proto__ === obj\nobject.create = function (obj) {\n    function f() {}\n    f.prototype = obj;\n    return new f();\n};\n\n\n\n\n缺点：\n\n1.父类的共有属性会被子类实例共享\n\n2.创建子类对象无法传参，因为只有son.prototype = new father()可以传，但是会对所有子类有效。\n\n（2）构造函数继承\n\nfunction father(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction son(name,age,sex){\n    this.sex = sex;\n    father.call(this,name,age)\n}\nvar son1 = new son('张三','30','男')\n\n//简述new一个对象的过程\n//1.创造一个新的空对象\n//2.新对象的_proto_指向构造函数的原型对象\n//3.构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。\n//4.返回新对象地址\n\n//讲一下_proto_和prototype的区别\n//1.__proto__是 对象实例 都有的，而 prototype 是函数对象特有的\n//2.prototype 原型对象 有 constructor 属性，又指回 构造函数\n//3.对象实例的 __proto__ 均默认指向 它们的 构造函数的 prototype\n\n\n缺点：\n\n1.父类的原型方法不会被子类继承，如果全放到构造函数中，每个子类实例都单独拥有一份，违反复用性。\n\n2.不能通过 son instanceof father\n\n（3）组合继承\n\nfunction father(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction son(name,age,sex){\n    this.sex = sex;\n    father.call(this,name,age)\n}\nson.prototype = new father()\n\n\n缺点：父类的构造函数执行了两遍\n\n（4）原型式继承：对原型链继承的封装\n\nfunction inheritobject(o){\n    function f(){}\n    f.prototype = o;\n    return new f();\n}\nvar book = {\n    name:'js book'\n}\nvar newbook = inheritobject(book)\nvar newbook.name = 'ajax book'\n\n\n缺点：仍存在原型链继承的缺点\n\n优点：f中无内容，开销比较小。\n\n（5）寄生式继承：对原型继承的二次封装并进行了扩展\n\nvar book = {\n    name:'js book'\n}\nfunction cretebook(obj){\n    var o = inheritobject(obj); //不仅有父类中的属性和方法\n    //扩展新对象\n    o.getname = function(){     //还添加了新的属性和方法\n        console.log(name)\n    }\n    return o\n}\n\n\n缺点：方法在函数中定义，无法得到复用\n\n（6）寄生组合继承（最理想）\n\n组合继承= 原型链继承 + 构造函数继承\n\n寄生组合式继承=寄生式继承+构造函数继承\n\nfunction inheritobject(o){\n    function f(){}\n    f.prototype = o;\n    return new f();\n}\nfunction inheritprototype(subclass,superclass){\n    var p = inheritobject(superclass.prototype)\n    p.constructor = subclass\n    subclass.prototype = p\n}\n//父类\nfunction superclass(name){\n    this.name = name\n}\n//子类\nfunction subclass(name,time){\n    //构造函数式继承\n    superclass.call(this,name)\n    this.time = time\n}\n//寄生式继承父类原型\ninheritprototype(subclass,superclass)\n\n\n\n# 介绍一下箭头函数\n\n箭头函数的含义\n\nx => x * x  // 相当于\nfunction (x) {\n    return x * x;\n}\n\n\n * 说一下箭头函数和普通函数的区别\n\n（1）箭头函数是匿名函数，不能作为构造函数，不能使用new （2）箭头函数不绑定arguments，取而代之用rest参数…解决\n\nlet b = (b)=>{\n\tconsole.log(arguments);\n}\nb(2,92,32,32); // uncaught referenceerror: arguments is not defined\n\nlet c = (...c) => {\n  console.log(c);\n}\nc(3,82,32,11323);  // [3, 82, 32, 11323]   \n\n\n（3）箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 （4）箭头函数通过 call() 或 apply() 方法调用一个函数时，对 this 并没有影响。 （5）箭头函数没有原型属性\n\n\n# this 的指向\n\n * 普通函数指向函数调用者（执行的时候才确定）\n * 箭头函数指向函数所在的作用域（对象的{}和if(){}都构不成作用域）\n\nconst obj = {\n    name:'objname',\n    say:function(){console.log(this.name)},\n    read:()=>{console.log(this.name)}\n}\nobj.say();  //objname     指向的是调用者\nobj.read(); //undefined   指向的是window.name\n\n\n怎么答：\n\n 1. 全局环境中的this指向全局对象window\n 2. new绑定，并且构造函数没有返回其他对象，this指向这个新对象\n 3. 通过call，apply，bind，并且第一个参数值不是null,undefined，那么this绑定的就是指定的对象\n 4. 普通函数指向函数调用者（执行的时候才确定）\n 5. 箭头函数指向函数所在的作用域，根据上下文确定\n\n关于第二条\n\nfunction fn()  \n{  \n    this.user = '追梦子';  \n    return {};  \n}\nvar a = new fn;  \nconsole.log(a.user); //undefined\n\n\n\n# 简述css选择器的优先级规则\n\n> 优先级不同，高优先级属性覆盖低优先级属性 优先级相同，定义在后覆盖定义在先\n> \n> 内联 > id选择器 > 类选择器 > 标签选择器，伪类>元素标记 !important最高，但是在低版本ie有兼容性问题\n> \n> 如果link引入外部样式表，而本身又有内部样式表，则行内样式依旧优先级最高，内部样式表和外部样式表的优先级和定义先后顺序有关，定义在后的优先级更高。\n\n\n# 简述居中一个元素的方法\n\n考虑：水平还是垂直，块还是行内，是否需要知道宽高，兼容性\n\n（1）水平：\n\n1. margin: 0 auto; // 对于 block 生效\n2. text-align: center; // 对于 inline 和 inline-block 均生效\n\n\n（2）垂直：\n\n3. line-height：xxpx\n4. vertical-align：middle // 还有两个值text-top / text-bottom，常用于图片对齐文字\n5. align-items: center; // flex布局的居中方法\n\n\n（3）水平竖直同时居中\n\nabsolute方法：\n\n 5. 已知宽高：负数margin\n\n.parent{\n    position: relative;\n}\n.child{\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 80px;\n    height: 60px;\n    margin-left: -40px;\n    margin-top: -30px;\n}\n\n\n 6. 已知宽高：calc\n\n.parent{\n    position:relative;\n}\n.child{\n    position:absolute;\n    width: 80px;\n    height: 60px;\n    top:calc(50% - 30px);\n    left:calc(50% - 40px);\n}\n\n\n 7. 需要设定宽高：margin auto\n\n    .f14 .parent{\n        position: relative;\n    }\n    .f14 .child{\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        height: 50px;\n        width: 80px;\n        margin: auto;\n    }\n\n\n 8. 不需要设定宽高：transform(css3,ie8及以下不支持)\n\n    .f15 .parent{\n        position: relative;\n    }\n    .f15 .child{\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%,-50%);  自身偏移\n    }\n\n\n 9. flex布局\n\n.main{\n     display: flex;\n     justify-content: center;\n     align-items: center;\n }\n\n\n 10. table-cell + inline-block\n\ncss新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中，这个属性和table标签一样的居中原理。\n\n.parent{\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n.child{\n    display: inline-block;\n}\n\n\n\n# 浏览器缓存和webpack缓存配置\n\n我们经常谈论的浏览器缓存（强缓存，协商缓存）指的都是http缓存\n\n * 浏览器缓存: 重点看\n * hash、chunkhash和contenthash区别\n * http缓存、浏览器缓存、应用程序缓存\n\n> 当浏览器再次访问一个已经访问过的资源时，它会这样做：\n> \n>  1. 看看是否命中强缓存，如果命中，就直接使用缓存了。\n>  2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存（etag, last-modified）。\n>  3. 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。\n>  4. 否则，请求网络返回最新的资源。\n> \n> 浏览器缓存的位置：\n> \n>  1. service worker： 是运行在浏览器背后的独立线程，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。\n>  2. memory cache： 内存缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 tab 页面，内存中的缓存也就被释放了。\n>  3. disk cache: disk cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 memory cache 胜在容量和存储时效性上。\n\n> http缓存的基本目的就是使应用执行的更快，更易扩展，但是http缓存通常只适用于idempotent request（可以理解为查询请求，也就是不更新服务端数据的请求），这也就导致了在http的世界里，一般都是对get请求做缓存，post请求很少有缓存。\n> \n> get多用来直接获取数据，不修改数据，主要目的就是database的search语句的感觉。用缓存（有个代理服务器的概念）的目的就是查db的速度变快。\n> \n> post则是发送数据到服务器端去存储。类似db里的update delete和insert语句的感觉。更新db的意思。数据必须放在数据库，所以一般都得去访问服务器端，而极少需要缓存。\n\n缓存的实现： 强缓存和协商缓存都是根据 http header 来实现的，就看 response 中 cache-control 的值，如果有max-age=xxx秒，则命中强缓存。如果cache-control的值是no-cache，说明没命中强缓存，走协商缓存。\n\n\n# etag和last-modified区别\n\nlast-modified包含了上次更改文档的日期。事实证明，在尝试确定文档是否已更改时，last-modified日期并不很可靠。**有时开发人员会在修复某些内容后将所有文件上传到服务器，即使内容仅在子集上更改，也会重置所有文件的last-modified日期。**为了适应这种情况，大多数服务器也会发送一个etag。 etag代表实体标记，并且是唯一的标识符，其仅根据文件的内容而改变。大多数服务器实际上使用像sha256这样的散列函数来计算etag。\n\nlast-modified与etag类似。不过last-modified表示响应资源在服务器最后修改时间而已。与etag相比，不足为：\n\n 1. last-modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。如果1s内文件被修改了，但是last-modified没变，此时不能根据last-modified判断文件是否被修改过。\n 2. 如果某些文件会被定期生成，有时内容并没有任何变化，但last-modified却改变了，导致文件没法使用缓存；\n 3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。\n\n然而，etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。\n\netag生成的常用方法包括使用资源内容的抗冲突散列函数生成的哈希值、最后修改时间戳的散列或甚至仅使用资源的版本号。 即 etag 就是服务器生成的一个标记，用来标识返回值是否有变化，且etag的优先级高于last-modified。\n\n> 总结就是一般情况下last-modified已经足够，etag只在特定情况下才更有用，前端发布文件不可能一秒发布好多次，而且etag可能会给服务器带来更大的开销，所以一般就用last-modified就行\n\n\n# cache control 参数\n\npublic\n\n> 代表 http 请求返回的内容所经过的任何路径当中（包括中间一些http代理服务器以及发出请求的客户端浏览器），都可以对返回内容进行缓存操作\n\nprivate\n\n> 代表只有发起请求的浏览器才可以进行缓存\n\nno-cache\n\n> 不走强缓存，必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (etag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。\n\nno-store\n\n> 所有内容都不会被缓存到缓存或 internet 临时文件中\n\nmust-revalidation/proxy-revalidation\n\n> 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证\n\nmax-age=xxx\n\n> 缓存的内容将在 xxx 秒后失效, 这个选项只在http 1.1可用, 并如果和last-modified一起使用时, 优先级较高\n\ns-maxage=xxx\n\n> 同max-age作用一样，只在代理服务器中生效（比如cdn缓存）。比如当s-maxage=60时，在这60秒中，即使更新了cdn的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和expires header。\n\nimmutable\n\n> immutable表示响应内容将一直不会改变，它和max-age是对缓存生命周期控制的互补性属性，具体举例如下：cache-control: public, max-age=31536000, s-maxage=31536000, immutable\n\n\n# meta标签与视口\n\n首先介绍3个视口的概念\n\n * **layout viewport(布局视口)：**在pc端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为pc端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。js获取布局视口：document.documentelement.clientwidth | document.body.clientwidth；\n * **visual viewport(视觉视口)：**用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。js获取视觉视口：window.innerwidth；\n * **ideal viewport(理想视口)：**布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。js获取理想视口：window.screen.width；\n * 页面的滚动条取决于视觉视口和布局视口，页面元素宽度取决于布局视口大小\n\n我们在开发时，常常加入这样一行代码\n\n<meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\">\n\n\n * width=device-width，这句代码的意思就是把布局视口 = 理想视口。\n * initial-scale指的是缩放系数。其中有这样的公式：\n\n视觉视口宽度 = 理想视口宽度 / 缩放系数 \n\n比如iphone加入这段代码时：\n视觉视口 = 320/1.0 = 320\n布局视口 = 320\n当视觉视口= 布局视口，页面无滚动条。\n\n当改变initial-scale时：\n\ninitial-scale = 0.5 \n视觉视口宽度 = 320 / 0.5 = 640\n布局视口宽度 = 320\n又因为：视觉视口不能大于布局视口，所以此时，将布局视口的宽度提高等于640\n总结：视觉视口 = 布局视口 = 640\n\ninitial-scale = 2 「 div宽度320，页面有滚动条 」\n视觉视口宽度 = 320 / 2 = 160\n布局视口宽度 = 320\n总结：视觉视口 < 布局视口 页面出现了滚动条。\n\n\n\n# margin 写 3 个值\n\n> margin: 20px 40px 60px;（上20px；左、右40px；下60px）\n\n\n# background-size\n\n正常一个竖屏的封面图，怎么截取中间部分作为封面呢？\n\n采用background属性设置\n\n <div class=\"imagecover\" \n      :style=\"{'background-image': 'url(' + coverurl ')'}\"></div>\n\n<style>\n\t.imagecover {              \n        width: 345px;\n        height: 194px;\n        overflow: hidden;\n        background-size: cover;\n        background-position: center;\n        background-repeat: no-repeat;\n    }\n</style>\n\n\n * background-size属性\n\n> cover\n\n缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。\n\n> contain\n\n缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n\n\n# 浏览器标签页通信\n\n\n# cookie + setinterval\n\n> 想在所有的标签页中实现通信，我们必须将数据存放到一个公共的存储空间，所有的标签页都能获取并且还能进行修改；我们知道，cookie在用户所有浏览器标签页中都是共享的，因此，我们可以尝试把选中的数据存放到cookie中去，由于更新cookie并不能触发任何事件，因此我们需要通过定时器setinterval来主动监听cookie中的值是否改变。\n> \n> 缺点：定时器存在延时情况\n\n\n# localstorage\n\n> localstorage也是浏览器多个页面共用的存储空间；而且localstorage在一个页面中添加、修改或者删除时，都会在非当前页面中被动触发一个storage事件，我们通过在其他页面中监听storage事件，即可拿到storage更新前后的值\n\n\n# webworker\n\n> html5引入了一个**工作线程（webworker）**的概念。它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。\n> \n> 简而言之，就是允许javascript创建多个线程，但是子线程完全受主线程控制，且不得操作dom。\n> \n> **从而，**可以用webworker来处理一些比较耗时的计算。\n> \n> webworker也分为worker和sharedworker，普通的worker可以直接使用new worker()创建，只在当前页面中使用；而sharedworker通过名字我们也能看出，是可以在多个标签页面中数据是共享的；\n\n\n# websocket\n\n> websocket作为全双工通信，自然可以实现多个标签页之间的通信；websocket是html5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道。\n\n\n# cookie, localstorage, sessionstorage\n\n> cookie是网站为了标示用户身份而储存在用户本地终端（client side）上的数据（通常经过加密）。\n> \n> cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n> \n> sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n\n> cookie数据大小不能超过4k。\n> \n> sessionstorage和localstorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5m或更大\n\n有效时间：\n\n> localstorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n> \n> sessionstorage 数据在当前浏览器窗口关闭后自动删除。\n> \n> cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭",charsets:{cjk:!0}},{title:"智力题",frontmatter:{title:"智力题",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/iq.html",relativePath:"interview/iq.md",key:"v-1ef1807f",path:"/interview/iq.html",headers:[{level:2,title:"抓石子",slug:"抓石子",normalizedTitle:"抓石子",charIndex:2},{level:2,title:"红墨水蓝墨水",slug:"红墨水蓝墨水",normalizedTitle:"红墨水蓝墨水",charIndex:874},{level:2,title:"称重",slug:"称重",normalizedTitle:"称重",charIndex:1120},{level:2,title:"倒水",slug:"倒水",normalizedTitle:"倒水",charIndex:1174}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"抓石子 红墨水蓝墨水 称重 倒水",content:"# 抓石子\n\n> A、B从一个石子堆里抓石子，交替进行，一个人可以抓1或者2颗，A先走，几种可能性。\n\n// 和爬楼梯类似 f(n) = f(n-1) + f(n-2)\nfunction getClimbingWays(n) {\n    if (n < 1) return 0\n    if (n === 1) return 1\n    if (n === 2) return 2\n    let a = 1, b = 2, temp = 0\n    for (let i = 3; i <= n; i++) {\n        temp = a + b\n        a = b\n        b = temp\n    }\n    return temp\n}\n\n\n> 最后抓的算负，16颗的情况下，A、B有必胜可能么(谁先抓，怎么抓，谁必胜)。\n\n巴什博奕(Bash Game):\n\n只有一堆n个物品,两个人轮流从这堆物品中取物,规定每次至少取一个,最多取m个.最后取光者得胜\n\n> 结论：若n%(m+1)=0，则先手必败，否则先手必胜\n\n显然,如果n=m+1,那么由于一次最多只能取m个,所以,无论先取者拿走多少个,后取者都能够一次拿走剩余的物品,后者取胜。 引入一个概念，奇异局势。当面对这个局势时则会失败。\n\n奇异局势的判定：\n\n> 一般的奇异局势是n=(m+1)*i，其中i为自然数，即n%(m+1)=0，面对这种情况无论我怎么取，对方总可以将其恢复为n%(m+1)=0，一直到n=(m+1)局势。\n\n玩家的策略：\n\n> 就是把当前面对的非奇异局势变为奇异局势留给对方。如果当前的石子个数为(m+1)*i+s，那么就将s个石子取走，使其达到奇异局势。\n\n回到原题如果最后抓的算负\n\n> 结论，若n%(m+1)=1，则先手必败。即n%3==1，则先手必败\n> \n> 我剩1个必输\n> \n> 如果有4个，无论我怎么取对方都可以让我剩1个\n> \n> 如果有7个，无论我怎么取对方都可以让我剩4个\n> \n> 如果16个的话，先手必败\n\n\n# 红墨水蓝墨水\n\n> 一瓶红墨水50克,一瓶蓝墨水50克,从红墨水中取一克红墨水放入蓝墨水中，然后又从蓝墨水瓶中取出一克混合墨水送还到红墨水瓶中，请问现在是红墨水瓶的蓝墨水多还是蓝墨水瓶中的红墨水多？一样多\n\n第一次取，此时蓝墨水瓶中的混合墨水的比例为50:1，即混合墨水的应为1/51的红墨水和50/51的蓝墨水。\n\n1克混合墨水的应为1/51克的红墨水加50/51克的蓝墨水。\n\n第二次取：\n\n红墨水瓶中的蓝墨水 50/51\n蓝墨水瓶中的红墨水 1 - 1/51 = 50/51\n\n\n\n# 称重\n\n12个球里面有一个质量不均匀，给一个天平，如果用最少比较次数找出不均匀的球。\n\n答案：三次\n\n\n# 倒水\n\n如何用一个3升，一个5升的水杯，倒出一杯4升的水\n\n1. 3L装满倒入5L\n2. 3L继续装满倒入5L，3L里还剩1L\n3. 5L水全倒出，1L倒入5L杯\n4. 3L水装满倒入5L杯子\n",normalizedContent:"# 抓石子\n\n> a、b从一个石子堆里抓石子，交替进行，一个人可以抓1或者2颗，a先走，几种可能性。\n\n// 和爬楼梯类似 f(n) = f(n-1) + f(n-2)\nfunction getclimbingways(n) {\n    if (n < 1) return 0\n    if (n === 1) return 1\n    if (n === 2) return 2\n    let a = 1, b = 2, temp = 0\n    for (let i = 3; i <= n; i++) {\n        temp = a + b\n        a = b\n        b = temp\n    }\n    return temp\n}\n\n\n> 最后抓的算负，16颗的情况下，a、b有必胜可能么(谁先抓，怎么抓，谁必胜)。\n\n巴什博奕(bash game):\n\n只有一堆n个物品,两个人轮流从这堆物品中取物,规定每次至少取一个,最多取m个.最后取光者得胜\n\n> 结论：若n%(m+1)=0，则先手必败，否则先手必胜\n\n显然,如果n=m+1,那么由于一次最多只能取m个,所以,无论先取者拿走多少个,后取者都能够一次拿走剩余的物品,后者取胜。 引入一个概念，奇异局势。当面对这个局势时则会失败。\n\n奇异局势的判定：\n\n> 一般的奇异局势是n=(m+1)*i，其中i为自然数，即n%(m+1)=0，面对这种情况无论我怎么取，对方总可以将其恢复为n%(m+1)=0，一直到n=(m+1)局势。\n\n玩家的策略：\n\n> 就是把当前面对的非奇异局势变为奇异局势留给对方。如果当前的石子个数为(m+1)*i+s，那么就将s个石子取走，使其达到奇异局势。\n\n回到原题如果最后抓的算负\n\n> 结论，若n%(m+1)=1，则先手必败。即n%3==1，则先手必败\n> \n> 我剩1个必输\n> \n> 如果有4个，无论我怎么取对方都可以让我剩1个\n> \n> 如果有7个，无论我怎么取对方都可以让我剩4个\n> \n> 如果16个的话，先手必败\n\n\n# 红墨水蓝墨水\n\n> 一瓶红墨水50克,一瓶蓝墨水50克,从红墨水中取一克红墨水放入蓝墨水中，然后又从蓝墨水瓶中取出一克混合墨水送还到红墨水瓶中，请问现在是红墨水瓶的蓝墨水多还是蓝墨水瓶中的红墨水多？一样多\n\n第一次取，此时蓝墨水瓶中的混合墨水的比例为50:1，即混合墨水的应为1/51的红墨水和50/51的蓝墨水。\n\n1克混合墨水的应为1/51克的红墨水加50/51克的蓝墨水。\n\n第二次取：\n\n红墨水瓶中的蓝墨水 50/51\n蓝墨水瓶中的红墨水 1 - 1/51 = 50/51\n\n\n\n# 称重\n\n12个球里面有一个质量不均匀，给一个天平，如果用最少比较次数找出不均匀的球。\n\n答案：三次\n\n\n# 倒水\n\n如何用一个3升，一个5升的水杯，倒出一杯4升的水\n\n1. 3l装满倒入5l\n2. 3l继续装满倒入5l，3l里还剩1l\n3. 5l水全倒出，1l倒入5l杯\n4. 3l水装满倒入5l杯子\n",charsets:{cjk:!0}},{title:"面试题（八）",frontmatter:{title:"面试题（八）",date:"2018-08-03T09:21:01.000Z",categories:"面试"},regularPath:"/interview/interview-8.html",relativePath:"interview/interview-8.md",key:"v-7e715702",path:"/interview/interview-8.html",headers:[{level:2,title:"v-show 与 v-if 区别",slug:"v-show-与-v-if-区别",normalizedTitle:"v-show 与 v-if 区别",charIndex:13},{level:2,title:"动态绑定class的方法",slug:"动态绑定class的方法",normalizedTitle:"动态绑定class的方法",charIndex:33},{level:3,title:"（1）对象语法",slug:"_1-对象语法",normalizedTitle:"（1）对象语法",charIndex:932},{level:3,title:"（2）直接设置为对象",slug:"_2-直接设置为对象",normalizedTitle:"（2）直接设置为对象",charIndex:1587},{level:3,title:"（3）数组方法",slug:"_3-数组方法",normalizedTitle:"（3）数组方法",charIndex:1687},{level:3,title:"（4）三元运算符",slug:"_4-三元运算符",normalizedTitle:"（4）三元运算符",charIndex:1862},{level:3,title:"（5）computed",slug:"_5-computed",normalizedTitle:"（5）computed",charIndex:2003},{level:2,title:"v-model",slug:"v-model",normalizedTitle:"v-model",charIndex:49},{level:2,title:"Sass与Stylus的常见语法",slug:"sass与stylus的常见语法",normalizedTitle:"sass与stylus的常见语法",charIndex:66},{level:3,title:"Sass与Stylus的对比",slug:"sass与stylus的对比",normalizedTitle:"sass与stylus的对比",charIndex:2434},{level:2,title:"小程序的页面栈与生命周期",slug:"小程序的页面栈与生命周期",normalizedTitle:"小程序的页面栈与生命周期",charIndex:86},{level:3,title:"小程序的页面栈",slug:"小程序的页面栈",normalizedTitle:"小程序的页面栈",charIndex:86},{level:3,title:"小程序的生命周期",slug:"小程序的生命周期",normalizedTitle:"小程序的生命周期",charIndex:4135},{level:3,title:"页面的生命周期",slug:"页面的生命周期",normalizedTitle:"页面的生命周期",charIndex:4300},{level:2,title:"window.length",slug:"window-length",normalizedTitle:"window.length",charIndex:4565},{level:2,title:"package.json和package-lock.json",slug:"package-json和package-lock-json",normalizedTitle:"package.json和package-lock.json",charIndex:112},{level:3,title:"版本号区分",slug:"版本号区分",normalizedTitle:"版本号区分",charIndex:5197},{level:2,title:"npm nrm yarn",slug:"npm-nrm-yarn",normalizedTitle:"npm nrm yarn",charIndex:146},{level:3,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5422},{level:3,title:"npm中的 --save与--save-dev",slug:"npm中的-save与-save-dev",normalizedTitle:"npm中的 --save与--save-dev",charIndex:5998},{level:2,title:"什么是node-sass",slug:"什么是node-sass",normalizedTitle:"什么是node-sass",charIndex:162},{level:2,title:"url编码与解码",slug:"url编码与解码",normalizedTitle:"url编码与解码",charIndex:196}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"v-show 与 v-if 区别 动态绑定class的方法 （1）对象语法 （2）直接设置为对象 （3）数组方法 （4）三元运算符 （5）computed v-model Sass与Stylus的常见语法 Sass与Stylus的对比 小程序的页面栈与生命周期 小程序的页面栈 小程序的生命周期 页面的生命周期 window.length package.json和package-lock.json 版本号区分 npm nrm yarn 常用命令 npm中的 --save与--save-dev 什么是node-sass url编码与解码",content:'# 面试题（八）\n\n * v-show 与 v-if 区别\n * 动态绑定class的方法\n * v-model是怎么实现的\n * Sass与Stylus的常见语法\n * 小程序的页面栈与生命周期\n * 看代码说输出\n * package.json和package-lock.json\n * npm nrm yarn\n * 什么是node-sass\n * 封装小程序分享参数,获取参数\n * url编码与解码\n\n\n# v-show 与 v-if 区别\n\n相同点：v-if与v-show都可以动态控制dom元素显示隐藏\n\n不同点：v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加display:none，dom元素还在。\n\nvisibility:hidden和display:none的区别\n\nvisibility:hidden; 可以隐藏某个元素，但是隐藏的元素仍要占据空间，仍要影响布局，会触发重绘\ndisplay:none; 不会占据空间，会触发回流\n\n\n\t<div id=\'app\'>\n        <div v-if=\'isIf\'>我是v-if</div>\n        <div v-show=\'isShow\'>我是v-show</div>\n    </div>\n\n    <script src=\'vue.min.js\'><\/script>\n    <script>\n        let app = new Vue({\n            el:\'#app\',\n            data:{\n                isIf:true,\n                isShow:false\n            }\n        })\n    <\/script>\n\n\n**性能消耗：**v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n**使用场景：**v-if适合运营条件不大可能改变；v-show适合频繁切换。\n\n对于管理系统的权限列表的展示，这里可以使用V-if来渲染,对于前台页面的数据展示，这里推荐使用V-show\n\n\n# 动态绑定class的方法\n\n\n# （1）对象语法\n\n给v-bind:class 设置一个对象，可以动态地切换class，如下\n\n<div id="app">\n    <div :class="{\'active\':isActive}"></div>\n</div>\n\n<script>\n    var app = new Vue({\n        el:\'#app\',\n        data:{\n            isActive:true\n        }\n    })\n<\/script>\n\n\n最终渲染结果为：<div class="active">\\</div>\n\nv-bind就是用于绑定数据和元素属性的\n\n<div class="app">\n    <a v-bind:href="url">click me</a>\n</div>  \n\n<script>\n    var app = new Vue({\n        el:\'.app\',\n        data:{\n            url:"https://www.baidu.com",\n        }\n    });\n<\/script>\n\n\n当然对象中也可以传入多个属性\n\n<div id="app">\n    <div :class="{\'active\':isActive,\'error\':isError}"></div>\n</div>\n\n\x3c!--当值均为true时--\x3e\n<div class="active error"></div>\n\n\n\n# （2）直接设置为对象\n\n<div :class="classObject"></div>\n\ndata: {\n  classObject: {\n    active: true,\n  }\n}\n\n\n\n# （3）数组方法\n\n<div :class="[activeClass, errorClass]"></div>\n\n data:{\n      activeClass: "active",\n      errorClass: "disActive"\n },\n\n渲染为\n<div class="active disActive"></div>\n\n\n\n# （4）三元运算符\n\n<div :class="[isActive?\'active\':\'disActive\']"></div>\n\n data:{\n      isActive: false,\n  },\n\n渲染为：\n<div class="disActive"></div>\n\n\n\n# （5）computed\n\n<div :class="classObject"></div>\n\n  data:{\n    isActive: true,\n  },\n  computed: {\n      classObject: {\n          active: this.isActive,\n\t  }\n  }\n\n\n\n# v-model\n\nv-model本质上是一个语法糖。（双向的）\n\n如下代码<input v-model="test">本质上是<input :value="test" @input="test = $event.target.value">\n\n:value="test"设置input初始值为text值，\n\n@input="test = $event.target.value,当输入的值改变时，test更新\n\n\n# Sass与Stylus的常见语法\n\nSass,Stylus都是css预处理器，除了这两种之外还有less等。\n\n\n# Sass与Stylus的对比\n\n参考于这篇文章\n\n 1. 变量\n\nsass允许使用变量，所有的变量以$开头。\n\n$blue: #1875e7;\ndiv {\n   color: $blue\n }\n\n\nstylus也允许使用变量，变量名的$是可选的，变量值可以是表达式。\n\ncolor = blue 或者  $color = blue\ndiv\n    color: color\n\n\n 2. 计算属性\n\nsass允许在代码中使用算式:\n\nbody {\n    margin: (14px/2);\n    top: 50px + 100px;\n    right: $var * 10%;\n  }\n\n\nstylus同样也支持在代码中使用算式:\n\n body\n    margin: (14px/2)\n    top: 50px + 100px\n    right: var * 10%\n\n\n 3. 嵌套\n\nsass允许选择器嵌套。比如下面的css代码:\n\n  div h1 {\n    color: red\n  }\n  \n 可以写成：\n \n  div {\n    h1{\n      color: red\n   }\n }\n\n\nstylus同样支持选择器嵌套，上面的代码可以写成:\n\ndiv\n  h1\n    color: red\n\n\nsass也支持属性嵌套,比如border-color属性可以写成:\n\n p{\n     border: {\n       color: red;\n     }\n }\n \n border后面需要加上冒号\n\n\nstylus没有这个功能\n\n 4. 继承\n\nsass允许一个选择器，继承另一个选择器。比如，现在class1：\n\n.class1 {\n    border: 1px solid #ddd\n  }\n  \n  class2要继承class1，就要使用@extend命令。\n  \n  .class2 {\n    @extend .class1\n    font-size: 120%\n  }\n\n\nstylus的继承方式和sass基本一致，但有一些稍微的不同。\n\nstylus实现继承:\n\n.class1\n    border: 1px solid #ddd\n    \n .class2\n    @extend .class1\n    font-size: 120%\n\n\n两者的区别主要在于--sass不允许@extend嵌套选择器: 如下面的样式:\n\ndiv\n  h1\n   color: red\n\n\n在sass中，如果按照下面这样写就会直接编译错误。\n\n .div2 {\n    @extend div h1\n }\n\n\n而在stylus中却可以成功编译，因为stylus中，只要选择器匹配，继承就会生效。\n\n.div2\n   @extend div h1\n\n\n\n# 小程序的页面栈与生命周期\n\n\n# 小程序的页面栈\n\n路由方式                          页面栈\n初始化                           新页面入栈\n打开新页面（wx.navigateTo）          新页面入栈\n页面重定向（wx.redirctTo）           当前页面出栈，新页面入栈\n页面返回（wx.navigateBack）         页面不断出栈，直到目标返回页，新页面入栈\nTab切换（wx.switchTab或底部tab切换）   页面全部出栈，只留下新的Tab页面\n重启动（wx.relaunch）              页面全部出栈，只留下新的页面\n\n * navigateTo, redirectTo 只能打开非 tabBar 页面。\n * switchTab 只能打开 tabBar 页面。\n * reLaunch 可以打开任意页面。\n * 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。\n * 调用页面路由带的参数可以在目标页面的onLoad中获取。\n\n\n# 小程序的生命周期\n\nonLaunch() {\n    console.log(\'onLaunch监听小程序初始化\');\n}\n\nonShow() {\n    console.log(\'onShow监听小程序显示\');\n}\n\nonHide() {\n    console.log(\'onLaunch监听小程序隐藏\');\n}\n\n\n\n# 页面的生命周期\n\nonLoad(options) {\n    console.log(\'onLoad监听页面加载\');\n}\n\nonReady() {\n    console.log(\'onReady监听页面初次渲染完成\');\n}\n\nonShow() {\n    console.log(\'onShow监听页面显示\');\n}\n\nonHide() {\n    console.log(\'onHide监听页面隐藏\');\n}\n\nonUnload() {\n    console.log(\'onUnload监听页面卸载\');\n}\n\n\n\n# window.length\n\nfunction foo(){\n    console.log(length)  //词法作用域，找foo函数外面定义的length，即window.length\n}\nfunction bar(){\n    var length = \'jin\'\n    foo()\n}\nbar()  //输出的为window.length即为iframe的个数\n\n\n\n# package.json和package-lock.json\n\nnpm描述模块信息的文件就是 package.json ，npm install会根据package.json安装依赖\n\n每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号。\n\n> 原来的 package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。\n\n当文件中存在package-lock.json时，执行npm install，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。\n\n\n# 版本号区分\n\n * ^16.8.0表示安装16.x.x的最新版本，安装时不改变大版本号。\n * ~16.8.0表示安装16.8.x的最新版本，安装时不改变大版本号和次要版本号。\n * 16.8.0 表示安装指定的版本号，也就是安装16.8.0版本。\n\n\n# npm nrm yarn\n\n * npm,nrm,yarn的关系\n\n> yarn 是 FaceBook 开源的一个新的包管理器， 和npm的作用是一样的，但是解决了一些npm的痛点。\n\n\n# 常用命令\n\nNPM                             YARN\nnpm init                        yarn init\nnpm install                     yarn install\nnpm install --no-package-lock   yarn install --no-package-lock\nnpm install xxx --save          yarn add xxx\nnpm install xxx --save-dev      yarn add xxx --dev\nnpm uninstall xxx --save        yarn remove xxx\nyarn add xx@version             npm install xx@vision\nyarn upgrade xx                 npm update xx\nyarn upgrade xx@version         npm update xx@vision\nyarn why xx                     -\nyarn config list                npm config list\n\n\n# npm中的 --save与--save-dev\n\n * i 是 install 的简写\n * -g 是全局安装，不带 -g 会安装在个人文件夹\n * -S 与 --save 的简写，安装包信息会写入 dependencies 中\n * -D 与 --save-dev 的简写，安装包写入 devDependencies 中\n * dependencies 生产阶段的依赖,也就是项目运行时的依赖\n * devDependencies 开发阶段的依赖，就是我们在开发过程中需要的依赖，只在开发阶段起作用的\n\n----------------------------------------\n\n比如写 ES6 代码，需要 babel 转换成 es5 ，转换完成后，我们只需要转换后的代码，上线的时候，直接把转换后的代码部署到生产环境，不需要 bebal 了，生产环境不需要。这就可以安装到 devDependencies ，再比如说代码提示工具，也可以安装到 devDependencies 。\n\n如果你用了 Element-UI，由于发布到生产后还是依赖 Element-UI，这就可以安装到 dependencies 。\n\n\n# 什么是node-sass\n\n> Node-sass是一个库，它将Node.js绑定到LibSass（流行样式表预处理器Sass的C版本）。它允许用户以令人难以置信的速度将.scss文件本地编译为css，并通过连接中间件自动编译。\n\n\n# url编码与解码\n\n网页URL只能使用英文、数字、还有一些特定的字符，若出现中文字符就必须经过编码解码，否则服务器无法识别\n\n编码方法有三种：\n\n方法                                             规则                                                          特点\nescape（编码） unescape                            除了ASCII字母、数字、标点符号"@ * _ + - . /"以外，对其他所有字符进行编码              不提倡\nencodeURI（编码） decodeURI（解码）                    除了常见的符号以外，对其他一些在网址中有特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码   encodeURI()是Javascript中真正用来对URL编码的函数，它着眼于对整个URL进行编码\nencodeURIComponent（编码） decodeURIComponent解码）   在encodeURI()中不被编码的符号"; / ? : @ & = + $ ,                    与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码\n                                               #"，在encodeURIComponent()中统统会被编码\n\nencodeURIComponent("http://www.test.com?a=哈哈")\n// "http%3A%2F%2Fwww.test.com%3Fa%3D%E5%93%88%E5%93%88"\n\nencodeURI("http://www.test.com?a=哈哈")\n// "http://www.test.com?a=%E5%93%88%E5%93%88"\n',normalizedContent:'# 面试题（八）\n\n * v-show 与 v-if 区别\n * 动态绑定class的方法\n * v-model是怎么实现的\n * sass与stylus的常见语法\n * 小程序的页面栈与生命周期\n * 看代码说输出\n * package.json和package-lock.json\n * npm nrm yarn\n * 什么是node-sass\n * 封装小程序分享参数,获取参数\n * url编码与解码\n\n\n# v-show 与 v-if 区别\n\n相同点：v-if与v-show都可以动态控制dom元素显示隐藏\n\n不同点：v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加display:none，dom元素还在。\n\nvisibility:hidden和display:none的区别\n\nvisibility:hidden; 可以隐藏某个元素，但是隐藏的元素仍要占据空间，仍要影响布局，会触发重绘\ndisplay:none; 不会占据空间，会触发回流\n\n\n\t<div id=\'app\'>\n        <div v-if=\'isif\'>我是v-if</div>\n        <div v-show=\'isshow\'>我是v-show</div>\n    </div>\n\n    <script src=\'vue.min.js\'><\/script>\n    <script>\n        let app = new vue({\n            el:\'#app\',\n            data:{\n                isif:true,\n                isshow:false\n            }\n        })\n    <\/script>\n\n\n**性能消耗：**v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n**使用场景：**v-if适合运营条件不大可能改变；v-show适合频繁切换。\n\n对于管理系统的权限列表的展示，这里可以使用v-if来渲染,对于前台页面的数据展示，这里推荐使用v-show\n\n\n# 动态绑定class的方法\n\n\n# （1）对象语法\n\n给v-bind:class 设置一个对象，可以动态地切换class，如下\n\n<div id="app">\n    <div :class="{\'active\':isactive}"></div>\n</div>\n\n<script>\n    var app = new vue({\n        el:\'#app\',\n        data:{\n            isactive:true\n        }\n    })\n<\/script>\n\n\n最终渲染结果为：<div class="active">\\</div>\n\nv-bind就是用于绑定数据和元素属性的\n\n<div class="app">\n    <a v-bind:href="url">click me</a>\n</div>  \n\n<script>\n    var app = new vue({\n        el:\'.app\',\n        data:{\n            url:"https://www.baidu.com",\n        }\n    });\n<\/script>\n\n\n当然对象中也可以传入多个属性\n\n<div id="app">\n    <div :class="{\'active\':isactive,\'error\':iserror}"></div>\n</div>\n\n\x3c!--当值均为true时--\x3e\n<div class="active error"></div>\n\n\n\n# （2）直接设置为对象\n\n<div :class="classobject"></div>\n\ndata: {\n  classobject: {\n    active: true,\n  }\n}\n\n\n\n# （3）数组方法\n\n<div :class="[activeclass, errorclass]"></div>\n\n data:{\n      activeclass: "active",\n      errorclass: "disactive"\n },\n\n渲染为\n<div class="active disactive"></div>\n\n\n\n# （4）三元运算符\n\n<div :class="[isactive?\'active\':\'disactive\']"></div>\n\n data:{\n      isactive: false,\n  },\n\n渲染为：\n<div class="disactive"></div>\n\n\n\n# （5）computed\n\n<div :class="classobject"></div>\n\n  data:{\n    isactive: true,\n  },\n  computed: {\n      classobject: {\n          active: this.isactive,\n\t  }\n  }\n\n\n\n# v-model\n\nv-model本质上是一个语法糖。（双向的）\n\n如下代码<input v-model="test">本质上是<input :value="test" @input="test = $event.target.value">\n\n:value="test"设置input初始值为text值，\n\n@input="test = $event.target.value,当输入的值改变时，test更新\n\n\n# sass与stylus的常见语法\n\nsass,stylus都是css预处理器，除了这两种之外还有less等。\n\n\n# sass与stylus的对比\n\n参考于这篇文章\n\n 1. 变量\n\nsass允许使用变量，所有的变量以$开头。\n\n$blue: #1875e7;\ndiv {\n   color: $blue\n }\n\n\nstylus也允许使用变量，变量名的$是可选的，变量值可以是表达式。\n\ncolor = blue 或者  $color = blue\ndiv\n    color: color\n\n\n 2. 计算属性\n\nsass允许在代码中使用算式:\n\nbody {\n    margin: (14px/2);\n    top: 50px + 100px;\n    right: $var * 10%;\n  }\n\n\nstylus同样也支持在代码中使用算式:\n\n body\n    margin: (14px/2)\n    top: 50px + 100px\n    right: var * 10%\n\n\n 3. 嵌套\n\nsass允许选择器嵌套。比如下面的css代码:\n\n  div h1 {\n    color: red\n  }\n  \n 可以写成：\n \n  div {\n    h1{\n      color: red\n   }\n }\n\n\nstylus同样支持选择器嵌套，上面的代码可以写成:\n\ndiv\n  h1\n    color: red\n\n\nsass也支持属性嵌套,比如border-color属性可以写成:\n\n p{\n     border: {\n       color: red;\n     }\n }\n \n border后面需要加上冒号\n\n\nstylus没有这个功能\n\n 4. 继承\n\nsass允许一个选择器，继承另一个选择器。比如，现在class1：\n\n.class1 {\n    border: 1px solid #ddd\n  }\n  \n  class2要继承class1，就要使用@extend命令。\n  \n  .class2 {\n    @extend .class1\n    font-size: 120%\n  }\n\n\nstylus的继承方式和sass基本一致，但有一些稍微的不同。\n\nstylus实现继承:\n\n.class1\n    border: 1px solid #ddd\n    \n .class2\n    @extend .class1\n    font-size: 120%\n\n\n两者的区别主要在于--sass不允许@extend嵌套选择器: 如下面的样式:\n\ndiv\n  h1\n   color: red\n\n\n在sass中，如果按照下面这样写就会直接编译错误。\n\n .div2 {\n    @extend div h1\n }\n\n\n而在stylus中却可以成功编译，因为stylus中，只要选择器匹配，继承就会生效。\n\n.div2\n   @extend div h1\n\n\n\n# 小程序的页面栈与生命周期\n\n\n# 小程序的页面栈\n\n路由方式                          页面栈\n初始化                           新页面入栈\n打开新页面（wx.navigateto）          新页面入栈\n页面重定向（wx.redirctto）           当前页面出栈，新页面入栈\n页面返回（wx.navigateback）         页面不断出栈，直到目标返回页，新页面入栈\ntab切换（wx.switchtab或底部tab切换）   页面全部出栈，只留下新的tab页面\n重启动（wx.relaunch）              页面全部出栈，只留下新的页面\n\n * navigateto, redirectto 只能打开非 tabbar 页面。\n * switchtab 只能打开 tabbar 页面。\n * relaunch 可以打开任意页面。\n * 页面底部的 tabbar 由页面决定，即只要是定义为 tabbar 的页面，底部都有 tabbar。\n * 调用页面路由带的参数可以在目标页面的onload中获取。\n\n\n# 小程序的生命周期\n\nonlaunch() {\n    console.log(\'onlaunch监听小程序初始化\');\n}\n\nonshow() {\n    console.log(\'onshow监听小程序显示\');\n}\n\nonhide() {\n    console.log(\'onlaunch监听小程序隐藏\');\n}\n\n\n\n# 页面的生命周期\n\nonload(options) {\n    console.log(\'onload监听页面加载\');\n}\n\nonready() {\n    console.log(\'onready监听页面初次渲染完成\');\n}\n\nonshow() {\n    console.log(\'onshow监听页面显示\');\n}\n\nonhide() {\n    console.log(\'onhide监听页面隐藏\');\n}\n\nonunload() {\n    console.log(\'onunload监听页面卸载\');\n}\n\n\n\n# window.length\n\nfunction foo(){\n    console.log(length)  //词法作用域，找foo函数外面定义的length，即window.length\n}\nfunction bar(){\n    var length = \'jin\'\n    foo()\n}\nbar()  //输出的为window.length即为iframe的个数\n\n\n\n# package.json和package-lock.json\n\nnpm描述模块信息的文件就是 package.json ，npm install会根据package.json安装依赖\n\n每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号。\n\n> 原来的 package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。\n\n当文件中存在package-lock.json时，执行npm install，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。\n\n\n# 版本号区分\n\n * ^16.8.0表示安装16.x.x的最新版本，安装时不改变大版本号。\n * ~16.8.0表示安装16.8.x的最新版本，安装时不改变大版本号和次要版本号。\n * 16.8.0 表示安装指定的版本号，也就是安装16.8.0版本。\n\n\n# npm nrm yarn\n\n * npm,nrm,yarn的关系\n\n> yarn 是 facebook 开源的一个新的包管理器， 和npm的作用是一样的，但是解决了一些npm的痛点。\n\n\n# 常用命令\n\nnpm                             yarn\nnpm init                        yarn init\nnpm install                     yarn install\nnpm install --no-package-lock   yarn install --no-package-lock\nnpm install xxx --save          yarn add xxx\nnpm install xxx --save-dev      yarn add xxx --dev\nnpm uninstall xxx --save        yarn remove xxx\nyarn add xx@version             npm install xx@vision\nyarn upgrade xx                 npm update xx\nyarn upgrade xx@version         npm update xx@vision\nyarn why xx                     -\nyarn config list                npm config list\n\n\n# npm中的 --save与--save-dev\n\n * i 是 install 的简写\n * -g 是全局安装，不带 -g 会安装在个人文件夹\n * -s 与 --save 的简写，安装包信息会写入 dependencies 中\n * -d 与 --save-dev 的简写，安装包写入 devdependencies 中\n * dependencies 生产阶段的依赖,也就是项目运行时的依赖\n * devdependencies 开发阶段的依赖，就是我们在开发过程中需要的依赖，只在开发阶段起作用的\n\n----------------------------------------\n\n比如写 es6 代码，需要 babel 转换成 es5 ，转换完成后，我们只需要转换后的代码，上线的时候，直接把转换后的代码部署到生产环境，不需要 bebal 了，生产环境不需要。这就可以安装到 devdependencies ，再比如说代码提示工具，也可以安装到 devdependencies 。\n\n如果你用了 element-ui，由于发布到生产后还是依赖 element-ui，这就可以安装到 dependencies 。\n\n\n# 什么是node-sass\n\n> node-sass是一个库，它将node.js绑定到libsass（流行样式表预处理器sass的c版本）。它允许用户以令人难以置信的速度将.scss文件本地编译为css，并通过连接中间件自动编译。\n\n\n# url编码与解码\n\n网页url只能使用英文、数字、还有一些特定的字符，若出现中文字符就必须经过编码解码，否则服务器无法识别\n\n编码方法有三种：\n\n方法                                             规则                                                          特点\nescape（编码） unescape                            除了ascii字母、数字、标点符号"@ * _ + - . /"以外，对其他所有字符进行编码              不提倡\nencodeuri（编码） decodeuri（解码）                    除了常见的符号以外，对其他一些在网址中有特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码   encodeuri()是javascript中真正用来对url编码的函数，它着眼于对整个url进行编码\nencodeuricomponent（编码） decodeuricomponent解码）   在encodeuri()中不被编码的符号"; / ? : @ & = + $ ,                    与encodeuri()的区别是，它用于对url的组成部分进行个别编码，而不用于对整个url进行编码\n                                               #"，在encodeuricomponent()中统统会被编码\n\nencodeuricomponent("http://www.test.com?a=哈哈")\n// "http%3a%2f%2fwww.test.com%3fa%3d%e5%93%88%e5%93%88"\n\nencodeuri("http://www.test.com?a=哈哈")\n// "http://www.test.com?a=%e5%93%88%e5%93%88"\n',charsets:{cjk:!0}},{title:"html基础",frontmatter:{},regularPath:"/interview/interview.html",relativePath:"interview/interview.md",key:"v-4cc5601f",path:"/interview/interview.html",headers:[{level:2,title:"html基础",slug:"html基础",normalizedTitle:"html基础",charIndex:2},{level:2,title:"JavaScript基础",slug:"javascript基础",normalizedTitle:"javascript基础",charIndex:158},{level:2,title:"CSS基础",slug:"css基础",normalizedTitle:"css基础",charIndex:4063},{level:2,title:"Vue相关",slug:"vue相关",normalizedTitle:"vue相关",charIndex:5059},{level:2,title:"浏览器相关",slug:"浏览器相关",normalizedTitle:"浏览器相关",charIndex:5865},{level:2,title:"网络与协议相关",slug:"网络与协议相关",normalizedTitle:"网络与协议相关",charIndex:9454},{level:2,title:"前端安全",slug:"前端安全",normalizedTitle:"前端安全",charIndex:13872},{level:2,title:"设计模式：简单介绍一下",slug:"设计模式-简单介绍一下",normalizedTitle:"设计模式：简单介绍一下",charIndex:15036},{level:2,title:"webpack",slug:"webpack",normalizedTitle:"webpack",charIndex:13653},{level:2,title:"git",slug:"git",normalizedTitle:"git",charIndex:15416},{level:2,title:"动画相关",slug:"动画相关",normalizedTitle:"动画相关",charIndex:15474},{level:2,title:"常用手写代码",slug:"常用手写代码",normalizedTitle:"常用手写代码",charIndex:17680},{level:2,title:"计算机基础",slug:"计算机基础",normalizedTitle:"计算机基础",charIndex:17893},{level:2,title:"项目",slug:"项目",normalizedTitle:"项目",charIndex:18331},{level:2,title:"权限管理",slug:"权限管理",normalizedTitle:"权限管理",charIndex:21932},{level:3,title:"RABC",slug:"rabc",normalizedTitle:"rabc",charIndex:21941},{level:3,title:"前端权限控制流程",slug:"前端权限控制流程",normalizedTitle:"前端权限控制流程",charIndex:22168},{level:2,title:"从0到1的B端平台项目",slug:"从0到1的b端平台项目",normalizedTitle:"从0到1的b端平台项目",charIndex:22776},{level:3,title:"技术选型",slug:"技术选型",normalizedTitle:"技术选型",charIndex:22792},{level:3,title:"架构设计",slug:"架构设计",normalizedTitle:"架构设计",charIndex:22912},{level:3,title:"工程化",slug:"工程化",normalizedTitle:"工程化",charIndex:20411},{level:3,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:5746}],lastUpdated:"9/2/2025, 11:24:35 AM",lastUpdatedTimestamp:1756783475e3,headersStr:"html基础 JavaScript基础 CSS基础 Vue相关 浏览器相关 网络与协议相关 前端安全 设计模式：简单介绍一下 webpack git 动画相关 常用手写代码 计算机基础 项目 权限管理 RABC 前端权限控制流程 从0到1的B端平台项目 技术选型 架构设计 工程化 性能优化",content:"# html基础\n\n * 常见行内元素：<span>、<a>、<b>、<strong>、<img>、<input>\n * 常见块元素：<p>、<h1>~<h6>、<ul>、<div>、<form>\n * 行内元素、块元素、行内块元素的区别；input 和 img 属于哪种？\n * html5常见语义化标签\n\n\n# JavaScript基础\n\n * 面向对象与基于对象\n   \n   * 面向对象的三个基本特征\n   * Js是基于对象但实现了面向对象编程(继承，函数重载)\n   * 如何实现继承（ES5六种，ES6的class）\n   * 原型与原型链\n   * Object与Function原型关系\n   * 如何实现函数重载（arguments）\n   * Object.create, 如何实现\n\n * 语言的强类型/弱类型，静态类型/动态类型\n\n * 为什么单线程？webworker\n\n * 数据类型（必考）\n   \n   * 5种基本 + 1种复杂 + 2种新增\n   * null和undefined区别\n     * null是不应该有值，如原型链终点\n     * undefined是缺少值，如变量声明未赋值\n   * Symbol：定义对象的唯一属性名\n   * BigInt解决的问题，从64位浮点数谈起\n   * 值类型 / 引用类型，堆 / 栈\n   * 如何定义一个常量对象Object.freeze\n\n * 进行类型判断的方式及优缺点\n   \n   * typeof（type of null， typeof NaN）\n   * instanceof（手写实现）\n   * Object.prototype.toString.call（为什么用call，内部属性[[Class]]）\n   * 判断数组的方法至少说出5种\n\n * 类型转换\n   \n   * 运算符带来的类型转换，-，*，、，%优先转数值，+ 除外\n   * +的规则，[] + {}，{} + []\n   * == 和 === 的区别\n   * 什么情况 a === a-1，Number.MAX_SAFE_INTEGER\n   * 什么情况 a == 1 && a == 2 && a == 3 为true\n\n * 作用域\n   \n   * 全局作用域\n   * 函数作用域\n   * 块级作用域\n   * 词法作用域\n   * 动态作用域\n\n * 作用域（链）与执行上下文（栈）的区别\n\n * this的指向，箭头函数与普通函数区别与new一个对象的过程\n\n * call / apply / bind\n\n * 闭包，高阶函数，vue中有什么应用\n\n * 深拷贝与浅拷贝\n   \n   * JSON.stringify中不安全的JSON值，参数\n   * JSON.parse(JSON.stringify)的问题\n   * 手写一个深拷贝方法\n\n * 函数与变量解析顺序（一般为看代码说结果）\n   \n   * 变量提升\n   * 函数声明优先级最高\n   * let / const 暂时性死区\n\n * ES6\n   \n   * let / const （块级作用域，不允许重复声明，暂时性死区）\n   * 箭头函数\n     * 没有构造函数，没有原型(prototype)\n     * 省略 return 关键字，隐式返回\n     * 继承当前上下文的 this 关键字\n     * 没有arguments属性，剩余运算符\n     * 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个箭头函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。\n     * 用处：箭头函数表达式对非方法函数是最合适的\n   * 扩展运算符（构造数组，解析数组，参数赋值）\n   * 剩余运算符（接收参数）\n   * Map, WeakMap, Set, WeakSet，如何理解weak\n     * WeakMap和WeakSet的键只能为对象\n     * 弱引用，GC算法，内存泄漏的场景（4种）\n     * 不可迭代，只支持部分方法\n   * 模板字符串\n   * 对象字面量的增强\n   * Object.assign / Object.is / Object.keys / Object.values / Object.entries\n\n * ES2016~ES2022\n   \n   * includes\n   \n   * 求幂运算符（**）\n   \n   * Object.values 与 Object.entries\n   \n   * Object.hasOwn()\n   \n   * String.prototype.padStart 与 Sting.prototype.padEnd\n   \n   * async/await\n   \n   * 异步迭代 for await...of\n   \n   * 顶层 await\n   \n   * Promise.prototype.finally\n   \n   * Promise.allSettled\n   \n   * Promise.any\n   \n   * flat 与 flatMap\n   \n   * 空值合并运算符\n   \n   * 可选链操作符\n   \n   * Dynamic import\n   \n   * BigInt\n   \n   * 数值分隔符\n   \n   * at() 方法\n   \n   * class 私有字段\n\n * 数组方法：forEach/find/map/filer/reduce/every/some\n\n * Array.from：如何初始化一个二维数组\n\n * promise\n\n * 手写promise.all和promise.race\n\n * promise.resolve四种参数\n\n * reject 和 catch 的区别\n   \n   * reject 是用来抛出异常，catch 是用来处理异常\n   * reject 是 Promise 的方法，而 catch 是 Promise 实例的方法\n   * reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch\n   * 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调\n\n * Generator\n\n * async / await （Generator + 自动执行器）\n   \n   * 更好的语义\n   \n   > async 和 await, 比起星号和yield，语义更加清楚，async表示函数里面有异步操作，await表示紧跟在后面的表达式需要等待结果。\n   \n   * 更广的适用性\n   \n   > co模块约定，yield命令后面只能是Thunk函数或者Promise对象， 而async函数的await后面，可以是Promise和原始类型值(数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象, 查看spawn函数中Promise.resolve(next.value))\n   \n   * 返回值是Promise\n   \n   > 比Generator函数的返回值是Iterator对象方便，可以使用then方法指定下一步操作\n\n * 宏任务/微任务/事件循环\n   \n   * 浏览器与node事件循环区别（libuv，c语言）\n\n * 微任务有哪些，MutationObserver是什么\n   \n   * 面试题看代码说结果\n\n * for in 与 for of\n   \n   * for in（字符串）/ Object.keys / Object.getOwnPropertyNames 区别\n   * 性能 for...i > forEach > for...of > map > for...in\n   * for in 为什么效率低，这是因为 for...in 有一些特殊的要求，包括：\n     * 遍历所有属性，不仅是 own properties 也包括原型链上的所有属性。\n     * 忽略 enumerable 为 false 的属性。\n     * 必须按特定顺序遍历，先遍历所有数字键，然后按照创建属性的顺序遍历剩下的。\n\n * for of ，迭代器，Generator\n\n * 事件冒泡 / 事件捕获 / 事件委托\n   \n   * DOM 事件流\n   * target 和 currentTarget 的区别\n     * target获取是触发事件的源对象\n     * currentTarget获取的事件绑定的对象\n\n * 函数式编程\n   \n   * 高阶函数\n   * 纯函数 / 记忆函数\n   * 函数柯里化 / 函数组合\n   * 尾递归 / 尾调用\n   * 常见数组方法，哪些是高阶函数，哪些会改变数组本身\n     * push,pop,splice,unshift,shift,reverse\n     * slice,concat,forEach,map,filter,some,every\n     * ['1', '2', '3'].map(parseInt)的结果\n\n * setTimeout误差\n\n * babel\n   \n   * 为什么使用babel\n\n * babel原理（词法分析生成tokens流，语法分析转换成AST，AST节点遍历进行添加更新移除，生成ES5字符串）\n   \n   * babel怎么处理ESM模块化（编译成CommonJS风格）\n\n\n# CSS基础\n\n * 盒模型\n\n * 居中一个元素的方法\n   \n   * 水平2种，垂直3种，垂直水平5种\n   * 单行文本水平垂直居中（text-align + line-height），多行文本水平垂直居中（table-cell）\n\n * BFC布局规则，如何创建BFC\n\n * Grid 网格布局，实现一个宽度1：2：3的网格布局\n\n * 两栏布局（右侧自适应）\n   \n   * 浮动，触发BFC\n   * flex布局，左侧固定宽度，右侧flex: 1\n   * 左侧浮动，右侧设置左边距\n\n * 三栏布局（中间自适应）\n   \n   * 左右侧浮动，中间设置左右边距，左右高度400，中间高度300，body高度？如何清除浮动？\n   * 左右侧绝对定位，中间设置左右边距\n   * 中间 flex: 1\n   * grid 布局，grid-template-columns: 200px auto 200px;\n   * 圣杯布局与双飞翼布局，margin-left: -100%;相对于父元素宽度的百分比\n\n * Flex 布局，三个值的含义\n\n * margin写两个值，三个值，四个值\n\n * css选择器的优先级规则\n\n * 脱离文档流 / 定位 / 浮动的区别\n\n * 清除浮动的方法\n\n * link 与 @import 的区别\n\n * js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？css会阻塞js吗\n\n * DOMContentLoaded 和 window.onload 区别\n\n * 画一个三角形 / 扇形\n\n * 隐藏一个元素的方法\n\n * 逻辑像素与物理像素\n\n * DPR\n\n * em / rem / rpx / vw / vh\n\n * rpx如何计算的，iphone6上750rpx = 375px（逻辑像素）iphone5上750rpx = 320px（逻辑像素）\n\n * 移动端 1px 问题\n\n * display / position / transform有哪些属性\n\n * 如何实现图片懒加载\n   \n   * 监听事件在哪个阶段写？（mounted，真实DOM挂载完毕，beforeDestroy销毁）\n\n * 伪类和伪元素\n\n * css硬件加速\n\n * 哪些css属性会触发回流与重绘\n\n\n# Vue相关\n\n * Vue 响应式原理 2.x\n   * 发布订阅模式（手写）\n   * 观察者模式（手写）\n   * Vue 实例初始化过程\n   * 组件渲染过程（3种Watcher）\n   * 响应式过程总结\n   * computed和watcher的原理，有什么区别及应用场景\n * Vue 响应式原理 3.0\n   * Composition API\n   * 函数式编程\n   * 性能提升\n     * proxy 对比一下 Object.defineProperty\n     * 编译优化：Fragments，静态提升，Patch flag\n     * 源码体积优化\n   * reactive / ref / toRefs 区别\n   * effect / track / trigger 功能\n * Vue 组件通信的方式（8种）\n * Vuex\n   * State\n   * Getters\n   * Mutations\n   * Actions\n   * Modules\n * Vue 中的 key的作用\n   * 什么是虚拟 DOM\n   * Diff算法的过程（patch / patchVnode / updateChildren）\n * nextTick的原理\n * data为什么是函数，可以换成箭头函数吗（this指向问题，应该指向vm实例）\n * Keep-alive的原理\n   * LRU算法（FIFO / OPT）\n   * 聊到操作系统顺便说一下进程与线程的区别\n   * 进程间通信的方式\n * 你做过哪些 Vue 的性能优化\n * MVVM\n * Vue渲染流程\n * Vue生命周期\n * Mounted和created你怎么区分和使用（字节）\n * 父子组件的生命周期触发顺序\n * 如何理解插槽slot\n * Vue css scoped\n\n\n# 浏览器相关\n\n * 输入 URL 到页面展现的过程\n   \n   * 刚输入时，浏览器会从历史记录、书签或缓存中查找地址，找到了，会从缓存中调出页面显示出来\n   \n   * 域名解析ip地址（浏览器缓存 => 操作系统缓存 => 本地dns服务器 => 根域名服务器 => 顶级域名服务器 => 二级域名服务器)，迭代查询与递归查询的区别（如果引入了CDN，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器，CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。CDN全局负载均衡设备会选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。）\n   \n   * TCP三次握手\n   \n   * TCP安全连接上发送 HTTP 请求\n     \n     * 常见请求头字段：connection，cookie，host，referer，origin，content-type\n   \n   * 服务器处理请求并返回 HTTP 响应\n   \n   *       类别                       原因短语\n     1XX   Informational（信息性状态码）    接收的请求正在处理\n     2XX   Success（成功状态码）           请求正常处理完毕\n     3XX   Redirection（重定向状态码）      需要进行附加操作以完成请求\n     4XX   Client Error（客户端错误状态码）   服务器无法处理请求\n     5XX   Server Error（服务器错误状态码）   服务器处理请求出错\n     \n     1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。\n     \n     100 Continue\n     103 Early Hints 用于在最终响应之前发送一个初步的 HTTP 响应，提升页面渲染性能。\n     \n     \n     HTTP 新增的 103 状态码，这次终于派上用场了！\n     \n     2xx：成功状态码，表示服务器已成功接收到请求并进行处理。\n     \n     200 OK 表示客户端请求成功\n     204 No Content 请求处理成功，但没有资源可返回，浏览器页面不会发生更新，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。\n     206 Partial Content 表示客户端进行了范围请求，而服务器执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n     \n     \n     3xx：重定向状态码，表示服务器要求客户端重定向。\n     \n     301和302对SEO的影响\n     \n     301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL\n     302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源\n     303 See Other 请求的资源存在着另一个URI，客户端应使用 GET 方法定向获取请求的资源\n     304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存\n     \n     301和302有什么区别？\n     \n     详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。\n     \n     307 Temporary Redirect（临时重定向），尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。\n     308 Permanent Redirect （永久重定向）\n     \n     307和308的出现也是给上面的行为做个规范，不过是不允许重定向时改变请求方法\n     \n     302 在最初的定义中，内容和现在的 307 是一样的，不允许重定向方法的改写。但是早期浏览器在实现的时候有的实现成 303（GET） 的效果，有的实现成 307（POST） 的效果。简单说下就是 http 1.0里面302具有二义性，在http 1.1中加入303和307就是为了消除二义性。\n     \n     \n     4xx：客户端错误状态码，表示客户端的请求有非法内容。\n     \n     400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解\n     401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用\n     403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因\n     404 Not Found 请求的资源不存在，例如，输入了错误的URL\n     \n     \n     5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。\n     \n     500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求\n     503 Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n     \n\n * 常见响应头字段：Set-cookie，Cache-Control，E-Tag，Last-Modified，Access-Control-Allow-Origin\n   \n   * TCP 四次挥手，为什么要等 2MSL\n\n * 浏览器解析渲染\n   \n   * GC算法\n     \n     * 标记清除 / 引用计数 / 标记整理\n     * 内存泄漏 / 内存溢出\n     * 新生代 / 老生代\n   \n   * 介绍下浏览器多进程架构，网站隔离技术\n   \n   * 渲染过程\n     \n     * 三个线程（Compositor Thread / Main Thread / Compositor Tile Worker(s)）\n     * js 会阻塞 DOM 解析\n     * css 不会阻塞 DOM 解析会阻塞渲染\n     * script标签中的async / defer\n     * DOMContentloaded和onload的区别（1是在DOM树解析完毕，2是页面完全加载完）\n   \n   * 浏览器缓存\n     \n     * 前端缓存（HTTP缓存 / 浏览器缓存）\n     * 缓存存储在哪里？\n     * 强缓存 / 协商缓存，优先级？\n     * expires（http1.0 已过时，缺点要求时间严格同步）\n     * Cache-Control （http1.1 / max-age / no-cache / no-store / public / private / s-maxage）\n     * Max-age = 0 会怎样\n     * ETag / Last-Modified，E-Tag对服务端有什么影响（性能，计算hash，如何计算 last-modify + content-length）\n     * hash、chunkhash、contenthash\n     * localStorage / sessionStorage / cookie\n   \n   * 除了css,js资源，那html文件会缓存吗\n   \n   * 标签页如何通信\n   \n   * Cookie + serInterval\n     \n     * localStorage\n   \n   * webworker\n   \n   * Websocket\n   \n   * 预检请求\n   \n   * 浏览器最大并发请求资源数\n\n\n# 网络与协议相关\n\n * 什么是ajax（手写）\n\n * 跨域的原因以及解决方式\n   \n   * jsonp\n     * JSONP请求首先是为了解决跨域问题而存在的一种民间解决方案\n     * 通过标签的形式发请求\n     * 需要和后端同学进行约束\n     * 只能使用get请求\n   * CORS\n   * iframe的几种方式\n   * postMessage（window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源）\n   * Iframe + document.domain（用于二级域名相同的情况下，比如 a.test.com 和 b.test.com ）\n   * iframe + window.name\n   * Iframe + location.hash\n   * nginx反向代理\n   * websocket\n   * web-dev-server中的proxy\n   \n   浏览器的同源策略的目的就是为了防止 XSS，CSRF 等恶意攻击。\n   \n   跨域限制的资源:\n   1.数据存储限制：Cookie, LocalStorage, IndexDB 无法读取\n   2.脚本 API 限制：DOM 无法操作\n   3.网络请求限制：XHR 请求无法接收响应\n   \n   发生跨域时，允许进行的操作:\n   1.通常允许跨域写操作（link、redirect、表单提交）\n   2.通常允许跨域资源嵌入（script、img、video...）\n   3.通常禁止跨域读操作(ajax)\n   4.可以正常发送请求，可以携带Cookie(withCredentials)，但是浏览器会限制来自于不同域的资源的接收\n   \n\n * http 和 https\n   \n   * http 0.9 / 1.0 / 1.1 / 2.0\n     \n     * http0.9\n       * 只支持 get\n       * 没有请求头概念，响应后只能返回 html\n     * http1.0\n       * 请求方式新增了post，head等方式\n       * 增添了请求头和响应头的概念\n       * 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输\n       * 问题：每请求一次都要建立一次连接\n     * http1.1\n       * 长连接：新增Connection字段，可以设置keep-alive值保持连接不断开\n       * 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，比较鸡肋，仍然会阻塞。\n     * 缓存处理：新增字段cache-control，新增状态码303，307\n       * 问题：基于文件串行传输，队头阻塞（后一请求需要等前一请求返回），最大并发数限制\n   \n   * http2.0\n     \n     * 二进制分帧\n     * 首部压缩\n     * 多路复用\n   \n   * TCP队头阻塞\n     \n     * http2通过分帧避免了请求时的队首阻塞问题，但TCP层面的阻塞是HTTP2无法解决的。因为TCP是可靠的传输，一旦丢包就要重新发包，阻塞后续，虽然有滑动窗口，但也没有彻底解决\n   \n   * 怎么减少 http 请求\n     \n     * 雪碧图\n     * 合并 js 和 css（构建工具完成）\n     * 利用浏览器缓存\n\n * 长连接与多路复用\n\n * SSL/TLS，对称加密 / 非对称加密\n\n * https主要流程，证书的作用\n\n * 中间人攻击\n   \n   1)客户端发送请求到服务端，请求被中间人截获。\n   \n   2)服务器向客户端发送公钥。\n   \n   3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端。\n   \n   4)客户端收到伪造的公钥后，生成密文发给服务器。\n   \n   5)中间人获得密文，用自己的私钥解密。同时用真正的公钥发给服务器。\n   \n   6)服务器获得加密信息，用自己的私钥解密。\n   \n\n * http请求方法\n\n * Content-type有哪些\n\n * 简单请求和复杂请求\n   \n   * 只要同时满足以下两大条件，就属于简单请求\n     \n     条件1：使用下列方法之一：GET，HEAD，POST\n     \n     条件2：Content-Type 的值仅限于下列三者之一：\n     \n     * text/plain\n       * multipart/form-data\n       * application/x-www-form-urlencoded\n\n * TCP 三次握手 / 四次挥手\n   \n   * SYN (synchronous建立联机)\n   * ACK (acknowledgement 确认)\n   * FIN (finish结束)\n\n * Sequence number (顺序号码)\n\n * TCP 与 UDP 的区别于应用场景\n   \n   * osi七层模型与 tcp/ip 五层模型\n   \n   * cookie，session，token，JWT\n     \n     * cookie带来的安全性问题及如何防御\n     \n     * cookie的属性\n       \n       * expire属性（指定浏览器可发送 Cookie 的有效期）\n       * domain属性（指定 cookie 可以送达的主机名，在set-cookie中设置）\n       * secure 属性（属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie）\n       * HttpOnly 属性（ Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie）\n     \n     * cookie如何被携带\n       \n       * 同域请求下，ajax会自动带上同源的cookie；\n       * 跨域请求下，ajax不会自动携带同源的cookie，需要通过前端配置相应参数才可以跨域携带同源cookie， withCredentials: true\n       * ajax请求任何时候都不会带上不同源的cookie\n     \n     * Session流程：\n       \n       * 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session，保存相关数据，比如用户角色、登录时间等等。\n       * 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器\n       * 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名\n       * 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n     \n     * 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n       \n       * sessionID是怎么生成的？(Tomcat的sessionid的生成主要是随机数，依赖的类是java.security.SecureRandom)\n     \n     * Token: 令牌**，**访问资源接口（API）时所需要的资源凭证。token是服务端生成的一串字符串,以作客户端进行请求的令牌,当第一次登陆后,服务器生成一个token便将此token返回给客户端,以后客户端只要带上这个token前来请求数据即可,无需再次带上用户名和密码。**Token **使服务端无状态化，不会存储会话信息。相比于Session的优点是，即使有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。最常见的生成方式是JWT：JSON Web Token 入门教程。\n       \n       放在哪？可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。\n       \n       > Authorization: Bearer <token>\n       \n       另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。\n\n * CDN是什么（内容分发网络）\n   \n   * 将源站内容分发至最接近用户的节点，使用户就近取得所需内容。解决了因分布，带宽，服务器性能带来的访问延迟问题。CDN负载均衡系统负责告诉用户缓存服务器的ip地址\n\n * 前端模块化\n   \n   * 文件划分 / 命名空间 / IIFE / CommonJS / AMD / CMD\n   * ESModules\n   * ESM与CommonJS的区别\n     * CommonJS模块输出拷贝，ES6 模块输出引用\n     * CommonJS 模块是运行时加载，ES6 模块是编译时加载，之所以webpack的tree-shaking只能作用于ES6模块，就是因为ES6模块在编译时就能确定依赖。\n     * CommonJS是require()同步加载模块，ES6模块是import命令是异步加载，有一个独立的模块依赖的解析阶段\n     * CommonJS第一次加载模块就会执行整个模块生成一个对象, 再次用到时到缓存中读取，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值\n     * 循环引用的处理\n\n\n# 前端安全\n\n * XSS（反射型 / 存储型 / DOM型）\n   \n   * httpOnly\n   * 纯前端渲染\n   * HTML转义\n   * CSP\n   * X-Xss-Protection\n\n * CSRF（第三方网站如何拿到cookie，script、image、iframe的src都不受同源策略的影响。所以我们可以借助这一特点，实现跨域）\n   \n   * origin（一般只存在于CORS跨域请求中，为什么要跨域， 同源策略怎么防止csrf攻击）\n     \n     在以下情况不存在此请求头：\n     \n     302 重定向： \n     1. 在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。\n     2.对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上。\n     \n     Origin 和 Referer 存在相同的问题，同样有可能丢失该字段。\n     \n   \n   * referer（协议+域名+查询参数）\n     \n     针对通过 Referer 字段去判断请求来源是否合法是不太靠谱的，这个字段很有可能会丢失：\n     \n     1.IE6、7下使用 window.location.href=url 进行界面的跳转或者 window.open，都会造成 Referer 丢失。\n     \n     2.HTTPS 页面跳转到 HTTP 页面，所有浏览器 Referer 都丢失。\n     \n     3.点击 Flash 上到达另外一个网站的时候，Referer 的情况就比较杂乱，不太可信。\n     \n     可以附加使用于判断请求来源，但是仅通过该字段进行判断是不太靠谱的，如果请求头丢失该字段，则服务端无法判断当前请求来源，无法校验请求是否合法。\n     \n   \n   * Samesite Cookie\n   \n   * CSRF Token\n     \n     * 在请求头中将获取到的 token 设置到 cookie 中。\n     * 将 token 放到请求参数中。\n   \n   * 验证码\n\n * 点击劫持\n\n * 中间人攻击\n\n * HTTP传输安全\n\n * 第三方依赖安全\n\n * 控制台注入代码\n\n * 钓鱼\n\n * 前端路由\n   \n   * hash模式\n     * window.location.hash\n     * onhashchange\n   * history模式\n     * pushState / replaceState / popState\n\n\n# 设计模式：简单介绍一下\n\n * 工厂模式\n * 抽象工厂模式\n * 单例模式\n * 建造者模式\n * 适配器模式\n * 装饰器模式\n * 过滤器模式\n\n\n# webpack\n\n * webpack，grunt，gulp的区别\n * webpack，rollup，parcel分别适用于什么场景\n * webpack插件主要是做什么的，常用的有哪些\n * 自己写过webpack插件吗（compiler / compilation）\n * Webpack loader主要是做什么的，常用的有哪些\n * loader 和 plugin 的区别及用处\n * webpack 热更新原理\n * Sourcemap（cheap-module-eval-source-map）\n * Webpack-dev-server\n * webpack打包流程和生命周期\n\n\n# git\n\n * Git reset 和 git revert 的区别\n * Git rebase的两种用途\n\n\n# 动画相关\n\n * css动画\n   \n   * transition: 过渡，是一次性的，只能定义起始和结束状态。\n     \n     #box {\n       height: 100px;\n       width: 100px;\n       background: green;\n       transition: transform 1s ease-in 1s;\n     }\n     #box:hover {\n       transform: rotate(180deg) scale(.5, .5);\n     }\n     \n   \n   * animation：动画，往复性的，keyframes提供更多的控制，尤其是时间百分比的控制\n     \n     .box {\n       height: 100px;\n       width: 100px;\n       border: 15px solid black;\n       animation: changebox 1s ease-in-out 1s infinite alternate running forwards;\n     }\n     \n     @keyframes changebox {\n       10% {\n         background: red;\n       }\n       50% {\n         width: 80px;\n       }\n       70% {\n         border: 15px solid yellow;\n       }\n       100% {\n         width: 180px;\n         height: 180px;\n       }\n     }\n     \n\n * js动画\n   \n   * 定时器：会出现卡顿抖动，定时器实际执行实际较晚，不用设备屏幕刷新频率不同\n     \n     var offsetX = 500  //要水平移动的距离\n     var moveOffset = 0  //当前已经移动的距离\n     var step = 5   //每次移动的距离\n     \n     function move(){\n       if(moveOffset < offsetX){\n         ball.style.left = parseInt(getComputedStyle(ball).left) + step + 'px'\n         moveOffset += step\n         setTimeout(move, 5)\n       }\n     }\n     move()\n     \n   \n   * requestAnimationframe：由系统来决定回调函数的执行时机。保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n     \n     var offsetX = 500  //要水平移动的距离\n     var moveOffset = 0  //当前已经移动的距离\n     var step = 5   //每次移动的距离\n     \n     function move(){\n       if(moveOffset < offsetX){\n         ball.style.left = parseInt(getComputedStyle(ball).left) + step + 'px'\n         moveOffset += step\n         requestAnimationFrame(move)\n       }\n     }\n     move()\n     \n\n * 怎么实现回到顶部动画？\n   \n   function toTOp() {\n     let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n     let timer = setInterval(() => {\n       scrollTop -= 100;\n       window.scrollTo(0, scrollTop)\n       if (scrollTop <= 0) {\n         clearInterval(timer)\n       }\n     }, 10)\n   }\n   \n   function toTOp() {\n     let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n     if (scrollTop > 0) {\n       requestAnimationFrame(function() {\n         scrollTop -= 100;\n       \twindow.scrollTo(0, scrollTop)\n       })\n     }\n   }\n   \n\n\n# 常用手写代码\n\n * 防抖 / 节流\n * 柯里化\n * apply,bind,call\n * promise.all\n * promise.race\n * 发布订阅模式\n * 数组扁平化带参数\n * 数组去重 4 种\n * instanceof\n * new\n * 深拷贝\n * ajax请求\n * 快排 / 冒泡 / 堆排序\n * 手写 map / reduce\n * 并发请求控制\n * 实现一个sleep函数\n\n\n# 计算机基础\n\n * 32位和64位的区别？\n   \n   > 寻址空间分别为2^32 = 4G和2^64，寻址空间一般指的是CPU对于内存寻址的能力。通俗地讲，就是最多能用到多少内存的一个问题。\n\n * cpu如何访问内存？\n   \n   > 首先 CPU 在访问内存的时候都需要通过 MMU（内存管理单元） 把虚拟地址转化为物理地址，然后通过总线访问内存。MMU 开启后 CPU 看到的所有地址都是虚拟地址，CPU 把这个虚拟地址发给 MMU 后，MMU 会通过页表在页表里查出这个虚拟地址对应的物理地址是什么，从而去访问外面的 DDR（内存条）。\n\n * 什么是平衡二叉树和红黑树\n   \n   * 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n   * 红黑树是一个自平衡(不是绝对的平衡)的二叉查找树\n   * 红黑树相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于AVL树。\n\n\n# 项目\n\n * 小程序\n   \n   * 长列表优化：为什么要做优化？1.小程序双线程 2. 框架缺陷\n   \n   * 小程序双线程原理\n   \n   * 小程序的双线程设计，主要为了管控安全，避免操作 DOM。逻辑线程是一个只能够运行JavaScript的沙箱环境，不提供DOM操作相关的API，所以不能直接操作UI，只能够通过setData更新数据的方式异步更新UI。\n     \n   \n   * setData工作原理\n     \n     小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。\n     \n     而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的setData函数将数据从逻辑层发送到视图层，是异步的。\n     \n     \n     var initData = {\n         info: {\n             name: 'hh'\n         }\n     };\n     \n     Page({\n         data: initData,\n         onClick() {\n             this.setData({\n                 'info.name': 'xx'\n             }, () => {\n                 console.log(initData.info.name) // hh\n             })\n         }\n     })\n     // 1. page初始化的时候data是深拷贝生成的，所以不会改变原来initData的值\n     // 2. 如果改变了initData的值，页面的初始值就会被改变了，navigateTo/redicetTo页面数据不一样\n     \n   \n   * 项目优化\n   \n   * mpvue原理\n     \n     * mpvue 保留了 vue.runtime 核心方法，无缝继承了 Vue.js 的基础能力\n     * mpvue-template-compiler 提供了将 vue 的模板语法转换到小程序的 wxml 语法的能力\n     * 修改了 vue 的建构配置，使之构建出符合小程序项目结构的代码格式： json/wxml/wxss/js 文件\n   \n   * 小程序框架对比：基于微信自定义组件实现组件开发的框架（uni-app/taro/chameleon），组件数据通讯性能接近于微信原生框架，远高于基于template实现组件开发的框架（wepy/mpvue）性能\n   \n   * 小程序为双线程模型，逻辑层和视图层，通过 Native 层通信。不像在 web 上 js 和 ui 会互斥，小程序中会限制 js 操作 dom，所以不用担心不同步问题。\n   \n   * 逻辑层和视图层通过 setData 进行通信，会把数据转换成字符串并拼接一段 js 脚本（evaluateJavascript）传到视图层，这个过程是异步的。\n   \n   * 如果每次 setData 的数据量过大，会非常损耗性能，最好是增量更新。uni-app、taro 都在调用setData之前自动做diff计算，每次仅传递变动的数据。\n   \n   * 而且基于微信自定义组件实现组件开发的框架（uni-app/taro），组件数据通讯性能接近于微信原生框架，远高于基于template实现组件开发的框架（wepy/mpvue）性能。\n   \n   * 跨端能力，uni-app 比较优秀，同时支持H5、多家小程序、跨平台App，但是一套代码横跨 iOS Android Web 和小程序比较复杂，可能会存在大量兼容性问题。\n\n * el-select的使用，vue自定义指令\n\n * Mixin\n\n * 其它\n   \n   * 自我介绍\n   * 为什么选择前端，如何学习，为什么选择这种学习方式？\n   * 对前端发展的看法？\n     * 早些时候，由于时代的问题，当时的web前端仅仅是展示一些简单的文本、图片，页面较为简单\n     * 前后端分离，MVVM框架(Vue, React, Angular等)的出现，使得前端更加应用化，性能更高。\n     * V8引擎和node的出现，促使前端能用自己熟悉的语法编写后台系统。\n     * 前端工程化的提出，提高了前端的开发效率，增强了可维护性\n     * 数据可视化百家争鸣，基于svg，canvas，webGL开发的可视化，3D动画已被广泛的应用到网站中。\n     * 大前端时代：随着智能手机的普及，如今Android端、iOS端等各种移动端的应用也越来越普及，单一面向于PC端的web应用，也向着移动端发展。类似各种手机app，小程序的诞生，使得人们的生活越来越便利，让人不禁遐想，将来的前端是否能应用到全端，即一套代码能通用多种平台。\n   * 最近在学什么？\n   * 项目中你印象最深的地方，有什么难点，怎么解决的？\n   * 技能和性格有什么缺陷？\n   * 平时看什么书？\n   * 优点？缺点？\n   * 说说对我们公司的了解？\n   * 职业规划？\n   * 反问\n     * 对我的评价？建议？\n     * 部门的业务情况？\n     * 团队架构？\n\n * santd\n   \n   * upload：底层实现还是基于input输入框（type=file），然后利用onchange事件，监听文件选择的事件，然后利用formData对象装载需要上传的文件，最后通过XMLHttpRequest来进行文件的网络异步传输。通过xhr.upload 的onprogress 事件的监听，可以正确的获取到上传文件的total值和loaded的值，从而实时的计算出当前上传的进度。\n   * tab：key、active_key\n   * table：通过 slot 让用户可以自定义 column title 并支持获取 column 信息\n\n * eslint-plugin-san\n   \n   * eslint-plugin-san 是 eslint 的一个插件，类似于 eslint-plugin-vue，内部配置了一系列针对性的规则\n   * eslint执行原理：使用解析器 espree 将代码解析成 AST，进行词法分析以及语法分析；通过 DFS 来遍历 AST；在遍历的过程中 eslint 通过选择器来匹配 AST 上的节点，通过代码路径分析来控制代码检测的范围。每个 rule 都定义了 create 方法，会返回一个 vistor（即访问到某些节点时做出的操作），eslint 会收集配置文件中所有规则的 vistor，遍历 AST 并调用 vistor，得到检测结果。规则内还可以定义 fix 方法，在报错的时候可以进行修正。\n   * no-empty-attributes: 默认检测 class 和 style 属性不能为空，可以通过 options 配置其他不允许为空的属性。\n   * data-name-casing：dataTypes, initData, computed 中的数据在多个单词的情况下使用 \"下划线\"、\"短横线\"、\"帕斯卡\"命名规则会报错，提示统一使用驼峰式命名法。\n   * boolean-value：强制布尔属性。<div attr></div>\n\n * san-loader:\n   \n   * SanLoaderPlugin 在 webpack 正式构建之前修改原有的配置 rules。\n   * webpack 从入口文件出发, 遇到.san文件，第一次调用 san-loader 来处理 san 单文件, 这个过程会调用 san-sfc-compiler 的 parseSFC 方法来解析文件内容生成 import 语句，对于每一条 import 语句再遍历 rules 进行规则匹配。最后提取代码块交给对应 loader 处理\n\n\n# 权限管理\n\n\n# RABC\n\n基于角色的访问控制（Role-Based Access Control，简称 RBAC），指的是通过用户的角色（Role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。\n\n * 用户（User）：系统实际使用者（如员工、管理员）\n * 角色（Role）：职级或职能的抽象集合（如「财务专员」「部门主管」）\n * 权限（Permission）：对系统资源的操作许可（如「查看报表」「导出数据」）\n\n\n# 前端权限控制流程\n\n 1. 用户登录与权限初始化 用户登录后，后端返回角色标识（如roles: [\"finance_staff\"]）和权限清单（如permissions: [\"invoice:view\", \"budget:edit\"]）前端将权限数据存入状态管理工具（如Vuex/Pinia），为后续控制提供依据\n 2. 动态路由生成\n\n * 路由分级配置：\n   * 基础路由（公共页面：登录页、404）\n   * 动态路由（需权限控制：仪表盘、订单管理）\n   * 每个动态路由配置meta.permissions字段标记所需权限（如{ path: \"/pay\", meta: { permissions: [\"payment:access\"] } }）\n * 路由过滤逻辑：根据用户权限清单过滤动态路由，仅保留用户有权访问的路由配置，通过router.addRoute()动态挂载\n\n 3. 前置守卫校验\n\n * 全局路由守卫：在vue-router的beforeEach钩子中，对每次路由跳转进行三重校验：\n   * 是否已登录（未登录跳转至登录页）\n   * 是否已获取权限（防止页面刷新后权限丢失）\n   * 目标路由是否在用户权限范围内（无权限跳转至403页）\n * 嵌套路由处理：对父级路由设置alwaysShow: true，确保即使子路由无权限，父级菜单仍可展示（但子菜单项置灰或隐藏）\n\n\n# 从0到1的B端平台项目\n\n\n# 技术选型\n\n 1. 框架选择：优先成熟框架（React/Vue）\n 2. 语言与工具：TypeScript减少运行时错误，结合Vite提升构建效率。\n 3. UI框架：Ant Design（React）/ Element（Vue）\n\n\n# 架构设计\n\n 1. 模块化与组件化：微前端（独立部署、技术栈解耦）/ 模块化（高内聚、低耦合，复用）\n 2. 状态管理：vuex / redux\n 3. 路由设计：权限控制（RBAC）/ 动态路由（根据用户角色加载）\n\n\n# 工程化\n\n 1. 代码规范：ESLint + Stylelint + Prettier\n 2. 测试策略：单元测试 / e2e测试\n 3. 监控与日志：性能监控（sentry捕获错误） / 日志管理\n 4. 集成部署：CI/CD\n\n\n# 性能优化\n\n 1. 加载优化：懒加载 / 资源压缩\n 2. 渲染优化：避免重排 / 虚拟列表\n 3. 构建优化：Tree shaking / 智能分包",normalizedContent:"# html基础\n\n * 常见行内元素：<span>、<a>、<b>、<strong>、<img>、<input>\n * 常见块元素：<p>、<h1>~<h6>、<ul>、<div>、<form>\n * 行内元素、块元素、行内块元素的区别；input 和 img 属于哪种？\n * html5常见语义化标签\n\n\n# javascript基础\n\n * 面向对象与基于对象\n   \n   * 面向对象的三个基本特征\n   * js是基于对象但实现了面向对象编程(继承，函数重载)\n   * 如何实现继承（es5六种，es6的class）\n   * 原型与原型链\n   * object与function原型关系\n   * 如何实现函数重载（arguments）\n   * object.create, 如何实现\n\n * 语言的强类型/弱类型，静态类型/动态类型\n\n * 为什么单线程？webworker\n\n * 数据类型（必考）\n   \n   * 5种基本 + 1种复杂 + 2种新增\n   * null和undefined区别\n     * null是不应该有值，如原型链终点\n     * undefined是缺少值，如变量声明未赋值\n   * symbol：定义对象的唯一属性名\n   * bigint解决的问题，从64位浮点数谈起\n   * 值类型 / 引用类型，堆 / 栈\n   * 如何定义一个常量对象object.freeze\n\n * 进行类型判断的方式及优缺点\n   \n   * typeof（type of null， typeof nan）\n   * instanceof（手写实现）\n   * object.prototype.tostring.call（为什么用call，内部属性[[class]]）\n   * 判断数组的方法至少说出5种\n\n * 类型转换\n   \n   * 运算符带来的类型转换，-，*，、，%优先转数值，+ 除外\n   * +的规则，[] + {}，{} + []\n   * == 和 === 的区别\n   * 什么情况 a === a-1，number.max_safe_integer\n   * 什么情况 a == 1 && a == 2 && a == 3 为true\n\n * 作用域\n   \n   * 全局作用域\n   * 函数作用域\n   * 块级作用域\n   * 词法作用域\n   * 动态作用域\n\n * 作用域（链）与执行上下文（栈）的区别\n\n * this的指向，箭头函数与普通函数区别与new一个对象的过程\n\n * call / apply / bind\n\n * 闭包，高阶函数，vue中有什么应用\n\n * 深拷贝与浅拷贝\n   \n   * json.stringify中不安全的json值，参数\n   * json.parse(json.stringify)的问题\n   * 手写一个深拷贝方法\n\n * 函数与变量解析顺序（一般为看代码说结果）\n   \n   * 变量提升\n   * 函数声明优先级最高\n   * let / const 暂时性死区\n\n * es6\n   \n   * let / const （块级作用域，不允许重复声明，暂时性死区）\n   * 箭头函数\n     * 没有构造函数，没有原型(prototype)\n     * 省略 return 关键字，隐式返回\n     * 继承当前上下文的 this 关键字\n     * 没有arguments属性，剩余运算符\n     * 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个箭头函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。\n     * 用处：箭头函数表达式对非方法函数是最合适的\n   * 扩展运算符（构造数组，解析数组，参数赋值）\n   * 剩余运算符（接收参数）\n   * map, weakmap, set, weakset，如何理解weak\n     * weakmap和weakset的键只能为对象\n     * 弱引用，gc算法，内存泄漏的场景（4种）\n     * 不可迭代，只支持部分方法\n   * 模板字符串\n   * 对象字面量的增强\n   * object.assign / object.is / object.keys / object.values / object.entries\n\n * es2016~es2022\n   \n   * includes\n   \n   * 求幂运算符（**）\n   \n   * object.values 与 object.entries\n   \n   * object.hasown()\n   \n   * string.prototype.padstart 与 sting.prototype.padend\n   \n   * async/await\n   \n   * 异步迭代 for await...of\n   \n   * 顶层 await\n   \n   * promise.prototype.finally\n   \n   * promise.allsettled\n   \n   * promise.any\n   \n   * flat 与 flatmap\n   \n   * 空值合并运算符\n   \n   * 可选链操作符\n   \n   * dynamic import\n   \n   * bigint\n   \n   * 数值分隔符\n   \n   * at() 方法\n   \n   * class 私有字段\n\n * 数组方法：foreach/find/map/filer/reduce/every/some\n\n * array.from：如何初始化一个二维数组\n\n * promise\n\n * 手写promise.all和promise.race\n\n * promise.resolve四种参数\n\n * reject 和 catch 的区别\n   \n   * reject 是用来抛出异常，catch 是用来处理异常\n   * reject 是 promise 的方法，而 catch 是 promise 实例的方法\n   * reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch\n   * 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调\n\n * generator\n\n * async / await （generator + 自动执行器）\n   \n   * 更好的语义\n   \n   > async 和 await, 比起星号和yield，语义更加清楚，async表示函数里面有异步操作，await表示紧跟在后面的表达式需要等待结果。\n   \n   * 更广的适用性\n   \n   > co模块约定，yield命令后面只能是thunk函数或者promise对象， 而async函数的await后面，可以是promise和原始类型值(数值、字符串和布尔值，但这时会自动转成立即 resolved 的 promise 对象, 查看spawn函数中promise.resolve(next.value))\n   \n   * 返回值是promise\n   \n   > 比generator函数的返回值是iterator对象方便，可以使用then方法指定下一步操作\n\n * 宏任务/微任务/事件循环\n   \n   * 浏览器与node事件循环区别（libuv，c语言）\n\n * 微任务有哪些，mutationobserver是什么\n   \n   * 面试题看代码说结果\n\n * for in 与 for of\n   \n   * for in（字符串）/ object.keys / object.getownpropertynames 区别\n   * 性能 for...i > foreach > for...of > map > for...in\n   * for in 为什么效率低，这是因为 for...in 有一些特殊的要求，包括：\n     * 遍历所有属性，不仅是 own properties 也包括原型链上的所有属性。\n     * 忽略 enumerable 为 false 的属性。\n     * 必须按特定顺序遍历，先遍历所有数字键，然后按照创建属性的顺序遍历剩下的。\n\n * for of ，迭代器，generator\n\n * 事件冒泡 / 事件捕获 / 事件委托\n   \n   * dom 事件流\n   * target 和 currenttarget 的区别\n     * target获取是触发事件的源对象\n     * currenttarget获取的事件绑定的对象\n\n * 函数式编程\n   \n   * 高阶函数\n   * 纯函数 / 记忆函数\n   * 函数柯里化 / 函数组合\n   * 尾递归 / 尾调用\n   * 常见数组方法，哪些是高阶函数，哪些会改变数组本身\n     * push,pop,splice,unshift,shift,reverse\n     * slice,concat,foreach,map,filter,some,every\n     * ['1', '2', '3'].map(parseint)的结果\n\n * settimeout误差\n\n * babel\n   \n   * 为什么使用babel\n\n * babel原理（词法分析生成tokens流，语法分析转换成ast，ast节点遍历进行添加更新移除，生成es5字符串）\n   \n   * babel怎么处理esm模块化（编译成commonjs风格）\n\n\n# css基础\n\n * 盒模型\n\n * 居中一个元素的方法\n   \n   * 水平2种，垂直3种，垂直水平5种\n   * 单行文本水平垂直居中（text-align + line-height），多行文本水平垂直居中（table-cell）\n\n * bfc布局规则，如何创建bfc\n\n * grid 网格布局，实现一个宽度1：2：3的网格布局\n\n * 两栏布局（右侧自适应）\n   \n   * 浮动，触发bfc\n   * flex布局，左侧固定宽度，右侧flex: 1\n   * 左侧浮动，右侧设置左边距\n\n * 三栏布局（中间自适应）\n   \n   * 左右侧浮动，中间设置左右边距，左右高度400，中间高度300，body高度？如何清除浮动？\n   * 左右侧绝对定位，中间设置左右边距\n   * 中间 flex: 1\n   * grid 布局，grid-template-columns: 200px auto 200px;\n   * 圣杯布局与双飞翼布局，margin-left: -100%;相对于父元素宽度的百分比\n\n * flex 布局，三个值的含义\n\n * margin写两个值，三个值，四个值\n\n * css选择器的优先级规则\n\n * 脱离文档流 / 定位 / 浮动的区别\n\n * 清除浮动的方法\n\n * link 与 @import 的区别\n\n * js执行会阻塞dom树的解析和渲染，那么css加载会阻塞dom树的解析和渲染吗？css会阻塞js吗\n\n * domcontentloaded 和 window.onload 区别\n\n * 画一个三角形 / 扇形\n\n * 隐藏一个元素的方法\n\n * 逻辑像素与物理像素\n\n * dpr\n\n * em / rem / rpx / vw / vh\n\n * rpx如何计算的，iphone6上750rpx = 375px（逻辑像素）iphone5上750rpx = 320px（逻辑像素）\n\n * 移动端 1px 问题\n\n * display / position / transform有哪些属性\n\n * 如何实现图片懒加载\n   \n   * 监听事件在哪个阶段写？（mounted，真实dom挂载完毕，beforedestroy销毁）\n\n * 伪类和伪元素\n\n * css硬件加速\n\n * 哪些css属性会触发回流与重绘\n\n\n# vue相关\n\n * vue 响应式原理 2.x\n   * 发布订阅模式（手写）\n   * 观察者模式（手写）\n   * vue 实例初始化过程\n   * 组件渲染过程（3种watcher）\n   * 响应式过程总结\n   * computed和watcher的原理，有什么区别及应用场景\n * vue 响应式原理 3.0\n   * composition api\n   * 函数式编程\n   * 性能提升\n     * proxy 对比一下 object.defineproperty\n     * 编译优化：fragments，静态提升，patch flag\n     * 源码体积优化\n   * reactive / ref / torefs 区别\n   * effect / track / trigger 功能\n * vue 组件通信的方式（8种）\n * vuex\n   * state\n   * getters\n   * mutations\n   * actions\n   * modules\n * vue 中的 key的作用\n   * 什么是虚拟 dom\n   * diff算法的过程（patch / patchvnode / updatechildren）\n * nexttick的原理\n * data为什么是函数，可以换成箭头函数吗（this指向问题，应该指向vm实例）\n * keep-alive的原理\n   * lru算法（fifo / opt）\n   * 聊到操作系统顺便说一下进程与线程的区别\n   * 进程间通信的方式\n * 你做过哪些 vue 的性能优化\n * mvvm\n * vue渲染流程\n * vue生命周期\n * mounted和created你怎么区分和使用（字节）\n * 父子组件的生命周期触发顺序\n * 如何理解插槽slot\n * vue css scoped\n\n\n# 浏览器相关\n\n * 输入 url 到页面展现的过程\n   \n   * 刚输入时，浏览器会从历史记录、书签或缓存中查找地址，找到了，会从缓存中调出页面显示出来\n   \n   * 域名解析ip地址（浏览器缓存 => 操作系统缓存 => 本地dns服务器 => 根域名服务器 => 顶级域名服务器 => 二级域名服务器)，迭代查询与递归查询的区别（如果引入了cdn，则本地dns系统会将域名的解析权交给cname指向的cdn专用dns服务器，cdn的dns服务器将cdn的全局负载均衡设备ip地址返回给用户。cdn全局负载均衡设备会选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。）\n   \n   * tcp三次握手\n   \n   * tcp安全连接上发送 http 请求\n     \n     * 常见请求头字段：connection，cookie，host，referer，origin，content-type\n   \n   * 服务器处理请求并返回 http 响应\n   \n   *       类别                       原因短语\n     1xx   informational（信息性状态码）    接收的请求正在处理\n     2xx   success（成功状态码）           请求正常处理完毕\n     3xx   redirection（重定向状态码）      需要进行附加操作以完成请求\n     4xx   client error（客户端错误状态码）   服务器无法处理请求\n     5xx   server error（服务器错误状态码）   服务器处理请求出错\n     \n     1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。\n     \n     100 continue\n     103 early hints 用于在最终响应之前发送一个初步的 http 响应，提升页面渲染性能。\n     \n     \n     http 新增的 103 状态码，这次终于派上用场了！\n     \n     2xx：成功状态码，表示服务器已成功接收到请求并进行处理。\n     \n     200 ok 表示客户端请求成功\n     204 no content 请求处理成功，但没有资源可返回，浏览器页面不会发生更新，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。\n     206 partial content 表示客户端进行了范围请求，而服务器执行了这部分的 get 请求。响应报文中包含由 content-range 指定范围的实体内容。\n     \n     \n     3xx：重定向状态码，表示服务器要求客户端重定向。\n     \n     301和302对seo的影响\n     \n     301 moved permanently 永久性重定向，响应报文的location首部应该有该资源的新url\n     302 found 临时性重定向，响应报文的location首部给出的url用来临时定位资源\n     303 see other 请求的资源存在着另一个uri，客户端应使用 get 方法定向获取请求的资源\n     304 not modified 服务器内容没有更新，可以直接读取浏览器缓存\n     \n     301和302有什么区别？\n     \n     详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的url地址，这个地址可以从响应的location首部中获取（用户看到的效果就是他输入的地址a瞬间变成了另一个地址b）——这是它们的共同点。他们的不同在于。301表示旧地址a的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址a的资源还在（仍然可以访问），这个重定向只是临时地从旧地址a跳转到地址b，搜索引擎会抓取新的内容而保存旧的网址。\n     \n     307 temporary redirect（临时重定向），尽管 302 标准禁止 post 变换成 get，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 post 变成 get。\n     308 permanent redirect （永久重定向）\n     \n     307和308的出现也是给上面的行为做个规范，不过是不允许重定向时改变请求方法\n     \n     302 在最初的定义中，内容和现在的 307 是一样的，不允许重定向方法的改写。但是早期浏览器在实现的时候有的实现成 303（get） 的效果，有的实现成 307（post） 的效果。简单说下就是 http 1.0里面302具有二义性，在http 1.1中加入303和307就是为了消除二义性。\n     \n     \n     4xx：客户端错误状态码，表示客户端的请求有非法内容。\n     \n     400 bad request 表示客户端请求有语法错误，不能被服务器所理解\n     401 unauthonzed 表示请求未经授权，该状态代码必须与 www-authenticate 报头域一起使用\n     403 forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因\n     404 not found 请求的资源不存在，例如，输入了错误的url\n     \n     \n     5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。\n     \n     500 internel server error 表示服务器发生不可预期的错误，导致无法完成客户端的请求\n     503 service unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n     \n\n * 常见响应头字段：set-cookie，cache-control，e-tag，last-modified，access-control-allow-origin\n   \n   * tcp 四次挥手，为什么要等 2msl\n\n * 浏览器解析渲染\n   \n   * gc算法\n     \n     * 标记清除 / 引用计数 / 标记整理\n     * 内存泄漏 / 内存溢出\n     * 新生代 / 老生代\n   \n   * 介绍下浏览器多进程架构，网站隔离技术\n   \n   * 渲染过程\n     \n     * 三个线程（compositor thread / main thread / compositor tile worker(s)）\n     * js 会阻塞 dom 解析\n     * css 不会阻塞 dom 解析会阻塞渲染\n     * script标签中的async / defer\n     * domcontentloaded和onload的区别（1是在dom树解析完毕，2是页面完全加载完）\n   \n   * 浏览器缓存\n     \n     * 前端缓存（http缓存 / 浏览器缓存）\n     * 缓存存储在哪里？\n     * 强缓存 / 协商缓存，优先级？\n     * expires（http1.0 已过时，缺点要求时间严格同步）\n     * cache-control （http1.1 / max-age / no-cache / no-store / public / private / s-maxage）\n     * max-age = 0 会怎样\n     * etag / last-modified，e-tag对服务端有什么影响（性能，计算hash，如何计算 last-modify + content-length）\n     * hash、chunkhash、contenthash\n     * localstorage / sessionstorage / cookie\n   \n   * 除了css,js资源，那html文件会缓存吗\n   \n   * 标签页如何通信\n   \n   * cookie + serinterval\n     \n     * localstorage\n   \n   * webworker\n   \n   * websocket\n   \n   * 预检请求\n   \n   * 浏览器最大并发请求资源数\n\n\n# 网络与协议相关\n\n * 什么是ajax（手写）\n\n * 跨域的原因以及解决方式\n   \n   * jsonp\n     * jsonp请求首先是为了解决跨域问题而存在的一种民间解决方案\n     * 通过标签的形式发请求\n     * 需要和后端同学进行约束\n     * 只能使用get请求\n   * cors\n   * iframe的几种方式\n   * postmessage（window.postmessage(message,targetorigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源）\n   * iframe + document.domain（用于二级域名相同的情况下，比如 a.test.com 和 b.test.com ）\n   * iframe + window.name\n   * iframe + location.hash\n   * nginx反向代理\n   * websocket\n   * web-dev-server中的proxy\n   \n   浏览器的同源策略的目的就是为了防止 xss，csrf 等恶意攻击。\n   \n   跨域限制的资源:\n   1.数据存储限制：cookie, localstorage, indexdb 无法读取\n   2.脚本 api 限制：dom 无法操作\n   3.网络请求限制：xhr 请求无法接收响应\n   \n   发生跨域时，允许进行的操作:\n   1.通常允许跨域写操作（link、redirect、表单提交）\n   2.通常允许跨域资源嵌入（script、img、video...）\n   3.通常禁止跨域读操作(ajax)\n   4.可以正常发送请求，可以携带cookie(withcredentials)，但是浏览器会限制来自于不同域的资源的接收\n   \n\n * http 和 https\n   \n   * http 0.9 / 1.0 / 1.1 / 2.0\n     \n     * http0.9\n       * 只支持 get\n       * 没有请求头概念，响应后只能返回 html\n     * http1.0\n       * 请求方式新增了post，head等方式\n       * 增添了请求头和响应头的概念\n       * 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输\n       * 问题：每请求一次都要建立一次连接\n     * http1.1\n       * 长连接：新增connection字段，可以设置keep-alive值保持连接不断开\n       * 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，比较鸡肋，仍然会阻塞。\n     * 缓存处理：新增字段cache-control，新增状态码303，307\n       * 问题：基于文件串行传输，队头阻塞（后一请求需要等前一请求返回），最大并发数限制\n   \n   * http2.0\n     \n     * 二进制分帧\n     * 首部压缩\n     * 多路复用\n   \n   * tcp队头阻塞\n     \n     * http2通过分帧避免了请求时的队首阻塞问题，但tcp层面的阻塞是http2无法解决的。因为tcp是可靠的传输，一旦丢包就要重新发包，阻塞后续，虽然有滑动窗口，但也没有彻底解决\n   \n   * 怎么减少 http 请求\n     \n     * 雪碧图\n     * 合并 js 和 css（构建工具完成）\n     * 利用浏览器缓存\n\n * 长连接与多路复用\n\n * ssl/tls，对称加密 / 非对称加密\n\n * https主要流程，证书的作用\n\n * 中间人攻击\n   \n   1)客户端发送请求到服务端，请求被中间人截获。\n   \n   2)服务器向客户端发送公钥。\n   \n   3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端。\n   \n   4)客户端收到伪造的公钥后，生成密文发给服务器。\n   \n   5)中间人获得密文，用自己的私钥解密。同时用真正的公钥发给服务器。\n   \n   6)服务器获得加密信息，用自己的私钥解密。\n   \n\n * http请求方法\n\n * content-type有哪些\n\n * 简单请求和复杂请求\n   \n   * 只要同时满足以下两大条件，就属于简单请求\n     \n     条件1：使用下列方法之一：get，head，post\n     \n     条件2：content-type 的值仅限于下列三者之一：\n     \n     * text/plain\n       * multipart/form-data\n       * application/x-www-form-urlencoded\n\n * tcp 三次握手 / 四次挥手\n   \n   * syn (synchronous建立联机)\n   * ack (acknowledgement 确认)\n   * fin (finish结束)\n\n * sequence number (顺序号码)\n\n * tcp 与 udp 的区别于应用场景\n   \n   * osi七层模型与 tcp/ip 五层模型\n   \n   * cookie，session，token，jwt\n     \n     * cookie带来的安全性问题及如何防御\n     \n     * cookie的属性\n       \n       * expire属性（指定浏览器可发送 cookie 的有效期）\n       * domain属性（指定 cookie 可以送达的主机名，在set-cookie中设置）\n       * secure 属性（属性用于限制 web 页面仅在 https 安全连接时，才可以发送 cookie）\n       * httponly 属性（ cookie 的扩展功能，它使 javascript 脚本无法获得 cookie）\n     \n     * cookie如何被携带\n       \n       * 同域请求下，ajax会自动带上同源的cookie；\n       * 跨域请求下，ajax不会自动携带同源的cookie，需要通过前端配置相应参数才可以跨域携带同源cookie， withcredentials: true\n       * ajax请求任何时候都不会带上不同源的cookie\n     \n     * session流程：\n       \n       * 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 session，保存相关数据，比如用户角色、登录时间等等。\n       * 请求返回时将此 session 的唯一标识信息 sessionid 返回给浏览器\n       * 浏览器接收到服务器返回的 sessionid 信息后，会将此信息存入到 cookie 中，同时 cookie 记录此 sessionid 属于哪个域名\n       * 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 cookie 信息，如果存在自动将 cookie 信息也发送给服务端，服务端会从 cookie 中获取 sessionid，再根据 sessionid 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作。\n     \n     * 根据以上流程可知，sessionid 是连接 cookie 和 session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n       \n       * sessionid是怎么生成的？(tomcat的sessionid的生成主要是随机数，依赖的类是java.security.securerandom)\n     \n     * token: 令牌**，**访问资源接口（api）时所需要的资源凭证。token是服务端生成的一串字符串,以作客户端进行请求的令牌,当第一次登陆后,服务器生成一个token便将此token返回给客户端,以后客户端只要带上这个token前来请求数据即可,无需再次带上用户名和密码。**token **使服务端无状态化，不会存储会话信息。相比于session的优点是，即使有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。最常见的生成方式是jwt：json web token 入门教程。\n       \n       放在哪？可以把它放在 cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 http 请求的头信息authorization字段里面。\n       \n       > authorization: bearer <token>\n       \n       另一种做法是，跨域的时候，jwt 就放在 post 请求的数据体里面。\n\n * cdn是什么（内容分发网络）\n   \n   * 将源站内容分发至最接近用户的节点，使用户就近取得所需内容。解决了因分布，带宽，服务器性能带来的访问延迟问题。cdn负载均衡系统负责告诉用户缓存服务器的ip地址\n\n * 前端模块化\n   \n   * 文件划分 / 命名空间 / iife / commonjs / amd / cmd\n   * esmodules\n   * esm与commonjs的区别\n     * commonjs模块输出拷贝，es6 模块输出引用\n     * commonjs 模块是运行时加载，es6 模块是编译时加载，之所以webpack的tree-shaking只能作用于es6模块，就是因为es6模块在编译时就能确定依赖。\n     * commonjs是require()同步加载模块，es6模块是import命令是异步加载，有一个独立的模块依赖的解析阶段\n     * commonjs第一次加载模块就会执行整个模块生成一个对象, 再次用到时到缓存中读取，es6 模块不会缓存运行结果，而是动态地去被加载的模块取值\n     * 循环引用的处理\n\n\n# 前端安全\n\n * xss（反射型 / 存储型 / dom型）\n   \n   * httponly\n   * 纯前端渲染\n   * html转义\n   * csp\n   * x-xss-protection\n\n * csrf（第三方网站如何拿到cookie，script、image、iframe的src都不受同源策略的影响。所以我们可以借助这一特点，实现跨域）\n   \n   * origin（一般只存在于cors跨域请求中，为什么要跨域， 同源策略怎么防止csrf攻击）\n     \n     在以下情况不存在此请求头：\n     \n     302 重定向： \n     1. 在 302 重定向之后 origin 不包含在重定向的请求中，因为 origin 可能会被认为是其他来源的敏感信息。\n     2.对于 302 重定向的情况来说都是定向到新的服务器上的 url，因此浏览器不想将 origin 泄漏到新的服务器上。\n     \n     origin 和 referer 存在相同的问题，同样有可能丢失该字段。\n     \n   \n   * referer（协议+域名+查询参数）\n     \n     针对通过 referer 字段去判断请求来源是否合法是不太靠谱的，这个字段很有可能会丢失：\n     \n     1.ie6、7下使用 window.location.href=url 进行界面的跳转或者 window.open，都会造成 referer 丢失。\n     \n     2.https 页面跳转到 http 页面，所有浏览器 referer 都丢失。\n     \n     3.点击 flash 上到达另外一个网站的时候，referer 的情况就比较杂乱，不太可信。\n     \n     可以附加使用于判断请求来源，但是仅通过该字段进行判断是不太靠谱的，如果请求头丢失该字段，则服务端无法判断当前请求来源，无法校验请求是否合法。\n     \n   \n   * samesite cookie\n   \n   * csrf token\n     \n     * 在请求头中将获取到的 token 设置到 cookie 中。\n     * 将 token 放到请求参数中。\n   \n   * 验证码\n\n * 点击劫持\n\n * 中间人攻击\n\n * http传输安全\n\n * 第三方依赖安全\n\n * 控制台注入代码\n\n * 钓鱼\n\n * 前端路由\n   \n   * hash模式\n     * window.location.hash\n     * onhashchange\n   * history模式\n     * pushstate / replacestate / popstate\n\n\n# 设计模式：简单介绍一下\n\n * 工厂模式\n * 抽象工厂模式\n * 单例模式\n * 建造者模式\n * 适配器模式\n * 装饰器模式\n * 过滤器模式\n\n\n# webpack\n\n * webpack，grunt，gulp的区别\n * webpack，rollup，parcel分别适用于什么场景\n * webpack插件主要是做什么的，常用的有哪些\n * 自己写过webpack插件吗（compiler / compilation）\n * webpack loader主要是做什么的，常用的有哪些\n * loader 和 plugin 的区别及用处\n * webpack 热更新原理\n * sourcemap（cheap-module-eval-source-map）\n * webpack-dev-server\n * webpack打包流程和生命周期\n\n\n# git\n\n * git reset 和 git revert 的区别\n * git rebase的两种用途\n\n\n# 动画相关\n\n * css动画\n   \n   * transition: 过渡，是一次性的，只能定义起始和结束状态。\n     \n     #box {\n       height: 100px;\n       width: 100px;\n       background: green;\n       transition: transform 1s ease-in 1s;\n     }\n     #box:hover {\n       transform: rotate(180deg) scale(.5, .5);\n     }\n     \n   \n   * animation：动画，往复性的，keyframes提供更多的控制，尤其是时间百分比的控制\n     \n     .box {\n       height: 100px;\n       width: 100px;\n       border: 15px solid black;\n       animation: changebox 1s ease-in-out 1s infinite alternate running forwards;\n     }\n     \n     @keyframes changebox {\n       10% {\n         background: red;\n       }\n       50% {\n         width: 80px;\n       }\n       70% {\n         border: 15px solid yellow;\n       }\n       100% {\n         width: 180px;\n         height: 180px;\n       }\n     }\n     \n\n * js动画\n   \n   * 定时器：会出现卡顿抖动，定时器实际执行实际较晚，不用设备屏幕刷新频率不同\n     \n     var offsetx = 500  //要水平移动的距离\n     var moveoffset = 0  //当前已经移动的距离\n     var step = 5   //每次移动的距离\n     \n     function move(){\n       if(moveoffset < offsetx){\n         ball.style.left = parseint(getcomputedstyle(ball).left) + step + 'px'\n         moveoffset += step\n         settimeout(move, 5)\n       }\n     }\n     move()\n     \n   \n   * requestanimationframe：由系统来决定回调函数的执行时机。保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n     \n     var offsetx = 500  //要水平移动的距离\n     var moveoffset = 0  //当前已经移动的距离\n     var step = 5   //每次移动的距离\n     \n     function move(){\n       if(moveoffset < offsetx){\n         ball.style.left = parseint(getcomputedstyle(ball).left) + step + 'px'\n         moveoffset += step\n         requestanimationframe(move)\n       }\n     }\n     move()\n     \n\n * 怎么实现回到顶部动画？\n   \n   function totop() {\n     let scrolltop = document.documentelement.scrolltop || document.body.scrolltop;\n     let timer = setinterval(() => {\n       scrolltop -= 100;\n       window.scrollto(0, scrolltop)\n       if (scrolltop <= 0) {\n         clearinterval(timer)\n       }\n     }, 10)\n   }\n   \n   function totop() {\n     let scrolltop = document.documentelement.scrolltop || document.body.scrolltop;\n     if (scrolltop > 0) {\n       requestanimationframe(function() {\n         scrolltop -= 100;\n       \twindow.scrollto(0, scrolltop)\n       })\n     }\n   }\n   \n\n\n# 常用手写代码\n\n * 防抖 / 节流\n * 柯里化\n * apply,bind,call\n * promise.all\n * promise.race\n * 发布订阅模式\n * 数组扁平化带参数\n * 数组去重 4 种\n * instanceof\n * new\n * 深拷贝\n * ajax请求\n * 快排 / 冒泡 / 堆排序\n * 手写 map / reduce\n * 并发请求控制\n * 实现一个sleep函数\n\n\n# 计算机基础\n\n * 32位和64位的区别？\n   \n   > 寻址空间分别为2^32 = 4g和2^64，寻址空间一般指的是cpu对于内存寻址的能力。通俗地讲，就是最多能用到多少内存的一个问题。\n\n * cpu如何访问内存？\n   \n   > 首先 cpu 在访问内存的时候都需要通过 mmu（内存管理单元） 把虚拟地址转化为物理地址，然后通过总线访问内存。mmu 开启后 cpu 看到的所有地址都是虚拟地址，cpu 把这个虚拟地址发给 mmu 后，mmu 会通过页表在页表里查出这个虚拟地址对应的物理地址是什么，从而去访问外面的 ddr（内存条）。\n\n * 什么是平衡二叉树和红黑树\n   \n   * 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n   * 红黑树是一个自平衡(不是绝对的平衡)的二叉查找树\n   * 红黑树相比于avl树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于avl树。\n\n\n# 项目\n\n * 小程序\n   \n   * 长列表优化：为什么要做优化？1.小程序双线程 2. 框架缺陷\n   \n   * 小程序双线程原理\n   \n   * 小程序的双线程设计，主要为了管控安全，避免操作 dom。逻辑线程是一个只能够运行javascript的沙箱环境，不提供dom操作相关的api，所以不能直接操作ui，只能够通过setdata更新数据的方式异步更新ui。\n     \n   \n   * setdata工作原理\n     \n     小程序的视图层目前使用 webview 作为渲染载体，而逻辑层是由独立的 javascriptcore 作为运行环境。在架构上，webview 和 javascriptcore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluatejavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 js 脚本，再通过执行 js 脚本的形式传递到两边独立环境。\n     \n     而 evaluatejavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的setdata函数将数据从逻辑层发送到视图层，是异步的。\n     \n     \n     var initdata = {\n         info: {\n             name: 'hh'\n         }\n     };\n     \n     page({\n         data: initdata,\n         onclick() {\n             this.setdata({\n                 'info.name': 'xx'\n             }, () => {\n                 console.log(initdata.info.name) // hh\n             })\n         }\n     })\n     // 1. page初始化的时候data是深拷贝生成的，所以不会改变原来initdata的值\n     // 2. 如果改变了initdata的值，页面的初始值就会被改变了，navigateto/redicetto页面数据不一样\n     \n   \n   * 项目优化\n   \n   * mpvue原理\n     \n     * mpvue 保留了 vue.runtime 核心方法，无缝继承了 vue.js 的基础能力\n     * mpvue-template-compiler 提供了将 vue 的模板语法转换到小程序的 wxml 语法的能力\n     * 修改了 vue 的建构配置，使之构建出符合小程序项目结构的代码格式： json/wxml/wxss/js 文件\n   \n   * 小程序框架对比：基于微信自定义组件实现组件开发的框架（uni-app/taro/chameleon），组件数据通讯性能接近于微信原生框架，远高于基于template实现组件开发的框架（wepy/mpvue）性能\n   \n   * 小程序为双线程模型，逻辑层和视图层，通过 native 层通信。不像在 web 上 js 和 ui 会互斥，小程序中会限制 js 操作 dom，所以不用担心不同步问题。\n   \n   * 逻辑层和视图层通过 setdata 进行通信，会把数据转换成字符串并拼接一段 js 脚本（evaluatejavascript）传到视图层，这个过程是异步的。\n   \n   * 如果每次 setdata 的数据量过大，会非常损耗性能，最好是增量更新。uni-app、taro 都在调用setdata之前自动做diff计算，每次仅传递变动的数据。\n   \n   * 而且基于微信自定义组件实现组件开发的框架（uni-app/taro），组件数据通讯性能接近于微信原生框架，远高于基于template实现组件开发的框架（wepy/mpvue）性能。\n   \n   * 跨端能力，uni-app 比较优秀，同时支持h5、多家小程序、跨平台app，但是一套代码横跨 ios android web 和小程序比较复杂，可能会存在大量兼容性问题。\n\n * el-select的使用，vue自定义指令\n\n * mixin\n\n * 其它\n   \n   * 自我介绍\n   * 为什么选择前端，如何学习，为什么选择这种学习方式？\n   * 对前端发展的看法？\n     * 早些时候，由于时代的问题，当时的web前端仅仅是展示一些简单的文本、图片，页面较为简单\n     * 前后端分离，mvvm框架(vue, react, angular等)的出现，使得前端更加应用化，性能更高。\n     * v8引擎和node的出现，促使前端能用自己熟悉的语法编写后台系统。\n     * 前端工程化的提出，提高了前端的开发效率，增强了可维护性\n     * 数据可视化百家争鸣，基于svg，canvas，webgl开发的可视化，3d动画已被广泛的应用到网站中。\n     * 大前端时代：随着智能手机的普及，如今android端、ios端等各种移动端的应用也越来越普及，单一面向于pc端的web应用，也向着移动端发展。类似各种手机app，小程序的诞生，使得人们的生活越来越便利，让人不禁遐想，将来的前端是否能应用到全端，即一套代码能通用多种平台。\n   * 最近在学什么？\n   * 项目中你印象最深的地方，有什么难点，怎么解决的？\n   * 技能和性格有什么缺陷？\n   * 平时看什么书？\n   * 优点？缺点？\n   * 说说对我们公司的了解？\n   * 职业规划？\n   * 反问\n     * 对我的评价？建议？\n     * 部门的业务情况？\n     * 团队架构？\n\n * santd\n   \n   * upload：底层实现还是基于input输入框（type=file），然后利用onchange事件，监听文件选择的事件，然后利用formdata对象装载需要上传的文件，最后通过xmlhttprequest来进行文件的网络异步传输。通过xhr.upload 的onprogress 事件的监听，可以正确的获取到上传文件的total值和loaded的值，从而实时的计算出当前上传的进度。\n   * tab：key、active_key\n   * table：通过 slot 让用户可以自定义 column title 并支持获取 column 信息\n\n * eslint-plugin-san\n   \n   * eslint-plugin-san 是 eslint 的一个插件，类似于 eslint-plugin-vue，内部配置了一系列针对性的规则\n   * eslint执行原理：使用解析器 espree 将代码解析成 ast，进行词法分析以及语法分析；通过 dfs 来遍历 ast；在遍历的过程中 eslint 通过选择器来匹配 ast 上的节点，通过代码路径分析来控制代码检测的范围。每个 rule 都定义了 create 方法，会返回一个 vistor（即访问到某些节点时做出的操作），eslint 会收集配置文件中所有规则的 vistor，遍历 ast 并调用 vistor，得到检测结果。规则内还可以定义 fix 方法，在报错的时候可以进行修正。\n   * no-empty-attributes: 默认检测 class 和 style 属性不能为空，可以通过 options 配置其他不允许为空的属性。\n   * data-name-casing：datatypes, initdata, computed 中的数据在多个单词的情况下使用 \"下划线\"、\"短横线\"、\"帕斯卡\"命名规则会报错，提示统一使用驼峰式命名法。\n   * boolean-value：强制布尔属性。<div attr></div>\n\n * san-loader:\n   \n   * sanloaderplugin 在 webpack 正式构建之前修改原有的配置 rules。\n   * webpack 从入口文件出发, 遇到.san文件，第一次调用 san-loader 来处理 san 单文件, 这个过程会调用 san-sfc-compiler 的 parsesfc 方法来解析文件内容生成 import 语句，对于每一条 import 语句再遍历 rules 进行规则匹配。最后提取代码块交给对应 loader 处理\n\n\n# 权限管理\n\n\n# rabc\n\n基于角色的访问控制（role-based access control，简称 rbac），指的是通过用户的角色（role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。\n\n * 用户（user）：系统实际使用者（如员工、管理员）\n * 角色（role）：职级或职能的抽象集合（如「财务专员」「部门主管」）\n * 权限（permission）：对系统资源的操作许可（如「查看报表」「导出数据」）\n\n\n# 前端权限控制流程\n\n 1. 用户登录与权限初始化 用户登录后，后端返回角色标识（如roles: [\"finance_staff\"]）和权限清单（如permissions: [\"invoice:view\", \"budget:edit\"]）前端将权限数据存入状态管理工具（如vuex/pinia），为后续控制提供依据\n 2. 动态路由生成\n\n * 路由分级配置：\n   * 基础路由（公共页面：登录页、404）\n   * 动态路由（需权限控制：仪表盘、订单管理）\n   * 每个动态路由配置meta.permissions字段标记所需权限（如{ path: \"/pay\", meta: { permissions: [\"payment:access\"] } }）\n * 路由过滤逻辑：根据用户权限清单过滤动态路由，仅保留用户有权访问的路由配置，通过router.addroute()动态挂载\n\n 3. 前置守卫校验\n\n * 全局路由守卫：在vue-router的beforeeach钩子中，对每次路由跳转进行三重校验：\n   * 是否已登录（未登录跳转至登录页）\n   * 是否已获取权限（防止页面刷新后权限丢失）\n   * 目标路由是否在用户权限范围内（无权限跳转至403页）\n * 嵌套路由处理：对父级路由设置alwaysshow: true，确保即使子路由无权限，父级菜单仍可展示（但子菜单项置灰或隐藏）\n\n\n# 从0到1的b端平台项目\n\n\n# 技术选型\n\n 1. 框架选择：优先成熟框架（react/vue）\n 2. 语言与工具：typescript减少运行时错误，结合vite提升构建效率。\n 3. ui框架：ant design（react）/ element（vue）\n\n\n# 架构设计\n\n 1. 模块化与组件化：微前端（独立部署、技术栈解耦）/ 模块化（高内聚、低耦合，复用）\n 2. 状态管理：vuex / redux\n 3. 路由设计：权限控制（rbac）/ 动态路由（根据用户角色加载）\n\n\n# 工程化\n\n 1. 代码规范：eslint + stylelint + prettier\n 2. 测试策略：单元测试 / e2e测试\n 3. 监控与日志：性能监控（sentry捕获错误） / 日志管理\n 4. 集成部署：ci/cd\n\n\n# 性能优化\n\n 1. 加载优化：懒加载 / 资源压缩\n 2. 渲染优化：避免重排 / 虚拟列表\n 3. 构建优化：tree shaking / 智能分包",charsets:{cjk:!0}},{title:"ES2016 - ES2022",frontmatter:{},regularPath:"/javascript/ES2017-2022.html",relativePath:"javascript/ES2017-2022.md",key:"v-389f887d",path:"/javascript/ES2017-2022.html",headers:[{level:2,title:"ES2016",slug:"es2016",normalizedTitle:"es2016",charIndex:2},{level:3,title:"Array.prototype.includes",slug:"array-prototype-includes",normalizedTitle:"array.prototype.includes",charIndex:180},{level:3,title:"求幂运算符",slug:"求幂运算符",normalizedTitle:"求幂运算符",charIndex:208},{level:2,title:"ES2017",slug:"es2017",normalizedTitle:"es2017",charIndex:522},{level:3,title:"Object.values 与 Object.entries",slug:"object-values-与-object-entries",normalizedTitle:"object.values 与 object.entries",charIndex:533},{level:3,title:"Object.getOwnPropertyDescriptors",slug:"object-getownpropertydescriptors",normalizedTitle:"object.getownpropertydescriptors",charIndex:567},{level:3,title:"padStart 与 padEnd",slug:"padstart-与-padend",normalizedTitle:"padstart 与 padend",charIndex:1629},{level:3,title:"尾逗号",slug:"尾逗号",normalizedTitle:"尾逗号",charIndex:664},{level:2,title:"ES2018",slug:"es2018",normalizedTitle:"es2018",charIndex:2004},{level:3,title:"异步迭代",slug:"异步迭代",normalizedTitle:"异步迭代",charIndex:2015},{level:3,title:"Promise.finally",slug:"promise-finally",normalizedTitle:"promise.finally",charIndex:2782},{level:3,title:"rest/spread",slug:"rest-spread",normalizedTitle:"rest/spread",charIndex:2070},{level:3,title:"Regexp",slug:"regexp",normalizedTitle:"regexp",charIndex:2085},{level:2,title:"ES2019",slug:"es2019",normalizedTitle:"es2019",charIndex:3999},{level:3,title:"Object.fromEntries",slug:"object-fromentries",normalizedTitle:"object.fromentries",charIndex:4010},{level:3,title:"flat 与 flatMap",slug:"flat-与-flatmap",normalizedTitle:"flat 与 flatmap",charIndex:4032},{level:3,title:"trimStart 与 trimEnd",slug:"trimstart-与-trimend",normalizedTitle:"trimstart 与 trimend",charIndex:4050},{level:2,title:"ES2020",slug:"es2020",normalizedTitle:"es2020",charIndex:4727},{level:3,title:"matchAll",slug:"matchall",normalizedTitle:"matchall",charIndex:4767},{level:3,title:"Promise.allSettled",slug:"promise-allsettled",normalizedTitle:"promise.allsettled",charIndex:4800},{level:3,title:"Dynamic import",slug:"dynamic-import",normalizedTitle:"dynamic import",charIndex:4822},{level:2,title:"ES2021",slug:"es2021",normalizedTitle:"es2021",charIndex:6344},{level:3,title:"逻辑赋值运算符",slug:"逻辑赋值运算符",normalizedTitle:"逻辑赋值运算符",charIndex:6384},{level:3,title:"replaceAll",slug:"replaceall",normalizedTitle:"replaceall",charIndex:6395},{level:3,title:"Promise.any",slug:"promise-any",normalizedTitle:"promise.any",charIndex:6409},{level:3,title:"数值分隔符",slug:"数值分隔符",normalizedTitle:"数值分隔符",charIndex:6424},{level:2,title:"ES2022",slug:"es2022",normalizedTitle:"es2022",charIndex:11},{level:3,title:"顶层 await",slug:"顶层-await",normalizedTitle:"顶层 await",charIndex:7791},{level:3,title:"at() 方法",slug:"at-方法",normalizedTitle:"at() 方法",charIndex:7803},{level:3,title:"Object.hasOwn()",slug:"object-hasown",normalizedTitle:"object.hasown()",charIndex:7814},{level:3,title:"class 私有字段",slug:"class-私有字段",normalizedTitle:"class 私有字段",charIndex:7833}],lastUpdated:"12/26/2022, 6:16:52 PM",lastUpdatedTimestamp:1672049812e3,headersStr:"ES2016 Array.prototype.includes 求幂运算符 ES2017 Object.values 与 Object.entries Object.getOwnPropertyDescriptors padStart 与 padEnd 尾逗号 ES2018 异步迭代 Promise.finally rest/spread Regexp ES2019 Object.fromEntries flat 与 flatMap trimStart 与 trimEnd ES2020 matchAll Promise.allSettled Dynamic import ES2021 逻辑赋值运算符 replaceAll Promise.any 数值分隔符 ES2022 顶层 await at() 方法 Object.hasOwn() class 私有字段",content:"# ES2016 - ES2022\n\n> ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为ECMA-417。关于ECMA的最新资讯可以浏览 ECMA news查看。\n> \n> ES2016 - ES2022 对应的是 ES7 - ES13\n\n\n# ES2016\n\n * Array.prototype.includes\n * 求幂运算符\n\n\n# Array.prototype.includes\n\nconst arr = [1, 3, 5, 2, '8', NaN, -0]\narr.includes(1) // true\narr.includes(1, 2) // false 该方法的第二个参数表示搜索的起始位置，默认为0\narr.includes('1') // false\narr.includes(NaN) // true\narr.includes(+0) // true\n\n\n\n# 求幂运算符\n\nconsole.log(2**10);// 输出1024\nconsole.log(Math.pow(2, 10)) // 输出1024\n\n\n\n# ES2017\n\n * Object.values 与 Object.entries\n * Object.getOwnPropertyDescriptors\n * String.prototype.padStart 与 Sting.prototype.padEnd\n * 函数参数中添加尾逗号\n * async/await\n\n\n# Object.values 与 Object.entries\n\nconst obj = {\n    foo: 'value1',\n    bar: 'value2'\n}\n\nconsole.log(Object.keys(obj))   // 键\nconsole.log(Object.values(obj)) // 值\n\nconsole.log(Object.entries(obj))\n// [[\"foo\", \"value1\"], [\"bar\", \"value2\"]]\n\n// 可以用这种方法来遍历对象\nfor(const [key, value] of Object.entries(obj)) {\n    console.log(key, value)\n}\n\n// 对象转换为Map\nnew Map(Object.entries(obj))\n\n\n\n# Object.getOwnPropertyDescriptors\n\n该函数返回指定对象（参数）的所有自身属性描述符。所谓自身属性描述符就是在对象自身内定义，不是通过原型链继承来的属性。\n\n描述符：\n\n * writable：表示该属性的值是否可以被修改\n\n * enumerable：表示该属性会是否出现在对象的枚举属性中。(for...in 和 Object.keys)\n\n * configurable：表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。\n\nconst obj = {foo: 'value1', bar: 'value2'}\nObject.getOwnPropertyDescriptors(obj)\n\n// 获取对象的完整描述信息\n{\n  foo: {\n    value: \"value1\",\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  bar: {\n    value: \"value2\",\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n}\n\n\n\n# padStart 与 padEnd\n\n// padEnd和padStart可以使输出更工整\nconst books = {\n    html: 5,\n    css: 16,\n    javascript: 128\n}\nfor(const [name, count] of Object.entries(books)) {\n    console.log(`${name.padEnd(16, '-')}|${count.toString().padStart(3, '0')}`)\n}\n\n// html------------|005\n// css-------------|016\n// javascript------|128\n\n\n\n# 尾逗号\n\nconst arr = [\n    100,\n    200,\n    300,\n]\n\n\n\n# ES2018\n\n * 异步迭代 for await...of\n * Promise.prototype.finally\n * 对象 rest/spread\n * Regexp\n   * dotAll\n   * 命名分组捕获\n\n\n# 异步迭代\n\nfor...of 内部是迭代器的应用，而 for await...of 对应的是异步迭代器。\n\nfunction fetchData(d) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\nconst dataList = [1, 2, 3];\n\nconst promiseList = [];\ndataList.forEach(d => {\n    promiseList.push(fetchData(d)); // 此处 fetchData 已经开始执行了\n});\n\nfor await (p of promiseList) {\n  console.log(p) // 隔一秒同时且按顺序输出 1,2,3\n}\n\n\n> For await...of 将会按迭代顺序收到响应。除非当前迭代的计算取决于之前的一些迭代，否则大部分业务场景下用 promise.all 即可解决问题。\n\nconst promiseList = [];\ndataList.forEach(d => {\n    promiseList.push(fetchData(d)); // 此处已经开始执行了\n});\n\nPromise.all(promiseList).then(res => {\n  console.log(res) // [1, 2, 3]\n})\n\n\n\n# Promise.finally\n\nES6为我们带来了 Promise，但是它的结果要么成功 then 要么失败 catch，使得我们的一些逻辑，如执行状态修改，结束回调都得在两边写一遍。有了 finally()，逻辑只可以放在一个地方了。\n\nnew Promise((reslove, reject) => {\n  // ...\n}).then((res) => {\n  // reslove\n}).catch((err) => {\n  // reject\n}).finally(() => {\n  // complete\n});\n\n\n\n# rest/spread\n\nES2015 引入了三个点（...）运算符，这个运算符既能用来收集函数的剩余参数，也可以用来扩展数组。\n\nES2018 对其进行了增强，将扩展和收集参数的能力扩大到了对象。使得 ... 运算符也可以用来收集对象的“剩余属性”。\n\n// rest\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nconst { a, ...x } = obj; // a = 1， x = { b: 2, c: 3 }\n\n// spread\nconst obj1 = { a: 1, b: 2, c: 3 };\nconst obj2 = { ...obj1, z: 26 }; // { a: 1, b: 2, c: 3, z: 26 }\n\n\n\n# Regexp\n\nRegExp 在 ES2018 中新增dotAll （点匹配）、命名分组捕获等。\n\n// ES2018引入了dotAll模式，通过使用标记s选项，.就可以匹配换行符。\n/hello.es9/.test('hello\\nes9');  // false\n/hello.es9/s.test('hello\\nes9');  // true\n\n// 命名分组捕获，ES2018允许命名捕获组使用符号?<name>, 可以指定小括号中匹配内容的名称放在groups里\nconst reg = /(\\d{4})-(\\d{2})-(\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched[0];  // 2018-12-12\nmatched[1];  // 2018\nmatched[2];  // 12\nmatched[3];  // 31\n\nconst reg = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched.groups.year;   // 2018\nmatched.groups.month;  // 12\nmatched.groups.day;    // 31\n\n\n\n# ES2019\n\n * Object.fromEntries\n * flat 与 flatMap\n * trimStart 与 trimEnd\n\n\n# Object.fromEntries\n\n通常用于将数组转化为对象,通常可以作为 Object.entries() 的反操作。\n\nconst obj = {name: '小米', skin: 'white', age: 2}\nconsole.log(Object.entries(obj)); \n// [['name','小米'],['skin','white'],['age',2]]\n\nconst arr = [['name','小米'],['skin','white'],['age',2]];\nconsole.log(Object.fromEntries(arr));\n// {name: '小米', skin: 'white', age: 2}\n\n\n\n# flat 与 flatMap\n\nflat 常用于将多维数组降维为一维数组，可以传参数，表示降维的深度，默认是1\n\nflatMap 相当于先对数组进行map操作，然后进行flat操作\n\n[[1,2],[3,4]].flat(); // [1, 2, 3, 4]\n[[1,2],[3,4]].flatMap(i => i.reverse()) //  [2, 1, 4, 3]\n\n\n\n# trimStart 与 trimEnd\n\n去除字符串（前）后面的空格\n\nconst str = ' Hello,ES2019! ';\nconsole.log(str.trimStart().trimEnd()); // Hello,ES2019!\n\n\n\n# ES2020\n\nhttps://h3manth.com/ES2020/\n\n * matchAll\n * 空值合并运算符\n * 可选链操作符\n * Promise.allSettled\n * Dynamic import\n * BigInt\n\n\n# matchAll\n\n// match\nconst str = 'Dr. Smith and Dr. Anderson';\nconst re = /(Dr\\. )\\w+/g;\nconst res = str.match(re);  //[\"Dr. Smith\", \"Dr. Anderson\"]\n\n// matchAll\nconst re = /(Dr\\. )\\w+/g;\nconst str = 'Dr. Smith and Dr. Anderson';\nconst matches = str.matchAll(re);\n\n// 返回的是迭代器对象需要 for...of 遍历\nfor (const match of matches) {\n  console.log(match);\n}\n\n// [\"Dr. Smith\", \"Dr. \", index: 0, input: \"Dr. Smith and Dr. Anderson\", groups: undefined]\n// [\"Dr. Anderson\", \"Dr. \", index: 14, input: \"Dr. Smith and Dr. Anderson\", groups: undefined]\n\n\n\n# Promise.allSettled\n\n> Promise.all 具有并发执行异步任务的能力。但它的最大问题就是如果参数中的任何一个promise为reject的话，则整个Promise.all 调用会立即终止，并返回一个reject的新的 Promise 对象。Promise.allSettled 的出现就可以解决这个痛点\n\nPromise.allSettled([\n  Promise.reject({ code: 500, msg: '服务异常' }),\n  Promise.resolve({ code: 200, list: [] }),\n  Promise.resolve({ code: 200, list: [] })\n]).then(res => {\n  console.log(res)\n  /*\n        0: {status: \"rejected\", reason: {…}}\n        1: {status: \"fulfilled\", value: {…}}\n        2: {status: \"fulfilled\", value: {…}}\n   */\n})\n\n\n\n# Dynamic import\n\n动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块。\n\n现在前端打包资源越来越大，前端应用初始化时根本不需要全部加载这些逻辑资源，为了首屏渲染速度更快，很多时候都是动态导入（按需加载）模块，比如懒加载图片等，这样可以帮助您提高应用程序的性能。\n\n其中按需加载这些逻辑资源都一般会在某一个事件回调中去执行：\n\nel.onclick = () => {\n  import('/modules/my-module.js')\n    .then(module => {\n      // Do something with the module.\n    })\n    .catch(err => {\n      // load error;\n    })\n}\n\n\n这种使用方式也支持 await 关键字。\n\nlet module = await import('/modules/my-module.js');\n\n\n\n# ES2021\n\nhttps://h3manth.com/ES2021/\n\n * 逻辑赋值运算符\n * replaceAll\n * Promise.any\n * 数值分隔符\n\n\n# 逻辑赋值运算符\n\n||=  // a ||= b 相当于 a = a || b\n&&=  // a &&= b 相当于 a = a && b\n??=  // a ??= b 相当于 a = a ?? b\n\n\n\n# replaceAll\n\n// ES2021 之前\n'1 2 1 2 1 2'.replace(/2/g, '0'); // '1 0 1 0 1 0'\n\n// 现在\n'1 2 1 2 1 2'.replaceAll('2', '0'); // '1 0 1 0 1 0'\n\n\n\n# Promise.any\n\n>  * Promise.all()中的Promise序列会全部执行通过才认为是成功，否则认为是失败；\n>  * Promise.race()中的Promise序列中第一个执行完毕的是通过，则认为成功，如果第一个执行完毕的Promise是拒绝，则认为失败；\n>  * Promise.any()中的Promise序列只要有一个执行通过，则认为成功，如果全部拒绝，则认为失败；\n\nPromise.any()适合用在通过不同路径请求同一个资源的需求上。\n\n例如，Vue3.0在unpkg和jsdelivr都有在线的CDN资源，都是国外的CDN，国内直接调用不确定哪个站点会抽风，加载慢，这时候可以两个资源都请求，哪个请求先成功就使用哪一个。\n\n比方说unpkg的地址是：https://unpkg.com/vue@3.0.11/dist/vue.global.js jsdelivr的地址是：https://cdn.jsdelivr.net/npm/vue@3.0.11/dist/vue.global.js\n\nlet startTime = +new Date();\nlet importUnpkg = import('https://unpkg.com/vue@3.0.11/dist/vue.runtime.esm-browser.js');\nlet importJsdelivr = import('https://cdn.jsdelivr.net/npm/vue@3.0.11/dist/vue.runtime.esm-browser.js');\nPromise.any([importUnpkg, importJsdelivr]).then(vue => {\n  console.log('加载完毕，时间是：' + (+new Date() - startTime) + 'ms');\n  console.log(vue.version);\n});\n\n\n\n# 数值分隔符\n\nconst a = 785_00;\nconst b = 1_000_000_000;\nconsole.log(a);                // 78500\nconsole.log(b);                  // 1000000000\nconsole.log(a === 78500);      // true\nconsole.log(b === 1000000000);   // true\n\n\n\n# ES2022\n\nhttps://h3manth.com/ES2022/\n\n * 顶层 await\n * at() 方法\n * Object.hasOwn()\n * class 私有字段\n\n\n# 顶层 await\n\n允许开发者在 async 函数外部使用 await 字段。它就像巨大的 async 函数，原因是 import 它们的模块会等待它们开始执行它的代码。\n\n// 过去\nawait Promise.resolve(console.log('🎉'));\n// → SyntaxError: await is only valid in async function\n\n(async function () {\n  await Promise.resolve(console.log('🎉'));\n  // → 🎉\n})();\n\n// 现在\nawait Promise.resolve(console.log('🎉'));\n\n\n以下例子尝试加载一个来自 first.com 的 JavaScript 模块，加载失败会有回退方案：\n\n//module.mjs\nlet module;\n\ntry {\n  module = await import('https://first.com/libs.com/module1');\n} catch {\n  module = await import('https://second.com/libs/module1');\n}\n\n\n这里 res 变量的初始值由最先结束的下载请求决定。\n\n//module.mjs\nconst resPromises = [    \n    donwloadFromResource1Site,\n    donwloadFromResource2Site\n];\n\nconst res = await Promise.any(resPromises);\n\n\n\n# at() 方法\n\n在此之前我们使用方括号 ([]) 来访问数组的第 N 个元素。但是，如果我们想使用方括号访问数组末尾的第 N 个项目，我们必须使用 arr.length - N 的索引。at 方法可以解决这个问题。\n\nconst arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.at(0)); // a\nconsole.log(arr.at(-1)); // d\nconsole.log(arr.at(-2)); // c\n\n\n\n# Object.hasOwn()\n\n在此之前，我们判断对象自身是否拥有某属性时，可以使用 hasOwnProperty，但是会有一些问题。\n\n// 对于使用 null 原型创建的对象尝试对其调用此方法会导致错误。\nconst obj = Object.create(null);\nobj.color = 'green';\n// TypeError: obj.hasOwnProperty is not a function\nconsole.log(obj.hasOwnProperty('color'));\n\n// hasOwnProperty() 方法不受保护, 可以被覆盖\nconst car = {\n color: 'green',\n hasOwnProperty: function() {\n   return false;\n }\n}\nconsole.log(car.hasOwnProperty('age')); // false\n\n\n当然以上问题都可以使用 Object.prototype.hasOwnProperty 来解决，但是我们以后可以直接用 Object.hasOwn 来替换。\n\n如果指定的对象自身有指定的属性，则静态方法 Object.hasOwn() 返回 true。如果属性是继承的或者不存在，该方法返回 false。\n\nconst object1 = {\n  prop: 'exists'\n};\n\nconsole.log(Object.hasOwn(object1, 'prop'));\n// expected output: true\n\nconsole.log(Object.hasOwn(object1, 'toString'));\n// expected output: false\n\n\n\n# class 私有字段\n\nclass Foo {\n  #iteration = 0;\n  \n  increment() {\n    this.#iteration++;\n  }\n  \n  #auditIncrement() {\n    console.log('auditing');\n  }\n\n  logIteration() {\n    console.log(this.#iteration);\n  }\n}\n\nconst x = new Foo();\n\nx.#iteration // error\nx.#auditIncrement() // error\nx.increment(); // ✅ works\nx.logIteration(); // ✅ works\n",normalizedContent:"# es2016 - es2022\n\n> es全称ecmascript，ecmascript是ecma制定的标准化脚本语言。目前javascript使用的ecmascript版本为ecma-417。关于ecma的最新资讯可以浏览 ecma news查看。\n> \n> es2016 - es2022 对应的是 es7 - es13\n\n\n# es2016\n\n * array.prototype.includes\n * 求幂运算符\n\n\n# array.prototype.includes\n\nconst arr = [1, 3, 5, 2, '8', nan, -0]\narr.includes(1) // true\narr.includes(1, 2) // false 该方法的第二个参数表示搜索的起始位置，默认为0\narr.includes('1') // false\narr.includes(nan) // true\narr.includes(+0) // true\n\n\n\n# 求幂运算符\n\nconsole.log(2**10);// 输出1024\nconsole.log(math.pow(2, 10)) // 输出1024\n\n\n\n# es2017\n\n * object.values 与 object.entries\n * object.getownpropertydescriptors\n * string.prototype.padstart 与 sting.prototype.padend\n * 函数参数中添加尾逗号\n * async/await\n\n\n# object.values 与 object.entries\n\nconst obj = {\n    foo: 'value1',\n    bar: 'value2'\n}\n\nconsole.log(object.keys(obj))   // 键\nconsole.log(object.values(obj)) // 值\n\nconsole.log(object.entries(obj))\n// [[\"foo\", \"value1\"], [\"bar\", \"value2\"]]\n\n// 可以用这种方法来遍历对象\nfor(const [key, value] of object.entries(obj)) {\n    console.log(key, value)\n}\n\n// 对象转换为map\nnew map(object.entries(obj))\n\n\n\n# object.getownpropertydescriptors\n\n该函数返回指定对象（参数）的所有自身属性描述符。所谓自身属性描述符就是在对象自身内定义，不是通过原型链继承来的属性。\n\n描述符：\n\n * writable：表示该属性的值是否可以被修改\n\n * enumerable：表示该属性会是否出现在对象的枚举属性中。(for...in 和 object.keys)\n\n * configurable：表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。\n\nconst obj = {foo: 'value1', bar: 'value2'}\nobject.getownpropertydescriptors(obj)\n\n// 获取对象的完整描述信息\n{\n  foo: {\n    value: \"value1\",\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  bar: {\n    value: \"value2\",\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n}\n\n\n\n# padstart 与 padend\n\n// padend和padstart可以使输出更工整\nconst books = {\n    html: 5,\n    css: 16,\n    javascript: 128\n}\nfor(const [name, count] of object.entries(books)) {\n    console.log(`${name.padend(16, '-')}|${count.tostring().padstart(3, '0')}`)\n}\n\n// html------------|005\n// css-------------|016\n// javascript------|128\n\n\n\n# 尾逗号\n\nconst arr = [\n    100,\n    200,\n    300,\n]\n\n\n\n# es2018\n\n * 异步迭代 for await...of\n * promise.prototype.finally\n * 对象 rest/spread\n * regexp\n   * dotall\n   * 命名分组捕获\n\n\n# 异步迭代\n\nfor...of 内部是迭代器的应用，而 for await...of 对应的是异步迭代器。\n\nfunction fetchdata(d) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\nconst datalist = [1, 2, 3];\n\nconst promiselist = [];\ndatalist.foreach(d => {\n    promiselist.push(fetchdata(d)); // 此处 fetchdata 已经开始执行了\n});\n\nfor await (p of promiselist) {\n  console.log(p) // 隔一秒同时且按顺序输出 1,2,3\n}\n\n\n> for await...of 将会按迭代顺序收到响应。除非当前迭代的计算取决于之前的一些迭代，否则大部分业务场景下用 promise.all 即可解决问题。\n\nconst promiselist = [];\ndatalist.foreach(d => {\n    promiselist.push(fetchdata(d)); // 此处已经开始执行了\n});\n\npromise.all(promiselist).then(res => {\n  console.log(res) // [1, 2, 3]\n})\n\n\n\n# promise.finally\n\nes6为我们带来了 promise，但是它的结果要么成功 then 要么失败 catch，使得我们的一些逻辑，如执行状态修改，结束回调都得在两边写一遍。有了 finally()，逻辑只可以放在一个地方了。\n\nnew promise((reslove, reject) => {\n  // ...\n}).then((res) => {\n  // reslove\n}).catch((err) => {\n  // reject\n}).finally(() => {\n  // complete\n});\n\n\n\n# rest/spread\n\nes2015 引入了三个点（...）运算符，这个运算符既能用来收集函数的剩余参数，也可以用来扩展数组。\n\nes2018 对其进行了增强，将扩展和收集参数的能力扩大到了对象。使得 ... 运算符也可以用来收集对象的“剩余属性”。\n\n// rest\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nconst { a, ...x } = obj; // a = 1， x = { b: 2, c: 3 }\n\n// spread\nconst obj1 = { a: 1, b: 2, c: 3 };\nconst obj2 = { ...obj1, z: 26 }; // { a: 1, b: 2, c: 3, z: 26 }\n\n\n\n# regexp\n\nregexp 在 es2018 中新增dotall （点匹配）、命名分组捕获等。\n\n// es2018引入了dotall模式，通过使用标记s选项，.就可以匹配换行符。\n/hello.es9/.test('hello\\nes9');  // false\n/hello.es9/s.test('hello\\nes9');  // true\n\n// 命名分组捕获，es2018允许命名捕获组使用符号?<name>, 可以指定小括号中匹配内容的名称放在groups里\nconst reg = /(\\d{4})-(\\d{2})-(\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched[0];  // 2018-12-12\nmatched[1];  // 2018\nmatched[2];  // 12\nmatched[3];  // 31\n\nconst reg = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched.groups.year;   // 2018\nmatched.groups.month;  // 12\nmatched.groups.day;    // 31\n\n\n\n# es2019\n\n * object.fromentries\n * flat 与 flatmap\n * trimstart 与 trimend\n\n\n# object.fromentries\n\n通常用于将数组转化为对象,通常可以作为 object.entries() 的反操作。\n\nconst obj = {name: '小米', skin: 'white', age: 2}\nconsole.log(object.entries(obj)); \n// [['name','小米'],['skin','white'],['age',2]]\n\nconst arr = [['name','小米'],['skin','white'],['age',2]];\nconsole.log(object.fromentries(arr));\n// {name: '小米', skin: 'white', age: 2}\n\n\n\n# flat 与 flatmap\n\nflat 常用于将多维数组降维为一维数组，可以传参数，表示降维的深度，默认是1\n\nflatmap 相当于先对数组进行map操作，然后进行flat操作\n\n[[1,2],[3,4]].flat(); // [1, 2, 3, 4]\n[[1,2],[3,4]].flatmap(i => i.reverse()) //  [2, 1, 4, 3]\n\n\n\n# trimstart 与 trimend\n\n去除字符串（前）后面的空格\n\nconst str = ' hello,es2019! ';\nconsole.log(str.trimstart().trimend()); // hello,es2019!\n\n\n\n# es2020\n\nhttps://h3manth.com/es2020/\n\n * matchall\n * 空值合并运算符\n * 可选链操作符\n * promise.allsettled\n * dynamic import\n * bigint\n\n\n# matchall\n\n// match\nconst str = 'dr. smith and dr. anderson';\nconst re = /(dr\\. )\\w+/g;\nconst res = str.match(re);  //[\"dr. smith\", \"dr. anderson\"]\n\n// matchall\nconst re = /(dr\\. )\\w+/g;\nconst str = 'dr. smith and dr. anderson';\nconst matches = str.matchall(re);\n\n// 返回的是迭代器对象需要 for...of 遍历\nfor (const match of matches) {\n  console.log(match);\n}\n\n// [\"dr. smith\", \"dr. \", index: 0, input: \"dr. smith and dr. anderson\", groups: undefined]\n// [\"dr. anderson\", \"dr. \", index: 14, input: \"dr. smith and dr. anderson\", groups: undefined]\n\n\n\n# promise.allsettled\n\n> promise.all 具有并发执行异步任务的能力。但它的最大问题就是如果参数中的任何一个promise为reject的话，则整个promise.all 调用会立即终止，并返回一个reject的新的 promise 对象。promise.allsettled 的出现就可以解决这个痛点\n\npromise.allsettled([\n  promise.reject({ code: 500, msg: '服务异常' }),\n  promise.resolve({ code: 200, list: [] }),\n  promise.resolve({ code: 200, list: [] })\n]).then(res => {\n  console.log(res)\n  /*\n        0: {status: \"rejected\", reason: {…}}\n        1: {status: \"fulfilled\", value: {…}}\n        2: {status: \"fulfilled\", value: {…}}\n   */\n})\n\n\n\n# dynamic import\n\n动态导入表达式是 ecmascript 的一个新功能，它允许你在程序的任意位置异步加载一个模块。\n\n现在前端打包资源越来越大，前端应用初始化时根本不需要全部加载这些逻辑资源，为了首屏渲染速度更快，很多时候都是动态导入（按需加载）模块，比如懒加载图片等，这样可以帮助您提高应用程序的性能。\n\n其中按需加载这些逻辑资源都一般会在某一个事件回调中去执行：\n\nel.onclick = () => {\n  import('/modules/my-module.js')\n    .then(module => {\n      // do something with the module.\n    })\n    .catch(err => {\n      // load error;\n    })\n}\n\n\n这种使用方式也支持 await 关键字。\n\nlet module = await import('/modules/my-module.js');\n\n\n\n# es2021\n\nhttps://h3manth.com/es2021/\n\n * 逻辑赋值运算符\n * replaceall\n * promise.any\n * 数值分隔符\n\n\n# 逻辑赋值运算符\n\n||=  // a ||= b 相当于 a = a || b\n&&=  // a &&= b 相当于 a = a && b\n??=  // a ??= b 相当于 a = a ?? b\n\n\n\n# replaceall\n\n// es2021 之前\n'1 2 1 2 1 2'.replace(/2/g, '0'); // '1 0 1 0 1 0'\n\n// 现在\n'1 2 1 2 1 2'.replaceall('2', '0'); // '1 0 1 0 1 0'\n\n\n\n# promise.any\n\n>  * promise.all()中的promise序列会全部执行通过才认为是成功，否则认为是失败；\n>  * promise.race()中的promise序列中第一个执行完毕的是通过，则认为成功，如果第一个执行完毕的promise是拒绝，则认为失败；\n>  * promise.any()中的promise序列只要有一个执行通过，则认为成功，如果全部拒绝，则认为失败；\n\npromise.any()适合用在通过不同路径请求同一个资源的需求上。\n\n例如，vue3.0在unpkg和jsdelivr都有在线的cdn资源，都是国外的cdn，国内直接调用不确定哪个站点会抽风，加载慢，这时候可以两个资源都请求，哪个请求先成功就使用哪一个。\n\n比方说unpkg的地址是：https://unpkg.com/vue@3.0.11/dist/vue.global.js jsdelivr的地址是：https://cdn.jsdelivr.net/npm/vue@3.0.11/dist/vue.global.js\n\nlet starttime = +new date();\nlet importunpkg = import('https://unpkg.com/vue@3.0.11/dist/vue.runtime.esm-browser.js');\nlet importjsdelivr = import('https://cdn.jsdelivr.net/npm/vue@3.0.11/dist/vue.runtime.esm-browser.js');\npromise.any([importunpkg, importjsdelivr]).then(vue => {\n  console.log('加载完毕，时间是：' + (+new date() - starttime) + 'ms');\n  console.log(vue.version);\n});\n\n\n\n# 数值分隔符\n\nconst a = 785_00;\nconst b = 1_000_000_000;\nconsole.log(a);                // 78500\nconsole.log(b);                  // 1000000000\nconsole.log(a === 78500);      // true\nconsole.log(b === 1000000000);   // true\n\n\n\n# es2022\n\nhttps://h3manth.com/es2022/\n\n * 顶层 await\n * at() 方法\n * object.hasown()\n * class 私有字段\n\n\n# 顶层 await\n\n允许开发者在 async 函数外部使用 await 字段。它就像巨大的 async 函数，原因是 import 它们的模块会等待它们开始执行它的代码。\n\n// 过去\nawait promise.resolve(console.log('🎉'));\n// → syntaxerror: await is only valid in async function\n\n(async function () {\n  await promise.resolve(console.log('🎉'));\n  // → 🎉\n})();\n\n// 现在\nawait promise.resolve(console.log('🎉'));\n\n\n以下例子尝试加载一个来自 first.com 的 javascript 模块，加载失败会有回退方案：\n\n//module.mjs\nlet module;\n\ntry {\n  module = await import('https://first.com/libs.com/module1');\n} catch {\n  module = await import('https://second.com/libs/module1');\n}\n\n\n这里 res 变量的初始值由最先结束的下载请求决定。\n\n//module.mjs\nconst respromises = [    \n    donwloadfromresource1site,\n    donwloadfromresource2site\n];\n\nconst res = await promise.any(respromises);\n\n\n\n# at() 方法\n\n在此之前我们使用方括号 ([]) 来访问数组的第 n 个元素。但是，如果我们想使用方括号访问数组末尾的第 n 个项目，我们必须使用 arr.length - n 的索引。at 方法可以解决这个问题。\n\nconst arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.at(0)); // a\nconsole.log(arr.at(-1)); // d\nconsole.log(arr.at(-2)); // c\n\n\n\n# object.hasown()\n\n在此之前，我们判断对象自身是否拥有某属性时，可以使用 hasownproperty，但是会有一些问题。\n\n// 对于使用 null 原型创建的对象尝试对其调用此方法会导致错误。\nconst obj = object.create(null);\nobj.color = 'green';\n// typeerror: obj.hasownproperty is not a function\nconsole.log(obj.hasownproperty('color'));\n\n// hasownproperty() 方法不受保护, 可以被覆盖\nconst car = {\n color: 'green',\n hasownproperty: function() {\n   return false;\n }\n}\nconsole.log(car.hasownproperty('age')); // false\n\n\n当然以上问题都可以使用 object.prototype.hasownproperty 来解决，但是我们以后可以直接用 object.hasown 来替换。\n\n如果指定的对象自身有指定的属性，则静态方法 object.hasown() 返回 true。如果属性是继承的或者不存在，该方法返回 false。\n\nconst object1 = {\n  prop: 'exists'\n};\n\nconsole.log(object.hasown(object1, 'prop'));\n// expected output: true\n\nconsole.log(object.hasown(object1, 'tostring'));\n// expected output: false\n\n\n\n# class 私有字段\n\nclass foo {\n  #iteration = 0;\n  \n  increment() {\n    this.#iteration++;\n  }\n  \n  #auditincrement() {\n    console.log('auditing');\n  }\n\n  logiteration() {\n    console.log(this.#iteration);\n  }\n}\n\nconst x = new foo();\n\nx.#iteration // error\nx.#auditincrement() // error\nx.increment(); // ✅ works\nx.logiteration(); // ✅ works\n",charsets:{cjk:!0}},{title:"ES扩展",frontmatter:{title:"ES扩展",date:"2020-11-06T09:52:01.000Z",categories:"JavaScript"},regularPath:"/javascript/ES6.html",relativePath:"javascript/ES6.md",key:"v-2e49301f",path:"/javascript/ES6.html",headers:[{level:2,title:"class",slug:"class",normalizedTitle:"class",charIndex:15},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:28},{level:3,title:"继承的时候extends干了什么",slug:"继承的时候extends干了什么",normalizedTitle:"继承的时候extends干了什么",charIndex:1845},{level:2,title:"let命令",slug:"let命令",normalizedTitle:"let命令",charIndex:2249},{level:2,title:"const命令",slug:"const命令",normalizedTitle:"const命令",charIndex:2884},{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:7704},{level:2,title:"对象字面量的增强",slug:"对象字面量的增强",normalizedTitle:"对象字面量的增强",charIndex:64},{level:2,title:"object.assign",slug:"object-assign",normalizedTitle:"object.assign",charIndex:76},{level:2,title:"object.is",slug:"object-is",normalizedTitle:"object.is",charIndex:8292},{level:2,title:"Map数据结构",slug:"map数据结构",normalizedTitle:"map数据结构",charIndex:93},{level:2,title:"Set数据结构",slug:"set数据结构",normalizedTitle:"set数据结构",charIndex:104},{level:2,title:"Symbol",slug:"symbol",normalizedTitle:"symbol",charIndex:115},{level:2,title:"forEach、find、map、filter、reduce、every、some",slug:"foreach、find、map、filter、reduce、every、some",normalizedTitle:"foreach、find、map、filter、reduce、every、some",charIndex:129},{level:2,title:"Array.from",slug:"array-from",normalizedTitle:"array.from",charIndex:174},{level:3,title:"从 String 生成数组",slug:"从-string-生成数组",normalizedTitle:"从 string 生成数组",charIndex:11151},{level:3,title:"从 Set 生成数组",slug:"从-set-生成数组",normalizedTitle:"从 set 生成数组",charIndex:11223},{level:3,title:"从 Map 生成数组",slug:"从-map-生成数组",normalizedTitle:"从 map 生成数组",charIndex:11335},{level:3,title:"从类数组对象（arguments）生成数组",slug:"从类数组对象-arguments-生成数组",normalizedTitle:"从类数组对象（arguments）生成数组",charIndex:11582},{level:3,title:"在 Array.from 中使用箭头函数",slug:"在-array-from-中使用箭头函数",normalizedTitle:"在 array.from 中使用箭头函数",charIndex:11688},{level:3,title:"初始化二维数组",slug:"初始化二维数组",normalizedTitle:"初始化二维数组",charIndex:12048},{level:2,title:"Array.of",slug:"array-of",normalizedTitle:"array.of",charIndex:12114}],lastUpdated:"12/7/2022, 2:52:13 PM",lastUpdatedTimestamp:1670395933e3,headersStr:"class 继承 继承的时候extends干了什么 let命令 const命令 模板字符串 对象字面量的增强 object.assign object.is Map数据结构 Set数据结构 Symbol forEach、find、map、filter、reduce、every、some Array.from 从 String 生成数组 从 Set 生成数组 从 Map 生成数组 从类数组对象（arguments）生成数组 在 Array.from 中使用箭头函数 初始化二维数组 Array.of",content:"# ES扩展\n\n * ES6的class\n * ES6的继承，extend与super\n * ES6的let与const\n * 对象字面量的增强\n * object.assign\n * Map数据结构\n * Set数据结构\n * Symbol可作为键\n * forEach、find、map、filter、reduce、every、some\n * Array.from\n\n\n# class\n\nclass Person{//定义了一个名字为Person的类\n    constructor(name,age){//constructor是一个构造方法，用来接收参数\n        this.name = name;//this代表的是实例对象\n        this.age = age;\n    }\n    say(){//这是一个类的方法，注意千万不要加上function\n        return \"我的名字叫\" + this.name+\"今年\"+this.age+\"岁了\";\n    }\n}\nvar obj=new Person(\"laotie\",88);\nconsole.log(obj.say());//我的名字叫laotie今年88岁了\nconsole.log(typeof Person);//function\nconsole.log(Person===Person.prototype.constructor);//true\n\n//实际上类的所有方法都定义在类的prototype属性上。\n//还可以通过Object.assign方法来为对象动态增加方法\nObject.assign(Person.prototype,{\n    getName:function(){\n        return this.name;\n    },\n    getAge:function(){\n        return this.age;\n    }\n})\nvar obj=new Person(\"laotie\",88);\nconsole.log(obj.getName());//laotie\nconsole.log(obj.getAge());//88\n\n//constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用该方法。\nclass Box{\n    constructor(){\n        console.log(\"啦啦啦，今天天气好晴朗\");//当实例化对象时该行代码会执行。\n    }\n}\nvar obj=new Box();\n\n//类的所有实例共享一个原型对象，它们的原型都是Person.prototype，所以proto属性是相等的\nclass Box{\n    constructor(num1,num2){\n        this.num1 = num1;\n        this.num2 = num2;\n    }\n    sum(){\n        return num1+num2;\n    }\n}\n//box1与box2都是Box的实例。它们的__proto__都指向Box的prototype\nvar box1=new Box(12,88);\nvar box2=new Box(40,60);\nconsole.log(box1.__proto__===box2.__proto__);//true\n//由此，也可以通过proto来为类增加方法。使用实例的proto属性改写原型，会改变Class的原始定义，影响到所有实例，所以不推荐使用！\n\n\n\n# 继承\n\nclass b extends a{\n    constructor(x, y, z) {\n        super(x, y);//要在this的前面\n        this.z = z;\n    }\n    toString2(){\n        return super.toString()+' '+this.z\n    }\n}\n//super表示父类的构造函数，并且子类的构造函数必须执行一次super\n//`super()`相当于`a.prototype.constructor.call(this)`\n\n\n * super完成了调用父类构造函数，extends实现了原型链的继承，本质上和ES5是一样的\n\n\n# 继承的时候extends干了什么\n\nextends在实现继承方面，本质上也是原型链继承,该方法实现了两步原型链继承 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。 Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n * （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。（把子类构造函数(Child)的原型(__proto__)指向了父类构造函数(Parent)，）\n * （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n * ES5继承\n * ES6继承\n\nES5只有两种声明变量的方式：var和function，ES6还添加了两种常用的声明变量的方式：let和const。\n\n\n# let命令\n\nES6新增了let命令，用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\n\n1、for循环的计数器，就很合适使用let。\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n\ta[i] = function() {\n\t\tconsole.log(i);\n\t}\n}\na[6](); // 10\n\n\n变量i是var声明的，在全局范围内有效，所以每次循环新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n\ta[i] = function() {\n\t\tconsole.log(i);\n\t}\n}\na[5](); // 5\n\n\n使用let，声明的变量仅在块级作用域内有效，最后输出的是5。\n\n2、let不存在变量提升：let不像var那样会发生变量提升，所以，变量一定要在声明后使用，否则报错。\n\nconsole.log(i); // 输出：undefined\nconsole.log(j); // 报错\nvar i = 5;\nlet j = 10;\n\n\n3、暂时性死区：\n\n只要块级作用域存在let命令，它所声明的变量就绑定到这个区域，不再受外部的影响。\n\nvar i= 6;\nif (i > 5) {\n\ti = 3; // 报错\n\tlet i;\n}\n\n\nES6明确规定，若块作用域中存在let和const命令，则它们声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量，就会报错。\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的（不可赋值，不可访问等），这称为“暂时性死区”。\n\n暂时性死区使得typeof操作不一定安全，所以在let声明之前，使用typeof操作符会报错。而在let出现之前，typeof是百分之百安全的，永远不会被报错，即使变量没有被声明，typeof也会返回undefined。\n\nif (true) {\n\talert(typeof x); // 报错\n\talert(typeof y); // undefined\n\tlet x;\n}\n\n\n暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\nES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止变量在声明前就使用该变量，从而导致意料之外的错误。这类错误在ES5中很常见。\n\n4、不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\nfunction func() { // 报错\n\tvar i= 1;\n\tlet i = 1;\n}\nfunction func() { // 报错\n\tlet i= 1;\n\tlet i = 1;\n}\n\n\n不能在函数内部重新声明参数。\n\nfunction func(arg) { // 报错\n\tlet arg;\n}\nfunction func(arg) { // 不报错\n\t{\n\t\tlet arg;\n\t}\n}\n\n\n\n# const命令\n\nconst声明一个只读的常量，一旦声明，常量的值就不能改变，这意味着，const一旦声明常量，就必须立即初始化，不能等到之后再赋值。因此，改变常量和只声明不赋初始值都会报错。\n\nconst的作用域与let命令相同，只在声明所在的块级作用域内有效。\n\nif (true) {\n\tconst i = 5;\n}\nconsole.log(i); // 报错\n\n\nconst声明的常量也不提升，同时存在暂时性死区，只能在声明的位置后面使用。\n\nif (true) {\n\tconsole.log(i); // 报错\n\tconst i = 5;\n}\n\n\nconst声明的常量，也和let一样不可重复声明。\n\nvar i = 5;\nlet j = 10;\nconst i =6; // 报错\nconst j = 11; // 报错\n\n\n对于复合类型的常量，常量名不指向数据，而是指向数据所在的地址。const命令只是保证常量名指向的地址不变，并不保证该地址的数据不变，也就是说，将对象常量指向另一个地址会报错，但对象本身是可变的，可以为其添加，修改属性，因此将一个对象声明为常量必须十分小心。\n\nconst obj = {};\nobj.name = “Alice”;\nobj = {}; // 报错\n\n\n将一个数组声明为常量，该数组本身是可写的，但是若将另一个数组赋值给该数组，会报错。\n\nconst arr = [];\narr.push(1);\narr = [1,2,3,4]; // 报错\n\n\n转载自https://blog.csdn.net/zhouziyu2011/article/details/68067609\n\n不用var，主用const，配合let\n主用const的好处是用于判断变量是否需要更改\n\n\n----------------------------------------\n\n * 箭头函数\n\n//不需要 function 关键字来创建函数\n//省略 return 关键字\n//继承当前上下文的 this 关键字\n\n// ES5\n[1,2,3].map((function(x){  //map方法返回一个由原数组中的每个元素调用指定方法后的返回值组成的新数组。\n    return x + 1;\n}).bind(this));\n\n//array.map(function() {}, this) 的作用实际上和 array.map(function() {}.bind(this)) 是一样的。map的第二个参数就是给第一个参数bind一个对象。\n    \n// 使用箭头函数\n[1,2,3].map(x => x + 1);\n\n\n * 函数默认参数值\n\n// ES6之前，当未传入参数时，text = 'default'；\nfunction printText(text) {\n    text = text || 'default';\n    console.log(text);\n}\n\n// ES6；\nfunction printText(text = 'default') {\n    console.log(text);\n}\n\n// 有多个参数时，带默认值的要放到最后\n\n\n * 扩展运算符(spread)和剩余运算符(rest)，即...的含义\n\n//扩展运算符(spread)   数组化为参数,功能是把数组或类数组对象展开成一系列用逗号隔开的值\n\n//1.构造数组\nvar arr1 = ['a','b','c'];\nvar arr2 = ['aa','bb','cc'];\nvar arrs = [...arr1, ...arr2];\nconsole.log(arrs); // ['a','b','c','aa','bb','cc']\n//2.解析数组\nvar son1,son2;\n[son1, ...son2] = arr1\nconsole.log(son1);  // 'a'\nconsole.log(son2);  //['b','c']\n//3.参数赋值\nconst arr = [2,3,1,5];\nconst maxNum = Math.max(...arr); // 返回5。max函数不接受数组只接受数列\n\n\n//剩余运算符(rest)     参数转化为数组,把逗号隔开的值序列组合成一个数组\n//1.所有参数可由一个变量统一接收\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\nfoo( 'a', 'b', 'c'); // [a,b,c]\n\n\n * 对象和数组解构\n\n//1.对象\nvar obj = {x: 1, y: 2, z: 3};\nconst {x, y, z} = obj; // x = 1, y = 2, z = 3\n//还可赋值a,b,c\nconst {x: a, y: b, z: c} = obj; // a = 1, b = 2, c = 3\n\n//2.数组\nconst arr = [1, 2, 3, 4, 5, 6]\nconst [a, b] = arr;\nconsole.log(a, b);  // 1, 2，按顺序自动获取\nconst [a, b,,, c] = arr;\nconsole.log(a, b, c);  // 1, 2, 5  获取指定位置\n\n//3.函数对象参数\nconst student = {\n  name: 'Job',\n  num: 001,\n  age: 18,\n  sex: 'boy'\n};\nconst check = function half({num,sex}) {\n    return (num , sex);\n};\nconsole.log(student); // 一个object\nconsole.log(check(student)); // (001, 'boy')\n\n\n * Map数据结构\n\n为什么需要Map，因为Object本质上是键值对的集合，Object的键在使用Object.keys输出时都转化为了字符串，如果键为对象则都转化为[object, Object]，但是Map的键不限。\n\n与Object的区别\n\n（1）Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。\n\n（2）你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。\n\n//Map的结构遍历\n// 1. keys()--\x3e将键名都取出来，组成一个可遍历的数据集合\nlet m = new Map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nfor(let x of m.keys()){  //m.keys => MapIterator {123, \"a\", false}  返回容器对象\n   console.log(x);\n}\n--\x3e123 a false\n\n//2. values()  返回键值的遍历器\nlet m = new Map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nfor(let x of m.values()){  //m.values=>MapIterator {\"abc\", \"hahaha\", \"baidu.com\"}\n   console.log(x);\n}\n--\x3eabc hahaha baidu.com\n\n//3. entries()  返回所有成员的遍历器\nlet m = new Map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nm.entries()   //MapIterator {123 => \"abc\", \"a\" => \"hahaha\", false => \"baidu.com\"}\n[...m.entries()] // [Array(2), Array(2), Array(2)]\n\n//4. 扩展运算符,转换为二维数组或一维数组\nlet m = new Map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nconsole.log([...m]) //(3) [Array(2), Array(2), Array(2)]\n[...m.keys()]       //[123, \"a\", false]\n\n\n * 数组的include方法\n\n在ES5，Array已经提供了indexOf用来查找某个元素的位置，如果不存在就返回-1，\n\n缺点：\n\n 1. 是它会返回-1和元素的位置来表示是否包含，在定位方面是没问题，就是不够语义化。\n\n 2. 不能判断是否有NaN的元素。\n\nES6提供了Array.includes()函数判断是否包含某一元素，除了不能定位外，解决了indexOf的上述的两个问题。它直接返回true或者false表示是否包含元素，对NaN一样能有有效。\n\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n[1, 2, 3].includes(3, 3);  // false  该方法的第二个参数表示搜索的起始位置，默认为0\n[1, 2, 3].includes(3, -1); // true\n\n\n\n# 模板字符串\n\n// 模板字符串前面可以添加标签\n\nconst name = 'tom'\nconst gender = true\n\nfunction myTagFunc (strings, name, gender) {\n    console.log(strings, name, gender)\n}\n\nconst result = myTagFuc`hey, ${name} is a ${gender}`\nconsole.log(result)\n\n\n\n# 对象字面量的增强\n\nconst bar = '345'\nconst obj = {\n    foo: 123\n    bar,                 // bar: bar\n    method1 () {         // 省略了 :function\n    \tconsole.log(1)   \n\t}\n\t[Math.random()]: 123 // 计算属性，加上方括号，可以为一个随机的值\n}\n\n\n * 对象初始化\n\n\n# object.assign\n\nconst source = {\n    a: 123,\n    b: 123\n}\n\nconst target = {\n    a: 456,\n    c: 456\n}\n\nObject.assign(target,source)\n\n\n\n# object.is\n\n+0 === -0 // true\nNaN === NaN // false\n\nobject.is(+0, -0) //false\nObject.is(NaN, NaN) // true\n\n\nObject.is() 方法判断两个值是否为同一个值。如果满足以下条件则两个值相等:\n\n * 都是 undefined\n * 都是 null\n * 都是 true 或 false\n * 都是相同长度的字符串且相同字符按相同顺序排列\n * 都是相同对象（意味着每个对象有同一个引用）\n * 都是数字且\n   * 都是 +0\n   * 都是 -0\n   * 都是 NaN\n   * 或都是非零而且非 NaN 且为同一个值\n\n与== 运算不同。 == 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 \"\" == false 判断为 true), 而 Object.is不会强制转换两边的值。\n\n与=== 运算也不相同。 === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将Number.NaN 与NaN视为不相等.\n\n\n# Map数据结构\n\nWhen You Should Prefer Map Over Object In JavaScript\n\nObject 相比于 Map 的缺点：\n\n * 原型污染：Object 会自动继承原型上的方法，如 hasOwnProperty,如果在对象本身定义了相同的方法，则无法区分方法是原型上的还是对象本身的。当然也可以使用 Object.create(null)来创建不会继承的对象。\n * 命名冲突：对象自己的属性可能会和原型上的属性冲突，此时我们需要用 Object.prototype.hasOwnProperty.call(obj, key) 来确定原型是否在对象本身，当然现在也可以用 Object.hasOwn。\n * 获取大小：没有直接获取 size 的 api，但是可以使用Object.keys, Object.values 和 Object.entries，获取对应数组。\n * 不可迭代：不能使用for...of迭代，但是可以使用Object.keys, Object.values 和 Object.entries，获取对应数组再进行迭代。\n * 清空对象：只能使用 delete 来逐个删除属性，相比于 Map.prototype.delete 要慢的很。\n * 检查属性：不能使用点运算和括号运算符来判断属性是否存在，因为属性可以被设置为 undefined，要使用Object.prototype.hasOwnProperty 或者 Object.hasOwn。\n\nMap 的优点：\n\n * 键可以为任意数据类型\n * 用户定义的属性和结构本身属性有明确的分离，Map.prototype.get 来获取用户定义的属性\n * 可以迭代，也可以进行解构：const [[firstKey, firstValue]] = map\n * 便捷的 api：Map.prototype.has,Map.prototype.get,Map.prototype.size,Map.prototype.clear\n * 性能更好\n\n\n# Set数据结构\n\nconst s = new Set()\ns.add(1).add(2)\n\nconsole.log(s.size)\nconsole.log(s.has(100))\nconsole.log(s.delete(3))\ns.clear()\n\n\n\n# Symbol\n\nconst obj = {\n    [Symbol()]: 'symbol value',\n    foo: 'value'\n}\n\n// 用for in, Object.keys, JSON.stringify都获取不到\n\n\n\n# forEach、find、map、filter、reduce、every、some\n\n# 1、forEach 没有返回值，只是让数组中的每个元素执行function的操作\n\nlet arr = [1,2,3,4,5];\narr.forEach((item,index)=>{\n    console.log(item * 2);       //2,4,6,8,10\n})\n\n\n# 2、find 返回数组中第一个满足条件的元素（查找）\n\nlet arr = [1,2,3,4,5];\narr.find((item,index)=>{\n    return item > 3;       //4\n})\n\n\n# 3、map 返回一个新数组，数组中的每个元素为调用function的结果\n\nlet arr = [1,2,3,4,5];\narr.map((item,index)=>{\n    return item * 2;       //[2,4,6,8,10]\n})\n\n\n# 4、filter 返回一个符合function条件的元素数组（过滤）\n\nlet arr = [1,2,3,4,5];\narr.filter((item,index)=>{\n    return item > 3;       //[4,5]\n})\n\n\n# 5、reduce 让数组中的前项和后项做某种运算，返回累计的最终值\n\nlet arr = [1,2,3,4,5];\narr.reduce((prev,next)=>{\n    return prev + next;       //15\n})\n\n\n# 6、every 返回一个Boolean值，判断数组中每一个元素是否符合function的条件\n\nlet arr = [1,2,3,4,5];\narr.every((item,index)=>{\n    return item > 0;       //true(所有元素都满足才为true)\n})\n\n\n# 7、some 返回一个Boolean值，判断数组中是否有元素符合function的条件\n\nlet arr = [1,2,3,4,5];\narr.some((item,index)=>{\n    return item > 4;       //true(只要有一个满足即可)\n})\n\n\n\n# Array.from\n\n将一个类数组对象或者可遍历对象转换成一个真正的数组。\n\n * 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。\n * 该类数组对象的属性名必须为数值型或字符串型的数字\n * 该类数组对象的属性名可以加引号，也可以不加引号\n * Array.from可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n\n# 从 String 生成数组\n\nArray.from('foo');\n// [ \"f\", \"o\", \"o\" ], 可以代替 split\n\n\n\n# 从 Set 生成数组\n\nconst set = new Set(['foo', 'bar', 'baz', 'foo']);\nArray.from(set);\n// [ \"foo\", \"bar\", \"baz\" ]\n\n\n\n# 从 Map 生成数组\n\nconst map = new Map([[1, 2], [2, 4], [4, 8]]);\nArray.from(map);\n// [[1, 2], [2, 4], [4, 8]]\n\nconst mapper = new Map([['1', 'a'], ['2', 'b']]);\nArray.from(mapper.values());\n// ['a', 'b'];\n\nArray.from(mapper.keys());\n// ['1', '2'];\n\n\n\n# 从类数组对象（arguments）生成数组\n\nfunction f() {\n  return Array.from(arguments);\n}\n\nf(1, 2, 3);\n\n// [ 1, 2, 3 ]\n\n\n\n# 在 Array.from 中使用箭头函数\n\n// Using an arrow function as the map function to\n// manipulate the elements\nArray.from([1, 2, 3], x => x + x);\n// [2, 4, 6]\n\n\n// Generate a sequence of numbers\n// Since the array is initialized with `undefined` on each position,\n// the value of `v` below will be `undefined`\nArray.from({length: 5}, (v, i) => i);\n// [0, 1, 2, 3, 4]\n\n\n\n# 初始化二维数组\n\nArray.from(new Array(m),()=>(new Array(n).fill(0)))\n\n\n\n# Array.of\n\nArray.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\n\nArray.of(7);       // [7]\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]\n",normalizedContent:"# es扩展\n\n * es6的class\n * es6的继承，extend与super\n * es6的let与const\n * 对象字面量的增强\n * object.assign\n * map数据结构\n * set数据结构\n * symbol可作为键\n * foreach、find、map、filter、reduce、every、some\n * array.from\n\n\n# class\n\nclass person{//定义了一个名字为person的类\n    constructor(name,age){//constructor是一个构造方法，用来接收参数\n        this.name = name;//this代表的是实例对象\n        this.age = age;\n    }\n    say(){//这是一个类的方法，注意千万不要加上function\n        return \"我的名字叫\" + this.name+\"今年\"+this.age+\"岁了\";\n    }\n}\nvar obj=new person(\"laotie\",88);\nconsole.log(obj.say());//我的名字叫laotie今年88岁了\nconsole.log(typeof person);//function\nconsole.log(person===person.prototype.constructor);//true\n\n//实际上类的所有方法都定义在类的prototype属性上。\n//还可以通过object.assign方法来为对象动态增加方法\nobject.assign(person.prototype,{\n    getname:function(){\n        return this.name;\n    },\n    getage:function(){\n        return this.age;\n    }\n})\nvar obj=new person(\"laotie\",88);\nconsole.log(obj.getname());//laotie\nconsole.log(obj.getage());//88\n\n//constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用该方法。\nclass box{\n    constructor(){\n        console.log(\"啦啦啦，今天天气好晴朗\");//当实例化对象时该行代码会执行。\n    }\n}\nvar obj=new box();\n\n//类的所有实例共享一个原型对象，它们的原型都是person.prototype，所以proto属性是相等的\nclass box{\n    constructor(num1,num2){\n        this.num1 = num1;\n        this.num2 = num2;\n    }\n    sum(){\n        return num1+num2;\n    }\n}\n//box1与box2都是box的实例。它们的__proto__都指向box的prototype\nvar box1=new box(12,88);\nvar box2=new box(40,60);\nconsole.log(box1.__proto__===box2.__proto__);//true\n//由此，也可以通过proto来为类增加方法。使用实例的proto属性改写原型，会改变class的原始定义，影响到所有实例，所以不推荐使用！\n\n\n\n# 继承\n\nclass b extends a{\n    constructor(x, y, z) {\n        super(x, y);//要在this的前面\n        this.z = z;\n    }\n    tostring2(){\n        return super.tostring()+' '+this.z\n    }\n}\n//super表示父类的构造函数，并且子类的构造函数必须执行一次super\n//`super()`相当于`a.prototype.constructor.call(this)`\n\n\n * super完成了调用父类构造函数，extends实现了原型链的继承，本质上和es5是一样的\n\n\n# 继承的时候extends干了什么\n\nextends在实现继承方面，本质上也是原型链继承,该方法实现了两步原型链继承 大多数浏览器的 es5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。 class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n * （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。（把子类构造函数(child)的原型(__proto__)指向了父类构造函数(parent)，）\n * （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n * es5继承\n * es6继承\n\nes5只有两种声明变量的方式：var和function，es6还添加了两种常用的声明变量的方式：let和const。\n\n\n# let命令\n\nes6新增了let命令，用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\n\n1、for循环的计数器，就很合适使用let。\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n\ta[i] = function() {\n\t\tconsole.log(i);\n\t}\n}\na[6](); // 10\n\n\n变量i是var声明的，在全局范围内有效，所以每次循环新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n\ta[i] = function() {\n\t\tconsole.log(i);\n\t}\n}\na[5](); // 5\n\n\n使用let，声明的变量仅在块级作用域内有效，最后输出的是5。\n\n2、let不存在变量提升：let不像var那样会发生变量提升，所以，变量一定要在声明后使用，否则报错。\n\nconsole.log(i); // 输出：undefined\nconsole.log(j); // 报错\nvar i = 5;\nlet j = 10;\n\n\n3、暂时性死区：\n\n只要块级作用域存在let命令，它所声明的变量就绑定到这个区域，不再受外部的影响。\n\nvar i= 6;\nif (i > 5) {\n\ti = 3; // 报错\n\tlet i;\n}\n\n\nes6明确规定，若块作用域中存在let和const命令，则它们声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量，就会报错。\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的（不可赋值，不可访问等），这称为“暂时性死区”。\n\n暂时性死区使得typeof操作不一定安全，所以在let声明之前，使用typeof操作符会报错。而在let出现之前，typeof是百分之百安全的，永远不会被报错，即使变量没有被声明，typeof也会返回undefined。\n\nif (true) {\n\talert(typeof x); // 报错\n\talert(typeof y); // undefined\n\tlet x;\n}\n\n\n暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\nes6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止变量在声明前就使用该变量，从而导致意料之外的错误。这类错误在es5中很常见。\n\n4、不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\nfunction func() { // 报错\n\tvar i= 1;\n\tlet i = 1;\n}\nfunction func() { // 报错\n\tlet i= 1;\n\tlet i = 1;\n}\n\n\n不能在函数内部重新声明参数。\n\nfunction func(arg) { // 报错\n\tlet arg;\n}\nfunction func(arg) { // 不报错\n\t{\n\t\tlet arg;\n\t}\n}\n\n\n\n# const命令\n\nconst声明一个只读的常量，一旦声明，常量的值就不能改变，这意味着，const一旦声明常量，就必须立即初始化，不能等到之后再赋值。因此，改变常量和只声明不赋初始值都会报错。\n\nconst的作用域与let命令相同，只在声明所在的块级作用域内有效。\n\nif (true) {\n\tconst i = 5;\n}\nconsole.log(i); // 报错\n\n\nconst声明的常量也不提升，同时存在暂时性死区，只能在声明的位置后面使用。\n\nif (true) {\n\tconsole.log(i); // 报错\n\tconst i = 5;\n}\n\n\nconst声明的常量，也和let一样不可重复声明。\n\nvar i = 5;\nlet j = 10;\nconst i =6; // 报错\nconst j = 11; // 报错\n\n\n对于复合类型的常量，常量名不指向数据，而是指向数据所在的地址。const命令只是保证常量名指向的地址不变，并不保证该地址的数据不变，也就是说，将对象常量指向另一个地址会报错，但对象本身是可变的，可以为其添加，修改属性，因此将一个对象声明为常量必须十分小心。\n\nconst obj = {};\nobj.name = “alice”;\nobj = {}; // 报错\n\n\n将一个数组声明为常量，该数组本身是可写的，但是若将另一个数组赋值给该数组，会报错。\n\nconst arr = [];\narr.push(1);\narr = [1,2,3,4]; // 报错\n\n\n转载自https://blog.csdn.net/zhouziyu2011/article/details/68067609\n\n不用var，主用const，配合let\n主用const的好处是用于判断变量是否需要更改\n\n\n----------------------------------------\n\n * 箭头函数\n\n//不需要 function 关键字来创建函数\n//省略 return 关键字\n//继承当前上下文的 this 关键字\n\n// es5\n[1,2,3].map((function(x){  //map方法返回一个由原数组中的每个元素调用指定方法后的返回值组成的新数组。\n    return x + 1;\n}).bind(this));\n\n//array.map(function() {}, this) 的作用实际上和 array.map(function() {}.bind(this)) 是一样的。map的第二个参数就是给第一个参数bind一个对象。\n    \n// 使用箭头函数\n[1,2,3].map(x => x + 1);\n\n\n * 函数默认参数值\n\n// es6之前，当未传入参数时，text = 'default'；\nfunction printtext(text) {\n    text = text || 'default';\n    console.log(text);\n}\n\n// es6；\nfunction printtext(text = 'default') {\n    console.log(text);\n}\n\n// 有多个参数时，带默认值的要放到最后\n\n\n * 扩展运算符(spread)和剩余运算符(rest)，即...的含义\n\n//扩展运算符(spread)   数组化为参数,功能是把数组或类数组对象展开成一系列用逗号隔开的值\n\n//1.构造数组\nvar arr1 = ['a','b','c'];\nvar arr2 = ['aa','bb','cc'];\nvar arrs = [...arr1, ...arr2];\nconsole.log(arrs); // ['a','b','c','aa','bb','cc']\n//2.解析数组\nvar son1,son2;\n[son1, ...son2] = arr1\nconsole.log(son1);  // 'a'\nconsole.log(son2);  //['b','c']\n//3.参数赋值\nconst arr = [2,3,1,5];\nconst maxnum = math.max(...arr); // 返回5。max函数不接受数组只接受数列\n\n\n//剩余运算符(rest)     参数转化为数组,把逗号隔开的值序列组合成一个数组\n//1.所有参数可由一个变量统一接收\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\nfoo( 'a', 'b', 'c'); // [a,b,c]\n\n\n * 对象和数组解构\n\n//1.对象\nvar obj = {x: 1, y: 2, z: 3};\nconst {x, y, z} = obj; // x = 1, y = 2, z = 3\n//还可赋值a,b,c\nconst {x: a, y: b, z: c} = obj; // a = 1, b = 2, c = 3\n\n//2.数组\nconst arr = [1, 2, 3, 4, 5, 6]\nconst [a, b] = arr;\nconsole.log(a, b);  // 1, 2，按顺序自动获取\nconst [a, b,,, c] = arr;\nconsole.log(a, b, c);  // 1, 2, 5  获取指定位置\n\n//3.函数对象参数\nconst student = {\n  name: 'job',\n  num: 001,\n  age: 18,\n  sex: 'boy'\n};\nconst check = function half({num,sex}) {\n    return (num , sex);\n};\nconsole.log(student); // 一个object\nconsole.log(check(student)); // (001, 'boy')\n\n\n * map数据结构\n\n为什么需要map，因为object本质上是键值对的集合，object的键在使用object.keys输出时都转化为了字符串，如果键为对象则都转化为[object, object]，但是map的键不限。\n\n与object的区别\n\n（1）map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，map 对象是按插入的顺序返回键值。\n\n（2）你可以通过 size 属性直接获取一个 map 的键值对个数，而 object 的键值对个数只能手动计算。\n\n//map的结构遍历\n// 1. keys()--\x3e将键名都取出来，组成一个可遍历的数据集合\nlet m = new map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nfor(let x of m.keys()){  //m.keys => mapiterator {123, \"a\", false}  返回容器对象\n   console.log(x);\n}\n--\x3e123 a false\n\n//2. values()  返回键值的遍历器\nlet m = new map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nfor(let x of m.values()){  //m.values=>mapiterator {\"abc\", \"hahaha\", \"baidu.com\"}\n   console.log(x);\n}\n--\x3eabc hahaha baidu.com\n\n//3. entries()  返回所有成员的遍历器\nlet m = new map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nm.entries()   //mapiterator {123 => \"abc\", \"a\" => \"hahaha\", false => \"baidu.com\"}\n[...m.entries()] // [array(2), array(2), array(2)]\n\n//4. 扩展运算符,转换为二维数组或一维数组\nlet m = new map([\n   [123,'abc'],\n   ['a','hahaha'],\n   [1>2,'baidu.com']\n]);\nconsole.log([...m]) //(3) [array(2), array(2), array(2)]\n[...m.keys()]       //[123, \"a\", false]\n\n\n * 数组的include方法\n\n在es5，array已经提供了indexof用来查找某个元素的位置，如果不存在就返回-1，\n\n缺点：\n\n 1. 是它会返回-1和元素的位置来表示是否包含，在定位方面是没问题，就是不够语义化。\n\n 2. 不能判断是否有nan的元素。\n\nes6提供了array.includes()函数判断是否包含某一元素，除了不能定位外，解决了indexof的上述的两个问题。它直接返回true或者false表示是否包含元素，对nan一样能有有效。\n\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, nan].includes(nan) // true\n[1, 2, 3].includes(3, 3);  // false  该方法的第二个参数表示搜索的起始位置，默认为0\n[1, 2, 3].includes(3, -1); // true\n\n\n\n# 模板字符串\n\n// 模板字符串前面可以添加标签\n\nconst name = 'tom'\nconst gender = true\n\nfunction mytagfunc (strings, name, gender) {\n    console.log(strings, name, gender)\n}\n\nconst result = mytagfuc`hey, ${name} is a ${gender}`\nconsole.log(result)\n\n\n\n# 对象字面量的增强\n\nconst bar = '345'\nconst obj = {\n    foo: 123\n    bar,                 // bar: bar\n    method1 () {         // 省略了 :function\n    \tconsole.log(1)   \n\t}\n\t[math.random()]: 123 // 计算属性，加上方括号，可以为一个随机的值\n}\n\n\n * 对象初始化\n\n\n# object.assign\n\nconst source = {\n    a: 123,\n    b: 123\n}\n\nconst target = {\n    a: 456,\n    c: 456\n}\n\nobject.assign(target,source)\n\n\n\n# object.is\n\n+0 === -0 // true\nnan === nan // false\n\nobject.is(+0, -0) //false\nobject.is(nan, nan) // true\n\n\nobject.is() 方法判断两个值是否为同一个值。如果满足以下条件则两个值相等:\n\n * 都是 undefined\n * 都是 null\n * 都是 true 或 false\n * 都是相同长度的字符串且相同字符按相同顺序排列\n * 都是相同对象（意味着每个对象有同一个引用）\n * 都是数字且\n   * 都是 +0\n   * 都是 -0\n   * 都是 nan\n   * 或都是非零而且非 nan 且为同一个值\n\n与== 运算不同。 == 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 \"\" == false 判断为 true), 而 object.is不会强制转换两边的值。\n\n与=== 运算也不相同。 === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将number.nan 与nan视为不相等.\n\n\n# map数据结构\n\nwhen you should prefer map over object in javascript\n\nobject 相比于 map 的缺点：\n\n * 原型污染：object 会自动继承原型上的方法，如 hasownproperty,如果在对象本身定义了相同的方法，则无法区分方法是原型上的还是对象本身的。当然也可以使用 object.create(null)来创建不会继承的对象。\n * 命名冲突：对象自己的属性可能会和原型上的属性冲突，此时我们需要用 object.prototype.hasownproperty.call(obj, key) 来确定原型是否在对象本身，当然现在也可以用 object.hasown。\n * 获取大小：没有直接获取 size 的 api，但是可以使用object.keys, object.values 和 object.entries，获取对应数组。\n * 不可迭代：不能使用for...of迭代，但是可以使用object.keys, object.values 和 object.entries，获取对应数组再进行迭代。\n * 清空对象：只能使用 delete 来逐个删除属性，相比于 map.prototype.delete 要慢的很。\n * 检查属性：不能使用点运算和括号运算符来判断属性是否存在，因为属性可以被设置为 undefined，要使用object.prototype.hasownproperty 或者 object.hasown。\n\nmap 的优点：\n\n * 键可以为任意数据类型\n * 用户定义的属性和结构本身属性有明确的分离，map.prototype.get 来获取用户定义的属性\n * 可以迭代，也可以进行解构：const [[firstkey, firstvalue]] = map\n * 便捷的 api：map.prototype.has,map.prototype.get,map.prototype.size,map.prototype.clear\n * 性能更好\n\n\n# set数据结构\n\nconst s = new set()\ns.add(1).add(2)\n\nconsole.log(s.size)\nconsole.log(s.has(100))\nconsole.log(s.delete(3))\ns.clear()\n\n\n\n# symbol\n\nconst obj = {\n    [symbol()]: 'symbol value',\n    foo: 'value'\n}\n\n// 用for in, object.keys, json.stringify都获取不到\n\n\n\n# foreach、find、map、filter、reduce、every、some\n\n# 1、foreach 没有返回值，只是让数组中的每个元素执行function的操作\n\nlet arr = [1,2,3,4,5];\narr.foreach((item,index)=>{\n    console.log(item * 2);       //2,4,6,8,10\n})\n\n\n# 2、find 返回数组中第一个满足条件的元素（查找）\n\nlet arr = [1,2,3,4,5];\narr.find((item,index)=>{\n    return item > 3;       //4\n})\n\n\n# 3、map 返回一个新数组，数组中的每个元素为调用function的结果\n\nlet arr = [1,2,3,4,5];\narr.map((item,index)=>{\n    return item * 2;       //[2,4,6,8,10]\n})\n\n\n# 4、filter 返回一个符合function条件的元素数组（过滤）\n\nlet arr = [1,2,3,4,5];\narr.filter((item,index)=>{\n    return item > 3;       //[4,5]\n})\n\n\n# 5、reduce 让数组中的前项和后项做某种运算，返回累计的最终值\n\nlet arr = [1,2,3,4,5];\narr.reduce((prev,next)=>{\n    return prev + next;       //15\n})\n\n\n# 6、every 返回一个boolean值，判断数组中每一个元素是否符合function的条件\n\nlet arr = [1,2,3,4,5];\narr.every((item,index)=>{\n    return item > 0;       //true(所有元素都满足才为true)\n})\n\n\n# 7、some 返回一个boolean值，判断数组中是否有元素符合function的条件\n\nlet arr = [1,2,3,4,5];\narr.some((item,index)=>{\n    return item > 4;       //true(只要有一个满足即可)\n})\n\n\n\n# array.from\n\n将一个类数组对象或者可遍历对象转换成一个真正的数组。\n\n * 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。\n * 该类数组对象的属性名必须为数值型或字符串型的数字\n * 该类数组对象的属性名可以加引号，也可以不加引号\n * array.from可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n\n# 从 string 生成数组\n\narray.from('foo');\n// [ \"f\", \"o\", \"o\" ], 可以代替 split\n\n\n\n# 从 set 生成数组\n\nconst set = new set(['foo', 'bar', 'baz', 'foo']);\narray.from(set);\n// [ \"foo\", \"bar\", \"baz\" ]\n\n\n\n# 从 map 生成数组\n\nconst map = new map([[1, 2], [2, 4], [4, 8]]);\narray.from(map);\n// [[1, 2], [2, 4], [4, 8]]\n\nconst mapper = new map([['1', 'a'], ['2', 'b']]);\narray.from(mapper.values());\n// ['a', 'b'];\n\narray.from(mapper.keys());\n// ['1', '2'];\n\n\n\n# 从类数组对象（arguments）生成数组\n\nfunction f() {\n  return array.from(arguments);\n}\n\nf(1, 2, 3);\n\n// [ 1, 2, 3 ]\n\n\n\n# 在 array.from 中使用箭头函数\n\n// using an arrow function as the map function to\n// manipulate the elements\narray.from([1, 2, 3], x => x + x);\n// [2, 4, 6]\n\n\n// generate a sequence of numbers\n// since the array is initialized with `undefined` on each position,\n// the value of `v` below will be `undefined`\narray.from({length: 5}, (v, i) => i);\n// [0, 1, 2, 3, 4]\n\n\n\n# 初始化二维数组\n\narray.from(new array(m),()=>(new array(n).fill(0)))\n\n\n\n# array.of\n\narray.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\n\narray.of(7);       // [7]\narray.of(1, 2, 3); // [1, 2, 3]\n\narray(7);          // [ , , , , , , ]\narray(1, 2, 3);    // [1, 2, 3]\n",charsets:{cjk:!0}},{title:"关于日期对象",frontmatter:{title:"关于日期对象",date:"2018-08-30T11:00:54.000Z",categories:"JavaScript"},regularPath:"/javascript/date.html",relativePath:"javascript/date.md",key:"v-276555bf",path:"/javascript/date.html",headers:[{level:2,title:"案例一：输出北京时间",slug:"案例一-输出北京时间",normalizedTitle:"案例一：输出北京时间",charIndex:1327},{level:2,title:"案例二：距离过年时间",slug:"案例二-距离过年时间",normalizedTitle:"案例二：距离过年时间",charIndex:2237},{level:2,title:"关于时间戳处理",slug:"关于时间戳处理",normalizedTitle:"关于时间戳处理",charIndex:21},{level:2,title:"一个兼容性问题",slug:"一个兼容性问题",normalizedTitle:"一个兼容性问题",charIndex:4022},{level:2,title:"一个函数",slug:"一个函数",normalizedTitle:"一个函数",charIndex:4253},{level:2,title:"moment  API",slug:"moment-api",normalizedTitle:"moment  api",charIndex:null},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"案例一：输出北京时间 案例二：距离过年时间 关于时间戳处理 一个兼容性问题 一个函数 moment  API ",content:"# 关于日期对象\n\n * 日期对象\n * 关于时间戳处理\n * Date.parse（）\n * moment API\n\n\t\tvar date = new Date();//返回时间；\n        var YY = date.getFullYear(); //返回年\n        var MM = date.getMonth() + 1  ;//返回月\n        var Day = date.getDay();//返回星期 【注意 ：每个星期第一天是星期日】\n        var DD = date.getDate();//返回天 \n        var hh = date.getHours(); //返回时\n        var mm = date.getMinutes();//返回分\n        var ss = date.getSeconds();//返回秒\n        var ms = date.getMilliseconds();//返回秒\n        var Time = date.getTime();//返回 1970 年 1 月 1 日至今的毫秒数 \n        var Now = Date.now(); //返回 1970 年 1 月 1 日至今的毫秒数  【不兼容IE】\n        var a = date.toLocaleString() //返回年月日，时分秒；\n        var b = date.toLocaleDateString(); //返回年月日\n        var c = date.toLocaleTimeString(); //返回时分秒\n\n\n\n        var date = new Date(); //返回指定的时间 【注意：月份会加1，所以我们设置的时候要减1】\n        var date1 = new Date( '2018/8/20' );\n        var date2 = new Date( 2018,7 );\n        var date3 = new Date( 2018 );\n        var date4 = new Date( '9' );\n        console.log( date ) //当前时间\n        console.log( date1 )//Mon Aug 20 2018 00:00:00\n        console.log( date2 )//Wed Aug 01 2018 00:00:00\n        console.log( date3 )//Thu Jan 01 1970 08:00:02\n        console.log( date4 )//Sat Sep 01 2001 00:00:00\n        //getTimezoneOffset() 世界时（东八区） - 本地时间（ 当前的时间 ）\n        console.log( date.getTimezoneOffset() ) //480/8 60分钟\n\n\n\n# 案例一：输出北京时间\n\n<div id=\"box\">\n\t\t现在是北京时间：\n\t\t<p></p>\n</div>\n\n<script>\n\t\tvar box = document.getElementById('box'),\n\t\tp = document.getElementsByTagName('p')[0],\n\t\tarr = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'];\n        function fn(){\n            var date = new Date();//返回时间；\n            var YY = date.getFullYear(); //返回年\n            var MM = date.getMonth() + 1  ;//返回月\n            var Day = date.getDay();//返回星期 【注意 ：每个星期第一天是星期日】\n            var DD = date.getDate();//返回天 \n            var hh = addZero(date.getHours()); //返回时\n            var mm = addZero(date.getMinutes());//返回分\n            var ss = addZero(date.getSeconds());//返回秒\n\n            var str = YY+'年'+MM+'月'+DD+'日'+arr[Day]+':'+hh+'时'+mm+'分'+ss+'秒';\n            p.innerHTML = str;\n        }\n\n        fn();//先执行一次，避免出现延迟加载\n        setInterval(fn,1000);\n\n        function addZero(n){\n            return n < 10 ? '0' + n : n;\n        }\n<\/script>\n\n\n\n# 案例二：距离过年时间\n\n\t<div>距离过年还有：\n        <p></p> \n\t</div>\n    <script>\n        var newYear = new Date( '2019/2/5' ),\n        p = document.getElementsByTagName('p')[0];\n        function fn(){\n            var date = newYear - Date.now(),//返回毫秒为距离明年过年要多少毫秒;\n                DD = Math.floor(date/1000/60/60/24), //返回天\n                hh = Math.floor(date/1000/60/60)%24,\n                mm = Math.floor(date/1000/60)%60,\n                ss = Math.floor(date/1000)%60;\n            console.log( DD ,hh,mm, ss)\n            var str =  DD +'日'+':'+hh+'时'+mm+'分'+ss+'秒';\n            p.innerHTML = str;\n        }\n        fn()\n        setInterval( fn ,1000 )\n    <\/script>\n\n\n\n# 关于时间戳处理\n\n在前后端接口开发时，时间对象的处理往往处理成13位的时间戳形式。\n\n一般时间选择器拿到的都是Thu Jul 04 2019 23:59:59 GMT+0800 (中国标准时间)即日期对象的格式\n\n * 时间对象转换为时间戳\n\n// 定义一个时间对象 dt，然后依次演示各种将 dt 转换为时间戳的写法\nvar dt = new Date(\"2019-07-04 23:59:59.999\");\n// Thu Jul 04 2019 23:59:59 GMT+0800 (中国标准时间)\n\n// 写法一，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(dt.getTime());\n\n// 写法二，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(dt.valueOf());\n\n// 写法三，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(Number(dt));\n\n// 写法四，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(+dt);\n\n// 写法五，精确到秒，得到 13 位时间戳 1562255999000，后三位固定为 000\nconsole.log(Date.parse(dt));\n\n// 但是如果这样写，还是可以的\nDate.parse(\"2019-07-04 23:59:59.999\")\n// 1562255999999\n\n\n * 时间戳转换为时间对象\n\n// 注意：参数中的时间戳必须是 13 位的，多一位或少一位都不行\nnew Date(1562169599000); // Wed Jul 03 2019 23:59:59 GMT+0800 (中国标准时间)\n\n// 将时间戳转换为更加直观形象的本地时间\nnew Date(1562169599000).toLocaleString() // \"2019/7/3 下午11:59:59\"\n\n// 判断两个时间差是否超过一天\n(Date.parse(new Date('2020-08-06 21:33:00')) - Date.parse(new Date('2020-08-05 21:33:00')))\n/1000/3600/24 = 1\n\n// 后三位是精确到毫秒，一般不用考虑\n+new Date(\"2019-07-04 23:59:59.999\")\n// 1562255999999\n\n+new Date(\"2019-07-04 23:59:59\")\n// 1562255999000\n\n\n\n# 一个兼容性问题\n\n> 时间格式为2020-08-09具有兼容性问题，正确用法是 new Date('2020/08/-09 21:33:00')\n\nstr.replace(/-/g,\"/\")\n\n(Date.parse(new Date('2020-08-06 21:33:00')) - Date.parse(new Date(('2020-08-05 21:33:00').replace(/-/g,\"/\"))))/1000/3600/24 = 1\n\n\n\n# 一个函数\n\n * 选择日期：比如说选择日期10.23-10.24，组件返回的是23号0点到24号零点，所以需要加一天时间\n * 但是如果组件是精确到秒的话直接用getTime就行了\n\ndisposeTime(start, end) {\n  let startDate, endDate\n  if (start.getTime) {\n    startDate = start.getTime()\n  } else {\n    startDate = moment(start).valueOf()\n  }\n  if (end.getTime) {\n    endDate = end.getTime()\n  } else {\n    endDate = moment(end).valueOf()\n  }\n  endDate += 24 * 60 * 60 * 1000 - 1;\n  return {\n    startDate,\n    endDate\n  }\n},\n\n\n * 其中的moment是一个时间格式化的插件\n * 可以参考：Vue使用Moment插件格式化时间\n\n> 给定一个时间戳，今天的展示今天，一个月内的发布日期，展示X天前，一个月前的展示年月日，如何实现？\n\n// 处理时间\ntransTime(time) {\n  const diff = (+new Date() - time) / 1000 / 3600 / 24\n  if (new Date(time).getDate() === new Date().getDate()) return '今天'\n  else if (diff < 30) return `${~~diff + 1}天前`\n  else return new Date(time).toLocaleString().split(' ')[0]\n}\n\n\n\n# moment API\n\nMOMENT                                                    含义                        数据类型\nmoment()                                                  当前时间                      moment 对象\nmoment('2020-01-02')                                      2020-01-02 00:00:00       moment 对象\nmoment('00:00:00', 'HH:mm:ss')                            当天0点                      moment 对象\nmoment(\"12-25-1995\", \"MM-DD-YYYY\")                        1995-12-25 00:00:00\nmoment().format(\"YYYY-MM-DD HH:mm:ss\")                    当前时间格式化处理                 string\nmoment().subtract(1, 'day'))                              当前时间减去一天                  moment 对象\nmoment().subtract(1, 'days'))\nmoment().subtract('days', 1)\nmoment().subtract('day', 1)\nmoment().add(1, 'week'))                                  当前时间加上一周                  moment 对象\nmoment().startOf('day')                                   当天0点                      moment 对象\nmoment().hours(0).minutes(0).seconds(0)\nmoment().endOf('year')                                    今年最后一天 23:59:59           moment 对象\nmoment('2021-07-24') < moment('2021-07-25')               比较大小                      bool\nmoment().day()                                            获取当天星期几                   number\nmoment().day(-7)，moment().day(0)                          上个星期日，这个星期日（0-6代表周日-周六）   moment 对象\nmoment().get('month')，moment().get('date')                当前月份-1，当前日期               number\nmoment().subtract(1, 'day').endOf('day').format()         链式操作，昨天23:59:59           string\nmoment().valueOf()                                        当前时间的时间戳                  number\nmoment('2021-07-22').diff(moment('2021-07-23'), 'days')   相差天数                      number\n\n\n#",normalizedContent:"# 关于日期对象\n\n * 日期对象\n * 关于时间戳处理\n * date.parse（）\n * moment api\n\n\t\tvar date = new date();//返回时间；\n        var yy = date.getfullyear(); //返回年\n        var mm = date.getmonth() + 1  ;//返回月\n        var day = date.getday();//返回星期 【注意 ：每个星期第一天是星期日】\n        var dd = date.getdate();//返回天 \n        var hh = date.gethours(); //返回时\n        var mm = date.getminutes();//返回分\n        var ss = date.getseconds();//返回秒\n        var ms = date.getmilliseconds();//返回秒\n        var time = date.gettime();//返回 1970 年 1 月 1 日至今的毫秒数 \n        var now = date.now(); //返回 1970 年 1 月 1 日至今的毫秒数  【不兼容ie】\n        var a = date.tolocalestring() //返回年月日，时分秒；\n        var b = date.tolocaledatestring(); //返回年月日\n        var c = date.tolocaletimestring(); //返回时分秒\n\n\n\n        var date = new date(); //返回指定的时间 【注意：月份会加1，所以我们设置的时候要减1】\n        var date1 = new date( '2018/8/20' );\n        var date2 = new date( 2018,7 );\n        var date3 = new date( 2018 );\n        var date4 = new date( '9' );\n        console.log( date ) //当前时间\n        console.log( date1 )//mon aug 20 2018 00:00:00\n        console.log( date2 )//wed aug 01 2018 00:00:00\n        console.log( date3 )//thu jan 01 1970 08:00:02\n        console.log( date4 )//sat sep 01 2001 00:00:00\n        //gettimezoneoffset() 世界时（东八区） - 本地时间（ 当前的时间 ）\n        console.log( date.gettimezoneoffset() ) //480/8 60分钟\n\n\n\n# 案例一：输出北京时间\n\n<div id=\"box\">\n\t\t现在是北京时间：\n\t\t<p></p>\n</div>\n\n<script>\n\t\tvar box = document.getelementbyid('box'),\n\t\tp = document.getelementsbytagname('p')[0],\n\t\tarr = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'];\n        function fn(){\n            var date = new date();//返回时间；\n            var yy = date.getfullyear(); //返回年\n            var mm = date.getmonth() + 1  ;//返回月\n            var day = date.getday();//返回星期 【注意 ：每个星期第一天是星期日】\n            var dd = date.getdate();//返回天 \n            var hh = addzero(date.gethours()); //返回时\n            var mm = addzero(date.getminutes());//返回分\n            var ss = addzero(date.getseconds());//返回秒\n\n            var str = yy+'年'+mm+'月'+dd+'日'+arr[day]+':'+hh+'时'+mm+'分'+ss+'秒';\n            p.innerhtml = str;\n        }\n\n        fn();//先执行一次，避免出现延迟加载\n        setinterval(fn,1000);\n\n        function addzero(n){\n            return n < 10 ? '0' + n : n;\n        }\n<\/script>\n\n\n\n# 案例二：距离过年时间\n\n\t<div>距离过年还有：\n        <p></p> \n\t</div>\n    <script>\n        var newyear = new date( '2019/2/5' ),\n        p = document.getelementsbytagname('p')[0];\n        function fn(){\n            var date = newyear - date.now(),//返回毫秒为距离明年过年要多少毫秒;\n                dd = math.floor(date/1000/60/60/24), //返回天\n                hh = math.floor(date/1000/60/60)%24,\n                mm = math.floor(date/1000/60)%60,\n                ss = math.floor(date/1000)%60;\n            console.log( dd ,hh,mm, ss)\n            var str =  dd +'日'+':'+hh+'时'+mm+'分'+ss+'秒';\n            p.innerhtml = str;\n        }\n        fn()\n        setinterval( fn ,1000 )\n    <\/script>\n\n\n\n# 关于时间戳处理\n\n在前后端接口开发时，时间对象的处理往往处理成13位的时间戳形式。\n\n一般时间选择器拿到的都是thu jul 04 2019 23:59:59 gmt+0800 (中国标准时间)即日期对象的格式\n\n * 时间对象转换为时间戳\n\n// 定义一个时间对象 dt，然后依次演示各种将 dt 转换为时间戳的写法\nvar dt = new date(\"2019-07-04 23:59:59.999\");\n// thu jul 04 2019 23:59:59 gmt+0800 (中国标准时间)\n\n// 写法一，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(dt.gettime());\n\n// 写法二，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(dt.valueof());\n\n// 写法三，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(number(dt));\n\n// 写法四，精确到毫秒，得到 13 位时间戳 1562255999999\nconsole.log(+dt);\n\n// 写法五，精确到秒，得到 13 位时间戳 1562255999000，后三位固定为 000\nconsole.log(date.parse(dt));\n\n// 但是如果这样写，还是可以的\ndate.parse(\"2019-07-04 23:59:59.999\")\n// 1562255999999\n\n\n * 时间戳转换为时间对象\n\n// 注意：参数中的时间戳必须是 13 位的，多一位或少一位都不行\nnew date(1562169599000); // wed jul 03 2019 23:59:59 gmt+0800 (中国标准时间)\n\n// 将时间戳转换为更加直观形象的本地时间\nnew date(1562169599000).tolocalestring() // \"2019/7/3 下午11:59:59\"\n\n// 判断两个时间差是否超过一天\n(date.parse(new date('2020-08-06 21:33:00')) - date.parse(new date('2020-08-05 21:33:00')))\n/1000/3600/24 = 1\n\n// 后三位是精确到毫秒，一般不用考虑\n+new date(\"2019-07-04 23:59:59.999\")\n// 1562255999999\n\n+new date(\"2019-07-04 23:59:59\")\n// 1562255999000\n\n\n\n# 一个兼容性问题\n\n> 时间格式为2020-08-09具有兼容性问题，正确用法是 new date('2020/08/-09 21:33:00')\n\nstr.replace(/-/g,\"/\")\n\n(date.parse(new date('2020-08-06 21:33:00')) - date.parse(new date(('2020-08-05 21:33:00').replace(/-/g,\"/\"))))/1000/3600/24 = 1\n\n\n\n# 一个函数\n\n * 选择日期：比如说选择日期10.23-10.24，组件返回的是23号0点到24号零点，所以需要加一天时间\n * 但是如果组件是精确到秒的话直接用gettime就行了\n\ndisposetime(start, end) {\n  let startdate, enddate\n  if (start.gettime) {\n    startdate = start.gettime()\n  } else {\n    startdate = moment(start).valueof()\n  }\n  if (end.gettime) {\n    enddate = end.gettime()\n  } else {\n    enddate = moment(end).valueof()\n  }\n  enddate += 24 * 60 * 60 * 1000 - 1;\n  return {\n    startdate,\n    enddate\n  }\n},\n\n\n * 其中的moment是一个时间格式化的插件\n * 可以参考：vue使用moment插件格式化时间\n\n> 给定一个时间戳，今天的展示今天，一个月内的发布日期，展示x天前，一个月前的展示年月日，如何实现？\n\n// 处理时间\ntranstime(time) {\n  const diff = (+new date() - time) / 1000 / 3600 / 24\n  if (new date(time).getdate() === new date().getdate()) return '今天'\n  else if (diff < 30) return `${~~diff + 1}天前`\n  else return new date(time).tolocalestring().split(' ')[0]\n}\n\n\n\n# moment api\n\nmoment                                                    含义                        数据类型\nmoment()                                                  当前时间                      moment 对象\nmoment('2020-01-02')                                      2020-01-02 00:00:00       moment 对象\nmoment('00:00:00', 'hh:mm:ss')                            当天0点                      moment 对象\nmoment(\"12-25-1995\", \"mm-dd-yyyy\")                        1995-12-25 00:00:00\nmoment().format(\"yyyy-mm-dd hh:mm:ss\")                    当前时间格式化处理                 string\nmoment().subtract(1, 'day'))                              当前时间减去一天                  moment 对象\nmoment().subtract(1, 'days'))\nmoment().subtract('days', 1)\nmoment().subtract('day', 1)\nmoment().add(1, 'week'))                                  当前时间加上一周                  moment 对象\nmoment().startof('day')                                   当天0点                      moment 对象\nmoment().hours(0).minutes(0).seconds(0)\nmoment().endof('year')                                    今年最后一天 23:59:59           moment 对象\nmoment('2021-07-24') < moment('2021-07-25')               比较大小                      bool\nmoment().day()                                            获取当天星期几                   number\nmoment().day(-7)，moment().day(0)                          上个星期日，这个星期日（0-6代表周日-周六）   moment 对象\nmoment().get('month')，moment().get('date')                当前月份-1，当前日期               number\nmoment().subtract(1, 'day').endof('day').format()         链式操作，昨天23:59:59           string\nmoment().valueof()                                        当前时间的时间戳                  number\nmoment('2021-07-22').diff(moment('2021-07-23'), 'days')   相差天数                      number\n\n\n#",charsets:{cjk:!0}},{title:"Promise",frontmatter:{},regularPath:"/javascript/asynchronous.html",relativePath:"javascript/asynchronous.md",key:"v-42ba8bff",path:"/javascript/asynchronous.html",headers:[{level:2,title:"promise",slug:"promise-2",normalizedTitle:"promise",charIndex:14},{level:3,title:"Promise静态方法",slug:"promise静态方法",normalizedTitle:"promise静态方法",charIndex:1579},{level:3,title:"Promise.then 返回值",slug:"promise-then-返回值",normalizedTitle:"promise.then 返回值",charIndex:2988},{level:2,title:"promise相关方法",slug:"promise相关方法",normalizedTitle:"promise相关方法",charIndex:25},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:40},{level:3,title:"for...of 与 Generator",slug:"for-of-与-generator",normalizedTitle:"for...of 与 generator",charIndex:5159},{level:2,title:"async和await",slug:"async和await",normalizedTitle:"async和await",charIndex:53},{level:3,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:6454},{level:3,title:"await后的值也可以是普通值",slug:"await后的值也可以是普通值",normalizedTitle:"await后的值也可以是普通值",charIndex:6681},{level:3,title:"async返回一个Promise对象",slug:"async返回一个promise对象",normalizedTitle:"async返回一个promise对象",charIndex:6791},{level:3,title:"同时发多个请求",slug:"同时发多个请求",normalizedTitle:"同时发多个请求",charIndex:7169},{level:3,title:"顶层 await",slug:"顶层-await",normalizedTitle:"顶层 await",charIndex:7442},{level:3,title:"try...catch处理错误",slug:"try-catch处理错误",normalizedTitle:"try...catch处理错误",charIndex:8599},{level:2,title:"宏任务，微任务，事件循环",slug:"宏任务-微任务-事件循环",normalizedTitle:"宏任务，微任务，事件循环",charIndex:68},{level:2,title:"面试题精选",slug:"面试题精选",normalizedTitle:"面试题精选",charIndex:84},{level:3,title:"手写代码",slug:"手写代码",normalizedTitle:"手写代码",charIndex:13279},{level:3,title:"看代码说答案",slug:"看代码说答案",normalizedTitle:"看代码说答案",charIndex:13384},{level:3,title:"当 async/await 遇到 forEach",slug:"当-async-await-遇到-foreach",normalizedTitle:"当 async/await 遇到 foreach",charIndex:17647},{level:2,title:"浏览器事件循环和node事件循环的区别",slug:"浏览器事件循环和node事件循环的区别",normalizedTitle:"浏览器事件循环和node事件循环的区别",charIndex:19347}],lastUpdated:"2/9/2023, 7:49:33 PM",lastUpdatedTimestamp:1675943373e3,headersStr:"promise Promise静态方法 Promise.then 返回值 promise相关方法 Generator for...of 与 Generator async和await 基本使用 await后的值也可以是普通值 async返回一个Promise对象 同时发多个请求 顶层 await try...catch处理错误 宏任务，微任务，事件循环 面试题精选 手写代码 看代码说答案 当 async/await 遇到 forEach 浏览器事件循环和node事件循环的区别",content:"# Promise\n\n * promise\n * promise相关方法\n * Generator\n * async和await\n * 宏任务，微任务，事件循环\n * 面试题精选\n * 浏览器与node的事件循环\n\n\n# promise\n\n首先想一下，怎么规定函数的执行顺序，通过回调的方式：\n\nfunction A(callback){\n    console.log(\"I am A\");\n    callback();  //调用该函数\n}\n\nfunction B(){\n   console.log(\"I am B\");\n}\n\nA(B);//先执行A后执行B，当需要执行ABCDEFG时，就会造成回调地狱\n\n\n回调地狱“也叫”回调金字塔“，我们平时写代码的时候 js如果异步 回调是不可避免的  例如 ajax不断的进行异步请求数据 回调方法里还要对数据进行处理，继续回调…形成回调地狱  这会使得我们的代码可读性变差，出现问题 不好调试 也会导致性能下降\n\nPromise：同步代码解决异步编程\n\n * 是一个构造函数，用来传递异步操作消息，链式调用，避免层层嵌套的回调函数。\n * promise接收两个函数参数，resolve和reject，分别表示异步操作执行成功后的回调和失败的回调\n * promise在声明的时候就已经执行了\n * 有三种状态：pending进行中、resolve已完成、rejected已失败,\n * 这些状态只能由pending -> resolved, pending -> rejected,一旦promise实例发生改变，就不能在变了，任何时候都能得到这个结果\n * promise对象的then方法会返回一个全新的promise对象\n * 前面then方法中的回调函数的返回值会作为后面then方法回调的参数\n * 如果回调中返回的是Promise，那后面的then方法的回调会等待它的结果\n * promise.reslove()可以快速创建一个Promise对象\n\nconsole.log(1)\nsetTimeout(() => console.log(5))\nnew Promise(function(resolve,reject){\n    console.log(2) //立刻执行\n    resolve()      //Promise.then是微任务\n}).then(function(){\n    console.log(3)\n})\nconsole.log(4)  //输出1,2,4,3,5\n\n//resolve可以接收参数\nnew Promise(function(resolve,reject){\n    resolve(\"2\")\n}).then(function(data){\n    console.log(data)\n})\n\n\n// 拿点外卖为例，点外卖后可能会成功派送也可能会延迟，无论如何都会有个结果\nfuntion dianwaimai(){\n    return new Promise((reslove,reject) => {\n        let result = cooking()\n        if (result===\"做好了\") reslove(\"正在派送\")\n        else reject(\"还没做好\")\n    })\n}\nfunction cooking(){\n    return Math.random() > 0.5 ? '菜烧好了' : '菜烧糊了'\n}\n\n//执行\ndianwaimai().then(res => console.log(res)).catch(res => console.log(res))\n\n\n\n# Promise静态方法\n\n * Promise.reslove(value)：相当于new Promise(resolve => resolve(value)),对参数都做了四种判断\n * Promise.reject\n\n这两种方法均会创建Promise对象\n\nPromise.resolve('foo')\n\t.then( value => console.log(value) )\n// foo\n\nPromise.reject(new Error('rejected'))\n\t.catch(err => console.log(err))\n// Error: rejected\n//    at <anonymous>:1:16\n\n\nPromise.resolve方法的参数分成四种情况。\n\n1）参数是一个 Promise 实例\n\n如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\nPromise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = Promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});\n\n\n上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。\n\n3）参数不是具有then方法的对象，或根本就不是对象。\n\n如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。\n\nconst p = Promise.resolve('Hello');\n\np.then(function (s){\n  console.log(s)\n});\n// Hello\n\n\n上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。\n\n4）不带有任何参数\n\nPromise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。\n\n所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。\n\nconst p = Promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n\n# Promise.then 返回值\n\nPromise.then方法的返回值问题\n\nvar p1 = Promise.resolve(42)\np1.then((value) => {\n  //第一种情况，返回一个Promise\n  return new Promise(function(resolve,rejected){\n    resolve(value + 1)\n  })\n\n  //第二种情况，返回一个值\n  return value + 2;\n\n  //第三种情况，新建一个promise，使用reslove返回值\n  const p2 = new Promise(function(resolve,rejected){\n    resolve(value + 3)\n  })\n\n  //第四种情况，新建一个promise，使用return返回值\n  const p2 = new Promise(function(resolve,rejected){\n    return(value + 4)\n  })\n\n  //第五种情况，没有返回值\n  return undefined\n\n}).then((value) => {\n  console.log(value)\n})\n\n\n> 第一种情况，新建promise的resolve传出的值将作为then方法返回的promise的resolve的值传递出，console将打印出43\n> \n> 第二种情况，return的值将作为then方法返回的promise的resolve的值传递出，console将打印出44\n> \n> 第三种情况，虽然新建了promise，但对于then方法来说，没有向它返回的promise传递返回值，console将打印出undifined\n> \n> 第四种情况，同第三种情况，\n> \n> 第五种情况，then方法没有返回值，then方法的promise的resolve的值将传递出undifined。\n\n参考文章开篇 promise 的特性：\n\n * promise对象的then方法会返回一个全新的promise对象\n * 前面then方法中的回调函数的返回值会作为后面then方法回调的参数\n\n所以 then 方法中如果没有返回值，则没有继续向后传递参数。如果有返回值，不论这个值是 promise 还是普通的值，都会被处理成 promise，具体可看 promise 实现\n\n\n# promise相关方法\n\n 1. Promise.all()：所有promise均resolve时，返回promise结果，只要有一个promise reject，那么返回的promise就reject\n 2. Promise.allSettled()：返回的所有的promise结果，无论resolve还是reject\n 3. Promise.any()：任意一个promise resolve，返回的promise则resolve。除非所有的promise均reject，则返回的promise才reject\n 4. Promise.race()：一旦某个 promise resolve或reject，返回的 promise 就会resolve或reject。（最快的那个promise无论resolve还是reject都取这个结果）\n 5. Promise.reject()\n 6. Promise.resolve()\n 7. Promise.prototype.then()\n 8. Promise.prototype.catch()\n 9. Promise.prototype.finally()：finally中的逻辑相当于在.then和.catch中各执行一遍\n\n\n# Generator\n\n * Generator 的中文名称是生成器，\n * 通过function*来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。\n * 也就是说Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），调用遍历器对象的next方法，使得指针移向下一个状态。\n\nfunction* say(){\n    for(let i=0;i<10;i++){\n        yield i\n    }\n}\nlet obj = say()//返回一个遍历器对象\nobj.next()  //Object {value: 0, done: false}\nobj.next()  //Object {value: 1, done: false}\nobj.next()  //Object {value: 2, done: false}\n...\nobj.next()  //Object {value: 9 done: false}\nobj.next()  //Object {value: undefined, done: true}\n\n\n\n# for...of 与 Generator\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [Symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor (let item of todos) {\n    console.log(item)\n}\n\n\n\n# async和await\n\nES2017提供了async函数，使得异步操作变得更加方便。async函数就是Generator函数的语法糖。 async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。 进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。\n\n * async 函数返回的就是一个 Promise 对象，所接收的值就是函数 return 的值\n\n * await 操作符用于等待一个 Promise 对象。它只能在异步函数 async function 中使用。\n\n * await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的 resolve 函数参数作为 await 表达式的值，继续执行 async function。\n\n * 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。\n\n * 另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。\n\n相比于Generator的改进\n\n * 内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。\n\n * 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n * 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n\n * 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。\n\n\n# 基本使用\n\nfunction getData () {\n    return new Promise(resolve => {\n        setTimeout(resolve, 1000, '结果') // 异步模拟数据请求\n    })\n}\n\nasync function asyncFn () {\n    let res = await getData()\n    console.log(res) // 1s之后输出 '结果'\n}\n\n\n\n# await后的值也可以是普通值\n\nasync function fn () {\n    return await 123\n}\nfn().then(res => console.log(res)) // 123\n\n\n\n# async返回一个Promise对象\n\n当没发生错误时 return 的值会成为 then 方法回调函数的参数。\n\n而当抛出错误时，会导致Promise对象变为 reject 状态，抛出的错误也会成为 catch 方法回调函数的参数。\n\nasync function f1(){\n    return 'hello world'\n}\nf1().then(res => {\n  console.log(res)} // hello world\n)\n\nasync function f2() {\n  throw new Error('error')\n}\nf2().then(res => {\n    console.log(res)\n}).catch(err => {\n    console.log(err) // Error: error\n})\n\n\n\n# 同时发多个请求\n\nasync function getABC() {\n  let A = await getA()\n  let B = await getB()\n  let C = await getC()\n  return A + B + C\n}\n\n// 正确处理\nasync function getABC() {\n  let results = await Promise.all([getA, getB, getC])\n  return results.reduce((acc, cur) => acc + cur, 0)\n}\n\n\n\n# 顶层 await\n\n顶层 await 允许我们在 async 函数外面使用 await 关键字。它允许模块充当大型异步函数，通过顶层 await，这些 ECMAScript 模块可以等待资源加载。这样其他导入这些模块的模块在执行代码之前要等待资源加载完再去执行。\n\n由于 await 仅在 async 函数中可用，因此模块可以通过将代码包装在 async 函数中来在代码中包含 await：\n\n// a.js\nimport fetch  from \"node-fetch\";\nlet users;\nexport const fetchUsers = async () => {\n  const resp = await fetch('https://jsonplaceholder.typicode.com/users');\n  users =  resp.json();\n}\nfetchUsers();\nexport { users };\n\n// usingAwait.js\nimport {users} from './a.js';\nconsole.log('users:', users); // undefined\nsetTimeout(() => {\n  console.log('users:', users);\n}, 100);\n\n\n一个方法是导出一个 promise，让导入模块知道数据已经准备好了：\n\n//a.js\nimport fetch  from \"node-fetch\";\nexport default (async () => {\n  const resp = await fetch('https://jsonplaceholder.typicode.com/users');\n  users = resp.json();\n})();\nexport { users };\n\n//usingAwait.js\nimport promise, {users} from './a.js';\npromise.then(() => {\n  setTimeout(() => console.log('users:', users), 100); \n});\n\n\n而顶层await就可以解决这些问题：\n\n// a.js\nconst resp = await fetch('https://jsonplaceholder.typicode.com/users');\nconst users = resp.json();\nexport { users};\n// usingAwait.js\nimport {users} from './a.mjs';\nconsole.log(users);\n\n\n\n# try...catch处理错误\n\nfunction getData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            reject(new Error('error')) // 模拟出错\n        }, 1000)\n    })\n}\nasync function fn() {\n    let res = await getData() // 会抛出错误，且不会向下执行\n    console.log(res) // 不会输出任何\n}\n\n// try..catch处理\nfunction getData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            reject(new Error('error'))\n        }, 1000)\n    })\n}\nasync function fn() {\n    try {\n        let res = await getData()\n        console.log(res)\n    } catch (err) {\n        console.log(err) // Error: error\n    }\n    console.log('继续执行') // 会输出\n}\n\nfn()\n\n\n第一种情况是抛出错误且不会继续执行，第二种情况是打印错误会继续执行\n\n\n# 宏任务，微任务，事件循环\n\n宏任务(macrotask)：：\n\nscript(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)\n\n微任务(microtask)：\n\nPromise、 MutaionObserver、process.nextTick(Node.js环境\n\n事件循环(Event Loop): 指主线程重复从任务队列中取任务、执行的过程\n\n * 一开始整个脚本作为一个宏任务执行\n * 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\n * 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完\n * 执行浏览器UI线程的渲染工作\n * 检查是否有Web Worker任务，有则执行\n * 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空\n\n微任务包括：MutationObserver、Promise.then()或reject()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。\n\n宏任务包括：script、script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering。\n\n注意⚠️：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如setTimeout)将被放到下一轮宏任务中来执行。\n\n * 图示\n\n\n# 面试题精选\n\nconsole.log('script start');\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\nconsole.log('script end');\n\n//script start\n//script end\n//promise1\n//promise2\n//setTimeout\n\n\nasync function async1(){\n    console.log('async1 start')  //2\n    await async2()               \n    console.log('async1 end')    //6 放入了微队列  \n}                                //    相当于async2.then(()=>{console.log('async1 end')})\nasync function async2(){\n    console.log('async2')       //3\n}\nconsole.log('script start')     //1\nsetTimeout(function(){\n    console.log('setTimeout')   //8\n},0)\nasync1()\nnew Promise(function(resolve){\n    console.log('promise1')     //4\n    resolve()\n}).then(function(){\n    console.log('promise2')    //7   放入了微队列\n})\nconsole.log('script end')     //5\n\n//await是一个让出线程的标志。await后面的表达式会先执行一遍，将await 后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\n\n> 1.首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。\n\n> 2.然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中\n\n> 3.script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1 start。 遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log('async1 end')加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码\n\n> 4.script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列\n\n> 5.script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。 因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了\n\n> 6.第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束\n\n// 上题变形\n// 本来是把 async1 end 加入微任务队列，结果 async 又返回了一个 promise ，加入微任务队列的就是这个 promise，执行完 async，最后才执行 async1 end\n// 解析：https://zhuanlan.zhihu.com/p/450906325\nasync function async1() {\n    console.log('async1 start')\n    await async2() \n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2 start')\n    return new Promise((resolve, reject) => {\n        resolve()\n        console.log('async2 promise')\n    })\n}\nconsole.log('script start')\nsetTimeout(function() {\n    console.log('setTimeout')\n}, 0)\nasync1()\nnew Promise(function(resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function() {\n    console.log('promise2')\n}).then(function() {\n    console.log('promise3')\n})\nconsole.log('script end')\n\n/**\nscript start\nasync1 start\nasync2 start\nasync2 promise\npromise1\nscript end\npromise2\npromise3\nasync1 end     注意这里 async 显示返回了 promise ，最后执行\nsetTimeout\n*/\n\n\n面试官问：\n\nsetTimeout（()=>{\n    console.log(\"1\")\n}, 0）;\nnew Promise（resolve => {\n    resolve()\n}）.then(() => {\n\tconsole.log(\"2\")\n})\nconsole.log(\"3\")\n//为什么你说先运行宏任务，不直接运行setTimeout呢？\n//因为后面如果有console.log(\"3\")时，肯定会先执行3，setTimeout是放到宏任务队列里的。\n\nPromise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log) // 1\n// then里面只要不是函数就不会传递，2是值，Promise.resolve(3)是Promise对象\n// console.log 是函数\n\n\n\n# 手写代码\n\n * Promise\n\n * promise.all\n\n * promise.race\n\n * promise.resolve\n\n * Promise 封装 AJAX\n\n * 手写代码整理\n\n\n# 看代码说答案\n\n// 原代码\nsetTimeout(function () {\n  var a = 'hello '\n  setTimeout(function () {\n    var b = 'lagou '\n    setTimeout(function () {\n      var c = 'I love you'\n      console.log(a + b + c)\n    }, 1000)\n  }, 1000)\n}, 1000)\n\n// 改进：高阶函数 + promise链式调用\nfunction f (str) {\n  return function (param) {\n    return new Promise((resolve,reject) => {\n      setTimeout(() => resolve(param += str), 1000)\n    })\n  }\n}\n\nvar p1 = f('hello ')\nvar p2 = f('lagou ')\nvar p3 = f('I love you')\n\np1('').then((res) => p2(res)).then((res) => p3(res)).then((res) => console.log(res))\np1('').then(p2).then(p3).then(console.log)\n\n\n\n红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：\n\nfunction red() {\n    console.log('red')\n}\nfunction green() {\n    console.log('green')\n}\nfunction yellow() {\n    console.log('yellow')\n}\n\nfunction light(time, fn) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            fn()\n            resolve()\n        }, time)\n    })\n}\n\nfunction step() {\n    Promise.resolve()\n    .then(() => light(3000, red))\n    .then(() => light(2000, green))\n    .then(() => light(1000, yellow))\n    .then(() => step())\n}\n\nstep()\n\n\n * 只有返回promsie对象后才会链式调用\n\nPromise.resolve().then(res => {\n   console.log('1')\n   new Promise((resolve, reject) => { \n        setTimeout(() => {\n            console.log('2')\n            resolve('newPromise')\n        }, 2000);\n    }).then(res =>{\n        console.log('3')\n        return \"newPromise1\"\n    })\n}).then(res=>{\n    console.log('4', res)\n})\n// 1 4 undefined  2 3\n\n\nPromise.resolve().then(res => {\n   console.log('1')\n   return new Promise((resolve, reject) => { \n        setTimeout(() => {\n            console.log('2')\n            resolve('newPromise')\n        }, 2000);\n    }).then(res =>{\n        console.log('3')\n        return \"newPromise1\"\n    })\n}).then(res=>{\n    console.log('4', res)\n})\n// 1 2  3 4 newPromise1\n\n\nconst promise = new Promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n    console.log(2);\n    reject('error');\n})\npromise.then(() => {\n    console.log(3);\n}).catch(e => console.log(e))\nconsole.log(4);\n\n// 1 2 4 3\n// promise构造函数的代码会立即执行，then或者reject里面的代码会放入异步微任务队列，在宏任务结束后会立即执行。规则二：promise的状态一旦变更为成功或者失败，则不会再次改变，所以执行结果为：1,2,4,3。而catch里面的函数不会再执行。\n\n\nconst promise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n             console.log('once')\n             resolve('success')\n        }, 1000)\n })\npromise.then((res) => {\n       console.log(res)\n})\npromise.then((res) => {\n     console.log(res)\n})\n// 将过一秒打印:once,success,success\n\n\nconst p1 = () => (new Promise((resolve, reject) => {\n\t \tconsole.log(1);\n \t\tlet p2 = new Promise((resolve, reject) => {\n        console.log(2);\n        const timeOut1 = setTimeout(() => { // timeout1 加入宏任务队列\n          console.log(3);\n          resolve(4);\n        }, 0)\n        resolve(5); // p2.then加入微任务队列\n \t\t});\n\t\tresolve(6); // p1.then加入微任务队列\n    p2.then((arg) => {\n  \t\t\tconsole.log(arg);\n \t\t});\n}));\n\nconst timeOut2 = setTimeout(() => { // timeout2 加入宏任务队列\n \t\tconsole.log(8);\n \t\tconst p3 = new Promise(reject => {\n  \t\treject(9);\n \t\t}).then(res => {\n  \t\tconsole.log(res)\n \t\t})\n}, 0)\n\n\np1().then((arg) => {\n \t\tconsole.log(arg);\n});\n\nconsole.log(10);\n\n// 1,2,10,5,6,8,9,3\n\n\n> 首先执行 script 代码块，我们来分析一下都做了什么：\n> \n>  1. 定义了 p1 函数，定义的时候p1没有执行，所以这时候内部实现先不看\n>  2. 执行了 timeout2 函数，返回值（是一个数值）赋值给 timeout2，timeout2加入了宏任务队列\n>  3. 执行 p1，定义即执行的有输出 1，2，p2.then，p1.then加入微任务队列，timeout1加入宏任务队列\n>  4. 输出10，执行完 script 宏任务后，清空微任务队列，p2.then => 5，p1.then => 6\n>  5. 找出宏任务，首先执行 timeout2，输出 8 , reject 只是形参起名字实际上还是 resolve，p3.then加入微队列\n>  6. Timeout2 宏任务执行结束清空微任务队列，输出9，然后再执行宏任务 timeout1,输出3，此时resolve(4)不会执行，因为p2状态已经成为 fullfilled\n\nPromise.resolve(1)\n.then(2)\n.then(Promise.resolve(3))\n.then(console.log)\n\n// Promise.resolve(1)会返回一个promise对象并且会将1当做then的参数。而.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。所以最后会输出：1。\n\n\nPromise.resolve(1)\n.then((x)=> x + 1)\n.then((x)=> { throw new Error('My Error') })\n.catch(()=>1)\n.then((x)=>x + 1)\n.then((x)=>console.log(x))\n.catch(console.error)\n\n// 因为then()和catch()又返回了一个promise，因此，后续调用可以串联起来。\n// catch 其实是 then(undefined, () => {}) 的语法糖，如下：\np.catch(err => {\n  console.log(\"catch \" + err); // catch error\n});\n\n// 等同于\np.then(undefined, err => {\n  console.log(\"catch \" + err); // catch error\n});\n\n\n\n# 当 async/await 遇到 forEach\n\n可以把下面代码复制到浏览器控制台执行：\n\n// 遍历 dataList，分别调用异步请求\nfunction fetchData(d) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\n\nconst dataList = [1, 2, 3];\ndataList.forEach(async d => {\n  const res = await fetchData(d);\n  console.log(res);\n});\n\n// 结果：1秒后同时输出 1，2，3\n\n\n> 此处我们期待的是每隔一秒输出 1，2，3，但是 forEach 却不能实现，至于为什么我们可以看下 forEach 和 普通的 for 循环有什么区别。\n\n// for 循环\nfor (let i = 0; i < dataList.length; i++) {\n  const res = await fetchData(dataList[i]);\n  console.log(res)\n}\n\n// 上面 forEach 的写法相当于\nconst fn = async d => {\n  const res = await fetchData(d);\n  console.log(res);\n}\nfor (let i = 0; i < dataList.length; i++) {\n  fn(dataList[i], i);\n}\n\n\n> 第一个 for 循环的 fetchData 要 await 返回后才继续执行，所以是顺序执行。而第二个的 fn 不会阻塞循环，因为调用的是传入 forEach 的回调函数，并没有 await 到 fetchData 的执行。\n> \n> 总结下解决办法：\n\nfunction fetchData(d) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\nconst dataList = [1, 2, 3];\n\n// 1. 改用 for 循环\nfor (let i = 0; i < dataList.length; i++) {\n  const res = await fetchData(dataList[i]);\n  console.log(res)\n}\n\n// 2. 改用 for...of\nfor (let d of dataList) {\n  const res = await fetchData(d);\n  console.log(res)\n}\n\n// 3. Promise.all\nconst promiseList = [];\ndataList.forEach(d => {\n    promiseList.push(fetchData(d)); // 此处已经开始执行了\n});\n\nPromise.all(promiseList).then(res => {\n  console.log(res) // [1, 2, 3]\n})\n\n// 4. for await...of : 同时输出 1，2，3\nconst promiseList = [];\ndataList.forEach(d => {\n    promiseList.push(fetchData(d)); // 此处已经开始执行了\n});\n\nfor await (p of promiseList) {\n  console.log(p)\n}\n\n\n> 其实不仅仅是 forEach，几乎有回调的遍历方法：forEach、map、filter、reduce、some、every、find等，使用await都是不生效的。\n\n\n# 浏览器事件循环和node事件循环的区别\n\nNode的事件循环是libuv实现的，大体的task（宏任务）执行顺序是这样的：图示\n\n * timers定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。\n * pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调。\n * idle, prepare：仅系统内部使用。\n * poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。\n * check 检测：setImmediate() 回调函数在这里执行。\n * close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。\n\n----------------------------------------\n\n * Node10以前，microtask 在事件循环的各个阶段之间执行，Node11之后和浏览器行为统一了，都是每执行一个宏任务就把微任务队列清空。\n * 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\n\nfunction test () {\n   console.log('start')\n    setTimeout(() => {\n        console.log('children2')\n        Promise.resolve().then(() => {console.log('children2-1')})\n    }, 0)\n    setTimeout(() => {\n        console.log('children3')\n        Promise.resolve().then(() => {console.log('children3-1')})\n    }, 0)\n    Promise.resolve().then(() => {console.log('children1')})\n    console.log('end')\n}\n\ntest()\n\n// 浏览器端 和 node11之后\n// start\n// end\n// children1\n// children2\n// children2-1\n// children3\n// children3-1\n\n// node10之前\n// start\n// end\n// children2\n// children3\n// children2-1\n// children3-1\n",normalizedContent:"# promise\n\n * promise\n * promise相关方法\n * generator\n * async和await\n * 宏任务，微任务，事件循环\n * 面试题精选\n * 浏览器与node的事件循环\n\n\n# promise\n\n首先想一下，怎么规定函数的执行顺序，通过回调的方式：\n\nfunction a(callback){\n    console.log(\"i am a\");\n    callback();  //调用该函数\n}\n\nfunction b(){\n   console.log(\"i am b\");\n}\n\na(b);//先执行a后执行b，当需要执行abcdefg时，就会造成回调地狱\n\n\n回调地狱“也叫”回调金字塔“，我们平时写代码的时候 js如果异步 回调是不可避免的  例如 ajax不断的进行异步请求数据 回调方法里还要对数据进行处理，继续回调…形成回调地狱  这会使得我们的代码可读性变差，出现问题 不好调试 也会导致性能下降\n\npromise：同步代码解决异步编程\n\n * 是一个构造函数，用来传递异步操作消息，链式调用，避免层层嵌套的回调函数。\n * promise接收两个函数参数，resolve和reject，分别表示异步操作执行成功后的回调和失败的回调\n * promise在声明的时候就已经执行了\n * 有三种状态：pending进行中、resolve已完成、rejected已失败,\n * 这些状态只能由pending -> resolved, pending -> rejected,一旦promise实例发生改变，就不能在变了，任何时候都能得到这个结果\n * promise对象的then方法会返回一个全新的promise对象\n * 前面then方法中的回调函数的返回值会作为后面then方法回调的参数\n * 如果回调中返回的是promise，那后面的then方法的回调会等待它的结果\n * promise.reslove()可以快速创建一个promise对象\n\nconsole.log(1)\nsettimeout(() => console.log(5))\nnew promise(function(resolve,reject){\n    console.log(2) //立刻执行\n    resolve()      //promise.then是微任务\n}).then(function(){\n    console.log(3)\n})\nconsole.log(4)  //输出1,2,4,3,5\n\n//resolve可以接收参数\nnew promise(function(resolve,reject){\n    resolve(\"2\")\n}).then(function(data){\n    console.log(data)\n})\n\n\n// 拿点外卖为例，点外卖后可能会成功派送也可能会延迟，无论如何都会有个结果\nfuntion dianwaimai(){\n    return new promise((reslove,reject) => {\n        let result = cooking()\n        if (result===\"做好了\") reslove(\"正在派送\")\n        else reject(\"还没做好\")\n    })\n}\nfunction cooking(){\n    return math.random() > 0.5 ? '菜烧好了' : '菜烧糊了'\n}\n\n//执行\ndianwaimai().then(res => console.log(res)).catch(res => console.log(res))\n\n\n\n# promise静态方法\n\n * promise.reslove(value)：相当于new promise(resolve => resolve(value)),对参数都做了四种判断\n * promise.reject\n\n这两种方法均会创建promise对象\n\npromise.resolve('foo')\n\t.then( value => console.log(value) )\n// foo\n\npromise.reject(new error('rejected'))\n\t.catch(err => console.log(err))\n// error: rejected\n//    at <anonymous>:1:16\n\n\npromise.resolve方法的参数分成四种情况。\n\n1）参数是一个 promise 实例\n\n如果参数是 promise 实例，那么promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\npromise.resolve方法会将这个对象转为 promise 对象，然后就立即执行thenable对象的then方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});\n\n\n上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。\n\n3）参数不是具有then方法的对象，或根本就不是对象。\n\n如果参数是一个原始值，或者是一个不具有then方法的对象，则promise.resolve方法返回一个新的 promise 对象，状态为resolved。\n\nconst p = promise.resolve('hello');\n\np.then(function (s){\n  console.log(s)\n});\n// hello\n\n\n上面代码生成一个新的 promise 对象的实例p。由于字符串hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。promise.resolve方法的参数，会同时传给回调函数。\n\n4）不带有任何参数\n\npromise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 promise 对象。\n\n所以，如果希望得到一个 promise 对象，比较方便的方法就是直接调用promise.resolve方法。\n\nconst p = promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n\n# promise.then 返回值\n\npromise.then方法的返回值问题\n\nvar p1 = promise.resolve(42)\np1.then((value) => {\n  //第一种情况，返回一个promise\n  return new promise(function(resolve,rejected){\n    resolve(value + 1)\n  })\n\n  //第二种情况，返回一个值\n  return value + 2;\n\n  //第三种情况，新建一个promise，使用reslove返回值\n  const p2 = new promise(function(resolve,rejected){\n    resolve(value + 3)\n  })\n\n  //第四种情况，新建一个promise，使用return返回值\n  const p2 = new promise(function(resolve,rejected){\n    return(value + 4)\n  })\n\n  //第五种情况，没有返回值\n  return undefined\n\n}).then((value) => {\n  console.log(value)\n})\n\n\n> 第一种情况，新建promise的resolve传出的值将作为then方法返回的promise的resolve的值传递出，console将打印出43\n> \n> 第二种情况，return的值将作为then方法返回的promise的resolve的值传递出，console将打印出44\n> \n> 第三种情况，虽然新建了promise，但对于then方法来说，没有向它返回的promise传递返回值，console将打印出undifined\n> \n> 第四种情况，同第三种情况，\n> \n> 第五种情况，then方法没有返回值，then方法的promise的resolve的值将传递出undifined。\n\n参考文章开篇 promise 的特性：\n\n * promise对象的then方法会返回一个全新的promise对象\n * 前面then方法中的回调函数的返回值会作为后面then方法回调的参数\n\n所以 then 方法中如果没有返回值，则没有继续向后传递参数。如果有返回值，不论这个值是 promise 还是普通的值，都会被处理成 promise，具体可看 promise 实现\n\n\n# promise相关方法\n\n 1. promise.all()：所有promise均resolve时，返回promise结果，只要有一个promise reject，那么返回的promise就reject\n 2. promise.allsettled()：返回的所有的promise结果，无论resolve还是reject\n 3. promise.any()：任意一个promise resolve，返回的promise则resolve。除非所有的promise均reject，则返回的promise才reject\n 4. promise.race()：一旦某个 promise resolve或reject，返回的 promise 就会resolve或reject。（最快的那个promise无论resolve还是reject都取这个结果）\n 5. promise.reject()\n 6. promise.resolve()\n 7. promise.prototype.then()\n 8. promise.prototype.catch()\n 9. promise.prototype.finally()：finally中的逻辑相当于在.then和.catch中各执行一遍\n\n\n# generator\n\n * generator 的中文名称是生成器，\n * 通过function*来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。\n * 也就是说generator 函数是一个状态机，封装了多个内部状态。执行 generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），调用遍历器对象的next方法，使得指针移向下一个状态。\n\nfunction* say(){\n    for(let i=0;i<10;i++){\n        yield i\n    }\n}\nlet obj = say()//返回一个遍历器对象\nobj.next()  //object {value: 0, done: false}\nobj.next()  //object {value: 1, done: false}\nobj.next()  //object {value: 2, done: false}\n...\nobj.next()  //object {value: 9 done: false}\nobj.next()  //object {value: undefined, done: true}\n\n\n\n# for...of 与 generator\n\nconst todos = {\n    life: ['吃饭', '睡觉', '打豆豆'],\n    learn: ['语文', '数学', '外语'],\n    work: ['喝茶'],\n\n    [symbol.iterator]: function * () {\n        const all = [...this.life, ...this.learn, ...this.work]\n        for(const item of all) {\n            yield item\n        }\n    }\n}\n\nfor (let item of todos) {\n    console.log(item)\n}\n\n\n\n# async和await\n\nes2017提供了async函数，使得异步操作变得更加方便。async函数就是generator函数的语法糖。 async函数就是将generator函数的星号（*）替换成async，将yield替换成await，仅此而已。 进一步说，async函数完全可以看作多个异步操作，包装成的一个promise对象，而await命令就是内部then命令的语法糖。\n\n * async 函数返回的就是一个 promise 对象，所接收的值就是函数 return 的值\n\n * await 操作符用于等待一个 promise 对象。它只能在异步函数 async function 中使用。\n\n * await 表达式会暂停当前 async function 的执行，等待 promise 处理完成。若 promise 正常处理(fulfilled)，其回调的 resolve 函数参数作为 await 表达式的值，继续执行 async function。\n\n * 若 promise 处理异常(rejected)，await 表达式会把 promise 的异常原因抛出。\n\n * 另外，如果 await 操作符后的表达式的值不是一个 promise，则返回该值本身。\n\n相比于generator的改进\n\n * 内置执行器。generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。\n\n * 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n * 更广的适用性。co模块约定，yield命令后面只能是 thunk 函数或 promise 对象，而async函数的await命令后面，可以是 promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 promise 对象）。\n\n * 返回值是 promise。async 函数返回值是 promise 对象，比 generator 函数返回的 iterator 对象方便，可以直接使用 then() 方法进行调用。\n\n\n# 基本使用\n\nfunction getdata () {\n    return new promise(resolve => {\n        settimeout(resolve, 1000, '结果') // 异步模拟数据请求\n    })\n}\n\nasync function asyncfn () {\n    let res = await getdata()\n    console.log(res) // 1s之后输出 '结果'\n}\n\n\n\n# await后的值也可以是普通值\n\nasync function fn () {\n    return await 123\n}\nfn().then(res => console.log(res)) // 123\n\n\n\n# async返回一个promise对象\n\n当没发生错误时 return 的值会成为 then 方法回调函数的参数。\n\n而当抛出错误时，会导致promise对象变为 reject 状态，抛出的错误也会成为 catch 方法回调函数的参数。\n\nasync function f1(){\n    return 'hello world'\n}\nf1().then(res => {\n  console.log(res)} // hello world\n)\n\nasync function f2() {\n  throw new error('error')\n}\nf2().then(res => {\n    console.log(res)\n}).catch(err => {\n    console.log(err) // error: error\n})\n\n\n\n# 同时发多个请求\n\nasync function getabc() {\n  let a = await geta()\n  let b = await getb()\n  let c = await getc()\n  return a + b + c\n}\n\n// 正确处理\nasync function getabc() {\n  let results = await promise.all([geta, getb, getc])\n  return results.reduce((acc, cur) => acc + cur, 0)\n}\n\n\n\n# 顶层 await\n\n顶层 await 允许我们在 async 函数外面使用 await 关键字。它允许模块充当大型异步函数，通过顶层 await，这些 ecmascript 模块可以等待资源加载。这样其他导入这些模块的模块在执行代码之前要等待资源加载完再去执行。\n\n由于 await 仅在 async 函数中可用，因此模块可以通过将代码包装在 async 函数中来在代码中包含 await：\n\n// a.js\nimport fetch  from \"node-fetch\";\nlet users;\nexport const fetchusers = async () => {\n  const resp = await fetch('https://jsonplaceholder.typicode.com/users');\n  users =  resp.json();\n}\nfetchusers();\nexport { users };\n\n// usingawait.js\nimport {users} from './a.js';\nconsole.log('users:', users); // undefined\nsettimeout(() => {\n  console.log('users:', users);\n}, 100);\n\n\n一个方法是导出一个 promise，让导入模块知道数据已经准备好了：\n\n//a.js\nimport fetch  from \"node-fetch\";\nexport default (async () => {\n  const resp = await fetch('https://jsonplaceholder.typicode.com/users');\n  users = resp.json();\n})();\nexport { users };\n\n//usingawait.js\nimport promise, {users} from './a.js';\npromise.then(() => {\n  settimeout(() => console.log('users:', users), 100); \n});\n\n\n而顶层await就可以解决这些问题：\n\n// a.js\nconst resp = await fetch('https://jsonplaceholder.typicode.com/users');\nconst users = resp.json();\nexport { users};\n// usingawait.js\nimport {users} from './a.mjs';\nconsole.log(users);\n\n\n\n# try...catch处理错误\n\nfunction getdata() {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            reject(new error('error')) // 模拟出错\n        }, 1000)\n    })\n}\nasync function fn() {\n    let res = await getdata() // 会抛出错误，且不会向下执行\n    console.log(res) // 不会输出任何\n}\n\n// try..catch处理\nfunction getdata() {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            reject(new error('error'))\n        }, 1000)\n    })\n}\nasync function fn() {\n    try {\n        let res = await getdata()\n        console.log(res)\n    } catch (err) {\n        console.log(err) // error: error\n    }\n    console.log('继续执行') // 会输出\n}\n\nfn()\n\n\n第一种情况是抛出错误且不会继续执行，第二种情况是打印错误会继续执行\n\n\n# 宏任务，微任务，事件循环\n\n宏任务(macrotask)：：\n\nscript(整体代码)、settimeout、setinterval、ui 渲染、 i/o、postmessage、 messagechannel、setimmediate(node.js 环境)\n\n微任务(microtask)：\n\npromise、 mutaionobserver、process.nexttick(node.js环境\n\n事件循环(event loop): 指主线程重复从任务队列中取任务、执行的过程\n\n * 一开始整个脚本作为一个宏任务执行\n * 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\n * 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完\n * 执行浏览器ui线程的渲染工作\n * 检查是否有web worker任务，有则执行\n * 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空\n\n微任务包括：mutationobserver、promise.then()或reject()、promise为基础开发的其它技术，比如fetch api、v8的垃圾回收过程、node独有的process.nexttick。\n\n宏任务包括：script、script 、settimeout、setinterval 、setimmediate 、i/o 、ui rendering。\n\n注意⚠️：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如settimeout)将被放到下一轮宏任务中来执行。\n\n * 图示\n\n\n# 面试题精选\n\nconsole.log('script start');\nsettimeout(function() {\n  console.log('settimeout');\n}, 0);\npromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\nconsole.log('script end');\n\n//script start\n//script end\n//promise1\n//promise2\n//settimeout\n\n\nasync function async1(){\n    console.log('async1 start')  //2\n    await async2()               \n    console.log('async1 end')    //6 放入了微队列  \n}                                //    相当于async2.then(()=>{console.log('async1 end')})\nasync function async2(){\n    console.log('async2')       //3\n}\nconsole.log('script start')     //1\nsettimeout(function(){\n    console.log('settimeout')   //8\n},0)\nasync1()\nnew promise(function(resolve){\n    console.log('promise1')     //4\n    resolve()\n}).then(function(){\n    console.log('promise2')    //7   放入了微队列\n})\nconsole.log('script end')     //5\n\n//await是一个让出线程的标志。await后面的表达式会先执行一遍，将await 后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsettimeout\n\n\n> 1.首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。\n\n> 2.然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 settimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中\n\n> 3.script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1 start。 遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log('async1 end')加入到microtask中的promise队列中，接着跳出async1函数来执行后面的代码\n\n> 4.script任务继续往下执行，遇到promise实例。由于promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列\n\n> 5.script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。 根据上述，每次执行完一个宏任务之后，会去检查是否存在 microtasks；如果有，则执行 microtasks 直至清空 microtask queue。 因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 microtasks 执行完毕之后，表示第一轮的循环就结束了\n\n> 6.第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 settimeout，取出直接输出即可，至此整个流程结束\n\n// 上题变形\n// 本来是把 async1 end 加入微任务队列，结果 async 又返回了一个 promise ，加入微任务队列的就是这个 promise，执行完 async，最后才执行 async1 end\n// 解析：https://zhuanlan.zhihu.com/p/450906325\nasync function async1() {\n    console.log('async1 start')\n    await async2() \n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2 start')\n    return new promise((resolve, reject) => {\n        resolve()\n        console.log('async2 promise')\n    })\n}\nconsole.log('script start')\nsettimeout(function() {\n    console.log('settimeout')\n}, 0)\nasync1()\nnew promise(function(resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function() {\n    console.log('promise2')\n}).then(function() {\n    console.log('promise3')\n})\nconsole.log('script end')\n\n/**\nscript start\nasync1 start\nasync2 start\nasync2 promise\npromise1\nscript end\npromise2\npromise3\nasync1 end     注意这里 async 显示返回了 promise ，最后执行\nsettimeout\n*/\n\n\n面试官问：\n\nsettimeout（()=>{\n    console.log(\"1\")\n}, 0）;\nnew promise（resolve => {\n    resolve()\n}）.then(() => {\n\tconsole.log(\"2\")\n})\nconsole.log(\"3\")\n//为什么你说先运行宏任务，不直接运行settimeout呢？\n//因为后面如果有console.log(\"3\")时，肯定会先执行3，settimeout是放到宏任务队列里的。\n\npromise.resolve(1).then(2).then(promise.resolve(3)).then(console.log) // 1\n// then里面只要不是函数就不会传递，2是值，promise.resolve(3)是promise对象\n// console.log 是函数\n\n\n\n# 手写代码\n\n * promise\n\n * promise.all\n\n * promise.race\n\n * promise.resolve\n\n * promise 封装 ajax\n\n * 手写代码整理\n\n\n# 看代码说答案\n\n// 原代码\nsettimeout(function () {\n  var a = 'hello '\n  settimeout(function () {\n    var b = 'lagou '\n    settimeout(function () {\n      var c = 'i love you'\n      console.log(a + b + c)\n    }, 1000)\n  }, 1000)\n}, 1000)\n\n// 改进：高阶函数 + promise链式调用\nfunction f (str) {\n  return function (param) {\n    return new promise((resolve,reject) => {\n      settimeout(() => resolve(param += str), 1000)\n    })\n  }\n}\n\nvar p1 = f('hello ')\nvar p2 = f('lagou ')\nvar p3 = f('i love you')\n\np1('').then((res) => p2(res)).then((res) => p3(res)).then((res) => console.log(res))\np1('').then(p2).then(p3).then(console.log)\n\n\n\n红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用promise实现）三个亮灯函数已经存在：\n\nfunction red() {\n    console.log('red')\n}\nfunction green() {\n    console.log('green')\n}\nfunction yellow() {\n    console.log('yellow')\n}\n\nfunction light(time, fn) {\n    return new promise(function (resolve, reject) {\n        settimeout(function () {\n            fn()\n            resolve()\n        }, time)\n    })\n}\n\nfunction step() {\n    promise.resolve()\n    .then(() => light(3000, red))\n    .then(() => light(2000, green))\n    .then(() => light(1000, yellow))\n    .then(() => step())\n}\n\nstep()\n\n\n * 只有返回promsie对象后才会链式调用\n\npromise.resolve().then(res => {\n   console.log('1')\n   new promise((resolve, reject) => { \n        settimeout(() => {\n            console.log('2')\n            resolve('newpromise')\n        }, 2000);\n    }).then(res =>{\n        console.log('3')\n        return \"newpromise1\"\n    })\n}).then(res=>{\n    console.log('4', res)\n})\n// 1 4 undefined  2 3\n\n\npromise.resolve().then(res => {\n   console.log('1')\n   return new promise((resolve, reject) => { \n        settimeout(() => {\n            console.log('2')\n            resolve('newpromise')\n        }, 2000);\n    }).then(res =>{\n        console.log('3')\n        return \"newpromise1\"\n    })\n}).then(res=>{\n    console.log('4', res)\n})\n// 1 2  3 4 newpromise1\n\n\nconst promise = new promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n    console.log(2);\n    reject('error');\n})\npromise.then(() => {\n    console.log(3);\n}).catch(e => console.log(e))\nconsole.log(4);\n\n// 1 2 4 3\n// promise构造函数的代码会立即执行，then或者reject里面的代码会放入异步微任务队列，在宏任务结束后会立即执行。规则二：promise的状态一旦变更为成功或者失败，则不会再次改变，所以执行结果为：1,2,4,3。而catch里面的函数不会再执行。\n\n\nconst promise = new promise((resolve, reject) => {\n        settimeout(() => {\n             console.log('once')\n             resolve('success')\n        }, 1000)\n })\npromise.then((res) => {\n       console.log(res)\n})\npromise.then((res) => {\n     console.log(res)\n})\n// 将过一秒打印:once,success,success\n\n\nconst p1 = () => (new promise((resolve, reject) => {\n\t \tconsole.log(1);\n \t\tlet p2 = new promise((resolve, reject) => {\n        console.log(2);\n        const timeout1 = settimeout(() => { // timeout1 加入宏任务队列\n          console.log(3);\n          resolve(4);\n        }, 0)\n        resolve(5); // p2.then加入微任务队列\n \t\t});\n\t\tresolve(6); // p1.then加入微任务队列\n    p2.then((arg) => {\n  \t\t\tconsole.log(arg);\n \t\t});\n}));\n\nconst timeout2 = settimeout(() => { // timeout2 加入宏任务队列\n \t\tconsole.log(8);\n \t\tconst p3 = new promise(reject => {\n  \t\treject(9);\n \t\t}).then(res => {\n  \t\tconsole.log(res)\n \t\t})\n}, 0)\n\n\np1().then((arg) => {\n \t\tconsole.log(arg);\n});\n\nconsole.log(10);\n\n// 1,2,10,5,6,8,9,3\n\n\n> 首先执行 script 代码块，我们来分析一下都做了什么：\n> \n>  1. 定义了 p1 函数，定义的时候p1没有执行，所以这时候内部实现先不看\n>  2. 执行了 timeout2 函数，返回值（是一个数值）赋值给 timeout2，timeout2加入了宏任务队列\n>  3. 执行 p1，定义即执行的有输出 1，2，p2.then，p1.then加入微任务队列，timeout1加入宏任务队列\n>  4. 输出10，执行完 script 宏任务后，清空微任务队列，p2.then => 5，p1.then => 6\n>  5. 找出宏任务，首先执行 timeout2，输出 8 , reject 只是形参起名字实际上还是 resolve，p3.then加入微队列\n>  6. timeout2 宏任务执行结束清空微任务队列，输出9，然后再执行宏任务 timeout1,输出3，此时resolve(4)不会执行，因为p2状态已经成为 fullfilled\n\npromise.resolve(1)\n.then(2)\n.then(promise.resolve(3))\n.then(console.log)\n\n// promise.resolve(1)会返回一个promise对象并且会将1当做then的参数。而.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。所以最后会输出：1。\n\n\npromise.resolve(1)\n.then((x)=> x + 1)\n.then((x)=> { throw new error('my error') })\n.catch(()=>1)\n.then((x)=>x + 1)\n.then((x)=>console.log(x))\n.catch(console.error)\n\n// 因为then()和catch()又返回了一个promise，因此，后续调用可以串联起来。\n// catch 其实是 then(undefined, () => {}) 的语法糖，如下：\np.catch(err => {\n  console.log(\"catch \" + err); // catch error\n});\n\n// 等同于\np.then(undefined, err => {\n  console.log(\"catch \" + err); // catch error\n});\n\n\n\n# 当 async/await 遇到 foreach\n\n可以把下面代码复制到浏览器控制台执行：\n\n// 遍历 datalist，分别调用异步请求\nfunction fetchdata(d) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\n\nconst datalist = [1, 2, 3];\ndatalist.foreach(async d => {\n  const res = await fetchdata(d);\n  console.log(res);\n});\n\n// 结果：1秒后同时输出 1，2，3\n\n\n> 此处我们期待的是每隔一秒输出 1，2，3，但是 foreach 却不能实现，至于为什么我们可以看下 foreach 和 普通的 for 循环有什么区别。\n\n// for 循环\nfor (let i = 0; i < datalist.length; i++) {\n  const res = await fetchdata(datalist[i]);\n  console.log(res)\n}\n\n// 上面 foreach 的写法相当于\nconst fn = async d => {\n  const res = await fetchdata(d);\n  console.log(res);\n}\nfor (let i = 0; i < datalist.length; i++) {\n  fn(datalist[i], i);\n}\n\n\n> 第一个 for 循环的 fetchdata 要 await 返回后才继续执行，所以是顺序执行。而第二个的 fn 不会阻塞循环，因为调用的是传入 foreach 的回调函数，并没有 await 到 fetchdata 的执行。\n> \n> 总结下解决办法：\n\nfunction fetchdata(d) {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n        resolve(d)\n    }, 1000)\n  })\n}\nconst datalist = [1, 2, 3];\n\n// 1. 改用 for 循环\nfor (let i = 0; i < datalist.length; i++) {\n  const res = await fetchdata(datalist[i]);\n  console.log(res)\n}\n\n// 2. 改用 for...of\nfor (let d of datalist) {\n  const res = await fetchdata(d);\n  console.log(res)\n}\n\n// 3. promise.all\nconst promiselist = [];\ndatalist.foreach(d => {\n    promiselist.push(fetchdata(d)); // 此处已经开始执行了\n});\n\npromise.all(promiselist).then(res => {\n  console.log(res) // [1, 2, 3]\n})\n\n// 4. for await...of : 同时输出 1，2，3\nconst promiselist = [];\ndatalist.foreach(d => {\n    promiselist.push(fetchdata(d)); // 此处已经开始执行了\n});\n\nfor await (p of promiselist) {\n  console.log(p)\n}\n\n\n> 其实不仅仅是 foreach，几乎有回调的遍历方法：foreach、map、filter、reduce、some、every、find等，使用await都是不生效的。\n\n\n# 浏览器事件循环和node事件循环的区别\n\nnode的事件循环是libuv实现的，大体的task（宏任务）执行顺序是这样的：图示\n\n * timers定时器：本阶段执行已经安排的 settimeout() 和 setinterval() 的回调函数。\n * pending callbacks待定回调：执行延迟到下一个循环迭代的 i/o 回调。\n * idle, prepare：仅系统内部使用。\n * poll 轮询：检索新的 i/o 事件;执行与 i/o 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setimmediate() 排定的之外），其余情况 node 将在此处阻塞。\n * check 检测：setimmediate() 回调函数在这里执行。\n * close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。\n\n----------------------------------------\n\n * node10以前，microtask 在事件循环的各个阶段之间执行，node11之后和浏览器行为统一了，都是每执行一个宏任务就把微任务队列清空。\n * 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\n\nfunction test () {\n   console.log('start')\n    settimeout(() => {\n        console.log('children2')\n        promise.resolve().then(() => {console.log('children2-1')})\n    }, 0)\n    settimeout(() => {\n        console.log('children3')\n        promise.resolve().then(() => {console.log('children3-1')})\n    }, 0)\n    promise.resolve().then(() => {console.log('children1')})\n    console.log('end')\n}\n\ntest()\n\n// 浏览器端 和 node11之后\n// start\n// end\n// children1\n// children2\n// children2-1\n// children3\n// children3-1\n\n// node10之前\n// start\n// end\n// children2\n// children3\n// children2-1\n// children3-1\n",charsets:{cjk:!0}},{title:"浅拷贝与深拷贝",frontmatter:{title:"浅拷贝与深拷贝",date:"2021-01-20T18:37:54.000Z",categories:"JavaScript"},regularPath:"/javascript/clone.html",relativePath:"javascript/clone.md",key:"v-6611c3b5",path:"/javascript/clone.html",headers:[{level:2,title:"对象间赋值",slug:"对象间赋值",normalizedTitle:"对象间赋值",charIndex:14},{level:2,title:"浅拷贝",slug:"浅拷贝",normalizedTitle:"浅拷贝",charIndex:2},{level:2,title:"深拷贝",slug:"深拷贝",normalizedTitle:"深拷贝",charIndex:6},{level:3,title:"递归方法实现深拷贝原理：",slug:"递归方法实现深拷贝原理",normalizedTitle:"递归方法实现深拷贝原理：",charIndex:2731}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"对象间赋值 浅拷贝 深拷贝 递归方法实现深拷贝原理：",content:"# 浅拷贝与深拷贝\n\n * 对象间赋值\n * 浅拷贝\n * 深拷贝\n * Object.assign\n * JSON.stringify\n * 递归实现深拷贝\n\n\n# 对象间赋值\n\n除了一些基本类型，对象之间的赋值，只是将地址指向同一个，而不是真正意义上的拷贝\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4); // b中添加了一个4\nalert(a); // a变成了[1,2,3,4] \n\nvar obj = {a:10};\nvar obj2 = obj;\nobj2.a = 20; // obj2.a改变了，\nalert(obj.a); // 20，obj的a跟着改变 \n\n\n\n# 浅拷贝\n\n所以为了解决地址指向同一个的问题，我们需要封装一个函数，来对对象进行拷贝，通过for in 循环获取基本类型，赋值每一个基本类型，才能真正意义上的复制一个对象\n\nvar obj = {a:10};\nfunction copy(obj){\n    var newobj = {};\n    for ( var attr in obj) {\n        newobj[attr] = obj[attr];\n    }\n    return newobj;\n}\nvar obj2 = copy(obj);\nobj2.a = 20;\nalert(obj.a); //10  \n\n\n这样就解决了对象赋值的问题。\n\n> 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。\n\nvar obj = {a:{b:10}};\nfunction copy(obj){\n    var newobj = {};\n    for ( var attr in obj) {\n        newobj[attr] = obj[attr];\n    }\n    return newobj;\n}\nvar obj2 = copy(obj);\nobj2.a.b = 20;\nalert(obj.a.b); //20  \n\n\n\n# 深拷贝\n\n> 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。\n\nlet obj = {\n    name:'a',\n    hobbies:{\n        like:'coding',\n        hate:'reading'\n    }\n}     \nlet obj2 = Object.assign({},obj)\nlet obj3 = JSON.parse(JSON.stringify(obj))\n\nobj.hobbies.like = 'reading'\nobj.name='b'\n\nconsole.log(obj)\nconsole.log(obj2) //name:a,like:reading,说明没有实现深拷贝\nconsole.log(obj3) //实现了深拷贝，但是存在问题\n\n// //JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象\n\n\n * Object.assign\n\n * JSON.stringify详解\n\n> JSON.parse(JSON.stringify(obj)) 的问题：\n> \n>  1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；\n>  2. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；\n>  3. 如果obj里有函数，undefined，symbol，则序列化的结果会把函数或 undefined丢失；\n>  4. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null\n>  5. JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；\n>  6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；因为JSON.tostringify 无法将一个无限引用的对象序列化为 JSON 字符串。\n\nlet obj = {\n    'date': new Date(),\n    'regexp': new RegExp(/a/),\n    'error': new Error('err'),\n    'fun': function a() {},\n    'undefined': undefined,\n    'symbol': Symbol('1'),\n    'nan': NaN,\n    'str': new String('a'),\n    'object': {a:1}\n}\n\nlet _obj = JSON.parse(JSON.stringify(obj))\nobj.object.a = 2\n\nconsole.log(obj)\n/**\n\tdate: Wed Feb 03 2021 10:37:06 GMT+0800 (中国标准时间) {}\n\terror: Error: err at <anonymous>:4:14\n  fun: ƒ a()\n  nan: NaN\n  object: {a: 2}\n  regexp: /a/\n  str: String {\"a\"}\n  symbol: Symbol(1)\n  undefined: undefined\n*/\nconsole.log(_obj)\n/**\n\tdate: \"2021-02-03T02:37:06.906Z\"\n\terror: {}\n  nan: null\n  object: {a: 1}\n  regexp: {}\n  str: \"a\"\n*/\n\n\n// 循环引用\nlet o = {}\nlet a = {\n    b:42,\n    c:o,\n    d:function(){}\n}\no.e = a //创建循环引用\nconsole.log(JSON.stringify(a)) //报错\n\n\n\n# 递归方法实现深拷贝原理：\n\n遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。\n\n> 有种特殊情况需注意就是对象存在循环引用的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。\n\nfunction deepClone(obj, hash = new WeakMap()) {\n    // 处理几种特殊的对象：Date, RegExp, Error\n    if (obj instanceof Date) return new Date(obj)\n    if (obj instanceof RegExp) return new RegExp(obj)\n    if (obj instanceof Error) return new Error(obj)\n    // 如果是 function, undefined, symbol, NaN 等不是对象的话是不需要深拷贝\n    if (typeof obj !== \"object\" || obj === null) return obj\n    // 是对象的话就要进行深拷贝, 若拷贝过直接返回\n    if (hash.get(obj)) return hash.get(obj)\n    // 否则创建新的对象\n    let cloneObj = new Object()\n    hash.set(obj, cloneObj)\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            // 实现一个递归拷贝\n            cloneObj[key] = deepClone(obj[key], hash)\n        }\n    }\n    return cloneObj\n}\n\nlet deepobj = deepClone(obj)\nconsole.log(deepobj)\n/**\n\tdate: Wed Feb 03 2021 11:02:25 GMT+0800 (中国标准时间) {}\n  error: Error at deepClone (<anonymous>:10:20) at deepClone (<anonymous>:16:29) at <anonymous>:35:15\n  fun: ƒ a()\n  nan: NaN\n  object: {a: 1}\n  regexp: /a/\n  str: String {\"\", 0: \"a\"}\n  symbol: Symbol(1)\n  undefined: undefined\n  __proto__: Object\n*/\n\n\nlet obj = { name: 1, address: { x: 100 } };\nobj.o = obj; // 对象存在循环引用的情况\nlet d = deepClone(obj);\nobj.address.x = 200;\n\nconsole.log(d);\n// { name: 1, address: { x: 100 } }\n",normalizedContent:"# 浅拷贝与深拷贝\n\n * 对象间赋值\n * 浅拷贝\n * 深拷贝\n * object.assign\n * json.stringify\n * 递归实现深拷贝\n\n\n# 对象间赋值\n\n除了一些基本类型，对象之间的赋值，只是将地址指向同一个，而不是真正意义上的拷贝\n\nvar a = [1,2,3];\nvar b = a;\nb.push(4); // b中添加了一个4\nalert(a); // a变成了[1,2,3,4] \n\nvar obj = {a:10};\nvar obj2 = obj;\nobj2.a = 20; // obj2.a改变了，\nalert(obj.a); // 20，obj的a跟着改变 \n\n\n\n# 浅拷贝\n\n所以为了解决地址指向同一个的问题，我们需要封装一个函数，来对对象进行拷贝，通过for in 循环获取基本类型，赋值每一个基本类型，才能真正意义上的复制一个对象\n\nvar obj = {a:10};\nfunction copy(obj){\n    var newobj = {};\n    for ( var attr in obj) {\n        newobj[attr] = obj[attr];\n    }\n    return newobj;\n}\nvar obj2 = copy(obj);\nobj2.a = 20;\nalert(obj.a); //10  \n\n\n这样就解决了对象赋值的问题。\n\n> 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。\n\nvar obj = {a:{b:10}};\nfunction copy(obj){\n    var newobj = {};\n    for ( var attr in obj) {\n        newobj[attr] = obj[attr];\n    }\n    return newobj;\n}\nvar obj2 = copy(obj);\nobj2.a.b = 20;\nalert(obj.a.b); //20  \n\n\n\n# 深拷贝\n\n> 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。\n\nlet obj = {\n    name:'a',\n    hobbies:{\n        like:'coding',\n        hate:'reading'\n    }\n}     \nlet obj2 = object.assign({},obj)\nlet obj3 = json.parse(json.stringify(obj))\n\nobj.hobbies.like = 'reading'\nobj.name='b'\n\nconsole.log(obj)\nconsole.log(obj2) //name:a,like:reading,说明没有实现深拷贝\nconsole.log(obj3) //实现了深拷贝，但是存在问题\n\n// //json.parse(json.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用json.stringify 将js对象序列化（json字符串），再使用json.parse来反序列化(还原)js对象\n\n\n * object.assign\n\n * json.stringify详解\n\n> json.parse(json.stringify(obj)) 的问题：\n> \n>  1. 如果obj里面有时间对象，则json.stringify后再json.parse的结果，时间将只是字符串的形式。而不是时间对象；\n>  2. 如果obj里有regexp、error对象，则序列化的结果将只得到空对象；\n>  3. 如果obj里有函数，undefined，symbol，则序列化的结果会把函数或 undefined丢失；\n>  4. 如果obj里有nan、infinity和-infinity，则序列化的结果会变成null\n>  5. json.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用json.parse(json.stringify(obj))深拷贝后，会丢弃对象的constructor；\n>  6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；因为json.tostringify 无法将一个无限引用的对象序列化为 json 字符串。\n\nlet obj = {\n    'date': new date(),\n    'regexp': new regexp(/a/),\n    'error': new error('err'),\n    'fun': function a() {},\n    'undefined': undefined,\n    'symbol': symbol('1'),\n    'nan': nan,\n    'str': new string('a'),\n    'object': {a:1}\n}\n\nlet _obj = json.parse(json.stringify(obj))\nobj.object.a = 2\n\nconsole.log(obj)\n/**\n\tdate: wed feb 03 2021 10:37:06 gmt+0800 (中国标准时间) {}\n\terror: error: err at <anonymous>:4:14\n  fun: ƒ a()\n  nan: nan\n  object: {a: 2}\n  regexp: /a/\n  str: string {\"a\"}\n  symbol: symbol(1)\n  undefined: undefined\n*/\nconsole.log(_obj)\n/**\n\tdate: \"2021-02-03t02:37:06.906z\"\n\terror: {}\n  nan: null\n  object: {a: 1}\n  regexp: {}\n  str: \"a\"\n*/\n\n\n// 循环引用\nlet o = {}\nlet a = {\n    b:42,\n    c:o,\n    d:function(){}\n}\no.e = a //创建循环引用\nconsole.log(json.stringify(a)) //报错\n\n\n\n# 递归方法实现深拷贝原理：\n\n遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。\n\n> 有种特殊情况需注意就是对象存在循环引用的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。\n\nfunction deepclone(obj, hash = new weakmap()) {\n    // 处理几种特殊的对象：date, regexp, error\n    if (obj instanceof date) return new date(obj)\n    if (obj instanceof regexp) return new regexp(obj)\n    if (obj instanceof error) return new error(obj)\n    // 如果是 function, undefined, symbol, nan 等不是对象的话是不需要深拷贝\n    if (typeof obj !== \"object\" || obj === null) return obj\n    // 是对象的话就要进行深拷贝, 若拷贝过直接返回\n    if (hash.get(obj)) return hash.get(obj)\n    // 否则创建新的对象\n    let cloneobj = new object()\n    hash.set(obj, cloneobj)\n    for (let key in obj) {\n        if (obj.hasownproperty(key)) {\n            // 实现一个递归拷贝\n            cloneobj[key] = deepclone(obj[key], hash)\n        }\n    }\n    return cloneobj\n}\n\nlet deepobj = deepclone(obj)\nconsole.log(deepobj)\n/**\n\tdate: wed feb 03 2021 11:02:25 gmt+0800 (中国标准时间) {}\n  error: error at deepclone (<anonymous>:10:20) at deepclone (<anonymous>:16:29) at <anonymous>:35:15\n  fun: ƒ a()\n  nan: nan\n  object: {a: 1}\n  regexp: /a/\n  str: string {\"\", 0: \"a\"}\n  symbol: symbol(1)\n  undefined: undefined\n  __proto__: object\n*/\n\n\nlet obj = { name: 1, address: { x: 100 } };\nobj.o = obj; // 对象存在循环引用的情况\nlet d = deepclone(obj);\nobj.address.x = 200;\n\nconsole.log(d);\n// { name: 1, address: { x: 100 } }\n",charsets:{cjk:!0}},{title:"console.log 控制台 I/O 异步",frontmatter:{},regularPath:"/javascript/log.html",relativePath:"javascript/log.md",key:"v-18136627",path:"/javascript/log.html",lastUpdated:"5/20/2022, 7:31:49 PM",lastUpdatedTimestamp:1653046309e3,headersStr:null,content:"# console.log 控制台 I/O 异步\n\n一个例子\n\nvar a = {\n  index: 1\n}\nconsole.log(a);\na.index++;\n\n\n我们可能会认为打印的结果是 {a: 1}，但是实际情况如下：\n\n可以看到打印出来的确实是{a: 1}，但是将其展开之后显示的index的值为2，这是为什么呢？这时我们发现结果中有个叹号，我们把鼠标移上去看看是什么？ 意思就是这个值计算了一次，但是后面可能是会变化的，那么为什么会出现这种情况呢？其实在《你不知道的JavaScript》这本书的中卷中给出了答案：\n\n> 并没有什么规范或一组需求指定 console.* 方法族如何工作——它们并不是JavaScript 正式的一部分，而是由宿主环境（请参考本书的“类型和语法”部分）添加到JavaScript 中的。因此，不同的浏览器和JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。\n\n> 尤其要提出的是，在某些条件下，某些浏览器的 console.log(…) 并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O 是非常低速的阻塞部分。所以，（从页面/UI 的角度来说）浏览器在后台异步处理控制台I/O 能够提高性能，这时用户甚至可能根本意识不到其发生。\n\n> 我们通常认为恰好在执行到console.log(..) 语句的时候会看到a对象的快照，打印出类似于{ index: 1 } 这样的内容，然后在下一条语句a.index++执行时将其修改，这句的执行会严格在a 的输出之后。多数情况下，前述代码在开发者工具的控制台中输出的对象表示与期望是一致的。但是，这段代码运行的时候，浏览器可能会认为需要把控制台I/O 延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时，a.index++可能已经执行，因此会显示{ index: 2 }。\n\n> 到底什么时候控制台I/O 会延迟，甚至是否能够被观察到，这都是游移不定的。所以如果在调试的过程中遇到对象在console.log(..) 语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种I/O 的异步化造成的。\n\n> 所以如果遇到这种情况，最优的方法是断点，次优的方法是把对象序列化，强制执行一次快照，比如JSON.stringify\n\n我们也可以理解为在这个例子中console.log打印的数据是引用类型，那么打印的只是一个快照{index: 1}，等我们展开对象时会重新取值，此时值已经被改变，所以取出来的就是最新的值也就是{index: 2}了。",normalizedContent:"# console.log 控制台 i/o 异步\n\n一个例子\n\nvar a = {\n  index: 1\n}\nconsole.log(a);\na.index++;\n\n\n我们可能会认为打印的结果是 {a: 1}，但是实际情况如下：\n\n可以看到打印出来的确实是{a: 1}，但是将其展开之后显示的index的值为2，这是为什么呢？这时我们发现结果中有个叹号，我们把鼠标移上去看看是什么？ 意思就是这个值计算了一次，但是后面可能是会变化的，那么为什么会出现这种情况呢？其实在《你不知道的javascript》这本书的中卷中给出了答案：\n\n> 并没有什么规范或一组需求指定 console.* 方法族如何工作——它们并不是javascript 正式的一部分，而是由宿主环境（请参考本书的“类型和语法”部分）添加到javascript 中的。因此，不同的浏览器和javascript 环境可以按照自己的意愿来实现，有时候这会引起混淆。\n\n> 尤其要提出的是，在某些条件下，某些浏览器的 console.log(…) 并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是javascript）中，i/o 是非常低速的阻塞部分。所以，（从页面/ui 的角度来说）浏览器在后台异步处理控制台i/o 能够提高性能，这时用户甚至可能根本意识不到其发生。\n\n> 我们通常认为恰好在执行到console.log(..) 语句的时候会看到a对象的快照，打印出类似于{ index: 1 } 这样的内容，然后在下一条语句a.index++执行时将其修改，这句的执行会严格在a 的输出之后。多数情况下，前述代码在开发者工具的控制台中输出的对象表示与期望是一致的。但是，这段代码运行的时候，浏览器可能会认为需要把控制台i/o 延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时，a.index++可能已经执行，因此会显示{ index: 2 }。\n\n> 到底什么时候控制台i/o 会延迟，甚至是否能够被观察到，这都是游移不定的。所以如果在调试的过程中遇到对象在console.log(..) 语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种i/o 的异步化造成的。\n\n> 所以如果遇到这种情况，最优的方法是断点，次优的方法是把对象序列化，强制执行一次快照，比如json.stringify\n\n我们也可以理解为在这个例子中console.log打印的数据是引用类型，那么打印的只是一个快照{index: 1}，等我们展开对象时会重新取值，此时值已经被改变，所以取出来的就是最新的值也就是{index: 2}了。",charsets:{cjk:!0}},{title:"闭包",frontmatter:{title:"闭包",date:"2018-08-16T21:00:54.000Z",categories:"JavaScript"},regularPath:"/javascript/closure.html",relativePath:"javascript/closure.md",key:"v-6c3f9039",path:"/javascript/closure.html",headers:[{level:2,title:"闭包的定义",slug:"闭包的定义",normalizedTitle:"闭包的定义",charIndex:2},{level:2,title:"闭包有三个特性：",slug:"闭包有三个特性",normalizedTitle:"闭包有三个特性：",charIndex:160},{level:2,title:"闭包优缺点",slug:"闭包优缺点",normalizedTitle:"闭包优缺点",charIndex:222},{level:2,title:"vue源码中闭包的应用",slug:"vue源码中闭包的应用",normalizedTitle:"vue源码中闭包的应用",charIndex:400},{level:2,title:"闭包与高阶函数",slug:"闭包与高阶函数",normalizedTitle:"闭包与高阶函数",charIndex:1286},{level:2,title:"javascript的垃圾回收原理",slug:"javascript的垃圾回收原理",normalizedTitle:"javascript的垃圾回收原理",charIndex:1463},{level:2,title:"一、全局变量的累加",slug:"一、全局变量的累加",normalizedTitle:"一、全局变量的累加",charIndex:1575},{level:2,title:"二、局部变量",slug:"二、局部变量",normalizedTitle:"二、局部变量",charIndex:1718},{level:2,title:"三、局部变量的累加",slug:"三、局部变量的累加",normalizedTitle:"三、局部变量的累加",charIndex:1904},{level:2,title:"函数声明与函数表达式",slug:"函数声明与函数表达式",normalizedTitle:"函数声明与函数表达式",charIndex:2197},{level:2,title:"四、模块化代码，减少全局变量的污染",slug:"四、模块化代码-减少全局变量的污染",normalizedTitle:"四、模块化代码，减少全局变量的污染",charIndex:2453},{level:2,title:"五、私有成员的存在",slug:"五、私有成员的存在",normalizedTitle:"五、私有成员的存在",charIndex:2685},{level:2,title:"六.使用匿名函数实现累加",slug:"六-使用匿名函数实现累加",normalizedTitle:"六.使用匿名函数实现累加",charIndex:2977},{level:2,title:"七、在循环中直接找到对应元素的索引",slug:"七、在循环中直接找到对应元素的索引",normalizedTitle:"七、在循环中直接找到对应元素的索引",charIndex:3339},{level:2,title:"八、使用闭包改写上面代码",slug:"八、使用闭包改写上面代码",normalizedTitle:"八、使用闭包改写上面代码",charIndex:3709},{level:2,title:"九.内存泄露问题",slug:"九-内存泄露问题",normalizedTitle:"九.内存泄露问题",charIndex:4074}],lastUpdated:"6/12/2025, 7:16:20 PM",lastUpdatedTimestamp:174972698e4,headersStr:"闭包的定义 闭包有三个特性： 闭包优缺点 vue源码中闭包的应用 闭包与高阶函数 javascript的垃圾回收原理 一、全局变量的累加 二、局部变量 三、局部变量的累加 函数声明与函数表达式 四、模块化代码，减少全局变量的污染 五、私有成员的存在 六.使用匿名函数实现累加 七、在循环中直接找到对应元素的索引 八、使用闭包改写上面代码 九.内存泄露问题",content:"# 闭包的定义\n\n * 犀牛书：函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。\n * 个人理解：闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，内部函数可以访问外面函数中的局部变量，一旦内部函数返回或者被引用，这个局部变量则会一直保留在内存中\n\n\n# 闭包有三个特性：\n\n1.函数嵌套函数\n2.函数内部可以引用外部的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n\n\n\n# 闭包优缺点\n\n缺点\n\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。\n\n一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！\n\n优点及用处\n\n * 有了闭包之后，可以在外部作用域访问内部作用域的成员\n\n * 希望一个变量长期驻扎在内存中\n\n * 避免全局变量的污染\n\n * 私有成员的存在\n\n\n# vue源码中闭包的应用\n\n> 因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。\n\nfunction createPatchFunction(nodeOps, modules) {\n  return function patch(vdom1, vdom2) {\n    // ...\n  }\n}\nconst patch = createPatchFunction(...)\n/**\n因为 vue 可以运行在多个平台上通过 nodeOps 来区分，patch 中有许多操作节点的函数，如果直接写在 patch 里面的话，需要在 patch 里面写一系列 if 平台判断，多次执行 patch 会判断多次，那么如过通过闭包把这个平台差异只执行一次就判断出来，今后不需要判断就好了。\n*/                    \nconst nodeOps = {\n    setTextContent (text) {\n        if (platform === 'weex') {\n            node.parentNode.setAttr('value', text);\n        } else if (platform === 'web') {\n            node.textContent = text;\n        }\n    },\n    parentNode () {\n        //......\n    },\n    removeChild () {\n        //......\n    },\n    nextSibling () {\n        //......\n    },\n    insertBefore () {\n        //......\n    }\n}\n\n\n\n# 闭包与高阶函数\n\n// 函数作为返回值\nfunction fn() {\n    let a = 1\n    return function() {\n        console.log(a++)\n    }\n}\n\nlet fn1 = fn()\nfn1()\n\n// 函数作为参数\n\n\n\n闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。\n\n\n# javascript的垃圾回收原理\n\n（1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收； （2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。\n\n\n# 一、全局变量的累加\n\n<script>\n  var a = 1;\n  function abc(){\n    a++;\n    alert(a);\n  }\n  abc();              //2\n  abc();            //3\n<\/script>\n\n\n\n# 二、局部变量\n\n<script>\n\n  function abc(){\n    var a = 1;\n    a++;\n    alert(a);\n  }\n  abc();                       //2\n  abc();                    //2\n<\/script>\n\n\n那么怎么才能做到变量a既是局部变量又可以累加呢？\n\n\n# 三、局部变量的累加\n\n<script>\n  function outer(){\n    var x=10;\n    return function(){             //函数嵌套函数\n      x++;\n      alert(x);\n    }\n  }\n  var y = outer();              //外部函数赋给变量y;\n  y();                 //y函数调用一次，结果为11，相当于outer()()；\n  y();                //y函数调用第二次，结果为12，实现了累加\n<\/script>\n\n\n\n# 函数声明与函数表达式\n\n在js中我们可以通过关键字function来声明一个函数：\n\n<script>\n  function abc(){\n    alert(123);\n  }\n  abc();\n<\/script>\n\n\n我们也可以通过一个\"()\"来将这个声明变成一个表达式：\n\n<script>\n  (function (){\n    alert(123);\n  })();                   //然后通过()直接调用前面的表达式即可，因此函数可以不必写名字；\n<\/script>\n\n\n\n# 四、模块化代码，减少全局变量的污染\n\n<script>\n  var abc = (function(){      //abc为外部匿名函数的返回值\n    var a = 1;\n    return function(){\n      a++;\n      alert(a);\n    }\n  })();\n  abc();    //2 ；调用一次abc函数，其实是调用里面内部函数的返回值    \n  abc();    //3\n<\/script>\n\n\n\n# 五、私有成员的存在\n\n<script>\n  var aaa = (function(){\n    var a = 1;\n    function bbb(){\n      a++;\n      alert(a);\n    }\n    function ccc(){\n      a++;\n      alert(a);\n    }\n    return {\n      b:bbb,             //json结构\n      c:ccc\n    }\n  })();\n  aaa.b();     //2\n  aaa.c()      //3\n<\/script>\n\n\n\n# 六.使用匿名函数实现累加\n\n//使用匿名函数实现局部变量驻留内存中，从而实现累加\n\n<script type=\"text/javascript\">\n\n  function box(){\n    var age = 100;\n    return function(){          //匿名函数\n      age++;\n      return age;\n    };\n\n  } \n  var b = box();\n  alert(b());\n  alert(b());    //即alert(box()())；\n  alert(b());\n  alert(b);\n  b = null；  //解除引用，等待垃圾回收\n<\/script>\n\n\n过度使用闭包会导致性能的下降。函数里放匿名函数，则产生了闭包\n\n\n# 七、在循环中直接找到对应元素的索引\n\n<script>\n  window.onload = function(){\n    var aLi = document.getElementsByTagName('li');\n    for (var i=0;i<aLi.length;i++){\n      aLi[i].onclick = function(){        //当点击时for循环已经结束\n        alert(i);\n      };\n    }\n  }\n<\/script>\n\n</head>\n<body>\n  <ul>\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n    <li>010</li>\n  </ul>\n</body>\n</html>\n\n\n\n# 八、使用闭包改写上面代码\n\n<script>\n  window.onload = function(){\n    var aLi = document.getElementsByTagName('li');\n    for (var i=0;i<aLi.length;i++){\n      (function(i){\n        aLi[i].onclick = function(){\n          alert(i);\n        };\n      })(i);\n    }\n  };\n<\/script>\n\n</head>\n<body>\n  <ul>\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n  </ul>\n</body>\n</html>\n\n\n\n# 九.内存泄露问题\n\n由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素\n\nfunction closure(){\n    var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中\n    oDiv.onclick = function () {\n        alert('oDiv.innerHTML');//这里用oDiv导致内存泄露\n    };\n}\nclosure();\n//最后应将oDiv解除引用来避免内存泄露\nfunction closure(){\n    var oDiv = document.getElementById('oDiv');\n    var test = oDiv.innerHTML;\n    oDiv.onclick = function () {\n        alert(test);\n    };\n    oDiv = null;\n}\n",normalizedContent:"# 闭包的定义\n\n * 犀牛书：函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。\n * 个人理解：闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，内部函数可以访问外面函数中的局部变量，一旦内部函数返回或者被引用，这个局部变量则会一直保留在内存中\n\n\n# 闭包有三个特性：\n\n1.函数嵌套函数\n2.函数内部可以引用外部的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n\n\n\n# 闭包优缺点\n\n缺点\n\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。\n\n一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！\n\n优点及用处\n\n * 有了闭包之后，可以在外部作用域访问内部作用域的成员\n\n * 希望一个变量长期驻扎在内存中\n\n * 避免全局变量的污染\n\n * 私有成员的存在\n\n\n# vue源码中闭包的应用\n\n> 因为使用了 virtual dom 的原因，vue.js具有了跨平台的能力，virtual dom 终归只是一些 javascript 对象罢了，那么最终是如何调用不同平台的 api 的呢？这就需要依赖一层适配层了，将不同平台的 api 封装在内，以同样的接口对外提供。\n\nfunction createpatchfunction(nodeops, modules) {\n  return function patch(vdom1, vdom2) {\n    // ...\n  }\n}\nconst patch = createpatchfunction(...)\n/**\n因为 vue 可以运行在多个平台上通过 nodeops 来区分，patch 中有许多操作节点的函数，如果直接写在 patch 里面的话，需要在 patch 里面写一系列 if 平台判断，多次执行 patch 会判断多次，那么如过通过闭包把这个平台差异只执行一次就判断出来，今后不需要判断就好了。\n*/                    \nconst nodeops = {\n    settextcontent (text) {\n        if (platform === 'weex') {\n            node.parentnode.setattr('value', text);\n        } else if (platform === 'web') {\n            node.textcontent = text;\n        }\n    },\n    parentnode () {\n        //......\n    },\n    removechild () {\n        //......\n    },\n    nextsibling () {\n        //......\n    },\n    insertbefore () {\n        //......\n    }\n}\n\n\n\n# 闭包与高阶函数\n\n// 函数作为返回值\nfunction fn() {\n    let a = 1\n    return function() {\n        console.log(a++)\n    }\n}\n\nlet fn1 = fn()\nfn1()\n\n// 函数作为参数\n\n\n\n闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。\n\n\n# javascript的垃圾回收原理\n\n（1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被gc回收； （2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。\n\n\n# 一、全局变量的累加\n\n<script>\n  var a = 1;\n  function abc(){\n    a++;\n    alert(a);\n  }\n  abc();              //2\n  abc();            //3\n<\/script>\n\n\n\n# 二、局部变量\n\n<script>\n\n  function abc(){\n    var a = 1;\n    a++;\n    alert(a);\n  }\n  abc();                       //2\n  abc();                    //2\n<\/script>\n\n\n那么怎么才能做到变量a既是局部变量又可以累加呢？\n\n\n# 三、局部变量的累加\n\n<script>\n  function outer(){\n    var x=10;\n    return function(){             //函数嵌套函数\n      x++;\n      alert(x);\n    }\n  }\n  var y = outer();              //外部函数赋给变量y;\n  y();                 //y函数调用一次，结果为11，相当于outer()()；\n  y();                //y函数调用第二次，结果为12，实现了累加\n<\/script>\n\n\n\n# 函数声明与函数表达式\n\n在js中我们可以通过关键字function来声明一个函数：\n\n<script>\n  function abc(){\n    alert(123);\n  }\n  abc();\n<\/script>\n\n\n我们也可以通过一个\"()\"来将这个声明变成一个表达式：\n\n<script>\n  (function (){\n    alert(123);\n  })();                   //然后通过()直接调用前面的表达式即可，因此函数可以不必写名字；\n<\/script>\n\n\n\n# 四、模块化代码，减少全局变量的污染\n\n<script>\n  var abc = (function(){      //abc为外部匿名函数的返回值\n    var a = 1;\n    return function(){\n      a++;\n      alert(a);\n    }\n  })();\n  abc();    //2 ；调用一次abc函数，其实是调用里面内部函数的返回值    \n  abc();    //3\n<\/script>\n\n\n\n# 五、私有成员的存在\n\n<script>\n  var aaa = (function(){\n    var a = 1;\n    function bbb(){\n      a++;\n      alert(a);\n    }\n    function ccc(){\n      a++;\n      alert(a);\n    }\n    return {\n      b:bbb,             //json结构\n      c:ccc\n    }\n  })();\n  aaa.b();     //2\n  aaa.c()      //3\n<\/script>\n\n\n\n# 六.使用匿名函数实现累加\n\n//使用匿名函数实现局部变量驻留内存中，从而实现累加\n\n<script type=\"text/javascript\">\n\n  function box(){\n    var age = 100;\n    return function(){          //匿名函数\n      age++;\n      return age;\n    };\n\n  } \n  var b = box();\n  alert(b());\n  alert(b());    //即alert(box()())；\n  alert(b());\n  alert(b);\n  b = null；  //解除引用，等待垃圾回收\n<\/script>\n\n\n过度使用闭包会导致性能的下降。函数里放匿名函数，则产生了闭包\n\n\n# 七、在循环中直接找到对应元素的索引\n\n<script>\n  window.onload = function(){\n    var ali = document.getelementsbytagname('li');\n    for (var i=0;i<ali.length;i++){\n      ali[i].onclick = function(){        //当点击时for循环已经结束\n        alert(i);\n      };\n    }\n  }\n<\/script>\n\n</head>\n<body>\n  <ul>\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n    <li>010</li>\n  </ul>\n</body>\n</html>\n\n\n\n# 八、使用闭包改写上面代码\n\n<script>\n  window.onload = function(){\n    var ali = document.getelementsbytagname('li');\n    for (var i=0;i<ali.length;i++){\n      (function(i){\n        ali[i].onclick = function(){\n          alert(i);\n        };\n      })(i);\n    }\n  };\n<\/script>\n\n</head>\n<body>\n  <ul>\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n  </ul>\n</body>\n</html>\n\n\n\n# 九.内存泄露问题\n\n由于ie的js对象和dom对象使用不同的垃圾收集方法，因此闭包在ie中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素\n\nfunction closure(){\n    var odiv = document.getelementbyid('odiv');//odiv用完之后一直驻留在内存中\n    odiv.onclick = function () {\n        alert('odiv.innerhtml');//这里用odiv导致内存泄露\n    };\n}\nclosure();\n//最后应将odiv解除引用来避免内存泄露\nfunction closure(){\n    var odiv = document.getelementbyid('odiv');\n    var test = odiv.innerhtml;\n    odiv.onclick = function () {\n        alert(test);\n    };\n    odiv = null;\n}\n",charsets:{cjk:!0}},{title:"js的数值范围",frontmatter:{title:"js的数值范围",date:"2020-07-11T10:27:54.000Z",categories:"JavaScript"},regularPath:"/javascript/number.html",relativePath:"javascript/number.md",key:"v-4444465f",path:"/javascript/number.html",headers:[{level:2,title:"js的数值范围以及为什么",slug:"js的数值范围以及为什么",normalizedTitle:"js的数值范围以及为什么",charIndex:2},{level:3,title:"数值精度",slug:"数值精度",normalizedTitle:"数值精度",charIndex:714}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"js的数值范围以及为什么 数值精度",content:'# js的数值范围以及为什么\n\n> JavaScript能表示并进行精确算术运算的整数范围为：正负2的53次方，也即从最小值-9007199254740992到最大值+9007199254740992之间的范围；对于超过这个范围的整数，JavaScript依旧可以进行运算，但却不保证运算结果的精度。\n\n+"6145390195186705543"    // 出现精度问题，6145390195186705000\nBigInt("6145390195186705543" )+1n  //6145390195186705544n\n\n\nJavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\n\n1 === 1.0 // true\n\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n\n0.1 + 0.2 === 0.3\n// false\n\n//0.1 => 0.0001 1001 1001 1001…（无限循环）\n//0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n//双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了0.30000000000000004。\n\n0.3 / 0.1\n// 2.999999999999999\n\n(0.3 - 0.2) === (0.2 - 0.1)\n// false\n\n\n\n# 数值精度\n\n根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。\n\n * 第1位：符号位，0表示正数，1表示负数 （1位）\n * 第2位到第12位：指数部分 （11位）\n * 第13位到第64位：尾数部分 （52位）\n\n符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。\n\nIEEE 754 规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。\n\n(-1)^符号位 * 1.xx...xx * 2^指数位\n\n精度最多只能到53个二进制位(有一位不在浮点数中)，这意味着，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。\n\n2^0+2^1+...+2^52 = 2^53-1 \n',normalizedContent:'# js的数值范围以及为什么\n\n> javascript能表示并进行精确算术运算的整数范围为：正负2的53次方，也即从最小值-9007199254740992到最大值+9007199254740992之间的范围；对于超过这个范围的整数，javascript依旧可以进行运算，但却不保证运算结果的精度。\n\n+"6145390195186705543"    // 出现精度问题，6145390195186705000\nbigint("6145390195186705543" )+1n  //6145390195186705544n\n\n\njavascript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。\n\n1 === 1.0 // true\n\n\n由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。\n\n0.1 + 0.2 === 0.3\n// false\n\n//0.1 => 0.0001 1001 1001 1001…（无限循环）\n//0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n//双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了0.30000000000000004。\n\n0.3 / 0.1\n// 2.999999999999999\n\n(0.3 - 0.2) === (0.2 - 0.1)\n// false\n\n\n\n# 数值精度\n\n根据国际标准 ieee 754，javascript 浮点数的64个二进制位，从最左边开始，是这样组成的。\n\n * 第1位：符号位，0表示正数，1表示负数 （1位）\n * 第2位到第12位：指数部分 （11位）\n * 第13位到第64位：尾数部分 （52位）\n\n符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。\n\nieee 754 规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，javascript 提供的有效数字最长为53个二进制位。\n\n(-1)^符号位 * 1.xx...xx * 2^指数位\n\n精度最多只能到53个二进制位(有一位不在浮点数中)，这意味着，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。\n\n2^0+2^1+...+2^52 = 2^53-1 \n',charsets:{cjk:!0}},{title:"JS数据类型",frontmatter:{title:"JS数据类型",date:"2020-03-05T09:52:01.000Z",categories:"JavaScript"},regularPath:"/javascript/datatype.html",relativePath:"javascript/datatype.md",key:"v-90ff3d02",path:"/javascript/datatype.html",headers:[{level:2,title:"JS基本数据类型与类型转换",slug:"js基本数据类型与类型转换",normalizedTitle:"js基本数据类型与类型转换",charIndex:2},{level:3,title:"转字符串",slug:"转字符串",normalizedTitle:"转字符串",charIndex:153},{level:3,title:"转布尔型",slug:"转布尔型",normalizedTitle:"转布尔型",charIndex:489},{level:3,title:"一道题",slug:"一道题",normalizedTitle:"一道题",charIndex:604},{level:3,title:"转数值",slug:"转数值",normalizedTitle:"转数值",charIndex:759},{level:3,title:"运算符带来的强制类型转换",slug:"运算符带来的强制类型转换",normalizedTitle:"运算符带来的强制类型转换",charIndex:1034},{level:2,title:"JS如何进行类型判断",slug:"js如何进行类型判断",normalizedTitle:"js如何进行类型判断",charIndex:2026},{level:3,title:"例：判断数组",slug:"例-判断数组",normalizedTitle:"例：判断数组",charIndex:4086},{level:2,title:"Symbol",slug:"symbol",normalizedTitle:"symbol",charIndex:100},{level:2,title:"Bigint",slug:"bigint",normalizedTitle:"bigint",charIndex:4519},{level:2,title:"什么情况下 a === a - 1",slug:"什么情况下-a-a-1",normalizedTitle:"什么情况下 a === a - 1",charIndex:4797},{level:2,title:"什么情况下 a==1&&a==2&&a==3为true成立",slug:"什么情况下-a-1-a-2-a-3为true成立",normalizedTitle:"什么情况下 a==1&amp;&amp;a==2&amp;&amp;a==3为true成立",charIndex:null}],lastUpdated:"2/6/2023, 6:11:44 PM",lastUpdatedTimestamp:1675678304e3,headersStr:"JS基本数据类型与类型转换 转字符串 转布尔型 一道题 转数值 运算符带来的强制类型转换 JS如何进行类型判断 例：判断数组 Symbol Bigint 什么情况下 a === a - 1 什么情况下 a==1&&a==2&&a==3为true成立",content:'# JS基本数据类型与类型转换\n\nES5基本有5种简单数据类型：String，Number，Boolean，Null，undefined。一种复杂的数据类型Object。\nES6新增一种简单数据类型：Symbol,还有BigInt\nJS是动态类型语言，所以类型不同的时候进行运算会进行类型转换。\n\n\n\n# 转字符串\n\n * 转字符串可以理解为 + “”，底层是toString方法，其中对象转为[object object]，数组去括号+“”\n\n2+"3"          //Number(2).toString()+"3"\ntrue+"1"       //Boolean(true).toString()+"1"\n""+{}          //输出[object object]\n""+{A:123}     //[object object]\n"123"=={toString(){return "123"}}    //true，因为重写了toString方法\n""+[]          //""\n""+[1,2,3]     //"1,2,3"\n\n\n\n# 转布尔型\n\nBoolean()传入变量\n\n0，NaN，""，null，undefined，false直接转换成false，其余都是真\n\n!!"123"       //true\n!!{}          //true\n\n\n\n# 一道题\n\nvar aLi = document.querySelectrAll("li")\nfor(let item,i = 0;item = aLi[i++];){  //每次赋值都返回当前值，当最后输出undefined是转布尔false\n        console.log(item)\n}\n\n\n\n# 转数值\n\nNumber()除了0，“”，false会转成0，true转成1，其余都是调用toSring若是数值形式就转数值，不然是NaN\n\nNumber(NaN)        //NaN\nNumber("NaN")      //NaN\nNumber(0123)       //83\nNumber("0123")     //123\nNumber("Infinity") //Infinity\nNumber([123])      //123   [123].toString()\nNumber([123，3])   //NaN   \n\n\n\n# 运算符带来的强制类型转换\n\n有字符串时加法会把其余类型转换为字符串\n\n-，*，、，%优先转数值，+ 除外\n\n"3"-"2"            //1\n3+2+"1"            //"51"\n"3"+2+1            //"321"\n"312"*1            //312\n123+null           //123+Number(null)\n[]+{}              //两个对象相加调用toString，""+[object object] = [object object]\n{}+[]              //{}解析为代码块，+[]，优先转为数值，0\n// 至于为什么解析成了代码块，和js引擎的解析相关，在V8，Chrome的JavaScript引擎中，它检查的第一件事一开始是否是 {，如果是，则解析为block。\n[1,2]+[2,3]        //"1,22,3"\n[1] == "1"         // true\n\n\n在js中，加法运算的规则很简单，只会触发两种情况:\n\n>  1. number + number\n>  2. string + string\n> \n> 除了这两种，若：\n> \n> 如果有一个数为string，则将另一个操作数隐式的转换为string，然后通过字符串拼接得出结果。\n> \n> 如果为布尔值这种简单的数据类型，那么将会转换为number类型来进行运算得出结果。\n> \n> 如果操作数为对象或者是数组这种复杂的数据类型，那么就将两个操作数都转换为字符串，进行拼接\n\ntrue + false   // 1\nnull + 10      // 10\nfalse + 20     // 20\nundefined + 30 // NaN\n1 + \'2\'        // "12"\nNaN + \'\'       // "NaN"\nundefined + \'\' // "undefined"\nnull + \'\'      // "null"\n\'\' - 3         // -3\n\n[20] - 10\n// 过程\n[20].toString()  // \'20\'\nNumber(\'20\')     // 20\n20 - 10          // 10\n\n\n\n# JS如何进行类型判断\n\n * typeof关键字，存在问题\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof \'str\');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n//这是js发展过程中设计者的重大失误，早期准备更改null的类型为null，由于当时已经有大量网站使用了null，如果更改，将导致很多网站的逻辑出现漏洞问题，就没有更改过来\nconsole.log(typeof new Boolean(true));   //object\nconsole.log(typeof new Number(1));       //object\nconsole.log(typeof new String("abc"));   //object\n//对于一些创建的对象，它们都会返回\'object\'\n\n\n * instanceof关键字：\n   \n   判断对象是否是某一数据类型（如Array）的实例 ，存在问题\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log(\'str\' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true  \n//问题：字面值被实例化才可，因为字面值不存在__proto__\nconsole.log(new Number(2) instanceof Number);                    // true\nconsole.log(new Boolean(true) instanceof Boolean);                // true \nconsole.log(new String(\'str\') instanceof String);                // true  \n\n\n * Object.prototype.toString.call()\n\nObject.toString()//"function Object() { [native code] }"\nObject.prototype.toString()//"[object Object]"\n//Object对象和它的原型链上各自有一个toString()方法，第一个返回的是一个函数，第二个返回的是值类型。\n\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call(\'str\'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n// [object Number]\n// [object Boolean]\n// [object String]\n// [object Array]\n// [object Function]\n// [object Object]\n// [object Undefined]\n// [object Null]\n\n\n\n# 例：判断数组\n\nconst arr = [1,2,3,4]\narr instanceof Array\nObject.prototype.toString.call(arr) === \'[object Array]\'\nArray.isArray(arr)\narr.__proto__.constructor === Array\narr.__proto__ === Array.prototype\n\n\n\n# Symbol\n\n * 为什么要用Symbol？\n\nES5里面的对象的属性名是字符串，当我们使用时，若想添加一些新属性，可能会出现重名的情况，于是我们借助Symbol来生成一个独一无二的值，这样就可以防止属性名的冲突了。\n\n * Symbol是什么\n\n它是ES6新引入的一种原始类型数据，使用Symbol可以直接生成一个新的值。\n\nlet a1 = Symbol("a")\nlet a2 = Symbol("a")\na1 === a2 // false\n\n\n\n# Bigint\n\nJS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。\n\n90099999999999992 == 90099999999999993 //true\n//使用新的数据类型BigInt  直接在数字后面加n即可\n90099999999999992n == 90099999999999993n //false\ntypeof 90099999999999992n  //"bigint"\n\n\n\n# 什么情况下 a === a - 1\n\n * 正负Infinity\n * 不可被精确表示的值\n\n> 在 JavaScript 里，整数可以被精确表示的范围是从-2 ** 53 + 1到2 ** 53 - 1，即-9007199254740991到9007199254740991。超过这个数值的整数，都不能被精确表示。 常量 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER分别对应9007199254740991和-9007199254740991。\n\nlet a = Number.MIN_SAFE_INTEGER - 1;\nconsole.log(a === a - 1); // true\n\nlet a = Number.MAX_SAFE_INTEGER + 1;\nconsole.log(a === a - 1); // false\n\nlet a = Number.MAX_SAFE_INTEGER + 2;\nconsole.log(a === a - 1); // false\n\nlet a = Number.MAX_SAFE_INTEGER + 3;\nconsole.log(a === a - 1); // false\n\nlet a = Number.MAX_SAFE_INTEGER + 4;\nconsole.log(a === a - 1); // true\n\nlet a = Number.MAX_SAFE_INTEGER + 5;\nconsole.log(a === a - 1); // true\n\n\n * js的数值范围\n\n\n# 什么情况下 a==1&&a==2&&a==3为true成立\n\nconst a = {\n  i: 1,\n  toString: function () {\n    return a.i++;\n  }\n}\nconsole.log(a == 1 && a == 2 && a == 3) // true\n\n// a是一个对象，在判断时会调用toString方法，而我们把toString方法重写了\n// 如果改成 === 则不成立，类型不同直接返回 false，不会隐式转换\n',normalizedContent:'# js基本数据类型与类型转换\n\nes5基本有5种简单数据类型：string，number，boolean，null，undefined。一种复杂的数据类型object。\nes6新增一种简单数据类型：symbol,还有bigint\njs是动态类型语言，所以类型不同的时候进行运算会进行类型转换。\n\n\n\n# 转字符串\n\n * 转字符串可以理解为 + “”，底层是tostring方法，其中对象转为[object object]，数组去括号+“”\n\n2+"3"          //number(2).tostring()+"3"\ntrue+"1"       //boolean(true).tostring()+"1"\n""+{}          //输出[object object]\n""+{a:123}     //[object object]\n"123"=={tostring(){return "123"}}    //true，因为重写了tostring方法\n""+[]          //""\n""+[1,2,3]     //"1,2,3"\n\n\n\n# 转布尔型\n\nboolean()传入变量\n\n0，nan，""，null，undefined，false直接转换成false，其余都是真\n\n!!"123"       //true\n!!{}          //true\n\n\n\n# 一道题\n\nvar ali = document.queryselectrall("li")\nfor(let item,i = 0;item = ali[i++];){  //每次赋值都返回当前值，当最后输出undefined是转布尔false\n        console.log(item)\n}\n\n\n\n# 转数值\n\nnumber()除了0，“”，false会转成0，true转成1，其余都是调用tosring若是数值形式就转数值，不然是nan\n\nnumber(nan)        //nan\nnumber("nan")      //nan\nnumber(0123)       //83\nnumber("0123")     //123\nnumber("infinity") //infinity\nnumber([123])      //123   [123].tostring()\nnumber([123，3])   //nan   \n\n\n\n# 运算符带来的强制类型转换\n\n有字符串时加法会把其余类型转换为字符串\n\n-，*，、，%优先转数值，+ 除外\n\n"3"-"2"            //1\n3+2+"1"            //"51"\n"3"+2+1            //"321"\n"312"*1            //312\n123+null           //123+number(null)\n[]+{}              //两个对象相加调用tostring，""+[object object] = [object object]\n{}+[]              //{}解析为代码块，+[]，优先转为数值，0\n// 至于为什么解析成了代码块，和js引擎的解析相关，在v8，chrome的javascript引擎中，它检查的第一件事一开始是否是 {，如果是，则解析为block。\n[1,2]+[2,3]        //"1,22,3"\n[1] == "1"         // true\n\n\n在js中，加法运算的规则很简单，只会触发两种情况:\n\n>  1. number + number\n>  2. string + string\n> \n> 除了这两种，若：\n> \n> 如果有一个数为string，则将另一个操作数隐式的转换为string，然后通过字符串拼接得出结果。\n> \n> 如果为布尔值这种简单的数据类型，那么将会转换为number类型来进行运算得出结果。\n> \n> 如果操作数为对象或者是数组这种复杂的数据类型，那么就将两个操作数都转换为字符串，进行拼接\n\ntrue + false   // 1\nnull + 10      // 10\nfalse + 20     // 20\nundefined + 30 // nan\n1 + \'2\'        // "12"\nnan + \'\'       // "nan"\nundefined + \'\' // "undefined"\nnull + \'\'      // "null"\n\'\' - 3         // -3\n\n[20] - 10\n// 过程\n[20].tostring()  // \'20\'\nnumber(\'20\')     // 20\n20 - 10          // 10\n\n\n\n# js如何进行类型判断\n\n * typeof关键字，存在问题\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof \'str\');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n//这是js发展过程中设计者的重大失误，早期准备更改null的类型为null，由于当时已经有大量网站使用了null，如果更改，将导致很多网站的逻辑出现漏洞问题，就没有更改过来\nconsole.log(typeof new boolean(true));   //object\nconsole.log(typeof new number(1));       //object\nconsole.log(typeof new string("abc"));   //object\n//对于一些创建的对象，它们都会返回\'object\'\n\n\n * instanceof关键字：\n   \n   判断对象是否是某一数据类型（如array）的实例 ，存在问题\n\nconsole.log(2 instanceof number);                    // false\nconsole.log(true instanceof boolean);                // false \nconsole.log(\'str\' instanceof string);                // false  \nconsole.log([] instanceof array);                    // true\nconsole.log(function(){} instanceof function);       // true\nconsole.log({} instanceof object);                   // true  \n//问题：字面值被实例化才可，因为字面值不存在__proto__\nconsole.log(new number(2) instanceof number);                    // true\nconsole.log(new boolean(true) instanceof boolean);                // true \nconsole.log(new string(\'str\') instanceof string);                // true  \n\n\n * object.prototype.tostring.call()\n\nobject.tostring()//"function object() { [native code] }"\nobject.prototype.tostring()//"[object object]"\n//object对象和它的原型链上各自有一个tostring()方法，第一个返回的是一个函数，第二个返回的是值类型。\n\nvar a = object.prototype.tostring;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call(\'str\'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n// [object number]\n// [object boolean]\n// [object string]\n// [object array]\n// [object function]\n// [object object]\n// [object undefined]\n// [object null]\n\n\n\n# 例：判断数组\n\nconst arr = [1,2,3,4]\narr instanceof array\nobject.prototype.tostring.call(arr) === \'[object array]\'\narray.isarray(arr)\narr.__proto__.constructor === array\narr.__proto__ === array.prototype\n\n\n\n# symbol\n\n * 为什么要用symbol？\n\nes5里面的对象的属性名是字符串，当我们使用时，若想添加一些新属性，可能会出现重名的情况，于是我们借助symbol来生成一个独一无二的值，这样就可以防止属性名的冲突了。\n\n * symbol是什么\n\n它是es6新引入的一种原始类型数据，使用symbol可以直接生成一个新的值。\n\nlet a1 = symbol("a")\nlet a2 = symbol("a")\na1 === a2 // false\n\n\n\n# bigint\n\njs 中的number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。\n\n90099999999999992 == 90099999999999993 //true\n//使用新的数据类型bigint  直接在数字后面加n即可\n90099999999999992n == 90099999999999993n //false\ntypeof 90099999999999992n  //"bigint"\n\n\n\n# 什么情况下 a === a - 1\n\n * 正负infinity\n * 不可被精确表示的值\n\n> 在 javascript 里，整数可以被精确表示的范围是从-2 ** 53 + 1到2 ** 53 - 1，即-9007199254740991到9007199254740991。超过这个数值的整数，都不能被精确表示。 常量 number.max_safe_integer 和 number.min_safe_integer分别对应9007199254740991和-9007199254740991。\n\nlet a = number.min_safe_integer - 1;\nconsole.log(a === a - 1); // true\n\nlet a = number.max_safe_integer + 1;\nconsole.log(a === a - 1); // false\n\nlet a = number.max_safe_integer + 2;\nconsole.log(a === a - 1); // false\n\nlet a = number.max_safe_integer + 3;\nconsole.log(a === a - 1); // false\n\nlet a = number.max_safe_integer + 4;\nconsole.log(a === a - 1); // true\n\nlet a = number.max_safe_integer + 5;\nconsole.log(a === a - 1); // true\n\n\n * js的数值范围\n\n\n# 什么情况下 a==1&&a==2&&a==3为true成立\n\nconst a = {\n  i: 1,\n  tostring: function () {\n    return a.i++;\n  }\n}\nconsole.log(a == 1 && a == 2 && a == 3) // true\n\n// a是一个对象，在判断时会调用tostring方法，而我们把tostring方法重写了\n// 如果改成 === 则不成立，类型不同直接返回 false，不会隐式转换\n',charsets:{cjk:!0}},{title:"原型和原型链",frontmatter:{},regularPath:"/javascript/prototype.html",relativePath:"javascript/prototype.md",key:"v-38e6942a",path:"/javascript/prototype.html",headers:[{level:2,title:"原型链继承",slug:"原型链继承",normalizedTitle:"原型链继承",charIndex:393},{level:2,title:"构造函数继承",slug:"构造函数继承",normalizedTitle:"构造函数继承",charIndex:646},{level:2,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:942},{level:2,title:"原型式继承",slug:"原型式继承",normalizedTitle:"原型式继承",charIndex:1302},{level:2,title:"寄生式继承",slug:"寄生式继承",normalizedTitle:"寄生式继承",charIndex:1553},{level:2,title:"寄生组合式继承",slug:"寄生组合式继承",normalizedTitle:"寄生组合式继承",charIndex:1920}],lastUpdated:"2/27/2023, 5:18:11 PM",lastUpdatedTimestamp:1677489491e3,headersStr:"原型链继承 构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承",content:'# 原型和原型链\n\n * 原型：https://blog.csdn.net/u012468376/article/details/53121081\n * 原型链：https://blog.csdn.net/u012468376/article/details/53127929\n * Object和Function图示\n\nFunction.prototype.a = () => console.log(1);\nObject.prototype.b = () => console.log(2);\nfunction A() {};\nvar a = new A(); // 记住 new 返回的是对象\na.a(); // not a function\na.b(); // 2\n\nlet fun = function x() {}\nfun.a() //1\nfun.b() //2\n\n\n\n# 原型链继承\n\nfunction Father() {\n    this.name = "马云"\n}\n\nfunction Son() {\n\n}\n\nSon.prototype = new Father()\nlet son = new Son()\n\nconsole.log(son.name) // 马云\nson.__proto__ // Father {name: "马云"}\nson instanceof Father // true\n\n// 1. 无法传参 2. 父类实例属性被所有子类实例共享\n\n\n\n# 构造函数继承\n\nfunction Father(name) {\n    this.name = name\n}\n\nfunction Son(name, age) {\n    this.age = age\n    Father.call(this, name)\n}\n\nlet son = new Son("马云", 18)\n\nconsole.log(son) // Son {age: 18, name: "马云"}\n\n// 1. 利用call实现了传参 \n// 2. son instanceof Father 为 false，不是真正的继承，所以 Father 原型中的属性拿不到\n\n\n\n# 组合继承\n\nfunction Father(name) {\n    this.name = name\n    Father.prototype.eat = function() {\n        console.log("吃东西")\n    }\n}\n\nfunction Son(name, age) {\n    this.age = age\n    Father.call(this, name)\n}\n\nSon.prototype = new Father()\n\nlet son = new Son("马云", 18)\n\nconsole.log(son) // Son {age: 18, name: "马云"}\nson.eat() // 吃东西\nson instanceof Father // true\n\n\n\n# 原型式继承\n\nfunction inheritObj(o) {\n    function F() {}\n    F.prototype = o\n    return new F()\n}\n\nlet book = {\n    name: "js book"\n}\n\nlet ajaxBook = inheritObj(book)\n\najaxBook.name // "js book"\najaxBook.__proto__ // {name: "js book"}\n\n// 就是对原型链继承的封装\n\n\n\n# 寄生式继承\n\nfunction inheritObj(o) {\n    function F() {}\n    F.prototype = o\n    return new F()\n}\n\nlet book = {\n    name: "js book"\n}\n\nfunction creteBook(obj){\n    var o = inheritObj(obj)  //不仅有父类中的属性和方法\n    o.getName = function() {  //还添加了新的属性和方法\n        console.log(this.name)\n    }\n    return o\n}\n\nlet ajaxBook = new creteBook(book)\n\najaxBook.getName() // js book\n\n\n\n# 寄生组合式继承\n\nfunction inheritObject(o){\n    function F(){}\n    F.prototype = o\n    return new F()\n}\nfunction inheritPrototype(subClass, superClass){\n    var p = inheritObject(superClass.prototype)\n    p.constructor = subClass\n    subClass.prototype = p\n}\n//父类\nfunction SuperClass(name){\n    this.name = name\n}\n//子类\nfunction SubClass(name,time){\n    //构造函数式继承\n    SuperClass.call(this,name)\n    this.time = time\n}\n//寄生式继承父类原型\ninheritPrototype(subClass,superClass)\n',normalizedContent:'# 原型和原型链\n\n * 原型：https://blog.csdn.net/u012468376/article/details/53121081\n * 原型链：https://blog.csdn.net/u012468376/article/details/53127929\n * object和function图示\n\nfunction.prototype.a = () => console.log(1);\nobject.prototype.b = () => console.log(2);\nfunction a() {};\nvar a = new a(); // 记住 new 返回的是对象\na.a(); // not a function\na.b(); // 2\n\nlet fun = function x() {}\nfun.a() //1\nfun.b() //2\n\n\n\n# 原型链继承\n\nfunction father() {\n    this.name = "马云"\n}\n\nfunction son() {\n\n}\n\nson.prototype = new father()\nlet son = new son()\n\nconsole.log(son.name) // 马云\nson.__proto__ // father {name: "马云"}\nson instanceof father // true\n\n// 1. 无法传参 2. 父类实例属性被所有子类实例共享\n\n\n\n# 构造函数继承\n\nfunction father(name) {\n    this.name = name\n}\n\nfunction son(name, age) {\n    this.age = age\n    father.call(this, name)\n}\n\nlet son = new son("马云", 18)\n\nconsole.log(son) // son {age: 18, name: "马云"}\n\n// 1. 利用call实现了传参 \n// 2. son instanceof father 为 false，不是真正的继承，所以 father 原型中的属性拿不到\n\n\n\n# 组合继承\n\nfunction father(name) {\n    this.name = name\n    father.prototype.eat = function() {\n        console.log("吃东西")\n    }\n}\n\nfunction son(name, age) {\n    this.age = age\n    father.call(this, name)\n}\n\nson.prototype = new father()\n\nlet son = new son("马云", 18)\n\nconsole.log(son) // son {age: 18, name: "马云"}\nson.eat() // 吃东西\nson instanceof father // true\n\n\n\n# 原型式继承\n\nfunction inheritobj(o) {\n    function f() {}\n    f.prototype = o\n    return new f()\n}\n\nlet book = {\n    name: "js book"\n}\n\nlet ajaxbook = inheritobj(book)\n\najaxbook.name // "js book"\najaxbook.__proto__ // {name: "js book"}\n\n// 就是对原型链继承的封装\n\n\n\n# 寄生式继承\n\nfunction inheritobj(o) {\n    function f() {}\n    f.prototype = o\n    return new f()\n}\n\nlet book = {\n    name: "js book"\n}\n\nfunction cretebook(obj){\n    var o = inheritobj(obj)  //不仅有父类中的属性和方法\n    o.getname = function() {  //还添加了新的属性和方法\n        console.log(this.name)\n    }\n    return o\n}\n\nlet ajaxbook = new cretebook(book)\n\najaxbook.getname() // js book\n\n\n\n# 寄生组合式继承\n\nfunction inheritobject(o){\n    function f(){}\n    f.prototype = o\n    return new f()\n}\nfunction inheritprototype(subclass, superclass){\n    var p = inheritobject(superclass.prototype)\n    p.constructor = subclass\n    subclass.prototype = p\n}\n//父类\nfunction superclass(name){\n    this.name = name\n}\n//子类\nfunction subclass(name,time){\n    //构造函数式继承\n    superclass.call(this,name)\n    this.time = time\n}\n//寄生式继承父类原型\ninheritprototype(subclass,superclass)\n',charsets:{cjk:!0}},{title:"谈谈JavaScript的作用域",frontmatter:{title:"谈谈JavaScript的作用域",date:"2018-11-01T10:00:54.000Z",categories:"JavaScript"},regularPath:"/javascript/scope.html",relativePath:"javascript/scope.md",key:"v-30a98ff2",path:"/javascript/scope.html",headers:[{level:3,title:"全局作用域",slug:"全局作用域",normalizedTitle:"全局作用域",charIndex:2},{level:3,title:"函数作用域",slug:"函数作用域",normalizedTitle:"函数作用域",charIndex:857},{level:3,title:"块级作用域",slug:"块级作用域",normalizedTitle:"块级作用域",charIndex:1869},{level:3,title:"词法作用域",slug:"词法作用域",normalizedTitle:"词法作用域",charIndex:2736},{level:3,title:"动态作用域",slug:"动态作用域",normalizedTitle:"动态作用域",charIndex:5868}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"全局作用域 函数作用域 块级作用域 词法作用域 动态作用域",content:"# 全局作用域\n\n作用域，是指变量的生命周期（一个变量在哪些范围内保持一定值）。\n\n> 全局变量：\n> \n> 生命周期将存在于整个程序之内。\n> \n> 能被程序中任何函数或者方法访问。\n> \n> 在 JavaScript 内默认是可以被修改的。\n\n全局变量，虽然好用，但是是非常可怕的，这是所有程序员公认的事实。\n\n# 显式声明：\n\n带有关键字 var 的声明；\n\n<script type=\"text/javascript\">\n\n    var testValue = 123;\n\n    var testFunc = function () { console.log('just test') };\n\n    /**---------全局变量会挂载到 window 对象上------------**/\n\n    console.log(window.testFunc)\t\t// ƒ () { console.log('just test') }\n\n    console.log(window.testValue)\t\t// 123\n    \n<\/script>\n复制代码\n\n\n其实，我们写的函数如果不经过封装，也会是全局变量，他的生命周期也就是全局作用域；\n\n# 隐式声明：\n\n不带有声明关键字的变量，JS 会默认帮你声明一个全局变量！！！\n\n<script type=\"text/javascript\">\n\n    function foo(value) {\n\n      result = value + 1;\t // 没有用 var 修饰\n\n      return result;\n    };\n\n    foo(123);\t\t\t\t// 124\n    \n    console.log(window.result);\t\t\t// 124 <=  挂在了 window全局对象上 \n    \n<\/script>\n复制代码\n\n\n现在，变量 result 被挂载到 window 对象上了！！！\n\n\n# 函数作用域\n\n函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域！！！\n\nfunction bar() {\n  var testValue = 'inner';\n}\n\nconsole.log(testValue);\t\t// 报错：ReferenceError: testValue is not defined\n\n\n# 通过 return 访问函数内部变量：\n\nfunction bar(value) {\n  var testValue = 'inner';\n  \n  return testValue + value;\n}\n\nconsole.log(bar('fun'));\t\t// \"innerfun\"\n复制代码\n\n\n函数就像一个工厂，我们输入一些东西，它在内部加工，然后给我们一个加工产物；\n\n# 通过 闭包 访问函数内部变量：\n\nfunction bar(value) {\n  var testValue = 'inner';\n  \n  var rusult = testValue + value;\n  \n  function innser() {\n     return rusult;\n  };\n  \n  return innser();\n}\n\nconsole.log(bar('fun'));\t\t// \"innerfun\"\n\n\n关于闭包，我不会在这篇文章过多描述，因为，想要描述闭包，本身需要跟本文章一样的长度；\n\n# 立即执行函数：\n\n这是个很实用的函数，很多库都用它分离全局作用域，形成一个单独的函数作用域；\n\n<script type=\"text/javascript\">\n\n    (function() {\n\n      var testValue = 123;\n\n      var testFunc = function () { console.log('just test'); };\n\n    })();\n\n    console.log(window.testValue);\t\t// undefined\n    \n    console.log(window.testFunc);\t\t// undefined\n    \n<\/script>\n\n\n它能够自动执行 (function() { //... })() 里面包裹的内容，能够很好地消除全局变量的影响；\n\n\n# 块级作用域\n\n在 ES6 之前，是没有块级作用域的概念的。如果你有 C++ 或者 Java 经验，想必你对块级作用域并不陌生；\n\nfor(var i = 0; i < 5; i++) {\n  // ...\n}\n\nconsole.log(i)\t\t\t\t// 5\n\n\n很明显，用 var 关键字声明的变量，在 for 循环之后仍然被保存这个作用域里；\n\n这可以说明： for() { }仍然在，全局作用域里，并没有产生像函数作用域一样的封闭效果；\n\n如果想要实现 块级作用域 那么我们需要用 let 关键字声明！！！\n\nfor(let i = 0; i < 5; i++) {\n  // ...\n}\n\nconsole.log(i)\t\t\t\t// 报错：ReferenceError: i is not defined\n\n\n在 for 循环执行完毕之后 i 变量就被释放了，它已经消失了！！！\n\n同样能形成块级作用域的还有 const 关键字：\n\nif (true) {\n  const a = 'inner';\n}\n\nconsole.log(a);\t\t\t\t// 报错：ReferenceError: a is not defined\n\n\nlet 和 const 关键字，创建块级作用域的条件是必须有一个 { } 包裹：\n\n{\n  let a = 'inner';\n}\n  \nif (true) {\n   let b = 'inner'; \n}\n\nvar i = 0;\n\n// ......\n\n\n不要小看块级作用域，它能帮你做很多事情，举个栗子：\n\n举一个面试中常见的例子：\n\nfor(var i = 0; i < 5; i++) {\n  setTimeout(function() {\n     console.log(i);\t\t\t// 5 5 5 5 5\n  }, 200);\n};\n\n\n这几乎是作用域的必考题目，你会觉得这种结果很奇怪，但是事实就是这么发生了；\n\n这里的 i 是在全局作用域里面的，只存在 1 个值，等到回调函数执行时，用词法作用域捕获的 i 就只能是 5；\n\n因为这个循环计算的 i 值在回调函数结束之前就已经执行到 5 了；我们应该如何让它恢复正常呢？？？\n\n解法1：调用函数，创建函数作用域：\n\nfor(var i = 0; i < 5; i++) {\n  abc(i);\n};\n\nfunction abc(i) {\n  setTimeout(function() {\n     console.log(i);\t\t\t// 0 1 2 3 4 \n  }, 200); \n}\n\n\n这里相当于创建了5个函数作用域来保存，我们的 i 值；\n\n解法2：采用立即执行函数，创建函数作用域；\n\nfor(var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function() {\n      console.log(j);\n    }, 200);\n  })(i);\n};\n\n\n原理同上，只不过换成了自动执行这个函数罢了，这里保存了 5 次 i 的值；\n\n**解法3：let 创建块级作用域，可以将块级作用域理解为: 使用let和const声明的变量, 只在当前大括号内生效 **\n\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function() {\n      console.log(i);\n    }, 200);\n};\n\n\n这里的大括号内主要指的是一下几种情况\n\n// 条件语句\nif () {}\n\n// switch语句\nswitch () {}\n\n// for / while循环语句\nfor () {}\nwhile () {}\n\n// try...catch语句\ntry () catch (err) {}\n\n// 单大括号\n{}\n\n\nfor循环问题的解决\n\n<ul>\n    <li>第一个</li>\n    <li>第二个</li>\n    <li>第三个</li>\n    <li>第四个</li>\n</ul>\n\n<script>\n    let oli = document.getElementsByTagName(\"li\")\n    for(var i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // //相当于\n    var i\n    i=0\n    oli[0].onclick = function(){\n            console.log(i)\n    }\n    i=1\n    oli[1].onclick = function(){\n            console.log(i)\n    }\n    i=2\n    oli[2].onclick = function(){\n            console.log(i)\n    }\n    i=3\n    oli[3].onclick = function(){\n            console.log(i)\n    }\n //按照词法作用域查找，会每次都找到全局的i\n\n\n    //方法一：改为let\n    for(let i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // 《深入理解ES6》上面说循环中的let声明在循环内部是标准中专门定义的\n    // 而是每次let声明都会创建一个新的变量i，并将其初始化为i的当前值\n    for(let i=0;i<4;i++){\n        let i = //i，暂存的思想\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    //这个时候在执行点击事件时，i会在for循环的第一行找到i的值\n\n    //方法二：闭包\n    for(var i=0;i<4;i++){\n        (function(i){\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        })(i)\n    }\n    \n    //方法三：暂存数据,和let原理类似\n    for(var i=0;i<4;i++){\n        oli[i].index = i\n        oli[i].onclick = function(){\n            console.log(this.index)\n        }\n    }\n\n    //方法四：事件委托\n    var oul = document.getElementsByTagName(\"ul\")[0];\n    oul.onclick = function(e){\n        var e = e || window.event\n        var target = e.target || e.srcElement\n        if(target.nodeName.toLowerCase() == 'li'){\n            var li=this.querySelectorAll(\"li\");\n            var index = Array.prototype.indexOf.call(li,target);\n            console.log(index);\n　　　　    }\n    }\n<\/script>\n\n\n\n# 词法作用域\n\n词法作用域是指一个变量的可见性，及其文本表述的模拟值（《JavaScript函数式编程》）;\n\n听起来，十分地晦涩，不过将代码拿来分析就非常浅显易懂了；\n\ntestValue = 'outer';\n\nfunction afun() {\n  var testValue = 'middle';\n  \n  console.log(testValue);\t\t// \"middle\"\n  \n  function innerFun() {\n    var testValue = 'inner';\n    \n    console.log(testValue);\t\t// \"inner\"\n  }\n  \n  return innerFun();\n}\n\nafun();\n\nconsole.log(testValue);\t\t\t// \"outer\"\n\n\n当我们要使用声明的变量时：JS引擎总会从最近的一个域，向外层域查找；\n\n\n\n再举一个一个实际的例子：\n\nvar testValue = 'outer';\n\nfunction foo() {\n  console.log(testValue);\t\t// \"outer\"\n}\n\nfunction bar() {\n  var testValue = 'inner';\n  \n  foo();\n}\n\nbar();\n// 个人理解词法作用于是基于代码定义的\n\n\n显然，当 JS 引擎查找这个变量时，发现全局的 testValue 离得更近一些，这恰好和 动态作用域 相反；\n\n\n\n如上图所示，下面将讲述与 词法作用域相反的动态作用域；\n\n\n# 动态作用域\n\n在编程中，最容易被低估和滥用的概念就是动态作用域（《JavaScript函数式编程》）。\n\n在 JavaScript 中的仅存的应用动态作用域的地方：this 引用，所以这是一个大坑！！！！！\n\n> 动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；\n> \n> 作用域嵌套，有词法作用域一样的特性，查找变量时，总是寻找最近的作用域；\n\n同样是，词法作用域，例子2，同一份代码，如果 是动态作用域：\n\nvar testValue = 'outer';\n\nfunction foo() {\n  console.log(testValue);\t\t// \"inner\"\n}\n\nfunction bar() {\n  var testValue = 'inner';\n  \n  foo();\n}\n\nbar();\n\n\n当然，JavaScript 除了this之外，其他，都是根据词法作用域查找！！！\n\n\n\n为什么要理解动态作用域呢？因为，这能让你更好地学习 this 引用！！！\n\n要清楚，JavaScript 实际上没有动态作用域。它拥有词法作用域。就这么简单。但是 this 机制有些像动态作用域。\n\n关键的差异：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。\n\n作者：leiting1998 链接：https://juejin.im/post/5abb99e9f265da2392366824 来源：掘金",normalizedContent:"# 全局作用域\n\n作用域，是指变量的生命周期（一个变量在哪些范围内保持一定值）。\n\n> 全局变量：\n> \n> 生命周期将存在于整个程序之内。\n> \n> 能被程序中任何函数或者方法访问。\n> \n> 在 javascript 内默认是可以被修改的。\n\n全局变量，虽然好用，但是是非常可怕的，这是所有程序员公认的事实。\n\n# 显式声明：\n\n带有关键字 var 的声明；\n\n<script type=\"text/javascript\">\n\n    var testvalue = 123;\n\n    var testfunc = function () { console.log('just test') };\n\n    /**---------全局变量会挂载到 window 对象上------------**/\n\n    console.log(window.testfunc)\t\t// ƒ () { console.log('just test') }\n\n    console.log(window.testvalue)\t\t// 123\n    \n<\/script>\n复制代码\n\n\n其实，我们写的函数如果不经过封装，也会是全局变量，他的生命周期也就是全局作用域；\n\n# 隐式声明：\n\n不带有声明关键字的变量，js 会默认帮你声明一个全局变量！！！\n\n<script type=\"text/javascript\">\n\n    function foo(value) {\n\n      result = value + 1;\t // 没有用 var 修饰\n\n      return result;\n    };\n\n    foo(123);\t\t\t\t// 124\n    \n    console.log(window.result);\t\t\t// 124 <=  挂在了 window全局对象上 \n    \n<\/script>\n复制代码\n\n\n现在，变量 result 被挂载到 window 对象上了！！！\n\n\n# 函数作用域\n\n函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域！！！\n\nfunction bar() {\n  var testvalue = 'inner';\n}\n\nconsole.log(testvalue);\t\t// 报错：referenceerror: testvalue is not defined\n\n\n# 通过 return 访问函数内部变量：\n\nfunction bar(value) {\n  var testvalue = 'inner';\n  \n  return testvalue + value;\n}\n\nconsole.log(bar('fun'));\t\t// \"innerfun\"\n复制代码\n\n\n函数就像一个工厂，我们输入一些东西，它在内部加工，然后给我们一个加工产物；\n\n# 通过 闭包 访问函数内部变量：\n\nfunction bar(value) {\n  var testvalue = 'inner';\n  \n  var rusult = testvalue + value;\n  \n  function innser() {\n     return rusult;\n  };\n  \n  return innser();\n}\n\nconsole.log(bar('fun'));\t\t// \"innerfun\"\n\n\n关于闭包，我不会在这篇文章过多描述，因为，想要描述闭包，本身需要跟本文章一样的长度；\n\n# 立即执行函数：\n\n这是个很实用的函数，很多库都用它分离全局作用域，形成一个单独的函数作用域；\n\n<script type=\"text/javascript\">\n\n    (function() {\n\n      var testvalue = 123;\n\n      var testfunc = function () { console.log('just test'); };\n\n    })();\n\n    console.log(window.testvalue);\t\t// undefined\n    \n    console.log(window.testfunc);\t\t// undefined\n    \n<\/script>\n\n\n它能够自动执行 (function() { //... })() 里面包裹的内容，能够很好地消除全局变量的影响；\n\n\n# 块级作用域\n\n在 es6 之前，是没有块级作用域的概念的。如果你有 c++ 或者 java 经验，想必你对块级作用域并不陌生；\n\nfor(var i = 0; i < 5; i++) {\n  // ...\n}\n\nconsole.log(i)\t\t\t\t// 5\n\n\n很明显，用 var 关键字声明的变量，在 for 循环之后仍然被保存这个作用域里；\n\n这可以说明： for() { }仍然在，全局作用域里，并没有产生像函数作用域一样的封闭效果；\n\n如果想要实现 块级作用域 那么我们需要用 let 关键字声明！！！\n\nfor(let i = 0; i < 5; i++) {\n  // ...\n}\n\nconsole.log(i)\t\t\t\t// 报错：referenceerror: i is not defined\n\n\n在 for 循环执行完毕之后 i 变量就被释放了，它已经消失了！！！\n\n同样能形成块级作用域的还有 const 关键字：\n\nif (true) {\n  const a = 'inner';\n}\n\nconsole.log(a);\t\t\t\t// 报错：referenceerror: a is not defined\n\n\nlet 和 const 关键字，创建块级作用域的条件是必须有一个 { } 包裹：\n\n{\n  let a = 'inner';\n}\n  \nif (true) {\n   let b = 'inner'; \n}\n\nvar i = 0;\n\n// ......\n\n\n不要小看块级作用域，它能帮你做很多事情，举个栗子：\n\n举一个面试中常见的例子：\n\nfor(var i = 0; i < 5; i++) {\n  settimeout(function() {\n     console.log(i);\t\t\t// 5 5 5 5 5\n  }, 200);\n};\n\n\n这几乎是作用域的必考题目，你会觉得这种结果很奇怪，但是事实就是这么发生了；\n\n这里的 i 是在全局作用域里面的，只存在 1 个值，等到回调函数执行时，用词法作用域捕获的 i 就只能是 5；\n\n因为这个循环计算的 i 值在回调函数结束之前就已经执行到 5 了；我们应该如何让它恢复正常呢？？？\n\n解法1：调用函数，创建函数作用域：\n\nfor(var i = 0; i < 5; i++) {\n  abc(i);\n};\n\nfunction abc(i) {\n  settimeout(function() {\n     console.log(i);\t\t\t// 0 1 2 3 4 \n  }, 200); \n}\n\n\n这里相当于创建了5个函数作用域来保存，我们的 i 值；\n\n解法2：采用立即执行函数，创建函数作用域；\n\nfor(var i = 0; i < 5; i++) {\n  (function(j) {\n    settimeout(function() {\n      console.log(j);\n    }, 200);\n  })(i);\n};\n\n\n原理同上，只不过换成了自动执行这个函数罢了，这里保存了 5 次 i 的值；\n\n**解法3：let 创建块级作用域，可以将块级作用域理解为: 使用let和const声明的变量, 只在当前大括号内生效 **\n\nfor(let i = 0; i < 5; i++) {\n    settimeout(function() {\n      console.log(i);\n    }, 200);\n};\n\n\n这里的大括号内主要指的是一下几种情况\n\n// 条件语句\nif () {}\n\n// switch语句\nswitch () {}\n\n// for / while循环语句\nfor () {}\nwhile () {}\n\n// try...catch语句\ntry () catch (err) {}\n\n// 单大括号\n{}\n\n\nfor循环问题的解决\n\n<ul>\n    <li>第一个</li>\n    <li>第二个</li>\n    <li>第三个</li>\n    <li>第四个</li>\n</ul>\n\n<script>\n    let oli = document.getelementsbytagname(\"li\")\n    for(var i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // //相当于\n    var i\n    i=0\n    oli[0].onclick = function(){\n            console.log(i)\n    }\n    i=1\n    oli[1].onclick = function(){\n            console.log(i)\n    }\n    i=2\n    oli[2].onclick = function(){\n            console.log(i)\n    }\n    i=3\n    oli[3].onclick = function(){\n            console.log(i)\n    }\n //按照词法作用域查找，会每次都找到全局的i\n\n\n    //方法一：改为let\n    for(let i=0;i<4;i++){\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    // 《深入理解es6》上面说循环中的let声明在循环内部是标准中专门定义的\n    // 而是每次let声明都会创建一个新的变量i，并将其初始化为i的当前值\n    for(let i=0;i<4;i++){\n        let i = //i，暂存的思想\n        oli[i].onclick = function(){\n            console.log(i)\n        }\n    }\n    //这个时候在执行点击事件时，i会在for循环的第一行找到i的值\n\n    //方法二：闭包\n    for(var i=0;i<4;i++){\n        (function(i){\n            oli[i].onclick = function(){\n                console.log(i)\n            }\n        })(i)\n    }\n    \n    //方法三：暂存数据,和let原理类似\n    for(var i=0;i<4;i++){\n        oli[i].index = i\n        oli[i].onclick = function(){\n            console.log(this.index)\n        }\n    }\n\n    //方法四：事件委托\n    var oul = document.getelementsbytagname(\"ul\")[0];\n    oul.onclick = function(e){\n        var e = e || window.event\n        var target = e.target || e.srcelement\n        if(target.nodename.tolowercase() == 'li'){\n            var li=this.queryselectorall(\"li\");\n            var index = array.prototype.indexof.call(li,target);\n            console.log(index);\n　　　　    }\n    }\n<\/script>\n\n\n\n# 词法作用域\n\n词法作用域是指一个变量的可见性，及其文本表述的模拟值（《javascript函数式编程》）;\n\n听起来，十分地晦涩，不过将代码拿来分析就非常浅显易懂了；\n\ntestvalue = 'outer';\n\nfunction afun() {\n  var testvalue = 'middle';\n  \n  console.log(testvalue);\t\t// \"middle\"\n  \n  function innerfun() {\n    var testvalue = 'inner';\n    \n    console.log(testvalue);\t\t// \"inner\"\n  }\n  \n  return innerfun();\n}\n\nafun();\n\nconsole.log(testvalue);\t\t\t// \"outer\"\n\n\n当我们要使用声明的变量时：js引擎总会从最近的一个域，向外层域查找；\n\n\n\n再举一个一个实际的例子：\n\nvar testvalue = 'outer';\n\nfunction foo() {\n  console.log(testvalue);\t\t// \"outer\"\n}\n\nfunction bar() {\n  var testvalue = 'inner';\n  \n  foo();\n}\n\nbar();\n// 个人理解词法作用于是基于代码定义的\n\n\n显然，当 js 引擎查找这个变量时，发现全局的 testvalue 离得更近一些，这恰好和 动态作用域 相反；\n\n\n\n如上图所示，下面将讲述与 词法作用域相反的动态作用域；\n\n\n# 动态作用域\n\n在编程中，最容易被低估和滥用的概念就是动态作用域（《javascript函数式编程》）。\n\n在 javascript 中的仅存的应用动态作用域的地方：this 引用，所以这是一个大坑！！！！！\n\n> 动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；\n> \n> 作用域嵌套，有词法作用域一样的特性，查找变量时，总是寻找最近的作用域；\n\n同样是，词法作用域，例子2，同一份代码，如果 是动态作用域：\n\nvar testvalue = 'outer';\n\nfunction foo() {\n  console.log(testvalue);\t\t// \"inner\"\n}\n\nfunction bar() {\n  var testvalue = 'inner';\n  \n  foo();\n}\n\nbar();\n\n\n当然，javascript 除了this之外，其他，都是根据词法作用域查找！！！\n\n\n\n为什么要理解动态作用域呢？因为，这能让你更好地学习 this 引用！！！\n\n要清楚，javascript 实际上没有动态作用域。它拥有词法作用域。就这么简单。但是 this 机制有些像动态作用域。\n\n关键的差异：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。\n\n作者：leiting1998 链接：https://juejin.im/post/5abb99e9f265da2392366824 来源：掘金",charsets:{cjk:!0}},{title:"JSON.stringify",frontmatter:{},regularPath:"/javascript/stringify.html",relativePath:"javascript/stringify.md",key:"v-f887684e",path:"/javascript/stringify.html",headers:[{level:3,title:"先说结论",slug:"先说结论",normalizedTitle:"先说结论",charIndex:215},{level:3,title:"不安全的JSON值",slug:"不安全的json值",normalizedTitle:"不安全的json值",charIndex:424},{level:3,title:"（1）undefined,function,symbol",slug:"_1-undefined-function-symbol",normalizedTitle:"（1）undefined,function,symbol",charIndex:438},{level:3,title:"（2）循环引用",slug:"_2-循环引用",normalizedTitle:"（2）循环引用",charIndex:807},{level:2,title:"JSON.stringify的几个参数",slug:"json-stringify的几个参数",normalizedTitle:"json.stringify的几个参数",charIndex:1233},{level:3,title:"（1）replacer",slug:"_1-replacer",normalizedTitle:"（1）replacer",charIndex:1257},{level:3,title:"（2）space",slug:"_2-space",normalizedTitle:"（2）space",charIndex:1963},{level:2,title:"联系序列化深拷贝",slug:"联系序列化深拷贝",normalizedTitle:"联系序列化深拷贝",charIndex:2289}],lastUpdated:"8/8/2022, 5:33:38 PM",lastUpdatedTimestamp:1659951218e3,headersStr:"先说结论 不安全的JSON值 （1）undefined,function,symbol （2）循环引用 JSON.stringify的几个参数 （1）replacer （2）space 联系序列化深拷贝",content:'# JSON.stringify\n\n我们都知道 toString 是用于处理非字符串到字符串的强制类型转换（隐式类型转换）\n\nlet a={}  \na.toString()   //[object Object]\nlet b=[1,2,3]\nb.toString()   //数组的toString被重写了，所以输出"1,2,3"\n\n\nJSON.stringify 将 JSON对象序列化时也用到了 toString()\n\n\n# 先说结论\n\n * 安全的 JSON 值可以序列化，不安全的 JSON 值会特殊处理\n\n * 安全：字符串，数字，布尔值和 null 的JSON.stringify 与 toString 基本相同\n\n * 不安全：undefined,function,symbol会特殊处理，如果传递给 JSON.stringify 的对象中定义了 toJSON方法，那么该方法会在字符串化前调用，将对象转化为安全JSON 值\n\n\n# 不安全的JSON值\n\n\n# （1）undefined,function,symbol\n\n 1. 直接放在对象中：undefined\n\nJSON.stringify(undefined)    //undefined\nJSON.stringify(function(){}) //undefined\nJSON.stringify(Symbol(a))    //undefined\n\n\n 2. 放在数组中：输出null\n\nJSON.stringify(\n\t[1,undefined,function(){},Symbol(a),4]\n)\n//[1,null,null,null,4]\n\nJSON.stringify(\n\t{a:1,b:undefined,c:function(){},d:Symbol(a),e:4}\n)\n//{"a": 1,"e": 4}\n\n\n\n# （2）循环引用\n\n可以定义toJSON方法来返回安全的JSON值\n\nlet o = {}\nlet a = {\n    b: 42,\n    c: o,\n    d: function(){}\n}\no.e = a // 创建循环引用\nconsole.log(JSON.stringify(a)) // 报错\n\n// 自定义一下 toJSON\na.toJSON = function() {\n    return {b: this.b}\n}\nconsole.log(JSON.stringify(a)) // {"b": 42}\n\n\n也就是说，toJSON应该返回一个能够被字符串化的安全JSON值\n\nvar a = {\n val: [1,2,3],\n toJSON: function(){\n \treturn this.val.slice(1);\n }\n};\nconsole.log(JSON.stringify(a)) // "[2,3]"\n\n\n\n# JSON.stringify的几个参数\n\n\n# （1）replacer\n\n * 是一个数组，那么他必须是一个字符串数组，其中包含的是要序列化的，除此之外的属性被忽略\n * 是一个函数，对对象本身调用一次，然后对每个属性各调用一次\n\nlet a = {\n    b: 42,\n    c: "42",\n    d: [1,2,3]\n}\nconsole.log(JSON.stringify(a, ["b","c"]))\n//{"b":42,"c":"42"}\n\nconsole.log(JSON.stringify(a, function(k,v) {\n    if(k !== "c") return v\n}))\n//{"b":42,"d":[1,2,3]}\n\nconst dude = {\n  name: "Pawel",\n  friends: new Set(["Dan", "Pedro", "Mr Gregory"])\n};\n\nconst dudeStringified = JSON.stringify(dude);\nconsole.log(dudeStringified);\n// {"name":"Pawel","friends":{}}\n\nconst dudeStringified = JSON.stringify(dude, (key, value) =>\n  value instanceof Set ? [...value] : value\n);\nconsole.log(dudeStringified);\n// {"name":"Pawel","friends":["Dan","Pedro","Mr Gregory"]}\n\n\n\n# （2）space\n\n用于指定缩进格式\n\nlet a = {\n    b: 42,\n    c: "42",\n    d: [1,2,3]\n}\nconsole.log(JSON.stringify(a, null, 3))\n/*\n{\n   "b": 42,\n   "c": "42",\n   "d": [\n      1,\n      2,\n      3\n   ]\n}\n*/\n\nconsole.log(JSON.stringify(a, null, \'----\'))\n/*\n{\n----"b": 42,\n----"c": "42",\n----"d": [\n--------1,\n--------2,\n--------3\n----]\n}\n*/\n\n\n\n# 联系序列化深拷贝\n\nJSON.parse(JSON.stringify(obj)) 的问题：\n\n 1. 对象的属性值是函数时，无法拷贝。\n 2. 原型链上的属性无法拷贝\n 3. 不能正确的处理 Date 类型的数据\n 4. 不能处理 RegExp\n 5. 会忽略 symbol\n 6. 会忽略 undefined\n\n由此可知，无法处理函数, undefied, symbol 是因为不是安全的 JSON 格式',normalizedContent:'# json.stringify\n\n我们都知道 tostring 是用于处理非字符串到字符串的强制类型转换（隐式类型转换）\n\nlet a={}  \na.tostring()   //[object object]\nlet b=[1,2,3]\nb.tostring()   //数组的tostring被重写了，所以输出"1,2,3"\n\n\njson.stringify 将 json对象序列化时也用到了 tostring()\n\n\n# 先说结论\n\n * 安全的 json 值可以序列化，不安全的 json 值会特殊处理\n\n * 安全：字符串，数字，布尔值和 null 的json.stringify 与 tostring 基本相同\n\n * 不安全：undefined,function,symbol会特殊处理，如果传递给 json.stringify 的对象中定义了 tojson方法，那么该方法会在字符串化前调用，将对象转化为安全json 值\n\n\n# 不安全的json值\n\n\n# （1）undefined,function,symbol\n\n 1. 直接放在对象中：undefined\n\njson.stringify(undefined)    //undefined\njson.stringify(function(){}) //undefined\njson.stringify(symbol(a))    //undefined\n\n\n 2. 放在数组中：输出null\n\njson.stringify(\n\t[1,undefined,function(){},symbol(a),4]\n)\n//[1,null,null,null,4]\n\njson.stringify(\n\t{a:1,b:undefined,c:function(){},d:symbol(a),e:4}\n)\n//{"a": 1,"e": 4}\n\n\n\n# （2）循环引用\n\n可以定义tojson方法来返回安全的json值\n\nlet o = {}\nlet a = {\n    b: 42,\n    c: o,\n    d: function(){}\n}\no.e = a // 创建循环引用\nconsole.log(json.stringify(a)) // 报错\n\n// 自定义一下 tojson\na.tojson = function() {\n    return {b: this.b}\n}\nconsole.log(json.stringify(a)) // {"b": 42}\n\n\n也就是说，tojson应该返回一个能够被字符串化的安全json值\n\nvar a = {\n val: [1,2,3],\n tojson: function(){\n \treturn this.val.slice(1);\n }\n};\nconsole.log(json.stringify(a)) // "[2,3]"\n\n\n\n# json.stringify的几个参数\n\n\n# （1）replacer\n\n * 是一个数组，那么他必须是一个字符串数组，其中包含的是要序列化的，除此之外的属性被忽略\n * 是一个函数，对对象本身调用一次，然后对每个属性各调用一次\n\nlet a = {\n    b: 42,\n    c: "42",\n    d: [1,2,3]\n}\nconsole.log(json.stringify(a, ["b","c"]))\n//{"b":42,"c":"42"}\n\nconsole.log(json.stringify(a, function(k,v) {\n    if(k !== "c") return v\n}))\n//{"b":42,"d":[1,2,3]}\n\nconst dude = {\n  name: "pawel",\n  friends: new set(["dan", "pedro", "mr gregory"])\n};\n\nconst dudestringified = json.stringify(dude);\nconsole.log(dudestringified);\n// {"name":"pawel","friends":{}}\n\nconst dudestringified = json.stringify(dude, (key, value) =>\n  value instanceof set ? [...value] : value\n);\nconsole.log(dudestringified);\n// {"name":"pawel","friends":["dan","pedro","mr gregory"]}\n\n\n\n# （2）space\n\n用于指定缩进格式\n\nlet a = {\n    b: 42,\n    c: "42",\n    d: [1,2,3]\n}\nconsole.log(json.stringify(a, null, 3))\n/*\n{\n   "b": 42,\n   "c": "42",\n   "d": [\n      1,\n      2,\n      3\n   ]\n}\n*/\n\nconsole.log(json.stringify(a, null, \'----\'))\n/*\n{\n----"b": 42,\n----"c": "42",\n----"d": [\n--------1,\n--------2,\n--------3\n----]\n}\n*/\n\n\n\n# 联系序列化深拷贝\n\njson.parse(json.stringify(obj)) 的问题：\n\n 1. 对象的属性值是函数时，无法拷贝。\n 2. 原型链上的属性无法拷贝\n 3. 不能正确的处理 date 类型的数据\n 4. 不能处理 regexp\n 5. 会忽略 symbol\n 6. 会忽略 undefined\n\n由此可知，无法处理函数, undefied, symbol 是因为不是安全的 json 格式',charsets:{cjk:!0}},{title:"函数式编程",frontmatter:{title:"函数式编程",date:"2020-08-18T09:21:01.000Z",categories:"函数式编程"},regularPath:"/javascript/function.html",relativePath:"javascript/function.md",key:"v-ce167802",path:"/javascript/function.html",headers:[{level:2,title:"JavaScript是函数式语言吗",slug:"javascript是函数式语言吗",normalizedTitle:"javascript是函数式语言吗",charIndex:12},{level:2,title:"函数式编程定义",slug:"函数式编程定义",normalizedTitle:"函数式编程定义",charIndex:276},{level:2,title:"编程范式",slug:"编程范式",normalizedTitle:"编程范式",charIndex:455},{level:2,title:"函数式编程优势",slug:"函数式编程优势",normalizedTitle:"函数式编程优势",charIndex:833},{level:2,title:"衍生应用场景",slug:"衍生应用场景",normalizedTitle:"衍生应用场景",charIndex:885},{level:3,title:"纯函数",slug:"纯函数",normalizedTitle:"纯函数",charIndex:88},{level:3,title:"副作用",slug:"副作用",normalizedTitle:"副作用",charIndex:694},{level:3,title:"递归与尾递归",slug:"递归与尾递归",normalizedTitle:"递归与尾递归",charIndex:911},{level:3,title:"记忆函数",slug:"记忆函数",normalizedTitle:"记忆函数",charIndex:903},{level:3,title:"高阶函数",slug:"高阶函数",normalizedTitle:"高阶函数",charIndex:182},{level:3,title:"柯里化与偏函数",slug:"柯里化与偏函数",normalizedTitle:"柯里化与偏函数",charIndex:3177},{level:3,title:"函数组合",slug:"函数组合",normalizedTitle:"函数组合",charIndex:951},{level:3,title:"惰性计算",slug:"惰性计算",normalizedTitle:"惰性计算",charIndex:197},{level:2,title:"理论范畴",slug:"理论范畴",normalizedTitle:"理论范畴",charIndex:4770},{level:3,title:"函子",slug:"函子",normalizedTitle:"函子",charIndex:4882},{level:3,title:"单子",slug:"单子",normalizedTitle:"单子",charIndex:4895},{level:2,title:"易与不易",slug:"易与不易",normalizedTitle:"易与不易",charIndex:6782},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7366}],lastUpdated:"2/6/2023, 6:11:44 PM",lastUpdatedTimestamp:1675678304e3,headersStr:"JavaScript是函数式语言吗 函数式编程定义 编程范式 函数式编程优势 衍生应用场景 纯函数 副作用 递归与尾递归 记忆函数 高阶函数 柯里化与偏函数 函数组合 惰性计算 理论范畴 函子 单子 易与不易 参考资料",content:"# 函数式编程\n\n\n# JavaScript是函数式语言吗\n\nJavaScript 既不是 C++，Java 那样的纯面向对象语言，也不是 Haskell 和 Lisp 那样的纯函数式语言。\n\n\n\n> Js 可以通过某些方式来实现封装，继承，多态，函数重载，但其中面向对象的设计模式是通过原型对象来实现的，并不是真正的面向对象语言。\n> \n> Js 允许匿名函数、高阶函数、闭包等函数式特性，且惰性计算可以通过 lazy.js 库实现，不可变数据可以简单地通过编程技术来实现，但这些都是需要程序员 polyfill，并不是语言本身所带的特性。\n\n\n# 函数式编程定义\n\nIn computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions.\n\n在计算机科学中，函数式编程是一种通过应用和组合函数来构建程序的编程范式。\n\n\n# 编程范式\n\n编程范式 指的是一种编程风格，它描述了程序员对程序执行的看法。在编程的世界中，同一个问题，可以站在多个角度去分析解决，这些不同的解决方案就对应了不同的编程风格。\n\n\n\n * Imperative 命令式：使用流程化的语句和过程直接控制程序的运行和数据状态。\n * Declarative 声名式：定义计算的逻辑而不是定义具体的流程控制。\n\n> 命令式，几乎完全集中于告诉计算机“如何”完成任务，它充斥着“if”语句、“for”循环、临时变量、带有副作用的函数调用以及函数之间的隐式数据流。当然，你可以通过它的逻辑来查看数据是如何流动和更改到最终状态的，但它一点也不清楚或直接。\n> \n> 声明式，它消除了前面提到的大多数命令式技术。注意没有显式的条件、循环、副作用。相反，它使用我们所说的函数式编程，如转换和组合。\n\n\n# 函数式编程优势\n\n * 代码精简\n * 模块化\n * 复用性\n * 减少耦合\n * 可读性\n\n\n\n\n# 衍生应用场景\n\n * 纯函数\n * 记忆函数\n * 递归与尾递归\n * 高阶函数\n * 闭包\n * 函数柯里化\n * 偏函数\n * 函数组合\n * 惰性求值\n\n\n# 纯函数\n\n纯函数（Pure Functions）是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。这意味着对外部状态的解耦。\n\n * 可缓存性（Cacheable）\n * 可测试性（Testable）\n * 合理性（Reasonable）\n * 并行代码（Parallel Code）\n * 可移植性／自文档化（Portable / Self-Documenting）\n\n// slice 是纯函数，splice 不是\nconst arr = [1,2,3,4,5,6]\narr.slice(0,2) //[1,2]\narr.slice(0,2) //[1,2]\n\narr.splice(0,2) //[1,2]\narr.splice(0,2) //[3,4]\n\n\n\n# 副作用\n\n只要是跟函数外部环境发生的交互就都是副作用---这一点可能会让你怀疑无副作用编程的可行性。\n\n * 发送一个 http 请求\n * 获取用户输入\n * DOM 查询\n * 往数据库插入记录\n * 打印/log\n * …\n\n> 函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。\n\n\n# 递归与尾递归\n\n> 如何实现一个计算斐波那契数列的函数？\n> \n> fibonacci：1，1，2，3，5，8，13 函数表达：f (n) = f (n - 1) + f (n - 2)\n\n// 迭代\nconst fibonacci = n => {\n  let current = 0;\n  let next = 1;\n  for (let i = 0; i < n; i++) {\n    [current, next] = [next, current + next];\n  }\n  return current;\n}\n\n// 递归\nconst fibonacci = n => {\n  return n < 3 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n\n递归的缺点：压栈和出栈会消耗性能。\n\n\n\n// 尾递归\nconst fibonacci = (n, sum1 = 1, sum2 = 1) => {\n  if (n < 3) return sum2;\n  return fibonacci(n - 1, sum2, sum1 + sum2);\n}\n\n\n\n\n\n# 记忆函数\n\nfunction memoize (fn) {\n    let cache = {};\n    return function () {\n        let key = JSON.stringify(arguments);\n        cache[key] = cache[key] || fn(...arguments); // 不必重新执行\n        return cache[key];\n    }\n}\nlet fibonacciWithMemory = memoize(fibonacci);\n\nfibonacciWithMemory(10);\nfibonacciWithMemory(10);\n\n\n> 函数经过记忆后运行的例子,可以明显的发现，第二次运行时是几乎不花时间的！\n> \n> 正是因为纯函数的可靠性，才能确保缓存的数据一定是我们想要的数据。\n\n\n# 高阶函数\n\nIn mathematics and computer science, a higher-order function is a function that does at least one of the following:\n\n * takes one or more functions as arguments (i.e. procedural parameters)\n * returns a function as its result.\n\n常见的高阶函数：\n\n * map\n * filter\n * reduce\n * every\n\n// 模拟 map\nconst map = (array, fn) => {\n    let res = []\n    for (let i = 0; i < arr.length; i++) {\n        res.push(fn(arr[i], i, arr))\n    }\n    return res\n}\n\n// 模拟 every\nconst every = (array, fn) => {\n    let res = true\n    for (let value of array) {\n        res = fn(value)\n        if(!res) break\n    }\n    return res\n}\nevery(arr, v => v > 10)\n\n// 模拟 some\nconst some = (array, fn) => {\n    let res = false\n    for (let value of array) {\n        res = fn(value)\n        if(res) break\n    }\n    return res\n}\n\n\n\n# 柯里化与偏函数\n\n * 柯里化：把接受多个参数的函数变换成一系列接受单一参数的函数的技术。将一个 n 元函数转换成 n 个一元函数。\n * 偏函数：一个函数，接受一个多参数的函数且传入部分参数后，返回一个需要更少参数的新函数。也就是将一个 n 元函数转换成一个 n - x 元函数。本质上可以将偏函数看成是柯里化的一种特殊情况。\n\n优势：\n\n * 对函数参数的缓存\n * 让函数变得更灵活，让函数的粒度更小\n * 把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n// arguments对象是所有（非箭头）函数中都可用的局部变量, 所以在这里需要在括号里声明一下 (...arguments)\nconst curry = (fn, ...args) => \n\targs.length < fn.length\n     ? (...arguments) => curry(fn, ...args, ...arguments)\n\t   : fn(...args)\n\nfunction plus(a, b, c) {\n  return a + b + c\n}\n\nlet curryPlus = curry(plus)\ncurryPlus(1)(2)(3) // 6\ncurryPlus(1)(2,3) // 6\ncurryPlus(1,2)(3) // 6\ncurryPlus(1,2,3) // 6\n\nlet curryPlus = curry(plus, 1, 2, 3) \nconsole.log(curryPlus) // 6\n\n\n柯里化在 Vue 源码中的应用\n\n// src/platform/web/patch.js\nfunction createPatch (obj) {\n    // 这样就不必每次都patch参数里传 obj 了\n    return function patch (vdom1, vdom2) {\n        ..\n    }\n}\n\nconst patch = createPatch(...)\n\n\n\n# 函数组合\n\n洋葱代码：tOUpper(first(reverse(arr))\n\n可以用函数组合把细粒度的函数组合成一个新的函数\n\nfunction compose(...args) {\n    return function(value) {\n        return args.reverse().reduce((acc, cur) => cur(acc), value)\n    }\n}\n\n// 实现：数组中的字符串 reverse -> 取第一个 -> 转换为大写\nfunction reverse (arr) {\n  return arr.reverse()\n}\nfunction first (arr) {\n  return arr[0]\n}\nfunction toUpper(str) {\n  return str.toUpperCase()\n}\n\nconst f = compose(toUpper, first, reverse)\nconsole.log(f(['one', 'two', 'three'])) // THREE\n\n\n> Pointfree 编程风格：即不使用所要处理的值，只合成运算过程。\n\n\n# 惰性计算\n\nlazy.js\n\n惰性计算，也称为非严格计算，按需调用和延迟执行，是一种计算策略，它等待直到需要值才能计算函数的结果，这对函数编程特别有用。\n\nLazy([1,2,3,4,5,6,7,8,9,10])\n\t.map(i => i * 2)\n\t.filter(i => i <= 10)\n\t.take(3)\n\t.each(i => print(i))\n\n// 2, 4, 6\n\n\n\n# 理论范畴\n\n> 对于函数式编程来说，以下这些理论不是必要的，其实你不懂也可以学会函数式编程，作为了解在这里简单介绍下。\n\n * Category theory 范畴论\n * Morphisms 态射\n * Functors 函子\n * Monads 单子\n * Semigroup 半群\n * Monoid 幺半群\n\n范畴\n\n> 任何事物都是对象，大量的对象结合起来就形成了集合，对象和对象之间存在一个或多个联系，任何一个联系就叫做态射。\n\n函子\n\n> 函子是一个容器，具有 map 方法，可以映射到另一个容器。\n> \n> 自函子：自函子就是一个将范畴映射到自身的函子。\n\n单子\n\n> 自函子范畴上的一个幺半群\n\n幺半群\n\n> 定义一：对于非空集合 S，若在 S 上定义了二元运算 ○，使得对于任意的 a, b ∈ *S,*有 a ○ b ∈ S，则称 {S, ○} 为群。\n> \n> 定义二：若 {S, ○} 为广群，且运算 ○ 还满足结合律，即：任意 a, b, c ∈ S，有 (a ○ b) ○ c = a ○ (b ○ c)，则称 {S, ○} 为半群。\n> \n> 定义三：幺半群是一个存在单位元（幺元）的半群。单位元：对于半群 <S, ○>，存在 e ∈ S，使得任意 a ∈ S 有 a ○ e = e ○ a\n\n\n# 函子\n\nclass Functor {\n  static of (value) {\n    return new Functor(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return Functor.of(fn(this._value));\n  }\n}\n\n// 链式操作，且不直接操作值\nFunctor.of(5).map(add5).map(double)\n\n\n * 函子是一个容器，里面包含了值。\n\n * 容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。\n\n * 函子具有有of方法，用来生成新的容器。\n\n * 运算都是通过函子完成，不直接针对于值。\n\n# Maybe 函子\n\n// 如何处理初始值为空的情况\nFunctor.of(null).map(s => s.toUpperCase());\n\nclass Maybe {\n  static of (value) {\n    return new Maybe(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return this._value ? Maybe.of(fn(this._value)) : Maybe.of(null);\n  }\n}\n\n\n# Ethier 函子\n\n// 如何实现以下功能\nfunction addOne (x) {\n  return x + 1;\n}\n\nFunctor.of(5, 6).map(addOne); // Functor(5, 7)\nFunctor.of(1, null).map(addOne); // Functor(2, null)\n\n\nclass Ethier {\n  static of (left, right) {\n    return new Ethier(left, right);\n  }\n  constructor (left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  map (fn) {\n    return this.right \n      ? Ethier.of(this.left, fn(this.right)) : Ethier.of(fn(this.left), this.right);\n  }\n}\n\n\n\n# 单子\n\n * 函数嵌套我们可以通过 compose 来解决。\n\n * 函子嵌套我们可以通过 Monads 来解决。\n\nclass Monad {\n  static of (value) {\n    return new Monad(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return Monad.of(fn(this._value));\n  }\n  join () {\n    return this.value;\n  }\n}\n\nconst a = Monad.of(Monad.of('str'));\na.join().map(toUpperCase);\n\n\n\n# 易与不易\n\n * 易：生生之谓易。“落花流水春去也”，这是根本性的规律，人们只有知道如何去适应这种变化的艺术，才不会被社会给淘汰。\n * 不易：老子称之为：有物混成，先天地生，寂兮寥兮，独立而不改，周行而不殆。庄子称之为“有情有信，无为无形，可传而不可受，可得而不可见，自本自根，未有天地，自古以固存……先天地生而不为久，长于上古而不为老”。\n\n> 变易：世界上的万事万物包括天地在内，都不是一成不变的，每一分钟都在悄悄的改变着现实的情况，只是有些变化显著，可以被人们所见到，而有些变化缓慢，并不被人们所察觉。\n> \n> 不易：天地之间万事万物都会改变，可是却有一个永远不变的东西存在，他是万事万物的本源，是永恒的存在。很多人都会感慨“世事无常”，觉得自己好像什么都掌握不住。这世上的变，变的只是现象而已，变的背后一定有不变的东西。所以说不易，就是万事万物背后的规律，背后不变的常则，我们把它叫做“常”，哲学上叫做“本体”。\n\n面向对象编程有两个概念，对象和类。他们是什么？是变化的中间态，个体，实体，张三是一个对象，李四又是一个对象，这是无穷无尽的。\n\n易经里的那个不易，不变，就好比函数式编程，函数具有不变性，一致性。就比如纯函数，一点副作用都没有。所有的变化，最后都通过函数串了起来。而变化的后面，就是不变，以不变应万变。我觉得这就是函数式编程的精髓！\n\n\n# 参考资料\n\nJavaScript中的函数式编程\n\nJavaScript轻量级函数式编程",normalizedContent:"# 函数式编程\n\n\n# javascript是函数式语言吗\n\njavascript 既不是 c++，java 那样的纯面向对象语言，也不是 haskell 和 lisp 那样的纯函数式语言。\n\n\n\n> js 可以通过某些方式来实现封装，继承，多态，函数重载，但其中面向对象的设计模式是通过原型对象来实现的，并不是真正的面向对象语言。\n> \n> js 允许匿名函数、高阶函数、闭包等函数式特性，且惰性计算可以通过 lazy.js 库实现，不可变数据可以简单地通过编程技术来实现，但这些都是需要程序员 polyfill，并不是语言本身所带的特性。\n\n\n# 函数式编程定义\n\nin computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions.\n\n在计算机科学中，函数式编程是一种通过应用和组合函数来构建程序的编程范式。\n\n\n# 编程范式\n\n编程范式 指的是一种编程风格，它描述了程序员对程序执行的看法。在编程的世界中，同一个问题，可以站在多个角度去分析解决，这些不同的解决方案就对应了不同的编程风格。\n\n\n\n * imperative 命令式：使用流程化的语句和过程直接控制程序的运行和数据状态。\n * declarative 声名式：定义计算的逻辑而不是定义具体的流程控制。\n\n> 命令式，几乎完全集中于告诉计算机“如何”完成任务，它充斥着“if”语句、“for”循环、临时变量、带有副作用的函数调用以及函数之间的隐式数据流。当然，你可以通过它的逻辑来查看数据是如何流动和更改到最终状态的，但它一点也不清楚或直接。\n> \n> 声明式，它消除了前面提到的大多数命令式技术。注意没有显式的条件、循环、副作用。相反，它使用我们所说的函数式编程，如转换和组合。\n\n\n# 函数式编程优势\n\n * 代码精简\n * 模块化\n * 复用性\n * 减少耦合\n * 可读性\n\n\n\n\n# 衍生应用场景\n\n * 纯函数\n * 记忆函数\n * 递归与尾递归\n * 高阶函数\n * 闭包\n * 函数柯里化\n * 偏函数\n * 函数组合\n * 惰性求值\n\n\n# 纯函数\n\n纯函数（pure functions）是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。这意味着对外部状态的解耦。\n\n * 可缓存性（cacheable）\n * 可测试性（testable）\n * 合理性（reasonable）\n * 并行代码（parallel code）\n * 可移植性／自文档化（portable / self-documenting）\n\n// slice 是纯函数，splice 不是\nconst arr = [1,2,3,4,5,6]\narr.slice(0,2) //[1,2]\narr.slice(0,2) //[1,2]\n\narr.splice(0,2) //[1,2]\narr.splice(0,2) //[3,4]\n\n\n\n# 副作用\n\n只要是跟函数外部环境发生的交互就都是副作用---这一点可能会让你怀疑无副作用编程的可行性。\n\n * 发送一个 http 请求\n * 获取用户输入\n * dom 查询\n * 往数据库插入记录\n * 打印/log\n * …\n\n> 函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。\n\n\n# 递归与尾递归\n\n> 如何实现一个计算斐波那契数列的函数？\n> \n> fibonacci：1，1，2，3，5，8，13 函数表达：f (n) = f (n - 1) + f (n - 2)\n\n// 迭代\nconst fibonacci = n => {\n  let current = 0;\n  let next = 1;\n  for (let i = 0; i < n; i++) {\n    [current, next] = [next, current + next];\n  }\n  return current;\n}\n\n// 递归\nconst fibonacci = n => {\n  return n < 3 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n\n递归的缺点：压栈和出栈会消耗性能。\n\n\n\n// 尾递归\nconst fibonacci = (n, sum1 = 1, sum2 = 1) => {\n  if (n < 3) return sum2;\n  return fibonacci(n - 1, sum2, sum1 + sum2);\n}\n\n\n\n\n\n# 记忆函数\n\nfunction memoize (fn) {\n    let cache = {};\n    return function () {\n        let key = json.stringify(arguments);\n        cache[key] = cache[key] || fn(...arguments); // 不必重新执行\n        return cache[key];\n    }\n}\nlet fibonacciwithmemory = memoize(fibonacci);\n\nfibonacciwithmemory(10);\nfibonacciwithmemory(10);\n\n\n> 函数经过记忆后运行的例子,可以明显的发现，第二次运行时是几乎不花时间的！\n> \n> 正是因为纯函数的可靠性，才能确保缓存的数据一定是我们想要的数据。\n\n\n# 高阶函数\n\nin mathematics and computer science, a higher-order function is a function that does at least one of the following:\n\n * takes one or more functions as arguments (i.e. procedural parameters)\n * returns a function as its result.\n\n常见的高阶函数：\n\n * map\n * filter\n * reduce\n * every\n\n// 模拟 map\nconst map = (array, fn) => {\n    let res = []\n    for (let i = 0; i < arr.length; i++) {\n        res.push(fn(arr[i], i, arr))\n    }\n    return res\n}\n\n// 模拟 every\nconst every = (array, fn) => {\n    let res = true\n    for (let value of array) {\n        res = fn(value)\n        if(!res) break\n    }\n    return res\n}\nevery(arr, v => v > 10)\n\n// 模拟 some\nconst some = (array, fn) => {\n    let res = false\n    for (let value of array) {\n        res = fn(value)\n        if(res) break\n    }\n    return res\n}\n\n\n\n# 柯里化与偏函数\n\n * 柯里化：把接受多个参数的函数变换成一系列接受单一参数的函数的技术。将一个 n 元函数转换成 n 个一元函数。\n * 偏函数：一个函数，接受一个多参数的函数且传入部分参数后，返回一个需要更少参数的新函数。也就是将一个 n 元函数转换成一个 n - x 元函数。本质上可以将偏函数看成是柯里化的一种特殊情况。\n\n优势：\n\n * 对函数参数的缓存\n * 让函数变得更灵活，让函数的粒度更小\n * 把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n// arguments对象是所有（非箭头）函数中都可用的局部变量, 所以在这里需要在括号里声明一下 (...arguments)\nconst curry = (fn, ...args) => \n\targs.length < fn.length\n     ? (...arguments) => curry(fn, ...args, ...arguments)\n\t   : fn(...args)\n\nfunction plus(a, b, c) {\n  return a + b + c\n}\n\nlet curryplus = curry(plus)\ncurryplus(1)(2)(3) // 6\ncurryplus(1)(2,3) // 6\ncurryplus(1,2)(3) // 6\ncurryplus(1,2,3) // 6\n\nlet curryplus = curry(plus, 1, 2, 3) \nconsole.log(curryplus) // 6\n\n\n柯里化在 vue 源码中的应用\n\n// src/platform/web/patch.js\nfunction createpatch (obj) {\n    // 这样就不必每次都patch参数里传 obj 了\n    return function patch (vdom1, vdom2) {\n        ..\n    }\n}\n\nconst patch = createpatch(...)\n\n\n\n# 函数组合\n\n洋葱代码：toupper(first(reverse(arr))\n\n可以用函数组合把细粒度的函数组合成一个新的函数\n\nfunction compose(...args) {\n    return function(value) {\n        return args.reverse().reduce((acc, cur) => cur(acc), value)\n    }\n}\n\n// 实现：数组中的字符串 reverse -> 取第一个 -> 转换为大写\nfunction reverse (arr) {\n  return arr.reverse()\n}\nfunction first (arr) {\n  return arr[0]\n}\nfunction toupper(str) {\n  return str.touppercase()\n}\n\nconst f = compose(toupper, first, reverse)\nconsole.log(f(['one', 'two', 'three'])) // three\n\n\n> pointfree 编程风格：即不使用所要处理的值，只合成运算过程。\n\n\n# 惰性计算\n\nlazy.js\n\n惰性计算，也称为非严格计算，按需调用和延迟执行，是一种计算策略，它等待直到需要值才能计算函数的结果，这对函数编程特别有用。\n\nlazy([1,2,3,4,5,6,7,8,9,10])\n\t.map(i => i * 2)\n\t.filter(i => i <= 10)\n\t.take(3)\n\t.each(i => print(i))\n\n// 2, 4, 6\n\n\n\n# 理论范畴\n\n> 对于函数式编程来说，以下这些理论不是必要的，其实你不懂也可以学会函数式编程，作为了解在这里简单介绍下。\n\n * category theory 范畴论\n * morphisms 态射\n * functors 函子\n * monads 单子\n * semigroup 半群\n * monoid 幺半群\n\n范畴\n\n> 任何事物都是对象，大量的对象结合起来就形成了集合，对象和对象之间存在一个或多个联系，任何一个联系就叫做态射。\n\n函子\n\n> 函子是一个容器，具有 map 方法，可以映射到另一个容器。\n> \n> 自函子：自函子就是一个将范畴映射到自身的函子。\n\n单子\n\n> 自函子范畴上的一个幺半群\n\n幺半群\n\n> 定义一：对于非空集合 s，若在 s 上定义了二元运算 ○，使得对于任意的 a, b ∈ *s,*有 a ○ b ∈ s，则称 {s, ○} 为群。\n> \n> 定义二：若 {s, ○} 为广群，且运算 ○ 还满足结合律，即：任意 a, b, c ∈ s，有 (a ○ b) ○ c = a ○ (b ○ c)，则称 {s, ○} 为半群。\n> \n> 定义三：幺半群是一个存在单位元（幺元）的半群。单位元：对于半群 <s, ○>，存在 e ∈ s，使得任意 a ∈ s 有 a ○ e = e ○ a\n\n\n# 函子\n\nclass functor {\n  static of (value) {\n    return new functor(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return functor.of(fn(this._value));\n  }\n}\n\n// 链式操作，且不直接操作值\nfunctor.of(5).map(add5).map(double)\n\n\n * 函子是一个容器，里面包含了值。\n\n * 容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。\n\n * 函子具有有of方法，用来生成新的容器。\n\n * 运算都是通过函子完成，不直接针对于值。\n\n# maybe 函子\n\n// 如何处理初始值为空的情况\nfunctor.of(null).map(s => s.touppercase());\n\nclass maybe {\n  static of (value) {\n    return new maybe(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return this._value ? maybe.of(fn(this._value)) : maybe.of(null);\n  }\n}\n\n\n# ethier 函子\n\n// 如何实现以下功能\nfunction addone (x) {\n  return x + 1;\n}\n\nfunctor.of(5, 6).map(addone); // functor(5, 7)\nfunctor.of(1, null).map(addone); // functor(2, null)\n\n\nclass ethier {\n  static of (left, right) {\n    return new ethier(left, right);\n  }\n  constructor (left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  map (fn) {\n    return this.right \n      ? ethier.of(this.left, fn(this.right)) : ethier.of(fn(this.left), this.right);\n  }\n}\n\n\n\n# 单子\n\n * 函数嵌套我们可以通过 compose 来解决。\n\n * 函子嵌套我们可以通过 monads 来解决。\n\nclass monad {\n  static of (value) {\n    return new monad(value);\n  }\n  constructor (value) {\n    this._value = value;\n  }\n  map (fn) {\n    return monad.of(fn(this._value));\n  }\n  join () {\n    return this.value;\n  }\n}\n\nconst a = monad.of(monad.of('str'));\na.join().map(touppercase);\n\n\n\n# 易与不易\n\n * 易：生生之谓易。“落花流水春去也”，这是根本性的规律，人们只有知道如何去适应这种变化的艺术，才不会被社会给淘汰。\n * 不易：老子称之为：有物混成，先天地生，寂兮寥兮，独立而不改，周行而不殆。庄子称之为“有情有信，无为无形，可传而不可受，可得而不可见，自本自根，未有天地，自古以固存……先天地生而不为久，长于上古而不为老”。\n\n> 变易：世界上的万事万物包括天地在内，都不是一成不变的，每一分钟都在悄悄的改变着现实的情况，只是有些变化显著，可以被人们所见到，而有些变化缓慢，并不被人们所察觉。\n> \n> 不易：天地之间万事万物都会改变，可是却有一个永远不变的东西存在，他是万事万物的本源，是永恒的存在。很多人都会感慨“世事无常”，觉得自己好像什么都掌握不住。这世上的变，变的只是现象而已，变的背后一定有不变的东西。所以说不易，就是万事万物背后的规律，背后不变的常则，我们把它叫做“常”，哲学上叫做“本体”。\n\n面向对象编程有两个概念，对象和类。他们是什么？是变化的中间态，个体，实体，张三是一个对象，李四又是一个对象，这是无穷无尽的。\n\n易经里的那个不易，不变，就好比函数式编程，函数具有不变性，一致性。就比如纯函数，一点副作用都没有。所有的变化，最后都通过函数串了起来。而变化的后面，就是不变，以不变应万变。我觉得这就是函数式编程的精髓！\n\n\n# 参考资料\n\njavascript中的函数式编程\n\njavascript轻量级函数式编程",charsets:{cjk:!0}},{title:"函数与变量的解析顺序",frontmatter:{title:"函数与变量的解析顺序",date:"2018-08-08T15:00:54.000Z",categories:"JavaScript"},regularPath:"/javascript/parse-order.html",relativePath:"javascript/parse-order.md",key:"v-4e92cd47",path:"/javascript/parse-order.html",headers:[{level:2,title:"首先了解一下规则",slug:"首先了解一下规则",normalizedTitle:"首先了解一下规则",charIndex:2},{level:3,title:"例子一",slug:"例子一",normalizedTitle:"例子一",charIndex:118},{level:3,title:"例子二",slug:"例子二",normalizedTitle:"例子二",charIndex:472},{level:3,title:"例子三",slug:"例子三",normalizedTitle:"例子三",charIndex:956},{level:3,title:"例子四",slug:"例子四",normalizedTitle:"例子四",charIndex:1456},{level:3,title:"例子五",slug:"例子五",normalizedTitle:"例子五",charIndex:1922},{level:3,title:"例子六",slug:"例子六",normalizedTitle:"例子六",charIndex:2321},{level:3,title:"例子七",slug:"例子七",normalizedTitle:"例子七",charIndex:2723}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"首先了解一下规则 例子一 例子二 例子三 例子四 例子五 例子六 例子七",content:"# 首先了解一下规则\n\n1)函数声明会置顶\n\n2)变量声明也会置顶\n\n3)函数声明更优先\n\n4)变量和赋值语句一起书写，在js引擎解析时，会将其拆成声明和赋值2部分，声明置顶，赋值保留在原来位置\n\n5)声明过的变量不会重复声明\n\n\n# 例子一\n\n先来看一下结果\n\nvar scope = gloabl;\nfunction f(){\n    console.log(scope);  \n    var scope = \"local\";  \n    console.log(scope);\t  \n}//输出undefined，local\n\n\n按照规则改写顺序之后\n\nvar scope = gloabl;\nfunction f(){\n    var scope;            //声明提前\n    console.log(scope);   //输出undefined，不是gloabl\n    scope = \"local\"       //初始化\n    console.log(scope);\t  //输出local\n}\n\n\n\n# 例子二\n\n先来看一下结果\n\nconsole.log( a );         \nvar a = 1;\nvar a = [];\nfunction a(){\n    console.log( 'fn' );  \n}\nconsole.log( a );         //输出函数体，[]\n\n\n按照规则改写顺序之后\n\nfunction a(){            //函数声明提前\n    console.log( 'fn' ); //不执行\n}\nvar a;                   //变量声明提前，但是在函数后面\nvar a;\nconsole.log( a );        //原本js内存地址中本来已经声明了一个名为a的函数对象                            （相当于已经将a这个地址指向了函数对象），再次声明一次                           a，但并没赋值，所以打印出来的依旧是函数a。\na = 1;\na = [];\nconsole.log( a );        //输出[]\n\n\n\n# 例子三\n\n先来看一下结果\n\nvar a = 1;\nfunction b(){\n    a = 10;              //这里a并没有提升为全局变量\n    return;\n    function a(){\n        console.log(a);  \n    }\t\n}\nb();\nconsole.log(a);          //输出1\n\n\n如果你不懂，我们来看看改写之后\n\nfunction b(){\n    function a(){       //函数声明置顶\n        console.log(a); //不执行\n    }\n    a = 10;             //10赋值给了函数名为a的这个函数对象！\n    return;\t\n}\nvar a;\na  = 1;\nb();\nconsole.log(a);        //输出1\n\n\n如果把函数a注释掉\n\nfunction b(){\n    a = 10;\n    return;\t\n}\nvar a;\na = 1;\nb();\nconsole.log(a);       //输出10\n\n\n\n# 例子四\n\nconsole.log( a );    \na();                 \nvar a = 1;\nconsole.log( a );    \nvar a = {};\nfunction a(){\n    var b = 5;\n    console.log( 'fn' );\n}\na();                 \nconsole.log( a );    //输出函数体，\"fn\"，1，报错\n\n\n改写顺序\n\nfunction a(){\n    var b = 5;\n    console.log( 'fn' );\n}\nvar a;\nvar a;\nconsole.log( a );    //输出函数体\na();                 //输出\"fn\"\na = 1;               //输出1\nconsole.log( a );\na = {};\na();                 //报错\nconsole.log( a );    //前面报错了，不执行了\n\n\n\n# 例子五\n\nfn()();\nvar a = 0;\nfunction fn(){\n    console.log( a );\n    var a = 3;\n    function b(){\n        console.log( a );\n    }\n    return b;\n}                      //输出undefined,3\n\n\n改写顺序\n\nfunction fn(){\n    function b(){\n        console.log( a );\n    }\n    var a;\n    console.log( a );  //输出undefined\n    a = 3;\n    return b;          //返回函数b\n}\nvar a;\nfn()();                //相当于b()，输出3\na = 0;\n\n\n\n# 例子六\n\nfunction fn1(){\n    var num = 10;\n    function fn2(){\n        console.log( num );\n    }\n    return fn2;\n}\nconsole.log( fn1() );\nvar b = fn1();\nb();\n\n\n改写顺序\n\nfunction fn1(){\n    function fn2(){\n        console.log( num );\n    }\n    var num;\n    num = 10;\n    return fn2;\n}\nvar b;\nconsole.log( fn1() ); //先执行fn1(),返回fn2,输出fn2的函数体\nb = fn1();            //b=fn2\nb();                  //fn2(),输出10\n\n\n\n# 例子七\n\na();\nfunction a(){\n    var fn = function(){\n        console.log( 123 );\n    }\n    return fn1;\n}\na();\nvar a = 0;\nvar a = 0;\nfunction fn1(){\n    console.log( a );\n    var a = 1;\n    return a;\n}\nconsole.log( fn1() );\nconsole.log( a );\nfn1()();//输出undefined,undefined,undefined,1,0,undefined,报错\n\n\n改写顺序\n\nfunction a(){\n    var fn = function(){\n        console.log( 123 );\n    }\n    return fn1();\n};\nfunction fn1(){\n    var a;\n    console.log( a );\n    a = 1;\n    return a;\n};\nvar a;\nvar a;\na();                 //fn1=>console.log(a)=>undefined\na();\t\t        //fn1=>console.log(a)=>undefined\na = 0;\na = 0;\nconsole.log( fn1() );//undefined,1\nconsole.log( a );    //0\nfn1()();             //fn1()=>console.log(a)=>undefined,a()=>报错\n",normalizedContent:"# 首先了解一下规则\n\n1)函数声明会置顶\n\n2)变量声明也会置顶\n\n3)函数声明更优先\n\n4)变量和赋值语句一起书写，在js引擎解析时，会将其拆成声明和赋值2部分，声明置顶，赋值保留在原来位置\n\n5)声明过的变量不会重复声明\n\n\n# 例子一\n\n先来看一下结果\n\nvar scope = gloabl;\nfunction f(){\n    console.log(scope);  \n    var scope = \"local\";  \n    console.log(scope);\t  \n}//输出undefined，local\n\n\n按照规则改写顺序之后\n\nvar scope = gloabl;\nfunction f(){\n    var scope;            //声明提前\n    console.log(scope);   //输出undefined，不是gloabl\n    scope = \"local\"       //初始化\n    console.log(scope);\t  //输出local\n}\n\n\n\n# 例子二\n\n先来看一下结果\n\nconsole.log( a );         \nvar a = 1;\nvar a = [];\nfunction a(){\n    console.log( 'fn' );  \n}\nconsole.log( a );         //输出函数体，[]\n\n\n按照规则改写顺序之后\n\nfunction a(){            //函数声明提前\n    console.log( 'fn' ); //不执行\n}\nvar a;                   //变量声明提前，但是在函数后面\nvar a;\nconsole.log( a );        //原本js内存地址中本来已经声明了一个名为a的函数对象                            （相当于已经将a这个地址指向了函数对象），再次声明一次                           a，但并没赋值，所以打印出来的依旧是函数a。\na = 1;\na = [];\nconsole.log( a );        //输出[]\n\n\n\n# 例子三\n\n先来看一下结果\n\nvar a = 1;\nfunction b(){\n    a = 10;              //这里a并没有提升为全局变量\n    return;\n    function a(){\n        console.log(a);  \n    }\t\n}\nb();\nconsole.log(a);          //输出1\n\n\n如果你不懂，我们来看看改写之后\n\nfunction b(){\n    function a(){       //函数声明置顶\n        console.log(a); //不执行\n    }\n    a = 10;             //10赋值给了函数名为a的这个函数对象！\n    return;\t\n}\nvar a;\na  = 1;\nb();\nconsole.log(a);        //输出1\n\n\n如果把函数a注释掉\n\nfunction b(){\n    a = 10;\n    return;\t\n}\nvar a;\na = 1;\nb();\nconsole.log(a);       //输出10\n\n\n\n# 例子四\n\nconsole.log( a );    \na();                 \nvar a = 1;\nconsole.log( a );    \nvar a = {};\nfunction a(){\n    var b = 5;\n    console.log( 'fn' );\n}\na();                 \nconsole.log( a );    //输出函数体，\"fn\"，1，报错\n\n\n改写顺序\n\nfunction a(){\n    var b = 5;\n    console.log( 'fn' );\n}\nvar a;\nvar a;\nconsole.log( a );    //输出函数体\na();                 //输出\"fn\"\na = 1;               //输出1\nconsole.log( a );\na = {};\na();                 //报错\nconsole.log( a );    //前面报错了，不执行了\n\n\n\n# 例子五\n\nfn()();\nvar a = 0;\nfunction fn(){\n    console.log( a );\n    var a = 3;\n    function b(){\n        console.log( a );\n    }\n    return b;\n}                      //输出undefined,3\n\n\n改写顺序\n\nfunction fn(){\n    function b(){\n        console.log( a );\n    }\n    var a;\n    console.log( a );  //输出undefined\n    a = 3;\n    return b;          //返回函数b\n}\nvar a;\nfn()();                //相当于b()，输出3\na = 0;\n\n\n\n# 例子六\n\nfunction fn1(){\n    var num = 10;\n    function fn2(){\n        console.log( num );\n    }\n    return fn2;\n}\nconsole.log( fn1() );\nvar b = fn1();\nb();\n\n\n改写顺序\n\nfunction fn1(){\n    function fn2(){\n        console.log( num );\n    }\n    var num;\n    num = 10;\n    return fn2;\n}\nvar b;\nconsole.log( fn1() ); //先执行fn1(),返回fn2,输出fn2的函数体\nb = fn1();            //b=fn2\nb();                  //fn2(),输出10\n\n\n\n# 例子七\n\na();\nfunction a(){\n    var fn = function(){\n        console.log( 123 );\n    }\n    return fn1;\n}\na();\nvar a = 0;\nvar a = 0;\nfunction fn1(){\n    console.log( a );\n    var a = 1;\n    return a;\n}\nconsole.log( fn1() );\nconsole.log( a );\nfn1()();//输出undefined,undefined,undefined,1,0,undefined,报错\n\n\n改写顺序\n\nfunction a(){\n    var fn = function(){\n        console.log( 123 );\n    }\n    return fn1();\n};\nfunction fn1(){\n    var a;\n    console.log( a );\n    a = 1;\n    return a;\n};\nvar a;\nvar a;\na();                 //fn1=>console.log(a)=>undefined\na();\t\t        //fn1=>console.log(a)=>undefined\na = 0;\na = 0;\nconsole.log( fn1() );//undefined,1\nconsole.log( a );    //0\nfn1()();             //fn1()=>console.log(a)=>undefined,a()=>报错\n",charsets:{cjk:!0}},{title:"Javascript中this的指向",frontmatter:{title:"Javascript中this的指向",date:"2018-10-31T10:00:54.000Z",categories:"JavaScript"},regularPath:"/javascript/this.html",relativePath:"javascript/this.md",key:"v-4d2d4882",path:"/javascript/this.html",headers:[{level:2,title:"箭头函数的 this",slug:"箭头函数的-this",normalizedTitle:"箭头函数的 this",charIndex:385},{level:2,title:"箭头函数与普通函数的区别",slug:"箭头函数与普通函数的区别",normalizedTitle:"箭头函数与普通函数的区别",charIndex:737},{level:2,title:"普通函数和作为对象方法的 this",slug:"普通函数和作为对象方法的-this",normalizedTitle:"普通函数和作为对象方法的 this",charIndex:1610},{level:2,title:"构造函数中this",slug:"构造函数中this",normalizedTitle:"构造函数中this",charIndex:1974},{level:2,title:"apply或call调用",slug:"apply或call调用",normalizedTitle:"apply或call调用",charIndex:2303}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"箭头函数的 this 箭头函数与普通函数的区别 普通函数和作为对象方法的 this 构造函数中this apply或call调用",content:"# Javascript中this的指向\n\n * 以函数的形式调用时，this指向的是window\n * 以对象的方法的形式调用时，this就是调用方法的那个对象\n * 当以构造函数的形式调用时，this就是新创建的那个对象\n * 使用call()和apply()调用时，this就是call()和apply()第一个参数的对象\n * 使用bind()()调用时，this就是bind()第一个参数的对象\n * 箭头函数没有自己的 this，箭头函数内部的 this 值始终等于离它最近的外部函数的 this 值。换句话说，箭头函数可按词法解析 this，箭头函数没有定义自己的执行上下文。\n * 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个箭头函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。\n\n\n# 箭头函数的 this\n\nconst obj = {\n    val: 1,\n    fn1: () => {\n        console.log(this.val)\n    },\n    fn2: function() {\n        console.log(this.val)\n    },\n    fn3: function() {\n        showThis = () => {\n            console.log(this.val)\n        }\n        showThis()\n    }\n}\nobj.fn1() // undefined\nobj.fn2() // 1\nobj.fn3() // 1 此处的 this 继承于 fn3的 this\n\n\n\n# 箭头函数与普通函数的区别\n\n * 不能通过 new 关键字调用, 没有原型\n\n * 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响\n\n * 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments\n\n * 隐式返回，箭头函数给你省了一个 return，适合这种函数体内只有一行代码的情况，多行还是需要写的\n\nvar Foo1 = () => {};\nvar foo = new Foo1(); // TypeError: Foo is not a constructor\nconsole.log(Foo1.prototype); // undefined\n\nvar Foo2 = () => {\n    console.log(arguments)\n};\nFoo2() // Uncaught ReferenceError: arguments is not defined\n\n\n由于不支持 arguments，ES6 也提供了这种不定参数情况下的参数如果操作，看下面的例子\n\nconst add = (...args) => {\n\treturn args.reduce((cur, i) => cur + i, 0)\n}\nadd(5, 10, 15)\n\n\n看一道题测试你是否掌握了\n\n// 普通函数\nfunction foo() {\n  setTimeout(function(){\n    console.log('id:', this.id);\n  },100)\n}\nvar id = 1;\n\nfoo.call({ id: 2 }); // id: undefined\n\n// 箭头函数\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 1;\n\nfoo.call({ id: 2 }); // id: 2\n\n\n\n# 普通函数和作为对象方法的 this\n\nwindow.val = 1;\nvar obj = {\n    val: 2,\n    dbl: function() {\n        this.val *= 2;\n        val *= 2;\n        console.log(val);\n        console.log(this.val);\n    }\n}\n//作为对象方法\nobj.dbl(); // 2 4,this指的是obj，所以this.val值为4，val相当于window.val值为2\n\n//普通函数\nvar func = obj.dbl;\nfunc(); // 8 8，func()没有任何前缀，this指的是window.func();所以此时this值得是window，值均为8\n\n\n\n# 构造函数中this\n\nJavaScript 支持面向对象式编程，与主流的面向对象式编程语言不同，JavaScript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。\n\nfunction Point(x, y){ \n\tthis.x = x; \n\tthis.y = y; \n}\n\nvar p = new Point(1,2);\nconsole.log(p.x);//==>1,this指向对象p\n\n\n\n# apply或call调用\n\n在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 JavaScript 中的技巧以及类库都用到了该方法。\n\nfunction Point(x, y){ \n   this.x = x; \n   this.y = y; \n   this.moveTo = function(x, y){ \n       this.x = x; \n       this.y = y; \n   } \n} \n \nvar p1 = new Point(0, 0); \nvar p2 = {x: 0, y: 0}; \np1.moveTo(1, 1); \np1.moveTo.apply(p2, [10, 10]);\n\n\n在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法；使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上，这时候 this 也被绑定到对象 p2 上。另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的。",normalizedContent:"# javascript中this的指向\n\n * 以函数的形式调用时，this指向的是window\n * 以对象的方法的形式调用时，this就是调用方法的那个对象\n * 当以构造函数的形式调用时，this就是新创建的那个对象\n * 使用call()和apply()调用时，this就是call()和apply()第一个参数的对象\n * 使用bind()()调用时，this就是bind()第一个参数的对象\n * 箭头函数没有自己的 this，箭头函数内部的 this 值始终等于离它最近的外部函数的 this 值。换句话说，箭头函数可按词法解析 this，箭头函数没有定义自己的执行上下文。\n * 由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个箭头函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。\n\n\n# 箭头函数的 this\n\nconst obj = {\n    val: 1,\n    fn1: () => {\n        console.log(this.val)\n    },\n    fn2: function() {\n        console.log(this.val)\n    },\n    fn3: function() {\n        showthis = () => {\n            console.log(this.val)\n        }\n        showthis()\n    }\n}\nobj.fn1() // undefined\nobj.fn2() // 1\nobj.fn3() // 1 此处的 this 继承于 fn3的 this\n\n\n\n# 箭头函数与普通函数的区别\n\n * 不能通过 new 关键字调用, 没有原型\n\n * 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响\n\n * 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments\n\n * 隐式返回，箭头函数给你省了一个 return，适合这种函数体内只有一行代码的情况，多行还是需要写的\n\nvar foo1 = () => {};\nvar foo = new foo1(); // typeerror: foo is not a constructor\nconsole.log(foo1.prototype); // undefined\n\nvar foo2 = () => {\n    console.log(arguments)\n};\nfoo2() // uncaught referenceerror: arguments is not defined\n\n\n由于不支持 arguments，es6 也提供了这种不定参数情况下的参数如果操作，看下面的例子\n\nconst add = (...args) => {\n\treturn args.reduce((cur, i) => cur + i, 0)\n}\nadd(5, 10, 15)\n\n\n看一道题测试你是否掌握了\n\n// 普通函数\nfunction foo() {\n  settimeout(function(){\n    console.log('id:', this.id);\n  },100)\n}\nvar id = 1;\n\nfoo.call({ id: 2 }); // id: undefined\n\n// 箭头函数\nfunction foo() {\n  settimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 1;\n\nfoo.call({ id: 2 }); // id: 2\n\n\n\n# 普通函数和作为对象方法的 this\n\nwindow.val = 1;\nvar obj = {\n    val: 2,\n    dbl: function() {\n        this.val *= 2;\n        val *= 2;\n        console.log(val);\n        console.log(this.val);\n    }\n}\n//作为对象方法\nobj.dbl(); // 2 4,this指的是obj，所以this.val值为4，val相当于window.val值为2\n\n//普通函数\nvar func = obj.dbl;\nfunc(); // 8 8，func()没有任何前缀，this指的是window.func();所以此时this值得是window，值均为8\n\n\n\n# 构造函数中this\n\njavascript 支持面向对象式编程，与主流的面向对象式编程语言不同，javascript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，javascript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。\n\nfunction point(x, y){ \n\tthis.x = x; \n\tthis.y = y; \n}\n\nvar p = new point(1,2);\nconsole.log(p.x);//==>1,this指向对象p\n\n\n\n# apply或call调用\n\n在 javascript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 javascript 中的技巧以及类库都用到了该方法。\n\nfunction point(x, y){ \n   this.x = x; \n   this.y = y; \n   this.moveto = function(x, y){ \n       this.x = x; \n       this.y = y; \n   } \n} \n \nvar p1 = new point(0, 0); \nvar p2 = {x: 0, y: 0}; \np1.moveto(1, 1); \np1.moveto.apply(p2, [10, 10]);\n\n\n在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveto 方法；使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上，这时候 this 也被绑定到对象 p2 上。另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的。",charsets:{cjk:!0}},{title:"galacean 3d",frontmatter:{},regularPath:"/mobile/gc-3d.html",relativePath:"mobile/gc-3d.md",key:"v-3cac1b41",path:"/mobile/gc-3d.html",headers:[{level:2,title:"Galacean engine 快速入门",slug:"galacean-engine-快速入门",normalizedTitle:"galacean engine 快速入门",charIndex:270},{level:2,title:"Galacean Effects 实现 3d",slug:"galacean-effects-实现-3d",normalizedTitle:"galacean effects 实现 3d",charIndex:1022},{level:2,title:"3d 实现对比",slug:"_3d-实现对比",normalizedTitle:"3d 实现对比",charIndex:1512},{level:2,title:"包体积对比",slug:"包体积对比",normalizedTitle:"包体积对比",charIndex:1969}],lastUpdated:"9/24/2025, 9:31:37 AM",lastUpdatedTimestamp:1758677497e3,headersStr:"Galacean engine 快速入门 Galacean Effects 实现 3d 3d 实现对比 包体积对比",content:"# galacean 3d\n\nGalacean 实现 3d 效果有两种方式：\n\n * Galacean Engine：直接用官方给的 Web 3D 引擎，可以理解为 three.js 引擎，底层都是 webgl。\n   * Galacean Engine 与 three.js 性能对比，可以看下官方文档：https://galacean.antgroup.com/engine/docs（链接有问题，看下图）\n\n\n\n\n\n * Galacean Effects：简单的 3d 效果可直接用 galacean effects 来实现\n\n\n# Galacean engine 快速入门\n\n快速入手可以看官方例子：https://galacean.antgroup.com/engine/docs/basics/quickStart/quick-start/（链接有问题，看下图）\n\n\n\n\n\n编辑器地址：https://galacean.antgroup.com/editor/projects\n\n按文档一步一步实践即可，这里主要介绍了如何在编辑器中创建 3d 项目以及在编辑器中引入 glb 模型、设置灯光、脚本、真机预览等。\n\n\n\n下面主要介绍下导出后在我们的项目中（feed-activity 为例）怎么使用：\n\n 1. 在这里我们导出示例中的 Vanilla JS 项目\n\n\n\n 1. 导出后的目录如下，其中public 中的文件都传到 cdn 中，然后在 project.json 中把所有的资源进行路径替换，然后再把 public/project.json 也传到 cdn 中\n\n（script.ts 从本地引入，测试发现不上传cdn也可以）\n\n\n\n\n\n 1. 项目根目录中还有一个 project.json ，把其中的 project.json url 替换成第二步的 cdn 地址（public中的那个）\n\n\n\n 1. 找到 src 中的 index.ts，scripts 就引入导出的 srcipts，projectInfo 引入第3步的 project.json，再把index.ts 中的初始代码复制到项目中即可。\n\n\n\n 1. 在 feed-activity 中如下，需要的只有 scripts （此处把 ts 改成了 js）和 project.json，其余内容都在 cdn 上\n\n\n\n 1. 最终在项目中跑通\n\n\n\n\n# Galacean Effects 实现 3d\n\n具体操作可以看 https://galacean.antgroup.com/effects/user/hpb4n5\n\n 1. 新建合成，场景选择 3d\n\n\n\n 1. 资源中添加 glb 模型，左上角可以平移旋转缩放等\n\n\n\n 1. 导出流程和2d类似，资源也是 .bin/.webp\n\n 2. 在 Galacean Effects 中使用 3D 元素的渲染，需要单独引入 3D 插件包。3D模型可能会引入复杂的渲染，上线前需要评估性能。\n\n// NPM\nimport { Player } from'@galacean/effects';\n// 确保在 Player 引入之后再引入插件, 插件版本保持和 Player 一致\nimport'@galacean/effects-plugin-model';\n\n\n使用示例：https://galacean.antgroup.com/effects/playground/vanilla-%E6%92%AD%E6%94%BE%203D%20%E6%A8%A1%E5%9E%8B\n\n\n# 3d 实现对比\n\n * galacean effects 3d\n   * 优点：用 Player 就可以实现 2d/3d 效果，3d 只需在原有 player 基础上引入插件即可。\n   * 缺点：只适用于简单的 3d 效果，并不适合跑酷等小游戏的实现。\n * galacean engine\n   * 优点：可以直接把模型导入3d编辑器，进行灯光位置等参数调试，可真机预览，研发和视觉沟通成本较小\n   * 缺点\n     * 学习3d编辑器成本，其中实体的脚本需要在编辑器中完成。\n     * 编辑器导出项目均是ts，且资源过多都需要上传cdn，从导出资源到在项目中使用这一过程消耗时间过长，一旦频繁改动则时间不可控。\n     * 需要导入新的包，体积会增加\n * three.js\n   * 可实现小游戏复杂交互，有之前的项目经验，上手容易\n   * 性能较好，galacean engine 官网给的性能比 three 好的例子都是大量 模型/粒子系统 的情况，正常项目不会有这么多。\n\n\n\n\n\n\n# 包体积对比\n\n\n\n\n\n场景                                  包                                             体积\n普通动效                                @galacean/effects                             141.67KB\n普通动效 + spine 2d 动效                  @galacean/effects +@galacean-plugin-spine     141.67KB + 48.99KB = 190.66 KB\n普通动效 +spine 2d 动效 + 3d 主动效          @galacean/effects +@galacean-plugin-spine +   141.67KB + 48.99KB +35.96KB = 226.62KB\n                                    @galacean-plugin-model\n普通动效 +spine 2d 动效 + 3d 主动效 +复杂小游戏   @galacean/effects +@galacean-plugin-spine +   141.67KB + 48.99KB +35.96KB +261.44KB = 487.95KB\n                                    @galacean-plugin-model +@galacean/engine\n普通动效 +复杂小游戏                         @galacean/effects +@galacean/engine           141.67KB + 261.44KB = 403.11KB\n\n可以看到体积最大的为 @galacean/engine 有 261.44KB，若全部引入则打包出来的 static/feed-acticity/js/galacean.js 有 500KB+\n\n相比之下 three.js 只有 147.35KB，以我们最常见的场景：普通2d动效 + 小游戏，普通东西采用 @galacean/effects，小游戏采用 three.js 则：\n\n场景                          包                                                      体积\n普通动效 +spine 2d 动效 + 复杂小游戏   @galacean/effects +@galacean-plugin-spine + three.js   galacean.js + three.js = 190.66KB + 147.35KB\n\n * 综上所述：\n   * 普通动效使用 @galacean/effects + @galacean-plugin-spine\n   * 简单的3d动效 @galacean/effects + @galacean-plugin-model\n   * 小游戏使用 three.js\n   * 普通动效 + 3d 动效 + 小游戏：@galacean/effects + @galacean-plugin-spine + @galacean-plugin-model + three.js （不建议）\n   * 普通动效 + 小游戏：@galacean/effects + @galacean-plugin-spine + three.js （小游戏项目常见）",normalizedContent:"# galacean 3d\n\ngalacean 实现 3d 效果有两种方式：\n\n * galacean engine：直接用官方给的 web 3d 引擎，可以理解为 three.js 引擎，底层都是 webgl。\n   * galacean engine 与 three.js 性能对比，可以看下官方文档：https://galacean.antgroup.com/engine/docs（链接有问题，看下图）\n\n\n\n\n\n * galacean effects：简单的 3d 效果可直接用 galacean effects 来实现\n\n\n# galacean engine 快速入门\n\n快速入手可以看官方例子：https://galacean.antgroup.com/engine/docs/basics/quickstart/quick-start/（链接有问题，看下图）\n\n\n\n\n\n编辑器地址：https://galacean.antgroup.com/editor/projects\n\n按文档一步一步实践即可，这里主要介绍了如何在编辑器中创建 3d 项目以及在编辑器中引入 glb 模型、设置灯光、脚本、真机预览等。\n\n\n\n下面主要介绍下导出后在我们的项目中（feed-activity 为例）怎么使用：\n\n 1. 在这里我们导出示例中的 vanilla js 项目\n\n\n\n 1. 导出后的目录如下，其中public 中的文件都传到 cdn 中，然后在 project.json 中把所有的资源进行路径替换，然后再把 public/project.json 也传到 cdn 中\n\n（script.ts 从本地引入，测试发现不上传cdn也可以）\n\n\n\n\n\n 1. 项目根目录中还有一个 project.json ，把其中的 project.json url 替换成第二步的 cdn 地址（public中的那个）\n\n\n\n 1. 找到 src 中的 index.ts，scripts 就引入导出的 srcipts，projectinfo 引入第3步的 project.json，再把index.ts 中的初始代码复制到项目中即可。\n\n\n\n 1. 在 feed-activity 中如下，需要的只有 scripts （此处把 ts 改成了 js）和 project.json，其余内容都在 cdn 上\n\n\n\n 1. 最终在项目中跑通\n\n\n\n\n# galacean effects 实现 3d\n\n具体操作可以看 https://galacean.antgroup.com/effects/user/hpb4n5\n\n 1. 新建合成，场景选择 3d\n\n\n\n 1. 资源中添加 glb 模型，左上角可以平移旋转缩放等\n\n\n\n 1. 导出流程和2d类似，资源也是 .bin/.webp\n\n 2. 在 galacean effects 中使用 3d 元素的渲染，需要单独引入 3d 插件包。3d模型可能会引入复杂的渲染，上线前需要评估性能。\n\n// npm\nimport { player } from'@galacean/effects';\n// 确保在 player 引入之后再引入插件, 插件版本保持和 player 一致\nimport'@galacean/effects-plugin-model';\n\n\n使用示例：https://galacean.antgroup.com/effects/playground/vanilla-%e6%92%ad%e6%94%be%203d%20%e6%a8%a1%e5%9e%8b\n\n\n# 3d 实现对比\n\n * galacean effects 3d\n   * 优点：用 player 就可以实现 2d/3d 效果，3d 只需在原有 player 基础上引入插件即可。\n   * 缺点：只适用于简单的 3d 效果，并不适合跑酷等小游戏的实现。\n * galacean engine\n   * 优点：可以直接把模型导入3d编辑器，进行灯光位置等参数调试，可真机预览，研发和视觉沟通成本较小\n   * 缺点\n     * 学习3d编辑器成本，其中实体的脚本需要在编辑器中完成。\n     * 编辑器导出项目均是ts，且资源过多都需要上传cdn，从导出资源到在项目中使用这一过程消耗时间过长，一旦频繁改动则时间不可控。\n     * 需要导入新的包，体积会增加\n * three.js\n   * 可实现小游戏复杂交互，有之前的项目经验，上手容易\n   * 性能较好，galacean engine 官网给的性能比 three 好的例子都是大量 模型/粒子系统 的情况，正常项目不会有这么多。\n\n\n\n\n\n\n# 包体积对比\n\n\n\n\n\n场景                                  包                                             体积\n普通动效                                @galacean/effects                             141.67kb\n普通动效 + spine 2d 动效                  @galacean/effects +@galacean-plugin-spine     141.67kb + 48.99kb = 190.66 kb\n普通动效 +spine 2d 动效 + 3d 主动效          @galacean/effects +@galacean-plugin-spine +   141.67kb + 48.99kb +35.96kb = 226.62kb\n                                    @galacean-plugin-model\n普通动效 +spine 2d 动效 + 3d 主动效 +复杂小游戏   @galacean/effects +@galacean-plugin-spine +   141.67kb + 48.99kb +35.96kb +261.44kb = 487.95kb\n                                    @galacean-plugin-model +@galacean/engine\n普通动效 +复杂小游戏                         @galacean/effects +@galacean/engine           141.67kb + 261.44kb = 403.11kb\n\n可以看到体积最大的为 @galacean/engine 有 261.44kb，若全部引入则打包出来的 static/feed-acticity/js/galacean.js 有 500kb+\n\n相比之下 three.js 只有 147.35kb，以我们最常见的场景：普通2d动效 + 小游戏，普通东西采用 @galacean/effects，小游戏采用 three.js 则：\n\n场景                          包                                                      体积\n普通动效 +spine 2d 动效 + 复杂小游戏   @galacean/effects +@galacean-plugin-spine + three.js   galacean.js + three.js = 190.66kb + 147.35kb\n\n * 综上所述：\n   * 普通动效使用 @galacean/effects + @galacean-plugin-spine\n   * 简单的3d动效 @galacean/effects + @galacean-plugin-model\n   * 小游戏使用 three.js\n   * 普通动效 + 3d 动效 + 小游戏：@galacean/effects + @galacean-plugin-spine + @galacean-plugin-model + three.js （不建议）\n   * 普通动效 + 小游戏：@galacean/effects + @galacean-plugin-spine + three.js （小游戏项目常见）",charsets:{cjk:!0}},{title:"galacean",frontmatter:{},regularPath:"/mobile/galacean.html",relativePath:"mobile/galacean.md",key:"v-59f34d9f",path:"/mobile/galacean.html",headers:[{level:2,title:"galacean",slug:"galacean",normalizedTitle:"galacean",charIndex:2},{level:2,title:"Galacean Effects",slug:"galacean-effects",normalizedTitle:"galacean effects",charIndex:276},{level:2,title:"Galacean Effects 编辑器",slug:"galacean-effects-编辑器",normalizedTitle:"galacean effects 编辑器",charIndex:1244},{level:2,title:"spine 动画",slug:"spine-动画",normalizedTitle:"spine 动画",charIndex:1516},{level:2,title:"动画的切换",slug:"动画的切换",normalizedTitle:"动画的切换",charIndex:3108},{level:2,title:"loadScene",slug:"loadscene",normalizedTitle:"loadscene",charIndex:2342},{level:2,title:"代码修改动效中的文字和图片",slug:"代码修改动效中的文字和图片",normalizedTitle:"代码修改动效中的文字和图片",charIndex:5298},{level:2,title:"粒子动画",slug:"粒子动画",normalizedTitle:"粒子动画",charIndex:5497},{level:2,title:"迎财神红包雨实现",slug:"迎财神红包雨实现",normalizedTitle:"迎财神红包雨实现",charIndex:5744},{level:2,title:"踩坑",slug:"踩坑",normalizedTitle:"踩坑",charIndex:6745},{level:3,title:"渲染出现锯齿",slug:"渲染出现锯齿",normalizedTitle:"渲染出现锯齿",charIndex:6752},{level:3,title:"循环播放后卡顿",slug:"循环播放后卡顿",normalizedTitle:"循环播放后卡顿",charIndex:6856},{level:3,title:"webgl context lost",slug:"webgl-context-lost",normalizedTitle:"webgl context lost",charIndex:7035},{level:2,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:8642}],lastUpdated:"9/24/2025, 9:31:37 AM",lastUpdatedTimestamp:1758677497e3,headersStr:"galacean Galacean Effects Galacean Effects 编辑器 spine 动画 动画的切换 loadScene 代码修改动效中的文字和图片 粒子动画 迎财神红包雨实现 踩坑 渲染出现锯齿 循环播放后卡顿 webgl context lost 优化",content:"# galacean\n\nGalacean 是蚂蚁集团的图形互动技术品牌，在 Galacean 品牌下，包含底层引擎 Galacean Engine，在线编辑开发环境 Galacean Editor 等，旨在为互动业务开发者提供完善的互动开发解决方案。\n\n官网：https://galacean.antgroup.com\n\n掘金专栏：https://juejin.cn/column/696130865589980368\n\n-Galacean Engine：行业领先的 Web 3D 引擎，可以理解为 three.js 引擎，底层都是 webgl。\n\n-Galacean Effects：专注于移动端的在线化动效编辑器，主要用于制作动效。\n\n * Galacean Effects Studio（编辑器）：用于设计师来制作；研发同时也可以在编辑器中查看动效产物。\n * Galacean Effects Player（播放器）：用于在代码中实现；播放器用于在运行时解析和播放编辑器中发布的动画产物，保障动画上线的效果和效率，大大节约设计师与开发者之间动效实现、效果调试的沟通成本。\n\n\n# Galacean Effects\n\n主要介绍下 Galacean Effects。\n\n文档：https://galacean.antgroup.com/effects/user/zn6zshqq6eb7gk2\n\n语雀开发文档：https://galacean-effects.yuque.com/kdpoyl/bsbqf\n\ndemo：https://galacean.antgroup.com/effects/playground/vanilla-%E5%9F%BA%E6%9C%AC%E6%92%AD%E6%94%BE\n\n-Galacean Effects Studio：设计师制作动效的编辑器。\n\n * VFX：Galacean Effects Studio 的工程文件格式。\n\n * Galacean Effects 产物：Galacean Effects 动画描述文件，在编辑器通过导出（zip格式）或发布（JSON格式）可以获得。\n\n-Galacean Effects Player：播放 Galacean Effects 动画的播放器，播放的文件为 Galacean Effects 产物。\n\n一般的工作流程为：\n\n 1. 设计师使用编辑器 Galacean Effects Studio 设计动效，并导出 VFX 工程文件给到研发。\n 2. 研发也可以用编辑器打开 VFX 文件进行查看，然后导出 json 产物。产物中的 json 会引入 bins 和 images，需要把 bins 和 images 上传到bos，在 json 中进行替换。\n\n\n\n\n\n\n\n 1. 研发在代码中引入 json 产物，并使用播放器 Galacean Effects Player 进行播放。\n\n\n# Galacean Effects 编辑器\n\n\n\n 1. 将vfx导入编辑器可以预览动效，左上方可以看到不同的 composition，设计同学可以在一个 vfx 中放置多个动效。合成是 Galacean Effects 动画中最基础的概念之一。1 个合成 = 1 段动画，一个项目往往包括多个合成。合成列表包含当前项目的所有合成。\n 2. 左下方选中元素后，右侧可以查看元素的细节。知道这些后我们就可以在代码中根据 name 进行操作。\n 3. 比如导出的时候记得选择默认动画，然后结束行为设置为循环，这样就不用在代码中单独去设置了。\n\n\n# spine 动画\n\nspine 官网：https://zh.esotericsoftware.com\n\nSpine动画是一种在游戏开发中广泛应用的2D骨骼动画系统，它由Esoteric Software公司开发。相比传统的帧动画，Spine采用骨骼和插槽的概念，使开发者能够以更灵活、高效的方式制作和控制角色、物体等元素的动画。\n\ngalacean 支持导入 spine 动画，具体怎么制作和导入是设计同学需要关注的，研发需要注意导出后在代码中引入 spine 插件\n\n\n\nimport {Component} from 'san';\nimport {Player} from '@galacean/effects';\nimport {SpineComponent} from '@galacean/effects-plugin-spine';\nimport {Stats} from '@galacean/effects-plugin-stats';\nimport tree from './tree.json';\nexport default class TreasureCard extends Component {\n    static template = /* html */`\n        <div id=\"container\"></div>\n    `;\n    attached() {\n        // 1. 实例化一个播放器\n        const player = new Player({\n            container: document.getElementById('container'),\n            pixelRatio: window.devicePixelRatio || 2,\n        });\n        // 1. 加载背景\n        player.loadScene(background);\n        // 2. 加载树\n        player\n            .loadScene(tree)\n            .then(composition => { // 加载 VFXJSON 获得合成对象 composition\n                const VFXItem = composition.getItemByName('treeeee'); // 通过 name 获得元素对象 VFXItem\n                const spineComponent = VFXItem.getComponent(SpineComponent); // 获取 VFXItem 上的 SpineComponent\n                const animationList = spineComponent.animationList; // 获取 SpineComponent 上的动画列表 animationList\n                this.state = spineComponent.state;\n                console.log(this.state, animationList);\n            })\n            .catch(err => {\n                // 降级逻辑，以下仅供参考\n            });\n        // 3. 加载按钮\n        player.loadScene(button);\n    };\n}\n\n\n注意：animationState 一定是在动画播放后才能获取到\n\n\n# 动画的切换\n\n正常情况下树会执行默认动画，点击或者生长的时候会切换动画，切换播放完之后又会恢复默认动画。\n\ngalacean effects 提供了 setAnimation 设置动画 功能\n\n/**\n * 设置单个动画\n * @param animation - 动画名\n * @param speed - 播放速度\n */\nsetAnimation(animation: string, speed?: number): void;\n/**\n * 设置播放一组动画\n * @param animationList - 动画名列表\n * @param speed - 播放速度\n */\nsetAnimationList(animationList: string[], speed?: number): void;\n/**\n * 设置播放一组动画，循环播放最后一个\n * @param animationList - 动画名列表\n * @param speed - 播放速度\n * @since 1.6.0\n */\nsetAnimationListLoopEnd(animationList: string[], speed?: number): void;\n\n\n但没有这里没有切换完继续播放的功能，其实这里可以使用 galacean engine 中更详细的动画参数，用于队列播放。 [https://galacean.antgroup.com/engine/docs/graphics/2D/spine/runtime/#%E5%8A%A8%E7%94%BB%E9%98%9F%E5%88%97](https://galacean.antgroup.com/engine/docs/graphics/2D/spine/runtime/#动画队列\n\nchangeAnimation(name) {\n    this.state.setAnimation(0, name, false); // 切换动画\n    this.state.addAnimation(0, 'moren', true); // 在轨道 0 播放完继续播放动画 moren\n}\n\n\n\n# loadScene\n\n作用：player 加载 VFXJSON，一般一个 VFXJSON 对应一个 composition，loadScene 中可以传多个，也可以多次传。\n\n// 1. 加载单个合成链接并设置可选参数\nconst composition = await player.loadScene('xxx.json', { ... });\nconst composition = await player.loadScene({ url: 'xxx.json' }, { ... });\n// 2. 加载单个合成的 JSON 对象并设置可选参数\nconst composition = await player.loadScene(JSONValue, { ... });\n// 3. 加载多个合成链接或 JSON 对象\nconst [_, _, _] = await player.loadScene(['x1.json', 'x2.json', JSONValue]);\n// 4. 加载多个合成链接并各自设置可选参数\nconst [_, _] = await player.loadScene([{\n    url: 'x1.json',\n    options: { autoplay: false, ... },\n}, {\n    url: 'x2.json',\n    options: { speed: 2, ... },\n}, { ... }]);\n// 5. 加载多个合成链接并统一设置可选参数（共用）\nconst [_, _, _] = await player.loadScene(['x1.json', 'x2.json', ...], { ... });\nconst [_, _] = await player.loadScene(\n    [{ url: 'x1.json' }, { url: 'x2.json' }, { ... }],\n    {\n        variables: {\n            name': 'value',\n        },\n        speed: 2,\n        ...\n    },\n);\n// 6. 疯狂混合\nawait player.loadScene([\n    {\n        url: 'x1.json',\n        options: {\n            variables: {\n                'name1': 'value1',\n            },\n            speed: 2,\n        },\n    },\n    'x2.json',\n    JSONValue,\n], {\n    variables: {\n        'name2': 'value2',\n    },\n    speed: 0.1,\n});\n\n\n\n# 代码修改动效中的文字和图片\n\ngalacean 支持将文字和图片设置为变量，在代码中动态去修改。\n\n代码修改文字：https://galacean-effects.yuque.com/kdpoyl/bsbqfx/acbim2s0uhuty5k\n\n代码修改图片：https://galacean-effects.yuque.com/kdpoyl/bsbqfx/oyvu6mxzo4n860m\n\n\n# 粒子动画\n\n粒子动画是由在一定范围内随机生成的大量粒子产生运动而组成的动画，粒子系统常用于游戏引擎，用来实现火、云、烟花、雨、雪花等效果的实现。如红包雨：https://galacean.antgroup.com/effects/playground/vue-%E4%BA%A4%E4%BA%92%E5%85%83%E7%B4%A0-%E7%82%B9%E5%87%BB\n\n在编辑器中可以针对粒子动画设置如下属性，红包点击消失的操作也是在这里配置了粒子交互，并不是在代码中实现的。\n\n\n\n\n# 迎财神红包雨实现\n\n从素材中可以看到大部分的动效都已经完善，我们只需在代码中补充红包点击交互的逻辑。\n\n// 给 player 添加点击事件，可以通过参数拿到点击元素对象\nplayer.on('click', evt => {\n     // 财神点击则播放红包雨\n    if (evt.name === 'caishen') {\n        this.playRain();\n    }\n    // 小红包点击\n    else if (evt.name.includes('hongbao')) {\n        // 让点击的小红包消失\n        const clickItem = this.rainComposition.getItemByName(evt.name);\n        clickItem.setVisible(false);\n        // 连击数 +1\n        this.data.set('clickNum', num + 1);\n        // 播放爆炸光效\n        this.burstComposition.items.forEach(item => {\n            const burst = item.content.emission?.bursts[0];\n            if (burst) {\n                const next = burst.clone();\n                next.once = true;\n                // 在点击位置播放爆炸效果\n                item.content.addBurst(next, [evt.hitPositions[0].toArray()]);\n            }\n        });\n    }\n    // 大红包点击\n    else {\n        // 切换大红包点击的动画\n        this.rainState.setAnimation(0, 'pick', false);\n        // 改变连击数\n        this.data.set('clickNum', num + 1);\n    }\n});\n\n\n\n# 踩坑\n\n\n# 渲染出现锯齿\n\nUnity之Spine动画有锯齿和白色描边_spine导出gif有锯齿-CSDN博客\n\n锯齿的原因：https://juejin.cn/post/723665666975241016\n\n\n# 循环播放后卡顿\n\n表现行为是每 8s 一轮循环后都会卡顿一下，改了下 endBehavior 从 5 => 2 。 https://github.com/galacean/effects-specification/blob/79cfe259f10f2900728294bcf53f0dfc28a5e60d/src/constants.ts\n\n\n\n\n\n\n# webgl context lost\n\n反作弊的sdk中会创建webgl，有可能导致 webgl 数量超出限制\n\n// webglcontext 超出限制时，会舍弃最开始创建的，这时需要重新初始化\nthis.player.on('webglcontextlost', () => {\n    // your code\n    this.initAnimation();\n});\n// 如何测试webgl超出限制\n<canvas id=\"webgl1\"></canvas>\n<canvas id=\"webgl2\"></canvas>\n<canvas id=\"webgl3\"></canvas>\n<canvas id=\"webgl4\"></canvas>\n<canvas id=\"webgl5\"></canvas>\n<canvas id=\"webgl6\"></canvas>\n<canvas id=\"webgl7\"></canvas>\n<canvas id=\"webgl8\"></canvas>\n<canvas id=\"webgl9\"></canvas>\n setTimeout(() => {\n    const canvas = document.getElementById('webgl1');\n    const gl1 = canvas.getContext('webgl');\n    console.log(gl1);\n    const canvas2 = document.getElementById('webgl2');\n    const gl2 = canvas2.getContext('webgl');\n    console.log(gl2);\n    const canvas3 = document.getElementById('webgl3');\n    const gl3 = canvas3.getContext('webgl');\n    console.log(gl3);\n    const canvas4 = document.getElementById('webgl4');\n    const gl4 = canvas4.getContext('webgl');\n    console.log(gl4);\n    const canvas5 = document.getElementById('webgl5');\n    const gl5 = canvas5.getContext('webgl');\n    console.log(gl5);\n    const canvas6 = document.getElementById('webgl6');\n    const gl6 = canvas6.getContext('webgl');\n    console.log(gl6);\n    const canvas7 = document.getElementById('webgl7');\n    const gl7 = canvas7.getContext('webgl');\n    console.log(gl7);\n    const canvas8 = document.getElementById('webgl8');\n    const gl8 = canvas8.getContext('webgl');\n    console.log(gl8);\n    const canvas9 = document.getElementById('webgl9');\n    const gl9 = canvas9.getContext('webgl');\n    console.log(gl9);\n}, 3000);\n\n\n\n# 优化\n\n测试后手机出现发烫情况，需要进行优化\n\n 1. 降低帧数，正常情况渲染帧数为60，在不影响视觉的效果下我们将其降低成30帧\n\nconst player = new Player({container: document.getElementById('decorate-bg-container')});\nplayer\n    .loadScene('https://feed-activity-new.cdn.bcebos.com/2024wish/huodong-modal1/data.json')\n    .then(() => {\n        this.player.ticker.setFPS(30);\n    })\n\n\n 1. 粒子动画，减少发射器/粒子的数量（，如本次将背景烟花动效优化后则发烫效果明显好转。影响比较大）\n 2. 合成资源优化，如图片资源，具体可以看 https://galacean.antgroup.com/effects/user/dtrbrf#u9da6e47\n 3. 降级方案，若播放器 player 加载资源失败的话，在 catch 中捕获，则去加载默认的[静态兜底图](https://feed-activity-new.cdn.bcebos.com/2024caishen%2Ftree%2Fdoudi.png\n\n// 加载树\nthis.player\n    .loadScene(treeFacai)\n    .then(composition => {\n        // ...\n    })\n    .catch(err => {\n        // 降级逻辑\n        this.showDowngradeImage();\n    });\n// 降级处理\nshowDowngradeImage() {\n    const containerStyle = this.ref('container').style;\n    containerStyle.backgroundImage = 'url(\"https://feed-activity-new.cdn.bcebos.com/2024caishen%2Ftree%2Fdoudi.png\")';\n    containerStyle.backgroundRepeat = 'no-repeat';\n    containerStyle.backgroundSize = 'cover';\n    containerStyle.backgroundPosition = 'center';\n}\n\n\n 1. 尽量减少项目中player数量，一般有一个 player 即可。但是如果不可避免的有两个 player 的时候，需要把原有的 player 暂停再去播放新的 player\n 2. 资源预加载：一个动画的播放由资源载入和播放动画两部分组成，这两部分的耗时是没办法避免的。但是如果我们想继续优化动画播放的体验，这就需要我们将资源载入部分和播放动画拆分，提前将资源准备好，在播放的时候只需要播放动画就可以了，代码参考如下：\n\n/*** === 资源准备阶段 === ***/\n// 创建一个资源加载器\nconst assetManager = new AssetManager();\n// 进行资源的加载\nconst scene = await assetManager.loadScene('xxx.json');\n// 其他业务逻辑代码\n/*** === 资源准备阶段 === ***/\n/*** === 预编译准备阶段 === ***/\n// 加载动画资源\nawait player.loadScene(scene, { autoplay: false });\n/*** === 预编译准备阶段 === ***/\n// 手动播放\nplayer.play();\n",normalizedContent:"# galacean\n\ngalacean 是蚂蚁集团的图形互动技术品牌，在 galacean 品牌下，包含底层引擎 galacean engine，在线编辑开发环境 galacean editor 等，旨在为互动业务开发者提供完善的互动开发解决方案。\n\n官网：https://galacean.antgroup.com\n\n掘金专栏：https://juejin.cn/column/696130865589980368\n\n-galacean engine：行业领先的 web 3d 引擎，可以理解为 three.js 引擎，底层都是 webgl。\n\n-galacean effects：专注于移动端的在线化动效编辑器，主要用于制作动效。\n\n * galacean effects studio（编辑器）：用于设计师来制作；研发同时也可以在编辑器中查看动效产物。\n * galacean effects player（播放器）：用于在代码中实现；播放器用于在运行时解析和播放编辑器中发布的动画产物，保障动画上线的效果和效率，大大节约设计师与开发者之间动效实现、效果调试的沟通成本。\n\n\n# galacean effects\n\n主要介绍下 galacean effects。\n\n文档：https://galacean.antgroup.com/effects/user/zn6zshqq6eb7gk2\n\n语雀开发文档：https://galacean-effects.yuque.com/kdpoyl/bsbqf\n\ndemo：https://galacean.antgroup.com/effects/playground/vanilla-%e5%9f%ba%e6%9c%ac%e6%92%ad%e6%94%be\n\n-galacean effects studio：设计师制作动效的编辑器。\n\n * vfx：galacean effects studio 的工程文件格式。\n\n * galacean effects 产物：galacean effects 动画描述文件，在编辑器通过导出（zip格式）或发布（json格式）可以获得。\n\n-galacean effects player：播放 galacean effects 动画的播放器，播放的文件为 galacean effects 产物。\n\n一般的工作流程为：\n\n 1. 设计师使用编辑器 galacean effects studio 设计动效，并导出 vfx 工程文件给到研发。\n 2. 研发也可以用编辑器打开 vfx 文件进行查看，然后导出 json 产物。产物中的 json 会引入 bins 和 images，需要把 bins 和 images 上传到bos，在 json 中进行替换。\n\n\n\n\n\n\n\n 1. 研发在代码中引入 json 产物，并使用播放器 galacean effects player 进行播放。\n\n\n# galacean effects 编辑器\n\n\n\n 1. 将vfx导入编辑器可以预览动效，左上方可以看到不同的 composition，设计同学可以在一个 vfx 中放置多个动效。合成是 galacean effects 动画中最基础的概念之一。1 个合成 = 1 段动画，一个项目往往包括多个合成。合成列表包含当前项目的所有合成。\n 2. 左下方选中元素后，右侧可以查看元素的细节。知道这些后我们就可以在代码中根据 name 进行操作。\n 3. 比如导出的时候记得选择默认动画，然后结束行为设置为循环，这样就不用在代码中单独去设置了。\n\n\n# spine 动画\n\nspine 官网：https://zh.esotericsoftware.com\n\nspine动画是一种在游戏开发中广泛应用的2d骨骼动画系统，它由esoteric software公司开发。相比传统的帧动画，spine采用骨骼和插槽的概念，使开发者能够以更灵活、高效的方式制作和控制角色、物体等元素的动画。\n\ngalacean 支持导入 spine 动画，具体怎么制作和导入是设计同学需要关注的，研发需要注意导出后在代码中引入 spine 插件\n\n\n\nimport {component} from 'san';\nimport {player} from '@galacean/effects';\nimport {spinecomponent} from '@galacean/effects-plugin-spine';\nimport {stats} from '@galacean/effects-plugin-stats';\nimport tree from './tree.json';\nexport default class treasurecard extends component {\n    static template = /* html */`\n        <div id=\"container\"></div>\n    `;\n    attached() {\n        // 1. 实例化一个播放器\n        const player = new player({\n            container: document.getelementbyid('container'),\n            pixelratio: window.devicepixelratio || 2,\n        });\n        // 1. 加载背景\n        player.loadscene(background);\n        // 2. 加载树\n        player\n            .loadscene(tree)\n            .then(composition => { // 加载 vfxjson 获得合成对象 composition\n                const vfxitem = composition.getitembyname('treeeee'); // 通过 name 获得元素对象 vfxitem\n                const spinecomponent = vfxitem.getcomponent(spinecomponent); // 获取 vfxitem 上的 spinecomponent\n                const animationlist = spinecomponent.animationlist; // 获取 spinecomponent 上的动画列表 animationlist\n                this.state = spinecomponent.state;\n                console.log(this.state, animationlist);\n            })\n            .catch(err => {\n                // 降级逻辑，以下仅供参考\n            });\n        // 3. 加载按钮\n        player.loadscene(button);\n    };\n}\n\n\n注意：animationstate 一定是在动画播放后才能获取到\n\n\n# 动画的切换\n\n正常情况下树会执行默认动画，点击或者生长的时候会切换动画，切换播放完之后又会恢复默认动画。\n\ngalacean effects 提供了 setanimation 设置动画 功能\n\n/**\n * 设置单个动画\n * @param animation - 动画名\n * @param speed - 播放速度\n */\nsetanimation(animation: string, speed?: number): void;\n/**\n * 设置播放一组动画\n * @param animationlist - 动画名列表\n * @param speed - 播放速度\n */\nsetanimationlist(animationlist: string[], speed?: number): void;\n/**\n * 设置播放一组动画，循环播放最后一个\n * @param animationlist - 动画名列表\n * @param speed - 播放速度\n * @since 1.6.0\n */\nsetanimationlistloopend(animationlist: string[], speed?: number): void;\n\n\n但没有这里没有切换完继续播放的功能，其实这里可以使用 galacean engine 中更详细的动画参数，用于队列播放。 [https://galacean.antgroup.com/engine/docs/graphics/2d/spine/runtime/#%e5%8a%a8%e7%94%bb%e9%98%9f%e5%88%97](https://galacean.antgroup.com/engine/docs/graphics/2d/spine/runtime/#动画队列\n\nchangeanimation(name) {\n    this.state.setanimation(0, name, false); // 切换动画\n    this.state.addanimation(0, 'moren', true); // 在轨道 0 播放完继续播放动画 moren\n}\n\n\n\n# loadscene\n\n作用：player 加载 vfxjson，一般一个 vfxjson 对应一个 composition，loadscene 中可以传多个，也可以多次传。\n\n// 1. 加载单个合成链接并设置可选参数\nconst composition = await player.loadscene('xxx.json', { ... });\nconst composition = await player.loadscene({ url: 'xxx.json' }, { ... });\n// 2. 加载单个合成的 json 对象并设置可选参数\nconst composition = await player.loadscene(jsonvalue, { ... });\n// 3. 加载多个合成链接或 json 对象\nconst [_, _, _] = await player.loadscene(['x1.json', 'x2.json', jsonvalue]);\n// 4. 加载多个合成链接并各自设置可选参数\nconst [_, _] = await player.loadscene([{\n    url: 'x1.json',\n    options: { autoplay: false, ... },\n}, {\n    url: 'x2.json',\n    options: { speed: 2, ... },\n}, { ... }]);\n// 5. 加载多个合成链接并统一设置可选参数（共用）\nconst [_, _, _] = await player.loadscene(['x1.json', 'x2.json', ...], { ... });\nconst [_, _] = await player.loadscene(\n    [{ url: 'x1.json' }, { url: 'x2.json' }, { ... }],\n    {\n        variables: {\n            name': 'value',\n        },\n        speed: 2,\n        ...\n    },\n);\n// 6. 疯狂混合\nawait player.loadscene([\n    {\n        url: 'x1.json',\n        options: {\n            variables: {\n                'name1': 'value1',\n            },\n            speed: 2,\n        },\n    },\n    'x2.json',\n    jsonvalue,\n], {\n    variables: {\n        'name2': 'value2',\n    },\n    speed: 0.1,\n});\n\n\n\n# 代码修改动效中的文字和图片\n\ngalacean 支持将文字和图片设置为变量，在代码中动态去修改。\n\n代码修改文字：https://galacean-effects.yuque.com/kdpoyl/bsbqfx/acbim2s0uhuty5k\n\n代码修改图片：https://galacean-effects.yuque.com/kdpoyl/bsbqfx/oyvu6mxzo4n860m\n\n\n# 粒子动画\n\n粒子动画是由在一定范围内随机生成的大量粒子产生运动而组成的动画，粒子系统常用于游戏引擎，用来实现火、云、烟花、雨、雪花等效果的实现。如红包雨：https://galacean.antgroup.com/effects/playground/vue-%e4%ba%a4%e4%ba%92%e5%85%83%e7%b4%a0-%e7%82%b9%e5%87%bb\n\n在编辑器中可以针对粒子动画设置如下属性，红包点击消失的操作也是在这里配置了粒子交互，并不是在代码中实现的。\n\n\n\n\n# 迎财神红包雨实现\n\n从素材中可以看到大部分的动效都已经完善，我们只需在代码中补充红包点击交互的逻辑。\n\n// 给 player 添加点击事件，可以通过参数拿到点击元素对象\nplayer.on('click', evt => {\n     // 财神点击则播放红包雨\n    if (evt.name === 'caishen') {\n        this.playrain();\n    }\n    // 小红包点击\n    else if (evt.name.includes('hongbao')) {\n        // 让点击的小红包消失\n        const clickitem = this.raincomposition.getitembyname(evt.name);\n        clickitem.setvisible(false);\n        // 连击数 +1\n        this.data.set('clicknum', num + 1);\n        // 播放爆炸光效\n        this.burstcomposition.items.foreach(item => {\n            const burst = item.content.emission?.bursts[0];\n            if (burst) {\n                const next = burst.clone();\n                next.once = true;\n                // 在点击位置播放爆炸效果\n                item.content.addburst(next, [evt.hitpositions[0].toarray()]);\n            }\n        });\n    }\n    // 大红包点击\n    else {\n        // 切换大红包点击的动画\n        this.rainstate.setanimation(0, 'pick', false);\n        // 改变连击数\n        this.data.set('clicknum', num + 1);\n    }\n});\n\n\n\n# 踩坑\n\n\n# 渲染出现锯齿\n\nunity之spine动画有锯齿和白色描边_spine导出gif有锯齿-csdn博客\n\n锯齿的原因：https://juejin.cn/post/723665666975241016\n\n\n# 循环播放后卡顿\n\n表现行为是每 8s 一轮循环后都会卡顿一下，改了下 endbehavior 从 5 => 2 。 https://github.com/galacean/effects-specification/blob/79cfe259f10f2900728294bcf53f0dfc28a5e60d/src/constants.ts\n\n\n\n\n\n\n# webgl context lost\n\n反作弊的sdk中会创建webgl，有可能导致 webgl 数量超出限制\n\n// webglcontext 超出限制时，会舍弃最开始创建的，这时需要重新初始化\nthis.player.on('webglcontextlost', () => {\n    // your code\n    this.initanimation();\n});\n// 如何测试webgl超出限制\n<canvas id=\"webgl1\"></canvas>\n<canvas id=\"webgl2\"></canvas>\n<canvas id=\"webgl3\"></canvas>\n<canvas id=\"webgl4\"></canvas>\n<canvas id=\"webgl5\"></canvas>\n<canvas id=\"webgl6\"></canvas>\n<canvas id=\"webgl7\"></canvas>\n<canvas id=\"webgl8\"></canvas>\n<canvas id=\"webgl9\"></canvas>\n settimeout(() => {\n    const canvas = document.getelementbyid('webgl1');\n    const gl1 = canvas.getcontext('webgl');\n    console.log(gl1);\n    const canvas2 = document.getelementbyid('webgl2');\n    const gl2 = canvas2.getcontext('webgl');\n    console.log(gl2);\n    const canvas3 = document.getelementbyid('webgl3');\n    const gl3 = canvas3.getcontext('webgl');\n    console.log(gl3);\n    const canvas4 = document.getelementbyid('webgl4');\n    const gl4 = canvas4.getcontext('webgl');\n    console.log(gl4);\n    const canvas5 = document.getelementbyid('webgl5');\n    const gl5 = canvas5.getcontext('webgl');\n    console.log(gl5);\n    const canvas6 = document.getelementbyid('webgl6');\n    const gl6 = canvas6.getcontext('webgl');\n    console.log(gl6);\n    const canvas7 = document.getelementbyid('webgl7');\n    const gl7 = canvas7.getcontext('webgl');\n    console.log(gl7);\n    const canvas8 = document.getelementbyid('webgl8');\n    const gl8 = canvas8.getcontext('webgl');\n    console.log(gl8);\n    const canvas9 = document.getelementbyid('webgl9');\n    const gl9 = canvas9.getcontext('webgl');\n    console.log(gl9);\n}, 3000);\n\n\n\n# 优化\n\n测试后手机出现发烫情况，需要进行优化\n\n 1. 降低帧数，正常情况渲染帧数为60，在不影响视觉的效果下我们将其降低成30帧\n\nconst player = new player({container: document.getelementbyid('decorate-bg-container')});\nplayer\n    .loadscene('https://feed-activity-new.cdn.bcebos.com/2024wish/huodong-modal1/data.json')\n    .then(() => {\n        this.player.ticker.setfps(30);\n    })\n\n\n 1. 粒子动画，减少发射器/粒子的数量（，如本次将背景烟花动效优化后则发烫效果明显好转。影响比较大）\n 2. 合成资源优化，如图片资源，具体可以看 https://galacean.antgroup.com/effects/user/dtrbrf#u9da6e47\n 3. 降级方案，若播放器 player 加载资源失败的话，在 catch 中捕获，则去加载默认的[静态兜底图](https://feed-activity-new.cdn.bcebos.com/2024caishen%2ftree%2fdoudi.png\n\n// 加载树\nthis.player\n    .loadscene(treefacai)\n    .then(composition => {\n        // ...\n    })\n    .catch(err => {\n        // 降级逻辑\n        this.showdowngradeimage();\n    });\n// 降级处理\nshowdowngradeimage() {\n    const containerstyle = this.ref('container').style;\n    containerstyle.backgroundimage = 'url(\"https://feed-activity-new.cdn.bcebos.com/2024caishen%2ftree%2fdoudi.png\")';\n    containerstyle.backgroundrepeat = 'no-repeat';\n    containerstyle.backgroundsize = 'cover';\n    containerstyle.backgroundposition = 'center';\n}\n\n\n 1. 尽量减少项目中player数量，一般有一个 player 即可。但是如果不可避免的有两个 player 的时候，需要把原有的 player 暂停再去播放新的 player\n 2. 资源预加载：一个动画的播放由资源载入和播放动画两部分组成，这两部分的耗时是没办法避免的。但是如果我们想继续优化动画播放的体验，这就需要我们将资源载入部分和播放动画拆分，提前将资源准备好，在播放的时候只需要播放动画就可以了，代码参考如下：\n\n/*** === 资源准备阶段 === ***/\n// 创建一个资源加载器\nconst assetmanager = new assetmanager();\n// 进行资源的加载\nconst scene = await assetmanager.loadscene('xxx.json');\n// 其他业务逻辑代码\n/*** === 资源准备阶段 === ***/\n/*** === 预编译准备阶段 === ***/\n// 加载动画资源\nawait player.loadscene(scene, { autoplay: false });\n/*** === 预编译准备阶段 === ***/\n// 手动播放\nplayer.play();\n",charsets:{cjk:!0}},{title:"跨平台与跨端技术简介",frontmatter:{},regularPath:"/mobile/cross.html",relativePath:"mobile/cross.md",key:"v-54d03685",path:"/mobile/cross.html",headers:[{level:2,title:"跨平台技术",slug:"跨平台技术",normalizedTitle:"跨平台技术",charIndex:73},{level:3,title:"浏览器",slug:"浏览器",normalizedTitle:"浏览器",charIndex:203},{level:3,title:"node",slug:"node",normalizedTitle:"node",charIndex:331},{level:2,title:"跨端技术",slug:"跨端技术",normalizedTitle:"跨端技术",charIndex:6},{level:3,title:"webview",slug:"webview",normalizedTitle:"webview",charIndex:732},{level:3,title:"小程序",slug:"小程序",normalizedTitle:"小程序",charIndex:1039},{level:3,title:"Flutter",slug:"flutter",normalizedTitle:"flutter",charIndex:1310},{level:3,title:"JS-Native",slug:"js-native",normalizedTitle:"js-native",charIndex:1344},{level:3,title:"DSL + Layout 方案",slug:"dsl-layout-方案",normalizedTitle:"dsl + layout 方案",charIndex:2887},{level:2,title:"动态化技术",slug:"动态化技术",normalizedTitle:"动态化技术",charIndex:3414}],lastUpdated:"1/6/2023, 2:27:26 PM",lastUpdatedTimestamp:1672986446e3,headersStr:"跨平台技术 浏览器 node 跨端技术 webview 小程序 Flutter JS-Native DSL + Layout 方案 动态化技术",content:"# 跨平台与跨端技术简介\n\n跨平台一般指的是跨操作系统（*nix、windows），而跨端是指客户端（web、android、ios）。\n\n\n# 跨平台技术\n\n我们知道，cpu 有不同的架构和指令集，上层也有不同的操作系统，一个系统的可执行文件在另一个系统上就是不可执行的，比如 windows 的 exe 文件在 mac 上就不能直接执行。不同的系统就是不同的运行平台。可执行文件是不跨平台的。\n\n\n# 浏览器\n\n操作系统不同，浏览器上跑的网页的代码确实同一份。浏览器就是一种历史悠久的跨平台方案。\n\n网页跨平台不意味着浏览器也是跨平台的，浏览器的可执行文件还是每个平台单独开发和编译的，但是他们支持的网页解析逻辑一样，这样上面跑的网页就是跨平台的。\n\n\n# node\n\n起初，node 只能在 *nix 平台上运行，Node 在 v0.6.0 版本支持了 windows 平台，这主要得益于 Node 架构层面的改动，它在操作系统与 Node 上层模块系统之间构建了一层平台层架构，即 libuv。\n\n\n\n例如 require 在引入 .node 文件（C++扩展模块）的过程中，*nix 平台下实际调用的是 dlopen 和 dlsym 两个方法；在 windows 平台下则是通过 LoadlibraryExw 和 GetProcAddress 这两个方法实现的，它们分别加载 .so 和 .dll 文件（实际是 .node 文件）\n\nvar hello = require('./hello.node');\n\n\n\n# 跨端技术\n\n简单来说，跨端技术就是写一份代码分别能运行在 ios、android、web，下面介绍一下业界常见的跨端技术：\n\n\n\n\n# webview\n\n参考：https://mp.weixin.qq.com/s/4k087DBswlufx97UpWqE1g\n\nWebView 就是浏览器引擎部分，你可以像插入 iframe 一样将 Webview 插入到你的原生应用中， WebView 通常会从 http:// 或者 https:// 地址下载网络内容。这意味着你可以从服务器中获取部分（或全部）Web 应用并且依赖 Webview 将这部分内容展示在原生应用中，且 Native App 与 WebView 具有交互能力。\n\n如果你有一个在浏览器中运行的响应式 Web 应用，那么在各种设备上使用相同的应用作为混合应用会非常简单。\n\n\n\n\n# 小程序\n\n微信小程序是介于 Native 和 WebApp 之间的产物，它依托浏览器 WebView 展示同时可以调用原生能力，比如获取通讯录、拍照等，同一份代码可运行在Android、iOS和微信调试开发工具内。\n\n与 React Native 的跨端不同的是，小程序大部分UI组件并不是原生渲染，还是类似 WebApp 使用浏览器渲染，只有少量组件使用Native实现，比如<canvas>、<video>、<map>、<textarea>。\n\n\n\n各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的，具体区别如下：\n\n\n\n\n# Flutter\n\n相比 React Native 和 Weex 等 JS-Native 技术，Flutter实现跨平台采用了更为彻底的方案。它既没有采用 WebView 也没有采用 JavaScript，而是自己实现了一套 UI 框架，然后直接系统更底层渲染系统上画UI。所以它采用的开发语言不是JS，而是 Dart。\n\nFlutter 使用自己的渲染引擎来绘制 UI，布局数据等由 Dart 语言直接控制，所以在布局过程中不需要像 RN 那样要在 JavaScript 和 Native 之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以 JavaScript 需要和 Native 之间不停的同步布局信息。\n\n\n\n\n# JS-Native\n\n采用 JSEngine 驱动 Native 渲染模式，在这基础上扩展 native 组件，采用 DSL （react、san、vue、html）编写，调用 Native 提供的渲染 api，驱动 Native 渲染。\n\n我们目前最主流的跨端方案就是这种，特别适合前端工程师进行开发，几种业界 js-native 方案及 Flutter 的对比\n\n框架                  TALOS（未开源）     REACT-NATIVE       WEEX           HIPPY             FLUTTER\n来源                  百度             FaceBook           阿里             腾讯                Google\nDSL 语言              San            React              Vue            React、Vue、Dart等   Dart\n引擎（Android / ios）   V8 / JS core   Hermes / JS core   V8 / JS core   Hippy 引擎          Flutter 引擎\n渲染                  原生 Native      原生 Native          原生 Native      原生 Native、自绘      自绘\n\nJavaScript引擎是一个专门处理 JavaScript 脚本的虚拟机，主要有以下两处应用：\n\n 1. web端 JavaScript 引擎：附带在浏览器之中\n\n 2. 移动端 JavaScript 引擎：跨端技术 js-native 方案中需要在端上使用 JavaScript 引擎运行 js 代码来进一步调用 Native 。（像 Flutter 这种自绘制的方案使用的是 Dart 语言需要自己的 Flutter 引擎）\n\n----------------------------------------\n\n主流的 JavaScript 引擎主要有以下几种：\n\n * V8 (Google)\n * JavaScriptCore (Apple)\n * QuickJS\n * Hermes(Facebook-React Native)\n\n关于几种引擎的介绍，强烈推荐这篇文章：移动端 JS 引擎哪家强？美国硅谷找......\n\nJIT 技术：V8引擎的JIT技术简述\n\n跨端布局引擎 Yoga 官网：https://yogalayout.com/\n\n> yoga 是 facebook 打造的一个跨IOS、Android、Window平台在内的布局引擎，兼容Flexbox布局方式，让界面更加简单。 react native 使用Yoga 实现跨平台布局。\n\n\n# DSL + Layout 方案\n\n对于交互较少的基础 UI 动态化布局能力，还有一种方式就是 DSL + Layout：就是动态下发 UI 的布局信息，Native 使用解析之后的数据对 View 进行布局。\n\n对于这种”配置性”的布局信息，我们通常选用JSON / XML / YAML等等来进行描述，客户端根据约定进行解析和使用即可。\n\n天猫的 Tangram、美团的 MTFlexbox 和 Picasso 等等都是在此基础上进行的完善和封装。同时由于 Flexbox + Yoga 的出现，这种技术方案甚至已经发展到了几乎每个小团队都有一个轮子的程度。\n\n> 通俗来讲，这种方案就是利用 json 来写 App。例如我配置好了一张 UI 卡片的 json 信息，下发到客户端，Android 和 IOS 分别按照定好的协议对此 json 进行解析，然后渲染出原生的组件。这样既可以保证一份数据双端运行，又可以保证 UI 卡片动态化能力，不依赖于端上发版，只依赖于下发的数据（可以通过服务端进行下发）。\n\n动态界面：DSL & 布局引擎\n\n基于Web技术栈的动态化跨平台漫谈\n\n动态卡片：富媒体内容井喷式增长下，新一代移动端动态研发的模式\n\n\n# 动态化技术\n\n动态化技术指不依赖 APP 发版，就能进行动态的增加或者修改来更新页面的技术。对于消息卡片这种需要快速迭代、实时调整的业务，动态化具有非常重要的意义。主要优势体现在：\n\n * 提高人效\n * 缩短版本迭代试错周期\n * 解决版本长尾问题\n * 减少包大小等\n\n上面介绍的 JS-Native 和 DSL + Layout 均属于动态化技术，不依赖 APP 发版。\n\n通过 DSL + Layout 的方式，我们就可以实现交互较少的基础 UI 动态化布局能力。那么随着动态化 UI 的功能边界不断扩大，这种方式的局限性也渐渐的显露出来：对于自定义视图的扩展、交互能力处理的限制、复杂 UI 状态的管理复杂性等等。\n\n所以 JS-Native 引入了 Javascript 引擎，随着语言运行时的引入可以实现更为复杂的代码逻辑来满足交互处理、通信和状态管理，同时这也需要扩展和完善 JS / Native 的通信机制、封装完善的组件和能力等等，这样就形成了类 react-native / Weex 框架的雏形。\n\n\n\n> DSL + Layout 的方式只需要将定义好的数据格式（如 JSON）下发给客户端，客户端按照已有的规则解析即可，在此期间我们可以修改下发的数据，来完成客户端上对应样式的修改，并不依赖 APP 发版。\n> \n> JS-Native 的方式只需要将我们写好的代码（如 react native）通过 cli 打包好，然后比如通过某个平台进行资源 bundle 文件的上传，然后客户端将资源下载下来，再通过 Javascript 引擎运行 js 代码，进一步驱动 NA 端渲染。",normalizedContent:"# 跨平台与跨端技术简介\n\n跨平台一般指的是跨操作系统（*nix、windows），而跨端是指客户端（web、android、ios）。\n\n\n# 跨平台技术\n\n我们知道，cpu 有不同的架构和指令集，上层也有不同的操作系统，一个系统的可执行文件在另一个系统上就是不可执行的，比如 windows 的 exe 文件在 mac 上就不能直接执行。不同的系统就是不同的运行平台。可执行文件是不跨平台的。\n\n\n# 浏览器\n\n操作系统不同，浏览器上跑的网页的代码确实同一份。浏览器就是一种历史悠久的跨平台方案。\n\n网页跨平台不意味着浏览器也是跨平台的，浏览器的可执行文件还是每个平台单独开发和编译的，但是他们支持的网页解析逻辑一样，这样上面跑的网页就是跨平台的。\n\n\n# node\n\n起初，node 只能在 *nix 平台上运行，node 在 v0.6.0 版本支持了 windows 平台，这主要得益于 node 架构层面的改动，它在操作系统与 node 上层模块系统之间构建了一层平台层架构，即 libuv。\n\n\n\n例如 require 在引入 .node 文件（c++扩展模块）的过程中，*nix 平台下实际调用的是 dlopen 和 dlsym 两个方法；在 windows 平台下则是通过 loadlibraryexw 和 getprocaddress 这两个方法实现的，它们分别加载 .so 和 .dll 文件（实际是 .node 文件）\n\nvar hello = require('./hello.node');\n\n\n\n# 跨端技术\n\n简单来说，跨端技术就是写一份代码分别能运行在 ios、android、web，下面介绍一下业界常见的跨端技术：\n\n\n\n\n# webview\n\n参考：https://mp.weixin.qq.com/s/4k087dbswlufx97upwqe1g\n\nwebview 就是浏览器引擎部分，你可以像插入 iframe 一样将 webview 插入到你的原生应用中， webview 通常会从 http:// 或者 https:// 地址下载网络内容。这意味着你可以从服务器中获取部分（或全部）web 应用并且依赖 webview 将这部分内容展示在原生应用中，且 native app 与 webview 具有交互能力。\n\n如果你有一个在浏览器中运行的响应式 web 应用，那么在各种设备上使用相同的应用作为混合应用会非常简单。\n\n\n\n\n# 小程序\n\n微信小程序是介于 native 和 webapp 之间的产物，它依托浏览器 webview 展示同时可以调用原生能力，比如获取通讯录、拍照等，同一份代码可运行在android、ios和微信调试开发工具内。\n\n与 react native 的跨端不同的是，小程序大部分ui组件并不是原生渲染，还是类似 webapp 使用浏览器渲染，只有少量组件使用native实现，比如<canvas>、<video>、<map>、<textarea>。\n\n\n\n各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的，具体区别如下：\n\n\n\n\n# flutter\n\n相比 react native 和 weex 等 js-native 技术，flutter实现跨平台采用了更为彻底的方案。它既没有采用 webview 也没有采用 javascript，而是自己实现了一套 ui 框架，然后直接系统更底层渲染系统上画ui。所以它采用的开发语言不是js，而是 dart。\n\nflutter 使用自己的渲染引擎来绘制 ui，布局数据等由 dart 语言直接控制，所以在布局过程中不需要像 rn 那样要在 javascript 和 native 之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以 javascript 需要和 native 之间不停的同步布局信息。\n\n\n\n\n# js-native\n\n采用 jsengine 驱动 native 渲染模式，在这基础上扩展 native 组件，采用 dsl （react、san、vue、html）编写，调用 native 提供的渲染 api，驱动 native 渲染。\n\n我们目前最主流的跨端方案就是这种，特别适合前端工程师进行开发，几种业界 js-native 方案及 flutter 的对比\n\n框架                  talos（未开源）     react-native       weex           hippy             flutter\n来源                  百度             facebook           阿里             腾讯                google\ndsl 语言              san            react              vue            react、vue、dart等   dart\n引擎（android / ios）   v8 / js core   hermes / js core   v8 / js core   hippy 引擎          flutter 引擎\n渲染                  原生 native      原生 native          原生 native      原生 native、自绘      自绘\n\njavascript引擎是一个专门处理 javascript 脚本的虚拟机，主要有以下两处应用：\n\n 1. web端 javascript 引擎：附带在浏览器之中\n\n 2. 移动端 javascript 引擎：跨端技术 js-native 方案中需要在端上使用 javascript 引擎运行 js 代码来进一步调用 native 。（像 flutter 这种自绘制的方案使用的是 dart 语言需要自己的 flutter 引擎）\n\n----------------------------------------\n\n主流的 javascript 引擎主要有以下几种：\n\n * v8 (google)\n * javascriptcore (apple)\n * quickjs\n * hermes(facebook-react native)\n\n关于几种引擎的介绍，强烈推荐这篇文章：移动端 js 引擎哪家强？美国硅谷找......\n\njit 技术：v8引擎的jit技术简述\n\n跨端布局引擎 yoga 官网：https://yogalayout.com/\n\n> yoga 是 facebook 打造的一个跨ios、android、window平台在内的布局引擎，兼容flexbox布局方式，让界面更加简单。 react native 使用yoga 实现跨平台布局。\n\n\n# dsl + layout 方案\n\n对于交互较少的基础 ui 动态化布局能力，还有一种方式就是 dsl + layout：就是动态下发 ui 的布局信息，native 使用解析之后的数据对 view 进行布局。\n\n对于这种”配置性”的布局信息，我们通常选用json / xml / yaml等等来进行描述，客户端根据约定进行解析和使用即可。\n\n天猫的 tangram、美团的 mtflexbox 和 picasso 等等都是在此基础上进行的完善和封装。同时由于 flexbox + yoga 的出现，这种技术方案甚至已经发展到了几乎每个小团队都有一个轮子的程度。\n\n> 通俗来讲，这种方案就是利用 json 来写 app。例如我配置好了一张 ui 卡片的 json 信息，下发到客户端，android 和 ios 分别按照定好的协议对此 json 进行解析，然后渲染出原生的组件。这样既可以保证一份数据双端运行，又可以保证 ui 卡片动态化能力，不依赖于端上发版，只依赖于下发的数据（可以通过服务端进行下发）。\n\n动态界面：dsl & 布局引擎\n\n基于web技术栈的动态化跨平台漫谈\n\n动态卡片：富媒体内容井喷式增长下，新一代移动端动态研发的模式\n\n\n# 动态化技术\n\n动态化技术指不依赖 app 发版，就能进行动态的增加或者修改来更新页面的技术。对于消息卡片这种需要快速迭代、实时调整的业务，动态化具有非常重要的意义。主要优势体现在：\n\n * 提高人效\n * 缩短版本迭代试错周期\n * 解决版本长尾问题\n * 减少包大小等\n\n上面介绍的 js-native 和 dsl + layout 均属于动态化技术，不依赖 app 发版。\n\n通过 dsl + layout 的方式，我们就可以实现交互较少的基础 ui 动态化布局能力。那么随着动态化 ui 的功能边界不断扩大，这种方式的局限性也渐渐的显露出来：对于自定义视图的扩展、交互能力处理的限制、复杂 ui 状态的管理复杂性等等。\n\n所以 js-native 引入了 javascript 引擎，随着语言运行时的引入可以实现更为复杂的代码逻辑来满足交互处理、通信和状态管理，同时这也需要扩展和完善 js / native 的通信机制、封装完善的组件和能力等等，这样就形成了类 react-native / weex 框架的雏形。\n\n\n\n> dsl + layout 的方式只需要将定义好的数据格式（如 json）下发给客户端，客户端按照已有的规则解析即可，在此期间我们可以修改下发的数据，来完成客户端上对应样式的修改，并不依赖 app 发版。\n> \n> js-native 的方式只需要将我们写好的代码（如 react native）通过 cli 打包好，然后比如通过某个平台进行资源 bundle 文件的上传，然后客户端将资源下载下来，再通过 javascript 引擎运行 js 代码，进一步驱动 na 端渲染。",charsets:{cjk:!0}},{title:"移动端h5开发",frontmatter:{title:"移动端h5开发",date:"2022-04-26T16:01:54.000Z",categories:"移动端"},regularPath:"/mobile/h5.html",relativePath:"mobile/h5.md",key:"v-7b5aca02",path:"/mobile/h5.html",headers:[{level:2,title:"适配方案",slug:"适配方案",normalizedTitle:"适配方案",charIndex:121},{level:3,title:"vw + rem方案",slug:"vw-rem方案",normalizedTitle:"vw + rem方案",charIndex:168},{level:2,title:"滚动加载注意事项",slug:"滚动加载注意事项",normalizedTitle:"滚动加载注意事项",charIndex:1593},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:136},{level:3,title:"ios 点击背景",slug:"ios-点击背景",normalizedTitle:"ios 点击背景",charIndex:3629},{level:3,title:"html不可选中",slug:"html不可选中",normalizedTitle:"html不可选中",charIndex:3759},{level:3,title:"页面不可放大缩小",slug:"页面不可放大缩小",normalizedTitle:"页面不可放大缩小",charIndex:4061},{level:3,title:"图片压缩",slug:"图片压缩",normalizedTitle:"图片压缩",charIndex:4201},{level:2,title:"调试",slug:"调试",normalizedTitle:"调试",charIndex:4242},{level:2,title:"h5 登录状态同步",slug:"h5-登录状态同步",normalizedTitle:"h5 登录状态同步",charIndex:4695}],lastUpdated:"6/7/2022, 7:16:51 PM",lastUpdatedTimestamp:1654600611e3,headersStr:"适配方案 vw + rem方案 滚动加载注意事项 注意事项 ios 点击背景 html不可选中 页面不可放大缩小 图片压缩 调试 h5 登录状态同步",content:"# 移动端h5开发\n\n众所周知，移动端app项目或者小程序项目中的一些页面都会用 h5 来写，一般我们会将写好的 h5 页面做好适配，上传到静态地址（如 Bos），然后 h5 页面会以 webview 的方式嵌入到原生应用中。这里主要总结一下适配方案以及一些在h5开发中的注意事项。\n\n\n# 适配方案\n\n更多方案可见移动端适配\n\n\n# vw + rem方案\n\n首先在 html 根元素中设置：\n\nhtml {\n  font-size: 5vw;\n}\n\n\n这样 1rem = 5 vw，20 rem = 100 vw。\n\n如果浏览器不支持 vw 写法，我们需要手动插入以下代码：\n\n(function (doc, win) {\n  var dummy = doc.createElement('_').style;\n  dummy.width = '1vw';\n  // 若支持vw则退出\n  if (dummy.width) {\n    return;\n  }\n  // 不支持 vw 则手动计算一下，设置 font-size 为屏幕宽度 1 / 20\n  var docEl = doc.documentElement,\n      resizeEvt = 'orientationchange' in win ? 'orientationchange' : 'resize',\n      recalc = function () {\n        var clientWidth = docEl.clientWidth;\n        if (!clientWidth) {\n          return;\n        }\n        docEl.style.fontSize = (clientWidth / 20) + 'px';\n      };\n  recalc();\n  win.addEventListener(resizeEvt, recalc, false);\n})(document, window);\n\n\n----------------------------------------\n\n开发时我们不建议直接写 rem，理想情况是设计稿给出多少我就写多少，所以我们需要再设置一下 rem 和 px 的转换关系：\n\n先说结论，如果设计稿是 n px 的，那么设置 1px = (20 / n) rem\n\n> 如果项目中写 100 px ，其实希望无论屏幕宽度是多少，它都占设计稿宽度的 100 / n 的。按照换算关系：\n> \n> 100px = 100 * (20 / n) rem = 100 * (20 / n) * 5 vw ，那么：\n> \n> 1 vw 占屏幕宽度的 1 /100 之一，100 * (20 / n) * 5 vw 则占屏幕的 100 * (20 / n) * 5 / 100 分之一，即 100 / n 分之一，就是我们所希望的结果。\n\n综上，如果设计稿是 375px 的，一个元素宽度为 100px，我们只需直接在项目中写 100px，那么这个元素无论在什么宽度的屏幕上，其宽度都会占屏幕宽度的 100 / 375 份，这就满足了自适应。\n\n----------------------------------------\n\n至于 px 转 rem 我们可以使用 postcss-px2rem 插件来实现，项目中新建 postcss.config.js，详见此项目\n\n// remUnit 即 n / 20 的值\nmodule.exports = {\n    plugins: [\n        require('postcss-px2rem')({remUnit: 18.75}),\n    ]\n}\n\n\n\n# 滚动加载注意事项\n\n一般我们在项目中使用滚动到底加载，这时候要注意两点：\n\n 1. 避免多次触发（前一个接口还没请求完，又去请求下一个接口）\n 2. 监听事件的取消\n\nasync getList() {\n  // 当上一个接口没返回时，不去请求下一个\n  if (this.'loading') {\n    return;\n  }\n  this.loading = true;\n  let res = await getDetail();\n  if (res && res.data) {\n    this.list = res.data;\n    return list;\n  });\n  this.data.set('loading', false);\n}\n\n\n关于滚动事件监听\n\nmounted() {\n  this.loadingFun = this.loading.bind(this);\n  window.addEventListener('scroll', this.loadingFun);\n}\n\nunmounted() {\n  window.removeEventListener('scroll', this.loadingFun);\n}\n\nloading() {\n  //文档内容实际高度（包括超出视窗的溢出部分）\n  let scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);\n  //滚动条滚动距离\n  let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n  //窗口可视范围高度\n  let clientHeight = window.innerHeight || Math.min(document.documentElement.clientHeight,document.body.clientHeight);\n\n  if (clientHeight + scrollTop >= scrollHeight - 500) {\n    this.getList();\n  }\n}\n\n\n为什么要 bind (this) ？\n\n> 因为 loading 内部还有 this，这个 this 应该指向组件实例，但是直接 window.addEventListener('scroll', this.loading); this.getList 就会指向 window\n> \n> 原因是 addEventListener 参数中回调函数的this指向目标元素。\n\n<button id=\"btn\">click</button>\n\nlet oBtn = document.getElementById('btn');\noBtn.addEventListener('click', function(){\n\tconsole.log(this) // 这里的 this 是button元素\n}, false)\n\n--------\n\noBtn.addEventListener('click', say, false)\nfunction say() {\n    console.log(this) // 这里的 this 也是button元素\n}\n\n--------\n\nlet obj = {\n\tsay: function() {\n\t\tconsole.log(this)\n\t}\n}\noBtn.addEventListener('click', obj.say, false)\n// 这里的 this 也是button元素\n\n\n那我使用箭头函数不行吗？这样 this 就会指向外部作用域了？\n\nwindow.addEventListener('scroll', () => {\n  this.loading;\n});\nwindow.removeEventListener('scroll', () => {\n  this.loading;\n});\n\n\n> 不行，因为 () => {} !== () => {}，不是一个函数，同下面这个例子\n\n为什么要定义个 loadingFunc？下面这样写不行吗？\n\nwindow.addEventListener('scroll', this.loading.bind(this));\nwindow.removeEventListener('scroll', this.loading.bind(this));\n\n\n> 不行，因为 bind 之后返回的是一个新函数，添加监听和移除监听的不是一个函数，不会生效\n\n\n# 注意事项\n\n\n# ios 点击背景\n\n在 ios 上，当你点击一个链接或者通过 Javascript 定义的可点击元素的时候，它就会出现一个半透明的灰色背景。需要设置下:\n\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n\n\n# html不可选中\n\nHtml 和 css 分别添加\n\n<body onselectstart=\"return false\">\n  <div id=\"app\"></div>\n</body>\n\n\n-webkit-touch-callout: none; /*系统默认菜单被禁用*/\n-webkit-user-select: none; /*webkit浏览器*/\n-khtml-user-select: none; /*早期浏览器*/\n-moz-user-select: none;/*火狐*/\n-ms-user-select: none; /*IE10*/\nuser-select: none;\n\n\n\n# 页面不可放大缩小\n\nhtml 中添加 meta 标签\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n\n\n\n# 图片压缩\n\n一般移动端项目都要进行图片压缩，否则列表中图片会展示的很慢。\n\n\n# 调试\n\nH5 移动调试全攻略\n\n抓包查看数据：Charles 工具\n\n# Android\n\n 1. 首先打开手机开发者选项，允许 usb 调试，然后将手机通过转接头连接到电脑上，出现以下弹窗则成功。\n\n\n\n 2. chrome 中打开 chrome://inspect/#devices，android 上打开 h5 页面时，Remote Target 中会显示设备。\n\n\n\n> 手机开发者选项不同手机不一致，百度一下即可。\n> \n> 如果没显示 Remote Target 记得拔掉 usb 重试几次，直到手机上弹出【允许 usb 调试】字样。\n\n# IOS\n\nsafari调试\n\n打开iPhone手机设置设置 -> Safari -> 高级 -> 打开Web检查器，然后通过数据线将iPhone连接到Mac，电脑和手机同时打开Safari，电脑上Safari打开 开发-iPhone，就能开始调试啦。\n\n> 限制是只能在 ios safari 下调试，app 内的 webview 没办法调试\n\n\n# h5 登录状态同步\n\nApp 如何把登录状态传给H5页面呢？其实需要把登录后服务器返回的 token 、userId 等登录信息传给H5网页，userId 等数据可以通过 url 传递，token 最简单的办法是由 app 端存入到 webview 的 cookie 中。\n\n如果登录校验是后端从 cookie 中取出 token 的话，前端不用作任何处理。",normalizedContent:"# 移动端h5开发\n\n众所周知，移动端app项目或者小程序项目中的一些页面都会用 h5 来写，一般我们会将写好的 h5 页面做好适配，上传到静态地址（如 bos），然后 h5 页面会以 webview 的方式嵌入到原生应用中。这里主要总结一下适配方案以及一些在h5开发中的注意事项。\n\n\n# 适配方案\n\n更多方案可见移动端适配\n\n\n# vw + rem方案\n\n首先在 html 根元素中设置：\n\nhtml {\n  font-size: 5vw;\n}\n\n\n这样 1rem = 5 vw，20 rem = 100 vw。\n\n如果浏览器不支持 vw 写法，我们需要手动插入以下代码：\n\n(function (doc, win) {\n  var dummy = doc.createelement('_').style;\n  dummy.width = '1vw';\n  // 若支持vw则退出\n  if (dummy.width) {\n    return;\n  }\n  // 不支持 vw 则手动计算一下，设置 font-size 为屏幕宽度 1 / 20\n  var docel = doc.documentelement,\n      resizeevt = 'orientationchange' in win ? 'orientationchange' : 'resize',\n      recalc = function () {\n        var clientwidth = docel.clientwidth;\n        if (!clientwidth) {\n          return;\n        }\n        docel.style.fontsize = (clientwidth / 20) + 'px';\n      };\n  recalc();\n  win.addeventlistener(resizeevt, recalc, false);\n})(document, window);\n\n\n----------------------------------------\n\n开发时我们不建议直接写 rem，理想情况是设计稿给出多少我就写多少，所以我们需要再设置一下 rem 和 px 的转换关系：\n\n先说结论，如果设计稿是 n px 的，那么设置 1px = (20 / n) rem\n\n> 如果项目中写 100 px ，其实希望无论屏幕宽度是多少，它都占设计稿宽度的 100 / n 的。按照换算关系：\n> \n> 100px = 100 * (20 / n) rem = 100 * (20 / n) * 5 vw ，那么：\n> \n> 1 vw 占屏幕宽度的 1 /100 之一，100 * (20 / n) * 5 vw 则占屏幕的 100 * (20 / n) * 5 / 100 分之一，即 100 / n 分之一，就是我们所希望的结果。\n\n综上，如果设计稿是 375px 的，一个元素宽度为 100px，我们只需直接在项目中写 100px，那么这个元素无论在什么宽度的屏幕上，其宽度都会占屏幕宽度的 100 / 375 份，这就满足了自适应。\n\n----------------------------------------\n\n至于 px 转 rem 我们可以使用 postcss-px2rem 插件来实现，项目中新建 postcss.config.js，详见此项目\n\n// remunit 即 n / 20 的值\nmodule.exports = {\n    plugins: [\n        require('postcss-px2rem')({remunit: 18.75}),\n    ]\n}\n\n\n\n# 滚动加载注意事项\n\n一般我们在项目中使用滚动到底加载，这时候要注意两点：\n\n 1. 避免多次触发（前一个接口还没请求完，又去请求下一个接口）\n 2. 监听事件的取消\n\nasync getlist() {\n  // 当上一个接口没返回时，不去请求下一个\n  if (this.'loading') {\n    return;\n  }\n  this.loading = true;\n  let res = await getdetail();\n  if (res && res.data) {\n    this.list = res.data;\n    return list;\n  });\n  this.data.set('loading', false);\n}\n\n\n关于滚动事件监听\n\nmounted() {\n  this.loadingfun = this.loading.bind(this);\n  window.addeventlistener('scroll', this.loadingfun);\n}\n\nunmounted() {\n  window.removeeventlistener('scroll', this.loadingfun);\n}\n\nloading() {\n  //文档内容实际高度（包括超出视窗的溢出部分）\n  let scrollheight = math.max(document.documentelement.scrollheight, document.body.scrollheight);\n  //滚动条滚动距离\n  let scrolltop = window.pageyoffset || document.documentelement.scrolltop || document.body.scrolltop;\n  //窗口可视范围高度\n  let clientheight = window.innerheight || math.min(document.documentelement.clientheight,document.body.clientheight);\n\n  if (clientheight + scrolltop >= scrollheight - 500) {\n    this.getlist();\n  }\n}\n\n\n为什么要 bind (this) ？\n\n> 因为 loading 内部还有 this，这个 this 应该指向组件实例，但是直接 window.addeventlistener('scroll', this.loading); this.getlist 就会指向 window\n> \n> 原因是 addeventlistener 参数中回调函数的this指向目标元素。\n\n<button id=\"btn\">click</button>\n\nlet obtn = document.getelementbyid('btn');\nobtn.addeventlistener('click', function(){\n\tconsole.log(this) // 这里的 this 是button元素\n}, false)\n\n--------\n\nobtn.addeventlistener('click', say, false)\nfunction say() {\n    console.log(this) // 这里的 this 也是button元素\n}\n\n--------\n\nlet obj = {\n\tsay: function() {\n\t\tconsole.log(this)\n\t}\n}\nobtn.addeventlistener('click', obj.say, false)\n// 这里的 this 也是button元素\n\n\n那我使用箭头函数不行吗？这样 this 就会指向外部作用域了？\n\nwindow.addeventlistener('scroll', () => {\n  this.loading;\n});\nwindow.removeeventlistener('scroll', () => {\n  this.loading;\n});\n\n\n> 不行，因为 () => {} !== () => {}，不是一个函数，同下面这个例子\n\n为什么要定义个 loadingfunc？下面这样写不行吗？\n\nwindow.addeventlistener('scroll', this.loading.bind(this));\nwindow.removeeventlistener('scroll', this.loading.bind(this));\n\n\n> 不行，因为 bind 之后返回的是一个新函数，添加监听和移除监听的不是一个函数，不会生效\n\n\n# 注意事项\n\n\n# ios 点击背景\n\n在 ios 上，当你点击一个链接或者通过 javascript 定义的可点击元素的时候，它就会出现一个半透明的灰色背景。需要设置下:\n\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n\n\n# html不可选中\n\nhtml 和 css 分别添加\n\n<body onselectstart=\"return false\">\n  <div id=\"app\"></div>\n</body>\n\n\n-webkit-touch-callout: none; /*系统默认菜单被禁用*/\n-webkit-user-select: none; /*webkit浏览器*/\n-khtml-user-select: none; /*早期浏览器*/\n-moz-user-select: none;/*火狐*/\n-ms-user-select: none; /*ie10*/\nuser-select: none;\n\n\n\n# 页面不可放大缩小\n\nhtml 中添加 meta 标签\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n\n\n\n# 图片压缩\n\n一般移动端项目都要进行图片压缩，否则列表中图片会展示的很慢。\n\n\n# 调试\n\nh5 移动调试全攻略\n\n抓包查看数据：charles 工具\n\n# android\n\n 1. 首先打开手机开发者选项，允许 usb 调试，然后将手机通过转接头连接到电脑上，出现以下弹窗则成功。\n\n\n\n 2. chrome 中打开 chrome://inspect/#devices，android 上打开 h5 页面时，remote target 中会显示设备。\n\n\n\n> 手机开发者选项不同手机不一致，百度一下即可。\n> \n> 如果没显示 remote target 记得拔掉 usb 重试几次，直到手机上弹出【允许 usb 调试】字样。\n\n# ios\n\nsafari调试\n\n打开iphone手机设置设置 -> safari -> 高级 -> 打开web检查器，然后通过数据线将iphone连接到mac，电脑和手机同时打开safari，电脑上safari打开 开发-iphone，就能开始调试啦。\n\n> 限制是只能在 ios safari 下调试，app 内的 webview 没办法调试\n\n\n# h5 登录状态同步\n\napp 如何把登录状态传给h5页面呢？其实需要把登录后服务器返回的 token 、userid 等登录信息传给h5网页，userid 等数据可以通过 url 传递，token 最简单的办法是由 app 端存入到 webview 的 cookie 中。\n\n如果登录校验是后端从 cookie 中取出 token 的话，前端不用作任何处理。",charsets:{cjk:!0}},{title:"小程序长列表优化",frontmatter:{title:"小程序长列表优化",date:"2020-09-20T11:27:54.000Z",categories:"移动端"},regularPath:"/mobile/long-list.html",relativePath:"mobile/long-list.md",key:"v-4a5cdbb2",path:"/mobile/long-list.html",headers:[{level:2,title:"具体实现",slug:"具体实现",normalizedTitle:"具体实现",charIndex:208},{level:2,title:"自定义Vue指令",slug:"自定义vue指令",normalizedTitle:"自定义vue指令",charIndex:1820}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"具体实现 自定义Vue指令",content:'# 小程序长列表优化\n\n * 滚动加载\n\n * 虚拟列表\n\n * 参考：https://zhuanlan.zhihu.com/p/146791824\n\n思路:\n\n 1. 一维数组 => 二维数组，每个子数组存放十条数据（一屏）\n 2. 每加载一屏，计算一下高度，用一个高度数组存储\n 3. 对每一屏数据位置进行监听，只有在可视范围内展示\n 4. 为防止过快滚动出现白屏，可视范围扩展至屏幕上下各2000高度\n\n\n# 具体实现\n\n * 一维数组 => 二维数组\n\n<div :id="\'wrp_\' + index1" v-for="(question, index) in questionList" :key="index">\n\t<div v-if="question.length > 0">\n\t\t<div v-for="item in question" :key="item.questionId">\n            <list-item></list-item>\n\t\t</div>\n     <div v-else :style="{ height: pageHeightArr[index1] + \'px\' }"></div>\n</div>\n\n\n * 调用接口\n\n\t\tgetQuestionList() {\n            // 每次调用接口获取 10 条数据，为一组\n            API.getList(params).then(res => {\n                this.questionList.push(res)\n                this.dataList.push(res)\n                // setHeight: 获取高度\n                this.$nextTick(() => {\n                    setTimeout(() => {\n                        this.setHeight()\n                    }, 50)\n                })\n        }\n\n\n * 获取高度与监听\n\nsetHeight() {\n\tconst that = this\n\tconst wholePageIndex = this.pageNum - 1\n\tthis.query = wx.createSelectorQuery()\n    // 获取 DOM 元素\n\tthis.query.select(`#wrp_${wholePageIndex}`).boundingClientRect()\n    // 获取高度\n\tthis.query.exec(function(res) {\n\t\tthat.pageHeightArr[wholePageIndex] = res[0] && res[0].height\n\t\tconsole.log(\'高度数组：\' + that.pageHeightArr)\n\t})\n    // 监听\n\tthis.observePage(wholePageIndex)\n}\n\nobservePage(pageIndex) {\n    // 监听可视区域上下各 1500 范围内\n\tconst observerObj = wx.createIntersectionObserver().relativeToViewport(\n\t\t{ top: 1500, bottom: 1500 }\n    )\n\tobserverObj.observe(`#wrp_${pageIndex}`, (res) => {\n\t\tif (res.intersectionRatio <= 0) {\n            // 不在范围内 设置高度\n\t\t\tthis.$set(this.questionList, pageIndex, this.pageHeightArr[pageIndex])\n\t\t} else {\n            // 在范围内 设置数据\n\t\t\tthis.$set(this.questionList, pageIndex, this.dataList[pageIndex])\n\t\t}\n\t})\n}\n\n\n\n# 自定义Vue指令\n\nVue.directive(\'el-select-scroll\', {\n        bind(el, binding) {\n            // 获取DOM\n            let SCROLL_DOM = el.querySelector(\'.el-select-dropdown .el-select-dropdown__wrap\')\n            let scrollPosition = 0\n            SCROLL_DOM.addEventListener(\'scroll\', function () { \n\n                // 滚动方向: true是向上，false是向下\n                let flagToDirection = this.scrollTop - scrollPosition > 0\n\n                // 记录当前的滚动位置\n                scrollPosition = this.scrollTop\n\n                // 距离底部小于 120 触发\n                const LIMIT_BOTTOM = 120\n                let scrollBottom = this.scrollHeight - (this.scrollTop + this.clientHeight) < LIMIT_BOTTOM\n\n                // 将滚动行为告诉组件\n                if (flagToDirection && scrollBottom) {\n                    binding.value(flagToDirection)\n                }\n            })       \n        }\n    })\n\n\n<el-select\n  filterable \n  :filter-method="dataFilter1"\n  v-el-select-scroll="handleScrollThrittle1"\n  placeholder="请选择访问楼盘">\n      <el-option\n         v-for="item in buildGroup.list"\n         :key="item.pid"\n         :label="item.groupName"\n         :value="item.pid">\n      </el-option>\n</el-select>\n',normalizedContent:'# 小程序长列表优化\n\n * 滚动加载\n\n * 虚拟列表\n\n * 参考：https://zhuanlan.zhihu.com/p/146791824\n\n思路:\n\n 1. 一维数组 => 二维数组，每个子数组存放十条数据（一屏）\n 2. 每加载一屏，计算一下高度，用一个高度数组存储\n 3. 对每一屏数据位置进行监听，只有在可视范围内展示\n 4. 为防止过快滚动出现白屏，可视范围扩展至屏幕上下各2000高度\n\n\n# 具体实现\n\n * 一维数组 => 二维数组\n\n<div :id="\'wrp_\' + index1" v-for="(question, index) in questionlist" :key="index">\n\t<div v-if="question.length > 0">\n\t\t<div v-for="item in question" :key="item.questionid">\n            <list-item></list-item>\n\t\t</div>\n     <div v-else :style="{ height: pageheightarr[index1] + \'px\' }"></div>\n</div>\n\n\n * 调用接口\n\n\t\tgetquestionlist() {\n            // 每次调用接口获取 10 条数据，为一组\n            api.getlist(params).then(res => {\n                this.questionlist.push(res)\n                this.datalist.push(res)\n                // setheight: 获取高度\n                this.$nexttick(() => {\n                    settimeout(() => {\n                        this.setheight()\n                    }, 50)\n                })\n        }\n\n\n * 获取高度与监听\n\nsetheight() {\n\tconst that = this\n\tconst wholepageindex = this.pagenum - 1\n\tthis.query = wx.createselectorquery()\n    // 获取 dom 元素\n\tthis.query.select(`#wrp_${wholepageindex}`).boundingclientrect()\n    // 获取高度\n\tthis.query.exec(function(res) {\n\t\tthat.pageheightarr[wholepageindex] = res[0] && res[0].height\n\t\tconsole.log(\'高度数组：\' + that.pageheightarr)\n\t})\n    // 监听\n\tthis.observepage(wholepageindex)\n}\n\nobservepage(pageindex) {\n    // 监听可视区域上下各 1500 范围内\n\tconst observerobj = wx.createintersectionobserver().relativetoviewport(\n\t\t{ top: 1500, bottom: 1500 }\n    )\n\tobserverobj.observe(`#wrp_${pageindex}`, (res) => {\n\t\tif (res.intersectionratio <= 0) {\n            // 不在范围内 设置高度\n\t\t\tthis.$set(this.questionlist, pageindex, this.pageheightarr[pageindex])\n\t\t} else {\n            // 在范围内 设置数据\n\t\t\tthis.$set(this.questionlist, pageindex, this.datalist[pageindex])\n\t\t}\n\t})\n}\n\n\n\n# 自定义vue指令\n\nvue.directive(\'el-select-scroll\', {\n        bind(el, binding) {\n            // 获取dom\n            let scroll_dom = el.queryselector(\'.el-select-dropdown .el-select-dropdown__wrap\')\n            let scrollposition = 0\n            scroll_dom.addeventlistener(\'scroll\', function () { \n\n                // 滚动方向: true是向上，false是向下\n                let flagtodirection = this.scrolltop - scrollposition > 0\n\n                // 记录当前的滚动位置\n                scrollposition = this.scrolltop\n\n                // 距离底部小于 120 触发\n                const limit_bottom = 120\n                let scrollbottom = this.scrollheight - (this.scrolltop + this.clientheight) < limit_bottom\n\n                // 将滚动行为告诉组件\n                if (flagtodirection && scrollbottom) {\n                    binding.value(flagtodirection)\n                }\n            })       \n        }\n    })\n\n\n<el-select\n  filterable \n  :filter-method="datafilter1"\n  v-el-select-scroll="handlescrollthrittle1"\n  placeholder="请选择访问楼盘">\n      <el-option\n         v-for="item in buildgroup.list"\n         :key="item.pid"\n         :label="item.groupname"\n         :value="item.pid">\n      </el-option>\n</el-select>\n',charsets:{cjk:!0}},{title:"模块化",frontmatter:{title:"模块化",date:"2020-09-05T09:47:00.000Z",categories:"模块化"},regularPath:"/module/module.html",relativePath:"module/module.md",key:"v-332a845f",path:"/module/module.html",headers:[{level:2,title:"模块化的演变过程",slug:"模块化的演变过程",normalizedTitle:"模块化的演变过程",charIndex:41},{level:2,title:"ES Modules",slug:"es-modules",normalizedTitle:"es modules",charIndex:53},{level:3,title:"ES Modules 基本特性",slug:"es-modules-基本特性",normalizedTitle:"es modules 基本特性",charIndex:1272},{level:3,title:"ES Modules 的导入导出",slug:"es-modules-的导入导出",normalizedTitle:"es modules 的导入导出",charIndex:2118},{level:3,title:"几点注意事项",slug:"几点注意事项",normalizedTitle:"几点注意事项",charIndex:2565},{level:2,title:"Polyfill",slug:"polyfill",normalizedTitle:"polyfill",charIndex:67},{level:2,title:"ES Module与CommonJS交互",slug:"es-module与commonjs交互",normalizedTitle:"es module与commonjs交互",charIndex:79},{level:2,title:"import中的@",slug:"import中的",normalizedTitle:"import中的@",charIndex:103},{level:2,title:"几个实际的例子",slug:"几个实际的例子",normalizedTitle:"几个实际的例子",charIndex:116},{level:2,title:".mjs 与 .cjs",slug:"mjs-与-cjs",normalizedTitle:".mjs 与 .cjs",charIndex:5940},{level:2,title:"ES Modules 与 Common JS 差异",slug:"es-modules-与-common-js-差异",normalizedTitle:"es modules 与 common js 差异",charIndex:6455}],lastUpdated:"3/1/2022, 3:30:47 PM",lastUpdatedTimestamp:1646119847e3,headersStr:"模块化的演变过程 ES Modules ES Modules 基本特性 ES Modules 的导入导出 几点注意事项 Polyfill ES Module与CommonJS交互 import中的@ 几个实际的例子 .mjs 与 .cjs ES Modules 与 Common JS 差异",content:"# 模块化\n\n阮一峰文档：Module 的语法、Module 的加载实现\n\n * 模块化的演变过程\n * ES Modules\n * Polyfill\n * ES Module与CommonJS交互\n * import中的@\n * 几个实际的例子\n\n\n# 模块化的演变过程\n\n 1. 基于文件的划分模块的方式\n\n> 所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，\n> \n> 而且模块一段多了过后，容易产生命名冲突，\n> \n> 另外无法管理模块与模块之间的依赖关系\n\n 2. 命名空间方式\n\n> 具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，\n> \n> 有点类似于为模块内的成员添加了「命名空间」的感觉。\n> \n> 通过「命名空间」减小了命名冲突的可能，\n> \n> 但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，\n> \n> 而且也无法管理模块之间的依赖关系。\n\n 3. IIFE：立即执行函数，实现了私有成员\n\n> 具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，\n> \n> 对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现\n> \n> 有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。\n\n// module a 相关状态数据和功能函数，IIFE\n\n;(function () {\n  var name = 'module-a'\n  \n  function method1 () {\n    console.log(name + '#method1')\n  }\n  \n  function method2 () {\n    console.log(name + '#method2')\n  }\n\n  window.moduleA = {\n    method1: method1,\n    method2: method2\n  }\n})()\n\n\n\n 4. CommonJS规范（node环境）\n\n * 一个文件就是一个模块\n * 每个模块都有单独的作用域\n * 通过module.exports导出成员\n * 通过require函数载入模块\n\n> 浏览器端不能使用，因为CommonJS是以同步模式加载模块，每一次页面加载都会有大量模块请求\n\n 5. AMD：Asynchronous Module Definition （异步模块定义）\n\n> 同时期推出了require.js，实现了AMD规范\n> \n> 目前绝大数第三方库都支持AMD规范\n> \n> 但是AMD使用起来比较复杂，模块JS文件请求频繁\n\n 6. Sea.js + CMD ：Common Module Definition\n\n> 类似于CommonJS的语法\n\n\n# ES Modules\n\n * CommonJS in Node.js（目前Node8以上也支持ES Modules）\n * ES Modules in Browsers（ES6）\n\n\n# ES Modules 基本特性\n\n * 自动采用严格模式，忽略 'use strict'\n * 每个 ES Module 都是运行在单独的私有作用域中\n * ESM 是通过 CORS 的方式请求外部 JS 模块的\n * ESM 的 script 标签会延迟执行脚本\n\n  \x3c!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 --\x3e\n  <script type=\"module\">\n    console.log('this is es module')\n  <\/script>\n\n  \x3c!-- 1. ESM 自动采用严格模式，忽略 'use strict' --\x3e\n  <script type=\"module\">\n    console.log(this) // undefined\n  <\/script>\n\n  \x3c!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 --\x3e\n  <script type=\"module\">\n    var foo = 100\n    console.log(foo)\n  <\/script>\n  <script type=\"module\">\n    console.log(foo)\n  <\/script>\n\n  \x3c!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的，需要服务器端的跨域支持，普通script不存在跨域 --\x3e\n  <script type=\"module\" src=\"https://unpkg.com/jquery@3.4.1/dist/jquery.min.js\"><\/script> \n\n  \x3c!-- 4. ESM 的 script 标签会延迟执行脚本,此处会先执行p标签 --\x3e\n  <script defer src=\"demo.js\"><\/script>\n  <p>需要显示的内容</p> \n\n\n\n# ES Modules 的导入导出\n\n// app.js\nimport { default as fooName, fooHello, Person } from './module.js'\n\nimport height23 from './module.js' // 接收default\n\nconsole.log(fooName, fooHello, Person)\n\n// modeule.js\nvar name = 'foo module'\n\nvar height = 180\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass Person {}\n\nexport { name as default, hello as fooHello, Person }\n\nexport default height\n\n// index.html\n<script type=\"module\" src=\"app.js\"><\/script>\n\n\n\n# 几点注意事项\n\nimport { name } from './module.js' // 不能省略.js\nimport { lowercase } from './utils/index.js' // 不能省略index.js，否则找不到\nimport { name } from './module.js' // 不能省略./，否则认为加载第三方模块\nimport './module.js' // 加载这个模块但是不提取\nimport * as mod from './module.js' // 提取所有放入mod对象中\n\n// 下面这两种方式不正确，不能动态条件导入\nvar modulePath = './module.js'\nimport { name } from modulePath\nconsole.log(name)\n\n if (true) {\n   import { name } from './module.js'\n }\n\n// 那怎么动态导入呢\n import('./module.js').then(function (module) {\n   console.log(module)\n })\n\n// 提取默认成员和正常成员\nimport abc, { name, age } from './module.js'\nconsole.log(name, age, abc)\n\n// 直接导出导入成员\n\n// button.js\nvar Button = 'Button Component'\nexport default Button\n\n// avatar.js\nexport var Avatar = 'Avatar Component'\n\n// index.js\nexport { default as Button } from './button.js'\nexport { Avatar } from './avatar.js'\n\n// 第三方模块都是导出默认成员\nimport _ from 'lodash'\nimport { camelCase } from 'lodash' // 不正确\n\n\n\n# Polyfill\n\nie浏览器不兼容ES Modules\n\nPolyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。\n\n> 例如，querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.querySelectorAll，使用方法跟现代浏览器原生API无异。那么这个库就可以称为Polyfill或者Polyfiller。\n> \n> jQuery是不是一个Polyfill?答案是No。因为它并不是实现一些标准的原生API，而是封装了自己API。一个Polyfill是抹平新老浏览器 标准原生API 之间的差距的一种封装，而不是实现自己的API。\n> \n> 把旧的浏览器想象成为一面有了裂缝的墙.这些[polyfills]会帮助我们把这面墙的裂缝抹平,还我们一个更好的光滑的墙壁(浏览器)\n\n\n# ES Module与CommonJS交互\n\n在node原生环境中\n\n * ES Modules中可以导入CommonJS模块\n * CommonJS中可以导入ES Modules模块\n * CommonJS始终只会导出一个默认成员\n * 注意import不是解构对象\n\nes-module.mjs 文件名要改成.mjs\n\n// ES Module 中可以导入 CommonJS 模块\n\nimport mod from './commonjs.js'\nconsole.log(mod)\n\n// 不能直接提取成员，注意 import 不是解构导出对象\n\nimport { foo } from './commonjs.js'\nconsole.log(foo)\n\nexport const foo = 'es module export value'\n\n\ncommonjs.js\n\n// CommonJS 模块始终只会导出一个默认成员\n\nmodule.exports = {\n  foo: 'commonjs exports value'\n}\n\nexports.foo = 'commonjs exports value'\n\n// 不能在 CommonJS 模块中通过 require 载入 ES Module\n\nconst mod = require('./es-module.mjs')\nconsole.log(mod)\n\n\n> 无论是require或者import，目前仍然需要通过babel或者traceur之类的转义工具将之转义为ES5语法，才能在浏览器里运行。\n\n\n# import中的@\n\n> 这是webpack的路径别名，相关代码定义在配置文件webpack.base.config里：\n\n\tresolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n      'lib': resolve('src/lib'),\n      'style': resolve('src/style'),\n      'com': resolve('src/components'),\n      'serv': resolve('src/service'),\n      'api': resolve('src/api'),\n      'store': resolve('src/store')\n    }\n  },\n\n\n\n# 几个实际的例子\n\n某天在看代码时发现类似下面的写法：\n\n// a.ts\nexport default 123;\n\n\n// b.ts\nlet b = require('./a').default;\n\n\n对此我感到很疑惑，在我的记忆中，模块化无非就是两种：\n\n * ES Modules ：使用 import、export / export default 语法\n * CommonJS：使用 require、module.exports / exports 语法\n\n那么代码中的 require('./a').default 中的 .default 是什么意思呢？将其编译成 js 文件再来看：\n\n// a.js\n\"use strict\";\nexports.__esModule = true;\nexports[\"default\"] = 123;\n\n// b.js\nvar b = require('./a')[\"default\"];\n\n\n> 原来是经过 ts 编译后，es6 的 export default 都会被转换成 exports.default，即 CommonJS 规范\n> \n> 转换的逻辑非常简单，即将输出赋值给 exports，并带上一个标志 __esModule 表明这是个由 es6 转换来的 commonjs 输出。\n\n如果没有加上 .default ，则会得到整个对象：\n\n// a.ts\nexport default 123;\n\n// b.ts\nlet b = require('./a');\n\nconsole.log(b) // { __esModule: true, default: 123 }\n\n\n> 总结：esm 语法经过 ts 或者 babel 转换后会变为 commonjs 语法，所以这也解释了为什么两个文件既可以用 esm 语法，也可以用 CommonJs 语法，因为最后都会转换为 CommonJS 语法。\n\n参考链接：https://juejin.cn/post/6844903520865386510#heading-3\n\n\n# .mjs 与 .cjs\n\n从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。\n\nNode.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定\"use strict\"。\n\n如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。\n\n{\n   \"type\": \"module\"\n}\n\n\n一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。\n\n如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjs。如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 CommonJS 模块。\n\n总结为一句话：.mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。\n\n\n# ES Modules 与 Common JS 差异\n\n * CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n * CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n * CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。",normalizedContent:"# 模块化\n\n阮一峰文档：module 的语法、module 的加载实现\n\n * 模块化的演变过程\n * es modules\n * polyfill\n * es module与commonjs交互\n * import中的@\n * 几个实际的例子\n\n\n# 模块化的演变过程\n\n 1. 基于文件的划分模块的方式\n\n> 所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，\n> \n> 而且模块一段多了过后，容易产生命名冲突，\n> \n> 另外无法管理模块与模块之间的依赖关系\n\n 2. 命名空间方式\n\n> 具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，\n> \n> 有点类似于为模块内的成员添加了「命名空间」的感觉。\n> \n> 通过「命名空间」减小了命名冲突的可能，\n> \n> 但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，\n> \n> 而且也无法管理模块之间的依赖关系。\n\n 3. iife：立即执行函数，实现了私有成员\n\n> 具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，\n> \n> 对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现\n> \n> 有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。\n\n// module a 相关状态数据和功能函数，iife\n\n;(function () {\n  var name = 'module-a'\n  \n  function method1 () {\n    console.log(name + '#method1')\n  }\n  \n  function method2 () {\n    console.log(name + '#method2')\n  }\n\n  window.modulea = {\n    method1: method1,\n    method2: method2\n  }\n})()\n\n\n\n 4. commonjs规范（node环境）\n\n * 一个文件就是一个模块\n * 每个模块都有单独的作用域\n * 通过module.exports导出成员\n * 通过require函数载入模块\n\n> 浏览器端不能使用，因为commonjs是以同步模式加载模块，每一次页面加载都会有大量模块请求\n\n 5. amd：asynchronous module definition （异步模块定义）\n\n> 同时期推出了require.js，实现了amd规范\n> \n> 目前绝大数第三方库都支持amd规范\n> \n> 但是amd使用起来比较复杂，模块js文件请求频繁\n\n 6. sea.js + cmd ：common module definition\n\n> 类似于commonjs的语法\n\n\n# es modules\n\n * commonjs in node.js（目前node8以上也支持es modules）\n * es modules in browsers（es6）\n\n\n# es modules 基本特性\n\n * 自动采用严格模式，忽略 'use strict'\n * 每个 es module 都是运行在单独的私有作用域中\n * esm 是通过 cors 的方式请求外部 js 模块的\n * esm 的 script 标签会延迟执行脚本\n\n  \x3c!-- 通过给 script 添加 type = module 的属性，就可以以 es module 的标准执行其中的 js 代码了 --\x3e\n  <script type=\"module\">\n    console.log('this is es module')\n  <\/script>\n\n  \x3c!-- 1. esm 自动采用严格模式，忽略 'use strict' --\x3e\n  <script type=\"module\">\n    console.log(this) // undefined\n  <\/script>\n\n  \x3c!-- 2. 每个 es module 都是运行在单独的私有作用域中 --\x3e\n  <script type=\"module\">\n    var foo = 100\n    console.log(foo)\n  <\/script>\n  <script type=\"module\">\n    console.log(foo)\n  <\/script>\n\n  \x3c!-- 3. esm 是通过 cors 的方式请求外部 js 模块的，需要服务器端的跨域支持，普通script不存在跨域 --\x3e\n  <script type=\"module\" src=\"https://unpkg.com/jquery@3.4.1/dist/jquery.min.js\"><\/script> \n\n  \x3c!-- 4. esm 的 script 标签会延迟执行脚本,此处会先执行p标签 --\x3e\n  <script defer src=\"demo.js\"><\/script>\n  <p>需要显示的内容</p> \n\n\n\n# es modules 的导入导出\n\n// app.js\nimport { default as fooname, foohello, person } from './module.js'\n\nimport height23 from './module.js' // 接收default\n\nconsole.log(fooname, foohello, person)\n\n// modeule.js\nvar name = 'foo module'\n\nvar height = 180\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass person {}\n\nexport { name as default, hello as foohello, person }\n\nexport default height\n\n// index.html\n<script type=\"module\" src=\"app.js\"><\/script>\n\n\n\n# 几点注意事项\n\nimport { name } from './module.js' // 不能省略.js\nimport { lowercase } from './utils/index.js' // 不能省略index.js，否则找不到\nimport { name } from './module.js' // 不能省略./，否则认为加载第三方模块\nimport './module.js' // 加载这个模块但是不提取\nimport * as mod from './module.js' // 提取所有放入mod对象中\n\n// 下面这两种方式不正确，不能动态条件导入\nvar modulepath = './module.js'\nimport { name } from modulepath\nconsole.log(name)\n\n if (true) {\n   import { name } from './module.js'\n }\n\n// 那怎么动态导入呢\n import('./module.js').then(function (module) {\n   console.log(module)\n })\n\n// 提取默认成员和正常成员\nimport abc, { name, age } from './module.js'\nconsole.log(name, age, abc)\n\n// 直接导出导入成员\n\n// button.js\nvar button = 'button component'\nexport default button\n\n// avatar.js\nexport var avatar = 'avatar component'\n\n// index.js\nexport { default as button } from './button.js'\nexport { avatar } from './avatar.js'\n\n// 第三方模块都是导出默认成员\nimport _ from 'lodash'\nimport { camelcase } from 'lodash' // 不正确\n\n\n\n# polyfill\n\nie浏览器不兼容es modules\n\npolyfill 是一块代码（通常是 web 上的 javascript），用来为旧浏览器提供它没有原生支持的较新的功能。\n\n> 例如，queryselectorall是很多现代浏览器都支持的原生web api，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.queryselectorall，使用方法跟现代浏览器原生api无异。那么这个库就可以称为polyfill或者polyfiller。\n> \n> jquery是不是一个polyfill?答案是no。因为它并不是实现一些标准的原生api，而是封装了自己api。一个polyfill是抹平新老浏览器 标准原生api 之间的差距的一种封装，而不是实现自己的api。\n> \n> 把旧的浏览器想象成为一面有了裂缝的墙.这些[polyfills]会帮助我们把这面墙的裂缝抹平,还我们一个更好的光滑的墙壁(浏览器)\n\n\n# es module与commonjs交互\n\n在node原生环境中\n\n * es modules中可以导入commonjs模块\n * commonjs中可以导入es modules模块\n * commonjs始终只会导出一个默认成员\n * 注意import不是解构对象\n\nes-module.mjs 文件名要改成.mjs\n\n// es module 中可以导入 commonjs 模块\n\nimport mod from './commonjs.js'\nconsole.log(mod)\n\n// 不能直接提取成员，注意 import 不是解构导出对象\n\nimport { foo } from './commonjs.js'\nconsole.log(foo)\n\nexport const foo = 'es module export value'\n\n\ncommonjs.js\n\n// commonjs 模块始终只会导出一个默认成员\n\nmodule.exports = {\n  foo: 'commonjs exports value'\n}\n\nexports.foo = 'commonjs exports value'\n\n// 不能在 commonjs 模块中通过 require 载入 es module\n\nconst mod = require('./es-module.mjs')\nconsole.log(mod)\n\n\n> 无论是require或者import，目前仍然需要通过babel或者traceur之类的转义工具将之转义为es5语法，才能在浏览器里运行。\n\n\n# import中的@\n\n> 这是webpack的路径别名，相关代码定义在配置文件webpack.base.config里：\n\n\tresolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n      'lib': resolve('src/lib'),\n      'style': resolve('src/style'),\n      'com': resolve('src/components'),\n      'serv': resolve('src/service'),\n      'api': resolve('src/api'),\n      'store': resolve('src/store')\n    }\n  },\n\n\n\n# 几个实际的例子\n\n某天在看代码时发现类似下面的写法：\n\n// a.ts\nexport default 123;\n\n\n// b.ts\nlet b = require('./a').default;\n\n\n对此我感到很疑惑，在我的记忆中，模块化无非就是两种：\n\n * es modules ：使用 import、export / export default 语法\n * commonjs：使用 require、module.exports / exports 语法\n\n那么代码中的 require('./a').default 中的 .default 是什么意思呢？将其编译成 js 文件再来看：\n\n// a.js\n\"use strict\";\nexports.__esmodule = true;\nexports[\"default\"] = 123;\n\n// b.js\nvar b = require('./a')[\"default\"];\n\n\n> 原来是经过 ts 编译后，es6 的 export default 都会被转换成 exports.default，即 commonjs 规范\n> \n> 转换的逻辑非常简单，即将输出赋值给 exports，并带上一个标志 __esmodule 表明这是个由 es6 转换来的 commonjs 输出。\n\n如果没有加上 .default ，则会得到整个对象：\n\n// a.ts\nexport default 123;\n\n// b.ts\nlet b = require('./a');\n\nconsole.log(b) // { __esmodule: true, default: 123 }\n\n\n> 总结：esm 语法经过 ts 或者 babel 转换后会变为 commonjs 语法，所以这也解释了为什么两个文件既可以用 esm 语法，也可以用 commonjs 语法，因为最后都会转换为 commonjs 语法。\n\n参考链接：https://juejin.cn/post/6844903520865386510#heading-3\n\n\n# .mjs 与 .cjs\n\n从 node.js v13.2 版本开始，node.js 已经默认打开了 es6 模块支持。\n\nnode.js 要求 es6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。node.js 遇到.mjs文件，就认为它是 es6 模块，默认启用严格模式，不必在每个模块文件顶部指定\"use strict\"。\n\n如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。\n\n{\n   \"type\": \"module\"\n}\n\n\n一旦设置了以后，该项目的 js 脚本，就被解释成 es6 模块。\n\n如果这时还要使用 commonjs 模块，那么需要将 commonjs 脚本的后缀名都改成.cjs。如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 commonjs 模块。\n\n总结为一句话：.mjs文件总是以 es6 模块加载，.cjs文件总是以 commonjs 模块加载，.js文件的加载取决于package.json里面type字段的设置。\n\n\n# es modules 与 common js 差异\n\n * commonjs 模块输出的是一个值的拷贝，es6 模块输出的是值的引用。\n * commonjs 模块是运行时加载，es6 模块是编译时输出接口。\n * commonjs 模块的require()是同步加载模块，es6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。",charsets:{cjk:!0}},{title:"webpack 模块化",frontmatter:{},regularPath:"/module/webpack.html",relativePath:"module/webpack.md",key:"v-7df093d7",path:"/module/webpack.html",headers:[{level:2,title:"commonjs",slug:"commonjs",normalizedTitle:"commonjs",charIndex:87},{level:3,title:"webpack_require",slug:"webpack-require",normalizedTitle:"webpack_require",charIndex:316},{level:2,title:"ES Module",slug:"es-module",normalizedTitle:"es module",charIndex:2365},{level:3,title:"webpackrequire_.r",slug:"webpack-require-r",normalizedTitle:"webpackrequire_.r",charIndex:null},{level:3,title:"webpackrequire_.d",slug:"webpack-require-d",normalizedTitle:"webpackrequire_.d",charIndex:null},{level:3,title:"webpackrequire_.o",slug:"webpack-require-o",normalizedTitle:"webpackrequire_.o",charIndex:null},{level:2,title:"CommonJS 和 ES Module 混用",slug:"commonjs-和-es-module-混用",normalizedTitle:"commonjs 和 es module 混用",charIndex:4861},{level:3,title:"webpackrequire_.n",slug:"webpack-require-n",normalizedTitle:"webpackrequire_.n",charIndex:null}],lastUpdated:"2/11/2022, 12:03:11 PM",lastUpdatedTimestamp:1644552191e3,headersStr:"commonjs webpack_require ES Module webpackrequire_.r webpackrequire_.d webpackrequire_.o CommonJS 和 ES Module 混用 webpackrequire_.n",content:'# webpack 模块化\n\nwebpack并不强制你使用某种模块化方案，你可以随意选择你喜欢的模块化方案，webpack 通过兼容所有模块化方案让你无痛接入项目。\n\n\n# commonjs\n\n// index.js\nconst a = require(\'./a\')\nconsole.log(a)\n\n// a.js\nconst a = \'a\';\nmodule.exports = a;\n\n\nWebpack 打包后：\n\n(function(modules) {\n\t// The module cache\n\tvar installedModules = {};\n\t// The require function\n\tfunction __webpack_require__(moduleId) {\n\t\t// Check if module is in cache\n\t\tif(installedModules[moduleId]) {\n\t\t\treturn installedModules[moduleId].exports;\n\t\t}\n\t\t// Create a new module (and put it into the cache)\n\t\tvar module = installedModules[moduleId] = {\n\t\t\ti: moduleId,\n\t\t\tl: false,\n\t\t\texports: {}\n\t\t};\n\t\t// Execute the module function\n\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t// Flag the module as loaded\n\t\tmodule.l = true;\n\t\t// Return the exports of the module\n\t\treturn module.exports;\n\t}\n\n\t// Load entry module and return exports\n\treturn __webpack_require__(__webpack_require__.s = "./src/index.js");\n})\n/************************************************************************/\n({\n\n "./src/a.js":\n  (function(module, __webpack_exports__, __webpack_require__) {\n    const a = \'a\';\n    module.exports = a;\n  }),\n\n  "./src/index.js":\n  (function(module, __webpack_exports__, __webpack_require__) {\n    const a = __webpack_require__("./src/a.js")\n    console.log(a)\n  })\n});\n\n\n其结构简化如下，整个打包生成的代码是一个IIFE(立即执行函数)，因为浏览器本身不支持模块化，那么webpack就用函数作用域来hack模块化的效果：\n\n(function(modules) {\n    // Runtime\n})([\n    // 各个模块\n])\n\n\n\n# webpack_require\n\n * __webpack_require__函数可以类比CommonJS的require，都是加载模块代码。和 NodeJS 的设计很类似，都是先从缓存取用，否则加载模块并放入缓存。\n * __webpack_require__所在的闭包能访问外层变量modules和缓存installedModules。这个很关键，因为modules是webpack打包后立即执行函数传入的参数。modules是一个object，key是string类型，value是function类型。\n\n// 1、模块缓存对象\nvar installedModules = {};\n// 2、webpack实现的require\nfunction __webpack_require__(moduleId) {\n    // 3、判断是否已缓存模块\n    if(installedModules[moduleId]) {\n        return installedModules[moduleId].exports;\n    }\n    // 4、缓存模块\n    var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n    };\n    // 5、调用模块函数\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    // 6、标记模块为已加载\n    module.l = true;\n    // 7、返回module.exports\n    return module.exports;\n}\n// 8、require第一个模块\nreturn __webpack_require__(__webpack_require__.s = "./src/index.js");\n\n\n\n# ES Module\n\n// index.js\nimport a, { test } from \'./a\'\nimport b from \'./b\'\nconsole.log(a);\ntest();\nconsole.log(b)\n\n// a.js\nconst a = \'a\';\nfunction test() { }\nexport default a;\nexport { test }\n\n// b.js\nconst b = \'b\';\nexport default b;\n\n\nWebpack 打包后：\n\n{\n    "./src/a.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, "test", function () { return test; });\n\n        const a = \'a\';\n\n        function test() { }\n\n        /* harmony default export */\n        __webpack_exports__["default"] = (a);\n    }),\n    "./src/b.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        const b = \'b\';\n\n        /* harmony default export */\n        __webpack_exports__["default"] = (b);\n\n    }),\n    "./src/index.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n        var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/a.js");\n        /* harmony import */\n        var _b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/b.js");\n\n        console.log(_a__WEBPACK_IMPORTED_MODULE_0__["default"])\n\n        Object(_a__WEBPACK_IMPORTED_MODULE_0__["test"])();\n\n        console.log(_b__WEBPACK_IMPORTED_MODULE_1__["default"])\n    })\n}\n\n\nes模块化，exports 对象首先就会被__webpack_require__.r标记为es module，对于默认导出就是 exports 的 default 属性，对于具名导出使用 __webpack_require__.d 包装了一下，目的是让这些具名导出在模块之外只能读不能被修改（这是es module的特点）。\n\n\n# webpack_require__.r\n\n该函数用于标识 es 模块的导出\n\n// define __esModule on exports\n__webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n        Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n    }\n    Object.defineProperty(exports, \'__esModule\', { value: true });\n};\n\n\n\n# webpack_require__.d\n\n用于处理es模块的具名导出\n\n// define getter function for harmony exports\n__webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n        Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n};\n\n\n\n# webpack_require__.o\n\n就是 hasOwnPreperty\n\n__webpack_require__.o = \n    function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n\n\n# CommonJS 和 ES Module 混用\n\n\n# webpack_require__.n\n\n__webpack_require__.n是用来处理 commonjs 与 esm 混用的问题，如：\n\n// m.js\nexports.foo = function () {\n    return 1;\n}\n\n// index.js\nimport m from \'./m\';\nm.foo();\n\n\n打包之后（只截取IIFE的参数部分）：\n\n[\n  /* 0 */\n  (function(module, __webpack_exports__, __webpack_require__) {\n\n      "use strict";\n      Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n      /* harmony import */ \n      var __WEBPACK_IMPORTED_MODULE_0__m__ = __webpack_require__(1);\n      /* harmony import */ \n      var __WEBPACK_IMPORTED_MODULE_0__m___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__m__);\n\n      __WEBPACK_IMPORTED_MODULE_0__m___default.a.foo();\n\n  }),\n  /* 1 */\n  (function(module, exports, __webpack_require__) {\n      "use strict";\n      exports.foo = function () {\n          return 1;\n      }\n  })\n]\n\n\n看一下__webpack_require__.n的定义：\n\n// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n    var getter = module && module.__esModule ?\n        function getDefault() { return module[\'default\']; } :\n        function getModuleExports() { return module; };\n    __webpack_require__.d(getter, \'a\', getter);\n    return getter;\n};\n\n\n__webpack_require__.n会判断module是否为es模块，当__esModule为true的时候，标识module为es模块，那么module.a默认返回module.default，否则返回module。',normalizedContent:'# webpack 模块化\n\nwebpack并不强制你使用某种模块化方案，你可以随意选择你喜欢的模块化方案，webpack 通过兼容所有模块化方案让你无痛接入项目。\n\n\n# commonjs\n\n// index.js\nconst a = require(\'./a\')\nconsole.log(a)\n\n// a.js\nconst a = \'a\';\nmodule.exports = a;\n\n\nwebpack 打包后：\n\n(function(modules) {\n\t// the module cache\n\tvar installedmodules = {};\n\t// the require function\n\tfunction __webpack_require__(moduleid) {\n\t\t// check if module is in cache\n\t\tif(installedmodules[moduleid]) {\n\t\t\treturn installedmodules[moduleid].exports;\n\t\t}\n\t\t// create a new module (and put it into the cache)\n\t\tvar module = installedmodules[moduleid] = {\n\t\t\ti: moduleid,\n\t\t\tl: false,\n\t\t\texports: {}\n\t\t};\n\t\t// execute the module function\n\t\tmodules[moduleid].call(module.exports, module, module.exports, __webpack_require__);\n\t\t// flag the module as loaded\n\t\tmodule.l = true;\n\t\t// return the exports of the module\n\t\treturn module.exports;\n\t}\n\n\t// load entry module and return exports\n\treturn __webpack_require__(__webpack_require__.s = "./src/index.js");\n})\n/************************************************************************/\n({\n\n "./src/a.js":\n  (function(module, __webpack_exports__, __webpack_require__) {\n    const a = \'a\';\n    module.exports = a;\n  }),\n\n  "./src/index.js":\n  (function(module, __webpack_exports__, __webpack_require__) {\n    const a = __webpack_require__("./src/a.js")\n    console.log(a)\n  })\n});\n\n\n其结构简化如下，整个打包生成的代码是一个iife(立即执行函数)，因为浏览器本身不支持模块化，那么webpack就用函数作用域来hack模块化的效果：\n\n(function(modules) {\n    // runtime\n})([\n    // 各个模块\n])\n\n\n\n# webpack_require\n\n * __webpack_require__函数可以类比commonjs的require，都是加载模块代码。和 nodejs 的设计很类似，都是先从缓存取用，否则加载模块并放入缓存。\n * __webpack_require__所在的闭包能访问外层变量modules和缓存installedmodules。这个很关键，因为modules是webpack打包后立即执行函数传入的参数。modules是一个object，key是string类型，value是function类型。\n\n// 1、模块缓存对象\nvar installedmodules = {};\n// 2、webpack实现的require\nfunction __webpack_require__(moduleid) {\n    // 3、判断是否已缓存模块\n    if(installedmodules[moduleid]) {\n        return installedmodules[moduleid].exports;\n    }\n    // 4、缓存模块\n    var module = installedmodules[moduleid] = {\n        i: moduleid,\n        l: false,\n        exports: {}\n    };\n    // 5、调用模块函数\n    modules[moduleid].call(module.exports, module, module.exports, __webpack_require__);\n    // 6、标记模块为已加载\n    module.l = true;\n    // 7、返回module.exports\n    return module.exports;\n}\n// 8、require第一个模块\nreturn __webpack_require__(__webpack_require__.s = "./src/index.js");\n\n\n\n# es module\n\n// index.js\nimport a, { test } from \'./a\'\nimport b from \'./b\'\nconsole.log(a);\ntest();\nconsole.log(b)\n\n// a.js\nconst a = \'a\';\nfunction test() { }\nexport default a;\nexport { test }\n\n// b.js\nconst b = \'b\';\nexport default b;\n\n\nwebpack 打包后：\n\n{\n    "./src/a.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n        __webpack_require__.d(__webpack_exports__, "test", function () { return test; });\n\n        const a = \'a\';\n\n        function test() { }\n\n        /* harmony default export */\n        __webpack_exports__["default"] = (a);\n    }),\n    "./src/b.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        const b = \'b\';\n\n        /* harmony default export */\n        __webpack_exports__["default"] = (b);\n\n    }),\n    "./src/index.js": (function (module, __webpack_exports__, __webpack_require__) {\n\n        "use strict";\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n        var _a__webpack_imported_module_0__ = __webpack_require__("./src/a.js");\n        /* harmony import */\n        var _b__webpack_imported_module_1__ = __webpack_require__("./src/b.js");\n\n        console.log(_a__webpack_imported_module_0__["default"])\n\n        object(_a__webpack_imported_module_0__["test"])();\n\n        console.log(_b__webpack_imported_module_1__["default"])\n    })\n}\n\n\nes模块化，exports 对象首先就会被__webpack_require__.r标记为es module，对于默认导出就是 exports 的 default 属性，对于具名导出使用 __webpack_require__.d 包装了一下，目的是让这些具名导出在模块之外只能读不能被修改（这是es module的特点）。\n\n\n# webpack_require__.r\n\n该函数用于标识 es 模块的导出\n\n// define __esmodule on exports\n__webpack_require__.r = function (exports) {\n    if (typeof symbol !== \'undefined\' && symbol.tostringtag) {\n        object.defineproperty(exports, symbol.tostringtag, { value: \'module\' });\n    }\n    object.defineproperty(exports, \'__esmodule\', { value: true });\n};\n\n\n\n# webpack_require__.d\n\n用于处理es模块的具名导出\n\n// define getter function for harmony exports\n__webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n        object.defineproperty(exports, name, { enumerable: true, get: getter });\n    }\n};\n\n\n\n# webpack_require__.o\n\n就是 hasownpreperty\n\n__webpack_require__.o = \n    function (object, property) { return object.prototype.hasownproperty.call(object, property); };\n\n\n\n# commonjs 和 es module 混用\n\n\n# webpack_require__.n\n\n__webpack_require__.n是用来处理 commonjs 与 esm 混用的问题，如：\n\n// m.js\nexports.foo = function () {\n    return 1;\n}\n\n// index.js\nimport m from \'./m\';\nm.foo();\n\n\n打包之后（只截取iife的参数部分）：\n\n[\n  /* 0 */\n  (function(module, __webpack_exports__, __webpack_require__) {\n\n      "use strict";\n      object.defineproperty(__webpack_exports__, "__esmodule", { value: true });\n      /* harmony import */ \n      var __webpack_imported_module_0__m__ = __webpack_require__(1);\n      /* harmony import */ \n      var __webpack_imported_module_0__m___default = __webpack_require__.n(__webpack_imported_module_0__m__);\n\n      __webpack_imported_module_0__m___default.a.foo();\n\n  }),\n  /* 1 */\n  (function(module, exports, __webpack_require__) {\n      "use strict";\n      exports.foo = function () {\n          return 1;\n      }\n  })\n]\n\n\n看一下__webpack_require__.n的定义：\n\n// getdefaultexport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n    var getter = module && module.__esmodule ?\n        function getdefault() { return module[\'default\']; } :\n        function getmoduleexports() { return module; };\n    __webpack_require__.d(getter, \'a\', getter);\n    return getter;\n};\n\n\n__webpack_require__.n会判断module是否为es模块，当__esmodule为true的时候，标识module为es模块，那么module.a默认返回module.default，否则返回module。',charsets:{cjk:!0}},{title:"微前端",frontmatter:{},regularPath:"/micro/micro.html",relativePath:"micro/micro.md",key:"v-e6f13c42",path:"/micro/micro.html",headers:[{level:2,title:"一、核心优点",slug:"一、核心优点",normalizedTitle:"一、核心优点",charIndex:121},{level:3,title:"1. 技术栈解耦，独立开发与部署",slug:"_1-技术栈解耦-独立开发与部署",normalizedTitle:"1. 技术栈解耦，独立开发与部署",charIndex:132},{level:3,title:"2. 规模化团队的协作效率提升",slug:"_2-规模化团队的协作效率提升",normalizedTitle:"2. 规模化团队的协作效率提升",charIndex:357},{level:3,title:"3. 故障隔离与弹性恢复",slug:"_3-故障隔离与弹性恢复",normalizedTitle:"3. 故障隔离与弹性恢复",charIndex:533},{level:3,title:"4. 按需加载与性能优化",slug:"_4-按需加载与性能优化",normalizedTitle:"4. 按需加载与性能优化",charIndex:686},{level:3,title:"5. 支持多端复用与混合渲染",slug:"_5-支持多端复用与混合渲染",normalizedTitle:"5. 支持多端复用与混合渲染",charIndex:857},{level:2,title:"二、核心缺点",slug:"二、核心缺点",normalizedTitle:"二、核心缺点",charIndex:1054},{level:3,title:"1. 集成复杂度高，运维成本增加",slug:"_1-集成复杂度高-运维成本增加",normalizedTitle:"1. 集成复杂度高，运维成本增加",charIndex:1065},{level:3,title:"2. 性能开销与重复渲染",slug:"_2-性能开销与重复渲染",normalizedTitle:"2. 性能开销与重复渲染",charIndex:1281},{level:3,title:"3. 测试与调试难度上升",slug:"_3-测试与调试难度上升",normalizedTitle:"3. 测试与调试难度上升",charIndex:1478},{level:3,title:"4. 版本兼容性与依赖冲突",slug:"_4-版本兼容性与依赖冲突",normalizedTitle:"4. 版本兼容性与依赖冲突",charIndex:1619},{level:3,title:"5. SEO与首屏体验挑战",slug:"_5-seo与首屏体验挑战",normalizedTitle:"5. seo与首屏体验挑战",charIndex:1811},{level:2,title:"三、适用场景与不适用场景",slug:"三、适用场景与不适用场景",normalizedTitle:"三、适用场景与不适用场景",charIndex:1971},{level:3,title:"适合微前端的场景",slug:"适合微前端的场景",normalizedTitle:"适合微前端的场景",charIndex:1988},{level:3,title:"不适合微前端的场景",slug:"不适合微前端的场景",normalizedTitle:"不适合微前端的场景",charIndex:2147},{level:2,title:"四、主流实现方案对比",slug:"四、主流实现方案对比",normalizedTitle:"四、主流实现方案对比",charIndex:2260},{level:2,title:"五、总结与建议",slug:"五、总结与建议",normalizedTitle:"五、总结与建议",charIndex:2616}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"一、核心优点 1. 技术栈解耦，独立开发与部署 2. 规模化团队的协作效率提升 3. 故障隔离与弹性恢复 4. 按需加载与性能优化 5. 支持多端复用与混合渲染 二、核心缺点 1. 集成复杂度高，运维成本增加 2. 性能开销与重复渲染 3. 测试与调试难度上升 4. 版本兼容性与依赖冲突 5. SEO与首屏体验挑战 三、适用场景与不适用场景 适合微前端的场景 不适合微前端的场景 四、主流实现方案对比 五、总结与建议",content:"# 微前端\n\n微前端（Micro Frontends）是一种将前端应用拆分为多个独立子应用（或模块）的架构模式，每个子应用可以独立开发、部署和运行，最终通过主应用（或容器）整合为一个完整系统。以下是其核心优缺点及适用场景的详细分析：\n\n\n# 一、核心优点\n\n\n# 1. 技术栈解耦，独立开发与部署\n\n * 场景：团队A使用React，团队B使用Vue，团队C使用Angular。\n * 优势\n   * 各团队可自主选择技术栈，无需强制统一。\n   * 子应用独立开发、测试、部署，互不影响（如修改一个按钮不影响其他模块）。\n   * 部署频率差异大的场景（如营销页面需频繁更新，后台管理稳定）可并行迭代。\n * 案例：Airbnb将不同业务（如租房、体验、支付）拆分为独立子应用，各团队自主管理生命周期。\n\n\n# 2. 规模化团队的协作效率提升\n\n * 场景：大型企业（如银行、电商平台）有数十个前端团队。\n * 优势\n   * 避免“单应用过胖”导致的代码冲突、构建缓慢、测试复杂等问题。\n   * 明确子应用边界，减少跨团队沟通成本（如“订单模块”由订单团队全权负责）。\n   * 支持渐进式重构（如将老旧JQuery页面逐步迁移为React子应用）。\n\n\n# 3. 故障隔离与弹性恢复\n\n * 场景：某个子应用崩溃（如支付模块内存泄漏）。\n * 优势\n   * 错误不会扩散到其他子应用（通过沙箱隔离或独立进程）。\n   * 主应用可监控子应用状态，自动降级或重试（如显示“支付服务暂时不可用”）。\n * 对比：单体应用中一个组件崩溃可能导致整个页面白屏。\n\n\n# 4. 按需加载与性能优化\n\n * 场景：用户仅访问“商品列表”页面，无需加载“订单管理”代码。\n * 优势\n   * 子应用可动态加载（如通过路由或用户权限触发），减少首屏体积。\n   * 结合代码拆分（Code Splitting）和预加载（Prefetch），优化性能。\n * 数据：某电商采用微前端后，首屏加载时间减少40%。\n\n\n# 5. 支持多端复用与混合渲染\n\n * 场景：同一子应用需在Web、移动端H5、小程序中复用。\n * 优势\n   * 子应用可封装为独立组件，通过适配层适配不同平台（如React子应用通过Taro适配小程序）。\n   * 支持服务端渲染（SSR）与客户端渲染（CSR）混合（如首屏SSR，交互CSR）。\n\n----------------------------------------\n\n\n# 二、核心缺点\n\n\n# 1. 集成复杂度高，运维成本增加\n\n * 问题\n   * 通信机制：子应用间需通过事件总线、状态管理（如Redux）或URL参数通信，易引发混乱。\n   * 样式隔离：全局CSS可能冲突（需使用CSS Modules、Shadow DOM或命名空间）。\n   * 公共依赖：React/Vue等库可能重复加载（需通过externals或CDN共享）。\n * 案例：某团队因未隔离样式，导致子应用A的按钮样式覆盖了子应用B。\n\n\n# 2. 性能开销与重复渲染\n\n * 问题\n   * 沙箱隔离：若使用iframe或Proxy实现沙箱，可能增加内存占用和通信延迟。\n   * 重复渲染：主应用和子应用可能同时操作DOM（如路由切换时需协调生命周期）。\n * 优化方案\n   * 使用React的Portal或Vue的Teleport减少DOM层级。\n   * 通过React.lazy或动态import()实现按需加载。\n\n\n# 3. 测试与调试难度上升\n\n * 问题\n   * 端到端测试：需模拟子应用加载顺序和状态（如A子应用未加载时B子应用不可用）。\n   * 错误追踪：跨子应用的错误可能被隐藏（需统一日志收集和监控）。\n * 工具：使用Sentry、Playwright等工具实现跨应用监控。\n\n\n# 4. 版本兼容性与依赖冲突\n\n * 问题\n   * 子应用A依赖React 16，子应用B依赖React 18，可能导致运行时错误。\n   * 公共库（如Lodash）版本不一致可能引发行为差异。\n * 解决方案\n   * 强制统一公共依赖版本（通过peerDependencies或Monorepo管理）。\n   * 使用externals将公共库托管到CDN或全局变量。\n\n\n# 5. SEO与首屏体验挑战\n\n * 问题：\n   * 动态加载子应用可能导致搜索引擎爬虫无法抓取完整内容。\n   * 首屏需等待所有子应用加载完成（若未优化）。\n * 优化方案：\n   * 服务端渲染（SSR）主应用框架，客户端动态激活子应用。\n   * 使用预渲染（Prerender）生成静态HTML快照。\n\n\n# 三、适用场景与不适用场景\n\n\n# 适合微前端的场景\n\n 1. 大型企业应用：团队规模大、业务复杂度高（如银行、电商平台）。\n 2. 遗留系统重构：需逐步迁移老旧代码（如从JQuery迁移到React）。\n 3. 多技术栈共存：团队技术偏好差异大（如React vs Vue）。\n 4. 独立部署需求：子应用需独立发布（如营销活动需快速迭代）。\n\n\n# 不适合微前端的场景\n\n 1. 小型团队或简单应用：沟通成本可能超过架构收益。\n 2. 强一致性需求：如需要原子化更新（所有模块必须同时发布）。\n 3. 性能敏感型应用：如实时交易系统（微前端的通信延迟可能影响体验）。\n\n\n# 四、主流实现方案对比\n\n方案               代表工具        优点               缺点\n路由分发             单页应用+路由配置   简单易实现，无需复杂框架     集成度低，子应用强耦合主应用\niframe           浏览器原生       天然隔离，技术栈无关       性能差，通信困难\nWeb Components   原生API       标准兼容，样式隔离好       生态弱，需适配现代框架\n模块联邦             Webpack 5   代码共享，动态加载        配置复杂，依赖Webpack 5+\nSingle-SPA       社区方案        框架无关，支持多种子应用类型   学习曲线陡峭\n\n\n# 五、总结与建议\n\n * 优先选择：若团队规模大、业务复杂度高，且能接受一定集成成本，微前端能显著提升协作效率和可维护性。\n * 谨慎选择：小型团队或简单应用建议采用单体架构，避免过度设计。\n * 关键实践\n   1. 明确子应用边界（如按业务域划分）。\n   2. 统一通信协议（如发布-订阅模式）。\n   3. 使用Monorepo管理公共依赖和工具库。\n   4. 结合CI/CD实现自动化测试和部署。\n\n微前端不是“银弹”，但合理使用可解决大型前端项目的协作和扩展难题。",normalizedContent:"# 微前端\n\n微前端（micro frontends）是一种将前端应用拆分为多个独立子应用（或模块）的架构模式，每个子应用可以独立开发、部署和运行，最终通过主应用（或容器）整合为一个完整系统。以下是其核心优缺点及适用场景的详细分析：\n\n\n# 一、核心优点\n\n\n# 1. 技术栈解耦，独立开发与部署\n\n * 场景：团队a使用react，团队b使用vue，团队c使用angular。\n * 优势\n   * 各团队可自主选择技术栈，无需强制统一。\n   * 子应用独立开发、测试、部署，互不影响（如修改一个按钮不影响其他模块）。\n   * 部署频率差异大的场景（如营销页面需频繁更新，后台管理稳定）可并行迭代。\n * 案例：airbnb将不同业务（如租房、体验、支付）拆分为独立子应用，各团队自主管理生命周期。\n\n\n# 2. 规模化团队的协作效率提升\n\n * 场景：大型企业（如银行、电商平台）有数十个前端团队。\n * 优势\n   * 避免“单应用过胖”导致的代码冲突、构建缓慢、测试复杂等问题。\n   * 明确子应用边界，减少跨团队沟通成本（如“订单模块”由订单团队全权负责）。\n   * 支持渐进式重构（如将老旧jquery页面逐步迁移为react子应用）。\n\n\n# 3. 故障隔离与弹性恢复\n\n * 场景：某个子应用崩溃（如支付模块内存泄漏）。\n * 优势\n   * 错误不会扩散到其他子应用（通过沙箱隔离或独立进程）。\n   * 主应用可监控子应用状态，自动降级或重试（如显示“支付服务暂时不可用”）。\n * 对比：单体应用中一个组件崩溃可能导致整个页面白屏。\n\n\n# 4. 按需加载与性能优化\n\n * 场景：用户仅访问“商品列表”页面，无需加载“订单管理”代码。\n * 优势\n   * 子应用可动态加载（如通过路由或用户权限触发），减少首屏体积。\n   * 结合代码拆分（code splitting）和预加载（prefetch），优化性能。\n * 数据：某电商采用微前端后，首屏加载时间减少40%。\n\n\n# 5. 支持多端复用与混合渲染\n\n * 场景：同一子应用需在web、移动端h5、小程序中复用。\n * 优势\n   * 子应用可封装为独立组件，通过适配层适配不同平台（如react子应用通过taro适配小程序）。\n   * 支持服务端渲染（ssr）与客户端渲染（csr）混合（如首屏ssr，交互csr）。\n\n----------------------------------------\n\n\n# 二、核心缺点\n\n\n# 1. 集成复杂度高，运维成本增加\n\n * 问题\n   * 通信机制：子应用间需通过事件总线、状态管理（如redux）或url参数通信，易引发混乱。\n   * 样式隔离：全局css可能冲突（需使用css modules、shadow dom或命名空间）。\n   * 公共依赖：react/vue等库可能重复加载（需通过externals或cdn共享）。\n * 案例：某团队因未隔离样式，导致子应用a的按钮样式覆盖了子应用b。\n\n\n# 2. 性能开销与重复渲染\n\n * 问题\n   * 沙箱隔离：若使用iframe或proxy实现沙箱，可能增加内存占用和通信延迟。\n   * 重复渲染：主应用和子应用可能同时操作dom（如路由切换时需协调生命周期）。\n * 优化方案\n   * 使用react的portal或vue的teleport减少dom层级。\n   * 通过react.lazy或动态import()实现按需加载。\n\n\n# 3. 测试与调试难度上升\n\n * 问题\n   * 端到端测试：需模拟子应用加载顺序和状态（如a子应用未加载时b子应用不可用）。\n   * 错误追踪：跨子应用的错误可能被隐藏（需统一日志收集和监控）。\n * 工具：使用sentry、playwright等工具实现跨应用监控。\n\n\n# 4. 版本兼容性与依赖冲突\n\n * 问题\n   * 子应用a依赖react 16，子应用b依赖react 18，可能导致运行时错误。\n   * 公共库（如lodash）版本不一致可能引发行为差异。\n * 解决方案\n   * 强制统一公共依赖版本（通过peerdependencies或monorepo管理）。\n   * 使用externals将公共库托管到cdn或全局变量。\n\n\n# 5. seo与首屏体验挑战\n\n * 问题：\n   * 动态加载子应用可能导致搜索引擎爬虫无法抓取完整内容。\n   * 首屏需等待所有子应用加载完成（若未优化）。\n * 优化方案：\n   * 服务端渲染（ssr）主应用框架，客户端动态激活子应用。\n   * 使用预渲染（prerender）生成静态html快照。\n\n\n# 三、适用场景与不适用场景\n\n\n# 适合微前端的场景\n\n 1. 大型企业应用：团队规模大、业务复杂度高（如银行、电商平台）。\n 2. 遗留系统重构：需逐步迁移老旧代码（如从jquery迁移到react）。\n 3. 多技术栈共存：团队技术偏好差异大（如react vs vue）。\n 4. 独立部署需求：子应用需独立发布（如营销活动需快速迭代）。\n\n\n# 不适合微前端的场景\n\n 1. 小型团队或简单应用：沟通成本可能超过架构收益。\n 2. 强一致性需求：如需要原子化更新（所有模块必须同时发布）。\n 3. 性能敏感型应用：如实时交易系统（微前端的通信延迟可能影响体验）。\n\n\n# 四、主流实现方案对比\n\n方案               代表工具        优点               缺点\n路由分发             单页应用+路由配置   简单易实现，无需复杂框架     集成度低，子应用强耦合主应用\niframe           浏览器原生       天然隔离，技术栈无关       性能差，通信困难\nweb components   原生api       标准兼容，样式隔离好       生态弱，需适配现代框架\n模块联邦             webpack 5   代码共享，动态加载        配置复杂，依赖webpack 5+\nsingle-spa       社区方案        框架无关，支持多种子应用类型   学习曲线陡峭\n\n\n# 五、总结与建议\n\n * 优先选择：若团队规模大、业务复杂度高，且能接受一定集成成本，微前端能显著提升协作效率和可维护性。\n * 谨慎选择：小型团队或简单应用建议采用单体架构，避免过度设计。\n * 关键实践\n   1. 明确子应用边界（如按业务域划分）。\n   2. 统一通信协议（如发布-订阅模式）。\n   3. 使用monorepo管理公共依赖和工具库。\n   4. 结合ci/cd实现自动化测试和部署。\n\n微前端不是“银弹”，但合理使用可解决大型前端项目的协作和扩展难题。",charsets:{cjk:!0}},{title:"express",frontmatter:{},regularPath:"/node/express.html",relativePath:"node/express.md",key:"v-2fabc2e5",path:"/node/express.html",headers:[{level:2,title:"中间件",slug:"中间件",normalizedTitle:"中间件",charIndex:477},{level:3,title:"应用程序级别中间件",slug:"应用程序级别中间件",normalizedTitle:"应用程序级别中间件",charIndex:869},{level:3,title:"路由级别中间件",slug:"路由级别中间件",normalizedTitle:"路由级别中间件",charIndex:1265}],lastUpdated:"3/29/2022, 12:21:20 PM",lastUpdatedTimestamp:164852768e4,headersStr:"中间件 应用程序级别中间件 路由级别中间件",content:"# express\n\nExpress 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。\n\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n\n\n应用程序会启动服务器，并在端口 3000 上侦听连接。此应用程序以“Hello World!”响应针对根 URL (/) 或路由的请求。对于其他所有路径，它将以 404 Not Found 进行响应。\n\n使用以下命令运行应用程序：\n\n$ node app.js\n\n\n然后，在浏览器中输入 http://localhost:3000/ 以查看输出。\n\n\n# 中间件\n\n中间件就是一个请求处理方法，用其把用户从请求到响应的整个过程分发到多个中间件去处理，这样做的目的是提高代码的灵活性，动态可扩展的。简单的理解就是：将收到的请求进行逐层过滤。\n\nvar express = require('express');\nvar app = express();\n\n// 中间件函数 myLogger\nvar myLogger = function (req, res, next) {\n  console.log('LOGGED');\n  next();\n};\n\napp.use(myLogger);\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\napp.listen(3000);\n\n\n应用程序每次收到请求时，会在终端上显示消息“LOGGED”。\n\n\n# 应用程序级别中间件\n\n 1. 全匹配（不关心任何请求路径和请求方法，当用户请求的时候如果分发到该中间件则直接进行处理请求操作）\n\napp.use(function(req, res, next) {\n  console.log('全匹配');\n  next();\n})\n\n\n当请求经过这个中间件的时候，不关心请求路径和方法，直接进入该中间件进行处理。其中next是一个方法，用于调用下一个符合条件的中间件。如果不写next，则会在当前中间件停留下来，不会再去匹配其他中间件。\n\n 2. 路径以/xx/开头的匹配（模糊匹配）\n\napp.use('/a', function(req, res, next) {\n  console.log('/a');\n  next();\n})\n\n\n只有以/a/开头的路径才可以匹配成功并处理，比如：/a/b是可以匹配成功的，但是/ab/b不能匹配成功\n\n\n# 路由级别中间件\n\n必须与请求路径和请求方法一致才匹配成功（精确匹配）\n\napp.get('/a', function(req, res, next) {\n  console.log('/a');\n  next();\n})\n",normalizedContent:"# express\n\nexpress 是一种保持最低程度规模的灵活 node.js web 应用程序框架，为 web 和移动应用程序提供一组强大的功能。\n\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) => {\n  res.send('hello world!')\n})\n\napp.listen(port, () => {\n  console.log(`example app listening on port ${port}`)\n})\n\n\n应用程序会启动服务器，并在端口 3000 上侦听连接。此应用程序以“hello world!”响应针对根 url (/) 或路由的请求。对于其他所有路径，它将以 404 not found 进行响应。\n\n使用以下命令运行应用程序：\n\n$ node app.js\n\n\n然后，在浏览器中输入 http://localhost:3000/ 以查看输出。\n\n\n# 中间件\n\n中间件就是一个请求处理方法，用其把用户从请求到响应的整个过程分发到多个中间件去处理，这样做的目的是提高代码的灵活性，动态可扩展的。简单的理解就是：将收到的请求进行逐层过滤。\n\nvar express = require('express');\nvar app = express();\n\n// 中间件函数 mylogger\nvar mylogger = function (req, res, next) {\n  console.log('logged');\n  next();\n};\n\napp.use(mylogger);\n\napp.get('/', function (req, res) {\n  res.send('hello world!');\n});\n\napp.listen(3000);\n\n\n应用程序每次收到请求时，会在终端上显示消息“logged”。\n\n\n# 应用程序级别中间件\n\n 1. 全匹配（不关心任何请求路径和请求方法，当用户请求的时候如果分发到该中间件则直接进行处理请求操作）\n\napp.use(function(req, res, next) {\n  console.log('全匹配');\n  next();\n})\n\n\n当请求经过这个中间件的时候，不关心请求路径和方法，直接进入该中间件进行处理。其中next是一个方法，用于调用下一个符合条件的中间件。如果不写next，则会在当前中间件停留下来，不会再去匹配其他中间件。\n\n 2. 路径以/xx/开头的匹配（模糊匹配）\n\napp.use('/a', function(req, res, next) {\n  console.log('/a');\n  next();\n})\n\n\n只有以/a/开头的路径才可以匹配成功并处理，比如：/a/b是可以匹配成功的，但是/ab/b不能匹配成功\n\n\n# 路由级别中间件\n\n必须与请求路径和请求方法一致才匹配成功（精确匹配）\n\napp.get('/a', function(req, res, next) {\n  console.log('/a');\n  next();\n})\n",charsets:{cjk:!0}},{title:"初识Node.js",frontmatter:{title:"初识Node.js",date:"2019-05-02T16:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-1.html",relativePath:"node/node-1.md",key:"v-92095dc2",path:"/node/node-1.html",headers:[{level:2,title:"1.Node.js的特点与优势",slug:"_1-node-js的特点与优势",normalizedTitle:"1.node.js的特点与优势",charIndex:351},{level:2,title:"2.第一个Node.js的web程序",slug:"_2-第一个node-js的web程序",normalizedTitle:"2.第一个node.js的web程序",charIndex:628},{level:2,title:"3.REPL运行环境（Read-Eval-Print-Loop）",slug:"_3-repl运行环境-read-eval-print-loop",normalizedTitle:"3.repl运行环境（read-eval-print-loop）",charIndex:893},{level:2,title:"4.global对象和模块作用域",slug:"_4-global对象和模块作用域",normalizedTitle:"4.global对象和模块作用域",charIndex:1009},{level:3,title:"4.1 require(),exports,module.exports",slug:"_4-1-require-exports-module-exports",normalizedTitle:"4.1 require(),exports,module.exports",charIndex:1193},{level:3,title:"4.2 exports和module.exports的区别",slug:"_4-2-exports和module-exports的区别",normalizedTitle:"4.2 exports和module.exports的区别",charIndex:1681},{level:2,title:"5.全局可用变量，函数和对象",slug:"_5-全局可用变量-函数和对象",normalizedTitle:"5.全局可用变量，函数和对象",charIndex:2265},{level:3,title:"5.1 dirname和 filename变量",slug:"_5-1-dirname和-filename变量",normalizedTitle:"5.1 dirname和 filename变量",charIndex:null},{level:3,title:"5.2 全局函数",slug:"_5-2-全局函数",normalizedTitle:"5.2 全局函数",charIndex:2607},{level:3,title:"5.3 console对象",slug:"_5-3-console对象",normalizedTitle:"5.3 console对象",charIndex:2810},{level:2,title:"6 重写计算器模块",slug:"_6-重写计算器模块",normalizedTitle:"6 重写计算器模块",charIndex:3064},{level:2,title:"7. require()的模块加载规则",slug:"_7-require-的模块加载规则",normalizedTitle:"7. require()的模块加载规则",charIndex:3373},{level:2,title:"8. 模块的缓存",slug:"_8-模块的缓存",normalizedTitle:"8. 模块的缓存",charIndex:3700}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"1.Node.js的特点与优势 2.第一个Node.js的web程序 3.REPL运行环境（Read-Eval-Print-Loop） 4.global对象和模块作用域 4.1 require(),exports,module.exports 4.2 exports和module.exports的区别 5.全局可用变量，函数和对象 5.1 dirname和 filename变量 5.2 全局函数 5.3 console对象 6 重写计算器模块 7. require()的模块加载规则 8. 模块的缓存",content:"JavaScript在客户端与服务端实现的功能不同，区别具体如下：\n\n在客户端，JavaScript需要依赖浏览器提供的JavaScript引擎解析执行，浏览器提供了对DOM的解析，客户端不仅要应用语法，而且要会操作DOM和BOM。\n\n在服务器端，JavaScript不依赖浏览器，而是由特定的运行环境提供的JavaScript引擎解析执行，例如Node.js，只需应用语法，不需要操作DOM和BOM。\n\nJavaScript包括ECMAScript,DOM,BOM三个部分，具体如下：\n\n 1. ECMAScript是JavaScript的核心语法\n 2. DOM是HTML和XML的应用程序接口，用于控制文档的内容和结构。\n 3. BOM（浏览器对象模型）可以对浏览器窗口进行访问和操作。\n\n\n# 1.Node.js的特点与优势\n\n * 它是一个JavaScript运行环境，前后端语言一致。\n * 依赖于Chrome v8引擎进行代码解析，这个引擎负责在非浏览器解析情况下解析代码\n * 事件驱动（Event-Driven）\n * 非阻塞I/O：服务器端会设计阻塞I/O的操作，Node.js使用事件回调的方式实现非阻塞I/O\n * 轻量，可伸缩，适于实时数据交互应用\n * 单进程，单线程：阻塞I/O一个线程只能处理一个任务，非阻塞I/O一个线程永远在处理任务，Node.js采用 单线程，利用事件驱动的异步编程模式，实现了非阻塞I/O。\n\n\n# 2.第一个Node.js的web程序\n\n命令行运行node demo.js,demo.js如下，打开浏览器输入127.0.0.1:3000,输出hello world\n\n//加载http模块\nvar http = require('http');\n//创建http服务器\nhttp.createServer(function(req,res){\n\t//响应结束\n\tres.end('hello world');\n\t//监听网址127.0.0.1 端口号3000\n}).listen(3000,'127.0.0.1');\n\n\n\n# 3.REPL运行环境（Read-Eval-Print-Loop）\n\n打开终端，输入node即可进入REPL运行环境，可以解析JS代码，执行变量和函数的相关操作。\n\n其实Chrome中的Console控制台就是REPL环境。\n\n\n# 4.global对象和模块作用域\n\n在Node.js中，默认声明的变量，函数都是属于当前文件模块，都是私有的，只有在当前模块作用域内可以使用，如果想在全局范围内为某个变量赋值，可以应用 全局对象global.\n\nvar foo = 'bar';\nglobal.foo = foo;\nconsole.log('global:foo'+global.foo);\n\n\n\n# 4.1 require(),exports,module.exports\n\n在一个文件模块中直接给某个全局变量赋值，显得很突兀，可能会污染命名空间，造成耦合的问题，为了解决上述问题，exports是模块公开的接口，require()用于从外部获取一个模块的接口。\n\ninfo.js:\n\n//向外开放变量name\nexports.name = 'itcast';\n//向外开放变量age\nmodule.exports.age = '10';\n//向外开放函数\nmodule.exports.sayHello = function(){\n    console.log('hello');\n}\n\n\ndemo.js\n\n//加载模块\nlet myModule = require('./info');\nconsole.log(myModule);\n//输出模块中的变量值\nconsole.log('name:'+myModule.name);\nconsole.log('age:'+myModule.age);\n//调用模块的方法\nmyModule.sayHello();\n\n\n\n# 4.2 exports和module.exports的区别\n\nexports是一个指向module.exports的引用，module.exports初始值为一个空对象{}，所以exports初始值也是{}，虽然exports和module.exports都可以向模块外开放变量和函数，但是使用上，module.exports可以单独定义，返回数据类型，而exports只能返回一个object对象。\n\n例如：\n\ntest.js\n\n//定义一个数组\nmodule.exports=['name','type','age'];\n\n\ndemo2-5.js\n\n//加载模块\nlet myModule = require('./test');\nconsole.log(myModule);\n//输出数组长度\nconsole.log('length:'+myModule.length); \n\n//输出 结果\n//[ 'name', 'type', 'age' ]\n//length:3\n\n\n修改test.js中的代码\n\nexports=['name','type','age'];\n\n//最后输出\n//{}\n//length:undefined\n\n\n可见使用exports直接定义数据，会切断exports与module.exports的联系，出现了找不到值的情况。\n\n\n# 5.全局可用变量，函数和对象\n\n即不需要进行模块加载，可以直接使用的，例如require()函数。\n\n\n# 5.1 _dirname和 _filename变量\n\n * _dirname表示当前文件所在的目录\n * _filename表示当前正在执行的脚本的文件名。（绝对路径）\n\nconsole.log('文件的目录是：'+__dirname);\nconsole.log('文件的绝对路径是：'+__filename);\n//输出\n//文件的目录是：C:\\Users\\Jin\\Desktop\\前端学习\\Node.js\\chapter 02\n//文件的绝对路径是：C:\\Users\\Jin\\Desktop\\前端学习\\Node.js\\chapter 02\\demo2-6.js\n\n\n\n# 5.2 全局函数\n\n * setTimeout(cb,ms)：ms后执行cb\n * clearTimeout()\n * setInterval(cb,ms)：每ms后执行cb\n * clearInterval()\n * setImmediate(cb)：延迟调用cb函数，cb将在I/O事件回调之后，setTimeout和setInterval回调之前调用\n * clearImmediate()\n\n\n# 5.3 console对象\n\nconsole是一个全局对象，除了console.log()函数外还提供了其他函数\n\n * console.info\n * console.error\n * console.warn\n * console.dir：用来对一个对象进行检查，以易于阅读和打印的格式显示\n * console.time和console.timeEnd\n * console.trace：当前执行代码在堆栈中的调用路径\n * console.assert：判断某个表达式或变量是否为真（断言）\n\n\n# 6 重写计算器模块\n\n以add.js为例，定义加减乘除模块\n\nmodule.exports = function(x,y){\n\treturn parseInt(x)+parseInt(y);\n}\n\n\nindex.js：分别使用require加载4个功能模块，并使用exports向外开放这4个接口\n\nmodule.exports = {\n    add:require('./add');\n    //sub\n    //mul\n    //divide\n}\n\n\ntestCal.js\n\nvar cal = require('./index');\nconsole.log(cal.add(1,2));//3\n\n\n\n# 7. require()的模块加载规则\n\n主要分为两类：文件模块和核心模块\n\n 1. 文件模块\n\nrequire('路径.扩展名');\nrequire('/example.js');//当前目录\nrequire('./example.js');\nrequire('../example.js');//上一目录\n\n\n 2. 核心模块\n\n核心模块包含了基本的API，保存在node.js源码的lib文件下，例如\n\n * 全局对象\n * 常用工具\n * 事件机制\n * 文件系统访问\n * HTTP服务器与客户端\n\nrequire('模块标识');\nconst os = require('os');\nconsole.log(os.cpus());\n\n\n\n# 8. 模块的缓存\n\n多次使用同一模块，Node.js只会加载一次，模块被缓存在require.cache中\n\nfoo.js:\n\nconsole.log('foo模块被加载了');\n\n\ntest.js:\n\nrequire('./foo');\nrequire('./foo');\nrequire('./foo');\nrequire('./foo');\n//只输出一次 foo模块被加载了，说明只加载了一次\n\n\n在foo.js加入\n\ndelete require.cache[module.filename];\n//删除缓存后输出4次\n",normalizedContent:"javascript在客户端与服务端实现的功能不同，区别具体如下：\n\n在客户端，javascript需要依赖浏览器提供的javascript引擎解析执行，浏览器提供了对dom的解析，客户端不仅要应用语法，而且要会操作dom和bom。\n\n在服务器端，javascript不依赖浏览器，而是由特定的运行环境提供的javascript引擎解析执行，例如node.js，只需应用语法，不需要操作dom和bom。\n\njavascript包括ecmascript,dom,bom三个部分，具体如下：\n\n 1. ecmascript是javascript的核心语法\n 2. dom是html和xml的应用程序接口，用于控制文档的内容和结构。\n 3. bom（浏览器对象模型）可以对浏览器窗口进行访问和操作。\n\n\n# 1.node.js的特点与优势\n\n * 它是一个javascript运行环境，前后端语言一致。\n * 依赖于chrome v8引擎进行代码解析，这个引擎负责在非浏览器解析情况下解析代码\n * 事件驱动（event-driven）\n * 非阻塞i/o：服务器端会设计阻塞i/o的操作，node.js使用事件回调的方式实现非阻塞i/o\n * 轻量，可伸缩，适于实时数据交互应用\n * 单进程，单线程：阻塞i/o一个线程只能处理一个任务，非阻塞i/o一个线程永远在处理任务，node.js采用 单线程，利用事件驱动的异步编程模式，实现了非阻塞i/o。\n\n\n# 2.第一个node.js的web程序\n\n命令行运行node demo.js,demo.js如下，打开浏览器输入127.0.0.1:3000,输出hello world\n\n//加载http模块\nvar http = require('http');\n//创建http服务器\nhttp.createserver(function(req,res){\n\t//响应结束\n\tres.end('hello world');\n\t//监听网址127.0.0.1 端口号3000\n}).listen(3000,'127.0.0.1');\n\n\n\n# 3.repl运行环境（read-eval-print-loop）\n\n打开终端，输入node即可进入repl运行环境，可以解析js代码，执行变量和函数的相关操作。\n\n其实chrome中的console控制台就是repl环境。\n\n\n# 4.global对象和模块作用域\n\n在node.js中，默认声明的变量，函数都是属于当前文件模块，都是私有的，只有在当前模块作用域内可以使用，如果想在全局范围内为某个变量赋值，可以应用 全局对象global.\n\nvar foo = 'bar';\nglobal.foo = foo;\nconsole.log('global:foo'+global.foo);\n\n\n\n# 4.1 require(),exports,module.exports\n\n在一个文件模块中直接给某个全局变量赋值，显得很突兀，可能会污染命名空间，造成耦合的问题，为了解决上述问题，exports是模块公开的接口，require()用于从外部获取一个模块的接口。\n\ninfo.js:\n\n//向外开放变量name\nexports.name = 'itcast';\n//向外开放变量age\nmodule.exports.age = '10';\n//向外开放函数\nmodule.exports.sayhello = function(){\n    console.log('hello');\n}\n\n\ndemo.js\n\n//加载模块\nlet mymodule = require('./info');\nconsole.log(mymodule);\n//输出模块中的变量值\nconsole.log('name:'+mymodule.name);\nconsole.log('age:'+mymodule.age);\n//调用模块的方法\nmymodule.sayhello();\n\n\n\n# 4.2 exports和module.exports的区别\n\nexports是一个指向module.exports的引用，module.exports初始值为一个空对象{}，所以exports初始值也是{}，虽然exports和module.exports都可以向模块外开放变量和函数，但是使用上，module.exports可以单独定义，返回数据类型，而exports只能返回一个object对象。\n\n例如：\n\ntest.js\n\n//定义一个数组\nmodule.exports=['name','type','age'];\n\n\ndemo2-5.js\n\n//加载模块\nlet mymodule = require('./test');\nconsole.log(mymodule);\n//输出数组长度\nconsole.log('length:'+mymodule.length); \n\n//输出 结果\n//[ 'name', 'type', 'age' ]\n//length:3\n\n\n修改test.js中的代码\n\nexports=['name','type','age'];\n\n//最后输出\n//{}\n//length:undefined\n\n\n可见使用exports直接定义数据，会切断exports与module.exports的联系，出现了找不到值的情况。\n\n\n# 5.全局可用变量，函数和对象\n\n即不需要进行模块加载，可以直接使用的，例如require()函数。\n\n\n# 5.1 _dirname和 _filename变量\n\n * _dirname表示当前文件所在的目录\n * _filename表示当前正在执行的脚本的文件名。（绝对路径）\n\nconsole.log('文件的目录是：'+__dirname);\nconsole.log('文件的绝对路径是：'+__filename);\n//输出\n//文件的目录是：c:\\users\\jin\\desktop\\前端学习\\node.js\\chapter 02\n//文件的绝对路径是：c:\\users\\jin\\desktop\\前端学习\\node.js\\chapter 02\\demo2-6.js\n\n\n\n# 5.2 全局函数\n\n * settimeout(cb,ms)：ms后执行cb\n * cleartimeout()\n * setinterval(cb,ms)：每ms后执行cb\n * clearinterval()\n * setimmediate(cb)：延迟调用cb函数，cb将在i/o事件回调之后，settimeout和setinterval回调之前调用\n * clearimmediate()\n\n\n# 5.3 console对象\n\nconsole是一个全局对象，除了console.log()函数外还提供了其他函数\n\n * console.info\n * console.error\n * console.warn\n * console.dir：用来对一个对象进行检查，以易于阅读和打印的格式显示\n * console.time和console.timeend\n * console.trace：当前执行代码在堆栈中的调用路径\n * console.assert：判断某个表达式或变量是否为真（断言）\n\n\n# 6 重写计算器模块\n\n以add.js为例，定义加减乘除模块\n\nmodule.exports = function(x,y){\n\treturn parseint(x)+parseint(y);\n}\n\n\nindex.js：分别使用require加载4个功能模块，并使用exports向外开放这4个接口\n\nmodule.exports = {\n    add:require('./add');\n    //sub\n    //mul\n    //divide\n}\n\n\ntestcal.js\n\nvar cal = require('./index');\nconsole.log(cal.add(1,2));//3\n\n\n\n# 7. require()的模块加载规则\n\n主要分为两类：文件模块和核心模块\n\n 1. 文件模块\n\nrequire('路径.扩展名');\nrequire('/example.js');//当前目录\nrequire('./example.js');\nrequire('../example.js');//上一目录\n\n\n 2. 核心模块\n\n核心模块包含了基本的api，保存在node.js源码的lib文件下，例如\n\n * 全局对象\n * 常用工具\n * 事件机制\n * 文件系统访问\n * http服务器与客户端\n\nrequire('模块标识');\nconst os = require('os');\nconsole.log(os.cpus());\n\n\n\n# 8. 模块的缓存\n\n多次使用同一模块，node.js只会加载一次，模块被缓存在require.cache中\n\nfoo.js:\n\nconsole.log('foo模块被加载了');\n\n\ntest.js:\n\nrequire('./foo');\nrequire('./foo');\nrequire('./foo');\nrequire('./foo');\n//只输出一次 foo模块被加载了，说明只加载了一次\n\n\n在foo.js加入\n\ndelete require.cache[module.filename];\n//删除缓存后输出4次\n",charsets:{cjk:!0}},{title:"Node.js异步资源和包资源管理",frontmatter:{title:"Node.js异步资源和包资源管理",date:"2019-05-03T16:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-3.html",relativePath:"node/node-3.md",key:"v-58d22542",path:"/node/node-3.html",headers:[{level:2,title:"同步和异步",slug:"同步和异步",normalizedTitle:"同步和异步",charIndex:164},{level:2,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:612},{level:2,title:"事件驱动",slug:"事件驱动",normalizedTitle:"事件驱动",charIndex:2227},{level:2,title:"包的概念",slug:"包的概念",normalizedTitle:"包的概念",charIndex:2471},{level:2,title:"NPM的概念",slug:"npm的概念",normalizedTitle:"npm的概念",charIndex:2689},{level:2,title:"基本应用",slug:"基本应用",normalizedTitle:"基本应用",charIndex:2868},{level:2,title:"包模块加载规则",slug:"包模块加载规则",normalizedTitle:"包模块加载规则",charIndex:2984}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"同步和异步 回调函数 事件驱动 包的概念 NPM的概念 基本应用 包模块加载规则",content:"# 异步编程\n\nJavaScript的执行环境是单线程的，单线程一次只能完成一个任务，如果有多个任务，就需要等待前面一个任务完成后，再执行后面的一个任务。常见的浏览器无响应就是某一段JS代码长时间运行造成的。\n\n为解决单线程阻塞的问题，Node.js中加入了异步编程模块，保证了Node.js快速响应，充分利用CPU。\n\n\n# 同步和异步\n\n 1. 同步：代码按照顺序依次执行\n\nconsole.log('起床');\nconsole.log('背单词');\nfunction eatBreakfast(){\n    console.log('早餐吃完了');\n}\neatBreakfast();\nconsole.log('去上学');\n\n\n 2. 异步：\n\nconsole.log('起床');\nconsole.log('背单词');\nfunction eatBreakfast(){\n    console.log('开始吃早餐了');\n    //setTimeout是一个异步函数，不会阻塞后面代码的继续执行\n    setTimeout(function(){\n        console.log('早餐吃完了');\n    },0);\n}\neatBreakfast();\nconsole.log('去上学');\n//相当于边去学校，边吃早餐\n//输出：起床，背单词，开始吃早餐了，去上学，早餐吃完了\n\n\n\n# 回调函数\n\n回调函数是指函数可以被传递到另一个函数中，然后被调用的形式，典型的应用就是异步函数的异常处理。\n\n 1. 同步代码中使用try...catch处理异常\n\n//同步代码处理异常\nfunction parseJsonStrToObj(str){\n    //用于从一个字符串中解析出json对象\n    return JSON.parse(str);\n}\n//对于同步代码，可以使用try...catch来捕获异常\ntry{\n    let obj = parseJsonStrToObj('foo');\n    console.log(obj);\n}catch (e) {\n    console.log('转换失败了');\n}\n\n//输出：转换失败了\n\n\n 2. 异步代码无法使用try...catch处理异常\n\n//异步代码无法处理异常\nfunction parseJsonStrToObj(str){\n    setTimeout(function(){\n            return JSON.parse(str);\n    },0)\n}\ntry{\n    let obj = parseJsonStrToObj('foo');\n    console.log(obj);\n}catch (e) {\n    console.log('转换失败了');\n}\n\n//最后会报错，说明异步代码无法处理异常\n\n\n 3. 使用回调函数接收异步代码的执行结果\n\n//try...catch写在异步代码中\nfunction parseJsonStrToObj(str){\n    setTimeout(function(){\n        try{\n            return JSON.parse(str);//有返回值，但是无法接收\n        }catch (e) {\n            console.log('转换失败了');\n        }\n    },0)\n}\nlet obj = parseJsonStrToObj('foo');\nconsole.log(obj);\n\n//输出：undefined 转换失败了\n\n\n根据此提出回调函数的设计，即当使用异步代码去做一件事时，不能预测这件事什么时候做完，其他的事情还在继续，这时可给异步代码准备一个包裹，当异步代码有了执行结果时，可以将结果放在这个包裹里，需要在哪里使用这个结果就从包裹取出。\n\n回调函数设计的3个约定：\n\n（1） 函数名通常为callback,在封装异步执行代码时，优先把callback作为函数最后一个参数出现\n\nfunction 函数名(arg1,arg2,callback){}\n\n\n（2）把代码中出现的错误作为callback回调函数的第一个参数进行传递,返回结果作为第二个参数\n\ncallback(err,result);\n\n\n改写上面函数\n\nfunction parseJsonStrToObj(str,callback){\n    setTimeout(function(){\n        try{\n            let obj = JSON.parse(str);\n            callback(null,obj);\n        }catch (e) {\n            callback(e,null);\n        }\n    },0)\n}\nparseJsonStrToObj('foo',function(err,result){\n    if(err){\n        return console.log('转换失败了');\n    }\n    console.log('转换成功：'+result);\n})\n//输出，转换失败了\n\n\n\n# 事件驱动\n\n当异步函数执行时，不确定何时执行完毕，回调函数会被压入到一个事件循环队列，然后往下执行其他代码，直到异步函数执行完成后，才会开始处理事件循环，调用相应的回调函数。事件循环队列为先进先出队列，按顺序执行。\n\n\n# Node.js的包和NPM\n\nNode.js根据CommonJS规范实现了包机制，CommomJS API定义很多用于非浏览器的应该使用的普通应用程序，Node.js就是一个非浏览器的应用，CommonJS是一种规范，Node.js是这种规范的部分实现。\n\n\n# 包的概念\n\n包和模块没有本质的区别，包是在模块的基础上更进一步的组织JavaSript代码的目录。\n\n包目录结构：\n\n规范的包结构         作用\npackage.json   顶层目录的包描述文件，说明文件（JSON字符串描述)\nbin            可执行的二进制文件\nlib            存放JS文件的目录\ndoc            文档\ntest           存放单元测试用例的代码\n\n\n# NPM的概念\n\n全称为Node.js Package Manage,有两种含义，一种是Node.js的开放模块登记和管理系统，是一个NPM网站:www.npmjs.com,里面所有的包都是通过Node.js实现的。\n\n另一种含义是Node.js的包管理工具，命令行下的软件，比如，npm install 包名\n\nNPM是随Node.js一同安装的。\n\n\n# 基本应用\n\n> npm install 包名\n\n安装后，Node.js会自动在项目当前根目录下创建一个目录，名为node_modules,然后把第三方包自动放在该目录下。node_modules就是专门用于放置第三方包的。\n\n\n# 包模块加载规则\n\n（1）加载时，默认为核心模块，若不是，则会去node_modules目录下寻找。\n\n（2）如果找到了，Node.js将会找到该目录下的package.json文件获取main属性值，根据main属性指定的路径值进行加载。",normalizedContent:"# 异步编程\n\njavascript的执行环境是单线程的，单线程一次只能完成一个任务，如果有多个任务，就需要等待前面一个任务完成后，再执行后面的一个任务。常见的浏览器无响应就是某一段js代码长时间运行造成的。\n\n为解决单线程阻塞的问题，node.js中加入了异步编程模块，保证了node.js快速响应，充分利用cpu。\n\n\n# 同步和异步\n\n 1. 同步：代码按照顺序依次执行\n\nconsole.log('起床');\nconsole.log('背单词');\nfunction eatbreakfast(){\n    console.log('早餐吃完了');\n}\neatbreakfast();\nconsole.log('去上学');\n\n\n 2. 异步：\n\nconsole.log('起床');\nconsole.log('背单词');\nfunction eatbreakfast(){\n    console.log('开始吃早餐了');\n    //settimeout是一个异步函数，不会阻塞后面代码的继续执行\n    settimeout(function(){\n        console.log('早餐吃完了');\n    },0);\n}\neatbreakfast();\nconsole.log('去上学');\n//相当于边去学校，边吃早餐\n//输出：起床，背单词，开始吃早餐了，去上学，早餐吃完了\n\n\n\n# 回调函数\n\n回调函数是指函数可以被传递到另一个函数中，然后被调用的形式，典型的应用就是异步函数的异常处理。\n\n 1. 同步代码中使用try...catch处理异常\n\n//同步代码处理异常\nfunction parsejsonstrtoobj(str){\n    //用于从一个字符串中解析出json对象\n    return json.parse(str);\n}\n//对于同步代码，可以使用try...catch来捕获异常\ntry{\n    let obj = parsejsonstrtoobj('foo');\n    console.log(obj);\n}catch (e) {\n    console.log('转换失败了');\n}\n\n//输出：转换失败了\n\n\n 2. 异步代码无法使用try...catch处理异常\n\n//异步代码无法处理异常\nfunction parsejsonstrtoobj(str){\n    settimeout(function(){\n            return json.parse(str);\n    },0)\n}\ntry{\n    let obj = parsejsonstrtoobj('foo');\n    console.log(obj);\n}catch (e) {\n    console.log('转换失败了');\n}\n\n//最后会报错，说明异步代码无法处理异常\n\n\n 3. 使用回调函数接收异步代码的执行结果\n\n//try...catch写在异步代码中\nfunction parsejsonstrtoobj(str){\n    settimeout(function(){\n        try{\n            return json.parse(str);//有返回值，但是无法接收\n        }catch (e) {\n            console.log('转换失败了');\n        }\n    },0)\n}\nlet obj = parsejsonstrtoobj('foo');\nconsole.log(obj);\n\n//输出：undefined 转换失败了\n\n\n根据此提出回调函数的设计，即当使用异步代码去做一件事时，不能预测这件事什么时候做完，其他的事情还在继续，这时可给异步代码准备一个包裹，当异步代码有了执行结果时，可以将结果放在这个包裹里，需要在哪里使用这个结果就从包裹取出。\n\n回调函数设计的3个约定：\n\n（1） 函数名通常为callback,在封装异步执行代码时，优先把callback作为函数最后一个参数出现\n\nfunction 函数名(arg1,arg2,callback){}\n\n\n（2）把代码中出现的错误作为callback回调函数的第一个参数进行传递,返回结果作为第二个参数\n\ncallback(err,result);\n\n\n改写上面函数\n\nfunction parsejsonstrtoobj(str,callback){\n    settimeout(function(){\n        try{\n            let obj = json.parse(str);\n            callback(null,obj);\n        }catch (e) {\n            callback(e,null);\n        }\n    },0)\n}\nparsejsonstrtoobj('foo',function(err,result){\n    if(err){\n        return console.log('转换失败了');\n    }\n    console.log('转换成功：'+result);\n})\n//输出，转换失败了\n\n\n\n# 事件驱动\n\n当异步函数执行时，不确定何时执行完毕，回调函数会被压入到一个事件循环队列，然后往下执行其他代码，直到异步函数执行完成后，才会开始处理事件循环，调用相应的回调函数。事件循环队列为先进先出队列，按顺序执行。\n\n\n# node.js的包和npm\n\nnode.js根据commonjs规范实现了包机制，commomjs api定义很多用于非浏览器的应该使用的普通应用程序，node.js就是一个非浏览器的应用，commonjs是一种规范，node.js是这种规范的部分实现。\n\n\n# 包的概念\n\n包和模块没有本质的区别，包是在模块的基础上更进一步的组织javasript代码的目录。\n\n包目录结构：\n\n规范的包结构         作用\npackage.json   顶层目录的包描述文件，说明文件（json字符串描述)\nbin            可执行的二进制文件\nlib            存放js文件的目录\ndoc            文档\ntest           存放单元测试用例的代码\n\n\n# npm的概念\n\n全称为node.js package manage,有两种含义，一种是node.js的开放模块登记和管理系统，是一个npm网站:www.npmjs.com,里面所有的包都是通过node.js实现的。\n\n另一种含义是node.js的包管理工具，命令行下的软件，比如，npm install 包名\n\nnpm是随node.js一同安装的。\n\n\n# 基本应用\n\n> npm install 包名\n\n安装后，node.js会自动在项目当前根目录下创建一个目录，名为node_modules,然后把第三方包自动放在该目录下。node_modules就是专门用于放置第三方包的。\n\n\n# 包模块加载规则\n\n（1）加载时，默认为核心模块，若不是，则会去node_modules目录下寻找。\n\n（2）如果找到了，node.js将会找到该目录下的package.json文件获取main属性值，根据main属性指定的路径值进行加载。",charsets:{cjk:!0}},{title:"移动端适配",frontmatter:{title:"移动端适配",date:"2020-11-16T16:01:54.000Z",categories:"移动端"},regularPath:"/mobile/adaptation.html",relativePath:"mobile/adaptation.md",key:"v-6770af3f",path:"/mobile/adaptation.html",headers:[{level:2,title:"移动端适配",slug:"移动端适配",normalizedTitle:"移动端适配",charIndex:2},{level:3,title:"逻辑像素与物理像素",slug:"逻辑像素与物理像素",normalizedTitle:"逻辑像素与物理像素",charIndex:12},{level:3,title:"常见长度单位",slug:"常见长度单位",normalizedTitle:"常见长度单位",charIndex:321},{level:3,title:"移动端 1px",slug:"移动端-1px",normalizedTitle:"移动端 1px",charIndex:1838},{level:3,title:"适配案例",slug:"适配案例",normalizedTitle:"适配案例",charIndex:3234},{level:3,title:"常见移动端适配方案",slug:"常见移动端适配方案",normalizedTitle:"常见移动端适配方案",charIndex:4033}],lastUpdated:"11/2/2023, 2:16:23 PM",lastUpdatedTimestamp:1698905783e3,headersStr:"移动端适配 逻辑像素与物理像素 常见长度单位 移动端 1px 适配案例 常见移动端适配方案",content:'# 移动端适配\n\n\n# 逻辑像素与物理像素\n\n * pt: html css中的使用的单位像素px: 实际上指的是逻辑像素pt\n\n * px: photoshop测量中的但是实际上指的是物理像素, 物理像素即表示的是一个点, 大小固定\n\n * 一个pt可以包含多个物理像素px\n\n * 在iphone6中一个单位的逻辑像素包含2个物理像素，iphone的分辨率为375*667实际上指的是逻辑像素为375*667, 所以一般移动端的设计图纸一般是给的是750*1334, 是因为一个逻辑像素pt包含两个物理像素px\n\n * 不同设备下的分辨率不同, 在iphone6s中 一个逻辑像素pt包含三个物理像素px 即 1pt = 3px\n\n\n# 常见长度单位\n\n# em\n\nem是相对长度单位。它的单位长度是根据元素的文本垂直长度来决定的。可以作用在width、height、line-height、margin、padding、border等样式的设置上。 如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 默认1em=16px。如果在body选择器中声明font-size=62.5%,则1em=10px。\n\n<style>\n\t.parent{ \n\t\t\tfont-size:5em; /*80px*/\n\t\t\theight:10em;/*800px*/\n\t}\n  .child{\n\t\t\tfont-size:2em;/*160px*/\n\t\t\theight:2em;/*320px*/\n\t}\n</style>\n\n<body>\n\t<div class="parent">\n    <div class="child"></div>\n\t</div>\n</body>\n\n\n在不设置元素font-size的情况下，em总是根据父元素的font-size来确定长度；即使元素设置了font-size，多次嵌套使用em也往往会造成疏忽，不仅使用前需要大量计算，而且不能保证没有漏网之鱼。这将是一个繁杂而低效率的工作。 于是有了rem.\n\n# rem\n\nrem不是依据父元素——而是依据根元素（root element）来确定其长度。\n\n我们一般给根元素设置一个容易计算的font-size\n\n<style>\n    html {\n        font-size: 62.5%;   /* 10px */\n    }\n    div {\n        font-size: 2.4rem;  /* 24px */\n        width: 64rem;   /* 640px */\n        border: 0.1rem solid #ccc;  /* 1px */\n    }\n</style>\n<body>\n    <div class="div1">\n        <div class="div2"></div>\n    </div>\n</body>\n\n\n# rpx\n\n设备             RPX换算PX (屏幕宽度/750)   PX换算RPX (750/屏幕宽度)\niPhone5        1rpx = 0.42px        1px = 2.34rpx\niPhone6        1rpx = 0.5px         1px = 2rpx\niPhone6 Plus   1rpx = 0.552px       1px = 1.81rpx\n\n * rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n * 建议小程序的设计稿以750 x 1334 的物理分辨率进行设计\n\n# vw,vh\n\n * vw和vh是css3中的新单位，是一种视窗单位，在小程序中也同样适用。\n * 小程序中，窗口宽度固定为100vw，将窗口宽度平均分成100份，1份是1vw\n * 小程序中，窗口高度固定为100vh ，将窗口高度平均分成100份，1份是1vh\n * 所以，我们在小程序中也可以使用vw、vh作为尺寸单位使用在布局中进行布局，但是一般情况下，百分比+rpx就已经足够使用了,所以它们的出场机会很少。\n\n\n# 移动端 1px\n\n# 原因\n\n * DPR(devicePixelRatio) 设备像素比 = 物理像素 / css像素 ，它是默认缩放为100%的屏幕下，设备像素和css像素的比值。\n * 目前比较主流的设备的DPR=2或3，所以： 当我们的DPR为2，也就是2倍屏时，当物理像素（设备像素）为1px的时候，我们的css像素应该是0.5px。当DPR=3，物理像素为1px时，css像素应该为1/3px。\n\n# 解决方案\n\n# scale\n\n如果在一个元素上使用scale时会导致整个元素同时缩放，所以应该在该元素的伪元素下设置scale属性。\n\n// 通过伪元素实现 0.5px border\n.border::after {\n    content: "";\n    box-sizing: border-box; // 为了与原元素等大\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 200%; \n    height: 200%; \n    border: 1px solid gray;\n    transform: scale(0.5); \n    transform-origin: 0 0;\n}\n\n// 通过伪元素实现 0.5px 细线\n.line::after {\n    content: \'\';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 200%;\n    height: 1px;\n    background: #b3b4b8;\n    transform: scale(0.5);\n    transform-origin: 0 0;\n}\n\n\n> 为什么要先放大 200% 再缩小 0.5？\n> \n> 为了只缩放 border 1px 的粗细，而保证 border 的大小不变。如果直接 scale(0.5) 的话 border 整体大小也会变成二分之一，所以先放大 200%（放大的时候 border 的粗细是不会被放大的）再缩放，就能保持原大小不变了。\n\n# linear-gradient\n\n通过线性渐变，也可以实现移动端1px的线。原理大致是使用渐变色，上部分为白色，下部分为黑色。这样就可以将线从视觉上看只有1px。\n\n由于是通过背景颜色渐变实现的，所以这里要使用伪元素并且设置伪元素的高度。 当然，也可以不使用伪元素，但是就会增加一个没有任何意义的空标签了。\n\ndiv.linear::after {\n    display: block;\n    content: \'\';\n    height: 1px;\n    background: linear-gradient(0, #fff, #000);\n}\n\n\n# box-shadow\n\n通过box-shaodow来实现1px也可以，实现原理是将纵坐标的shadow设置为0.5px即可。box-shadow属性在Chrome和Firefox下支持小数设置，但是在Safari下不支持。所以使用该方法设置移动端1px时应该慎重使用。\n\ndiv.shadow {\n    box-shadow: 0 0.5px 0 0 #000;\n}\n\n\n\n# 适配案例\n\n设计给出750px的设计稿，也按照750px来开发h5页面，怎么在小程序的 webview 页面中适配？\n\n * transform: scale\n * hack 为占满全屏的透明盒子，因为小程序存在顶部栏，所以不能用 screenHeight\n * toFixed 是为了取整，防止小数出现 bug\n\nfunction autoAdapt() {\n  var screenWidth = hack.offsetWidth\n  var screenHeight = hack.offsetHeight\n  var scale = (screenWidth / 750).toFixed(2)\n  if (scale < 1) {\n    main.style.width = `${(screenWidth / scale).toFixed(0)}px`\n    main.style.height = `${(screenHeight / scale).toFixed(0)}px`\n    main.style.overflow = \'auto\'\n    document.body.style.transform = `scale(${scale})`\n    document.body.style.transformOrigin = \'0% 0%\'\n    document.body.style.overflow = `hidden`\n  } else {\n    main.style.transform = `scale(${scale})`\n    main.style.transformOrigin = \'50% 0%\'\n  }\n}\nautoAdapt()\n\nwindow.onresize = function() {\n  autoAdapt()\n}\n\n\n\n# 常见移动端适配方案\n\n * media queries\n * flex 布局\n * rem + viewport\n * vh vw\n * 百分比\n\n# 一、Meida Queries\n\nmeida queries 的方式可以说是我早期采用的布局方式，它主要是通过查询设备的宽度来执行不同的 css 代码，最终达到界面的配置。\n\n核心语法:\n\n@media only screen and (max-width: 374px) {\n  /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置样式*/\n}\n@media only screen and (min-width: 375px) and (max-width: 413px) {\n  /* iphone6/7/8 和 iphone x */\n}\n@media only screen and (min-width: 414px) {\n  /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置样式 */\n}\n\n\n优点：\n\n * media query 可以做到设备像素比的判断，方法简单，成本低，特别是针对移动端和 PC 端维护同一套代码的时候。目前像 Bootstrap 等框架使用这种方式布局\n * 图片便于修改，只需修改 css 文件\n * 调整屏幕宽度的时候不用刷新页面即可响应式展示\n\n缺点：\n\n * 代码量比较大，维护不方便\n * 为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源\n * 为了兼顾移动端和 PC 端各自响应式的展示效果，难免会损失各自特有的交互方式\n\n# 二、Flex 弹性布局\n\n以天猫的实现方式进行说明：\n\n它的 viewport 是固定的：<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">\n\n高度定死，宽度自适应，元素都采用 px 做单位。\n\n随着屏幕宽度变化，页面也会跟着变化，效果就和 PC 页面的流体布局差不多，在哪个宽度需要调整的时候使用响应式布局调调就行（比如网易新闻），这样就实现了『适配』。\n\n# 三、rem+viewport 缩放\n\n实现原理：\n\n根据 rem 将页面放大 dpr 倍, 然后 viewport 设置为 1/dpr.\n\n * 如 iphone6 plus 的 dpr 为 3, 则页面整体放大 3 倍, 1px(css 单位)在 plus 下默认为 3px(物理像素)\n * 然后 viewport 设置为 1/3, 这样页面整体缩回原始大小. 从而实现高清。\n\n这样整个网页在设备内显示时的页面宽度就会等于设备逻辑像素大小，也就是 device-width。这个 device-width 的计算公式为：\n\n设备的物理分辨率/(devicePixelRatio * scale)，在 scale 为 1 的情况下，device-width = 设备的物理分辨率/devicePixelRatio。\n\n# 四、rem 实现\n\nrem是相对长度单位，rem方案中的样式设计为相对于根元素font-size计算值的倍数。根据屏幕宽度设置html标签的font-size，在布局时使用 rem 单位布局，达到自适应的目的。\n\nviewport 是固定的：<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">。\n\n通过以下代码来控制 rem 基准值(设计稿以 720px 宽度量取实际尺寸)\n\n!(function (d) {\n  var c = d.document;\n  var a = c.documentElement;\n  var b = d.devicePixelRatio;\n  var f;\n  function e() {\n    var h = a.getBoundingClientRect().width,\n      g;\n    if (b === 1) {\n      h = 720;\n    }\n    if (h > 720) h = 720; //设置基准值的极限值\n    g = h / 7.2;\n    a.style.fontSize = g + "px";\n  }\n  if (b > 2) {\n    b = 3;\n  } else {\n    if (b > 1) {\n      b = 2;\n    } else {\n      b = 1;\n    }\n  }\n  a.setAttribute("data-dpr", b);\n  d.addEventListener(\n    "resize",\n    function () {\n      clearTimeout(f);\n      f = setTimeout(e, 200);\n    },\n    false\n  );\n  e();\n})(window);\n\n\ncss 通过 sass 预编译，设置量取的 px 值转化 rem 的变量$px: (1/100)+rem;\n\n优点：\n\n * 兼容性好，页面不会因为伸缩发生变形，自适应效果更佳。\n\n缺点：\n\n * 不是纯 css 移动适配方案，需要在头部内嵌一段 js脚本监听分辨率的变化来动态改变根元素的字体大小，css样式和 js 代码有一定耦合性，并且必须将改变font-size的代码放在 css 样式之前。\n * 小数像素问题，浏览器渲染最小的单位是像素，元素根据屏幕宽度自适应，通过 rem 计算后可能会出现小数像素，浏览器会对这部分小数四舍五入，按照整数渲染，有可能没那么准确。\n\n# 五、纯 vw 方案\n\n视口是浏览器中用于呈现网页的区域。\n\n * vw : 1vw 等于 视口宽度 的 1%\n * vh : 1vh 等于 视口高度 的 **1% **\n * vmin : 选取 vw 和 vh 中 最小 的那个\n * vmax : 选取 vw 和 vh 中 最大 的那个\n\n虽然 vw 能更优雅的适配，但是还是有点小问题，就是宽，高没法限制。\n\n$base_vw = 375;\n@function vw ($px) {\n    return ($px/$base_vw) * 100vw\n};\n\n\n优点：\n\n * 纯 css 移动端适配方案，不存在脚本依赖问题。\n * 相对于 rem 以根元素字体大小的倍数定义元素大小，逻辑清晰简单。\n\n缺点：\n\n * 存在一些兼容性问题，有些浏览器不支持\n\n# 六、vw + rem 方案\n\n// scss 语法\n// 设置html根元素的大小 750px->75 640px->64\n// 将屏幕分成10份，每份作为根元素的大小。\n$vw_fontsize: 75\n@function rem($px) {\n    // 例如：一个div的宽度为100px，那么它对应的rem单位就是（100/根元素的大小）* 1rem\n    @return ($px / $vw_fontsize) * 1rem;\n}\n$base_design: 750\nhtml {\n    // rem与vw相关联\n    font-size: ($vw_fontsize / ($base_design / 2)) * 100vw;\n    // 同时，通过Media Queries 限制根元素最大最小值\n    @media screen and (max-width: 320px) {\n        font-size: 64px;\n    }\n    @media screen and (min-width: 540px) {\n        font-size: 108px;\n    }\n}\n\n// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小\nbody {\n    max-width: 540px;\n    min-width: 320px;\n}\n\n\n\n# 七、百分比\n\n使用百分比%定义宽度，高度用px固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用max-width/min-width控制尺寸范围过大或者过小。\n\n优点：\n\n * 原理简单，不存在兼容性问题\n\n缺点：\n\n * 如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。\n * 设置盒模型的不同属性时，其百分比设置的参考元素不唯一，容易使布局问题变得复杂。\n\n> 作者：前端先锋 链接：https://juejin.cn/post/6899291168891207688 来源：掘金',normalizedContent:'# 移动端适配\n\n\n# 逻辑像素与物理像素\n\n * pt: html css中的使用的单位像素px: 实际上指的是逻辑像素pt\n\n * px: photoshop测量中的但是实际上指的是物理像素, 物理像素即表示的是一个点, 大小固定\n\n * 一个pt可以包含多个物理像素px\n\n * 在iphone6中一个单位的逻辑像素包含2个物理像素，iphone的分辨率为375*667实际上指的是逻辑像素为375*667, 所以一般移动端的设计图纸一般是给的是750*1334, 是因为一个逻辑像素pt包含两个物理像素px\n\n * 不同设备下的分辨率不同, 在iphone6s中 一个逻辑像素pt包含三个物理像素px 即 1pt = 3px\n\n\n# 常见长度单位\n\n# em\n\nem是相对长度单位。它的单位长度是根据元素的文本垂直长度来决定的。可以作用在width、height、line-height、margin、padding、border等样式的设置上。 如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 默认1em=16px。如果在body选择器中声明font-size=62.5%,则1em=10px。\n\n<style>\n\t.parent{ \n\t\t\tfont-size:5em; /*80px*/\n\t\t\theight:10em;/*800px*/\n\t}\n  .child{\n\t\t\tfont-size:2em;/*160px*/\n\t\t\theight:2em;/*320px*/\n\t}\n</style>\n\n<body>\n\t<div class="parent">\n    <div class="child"></div>\n\t</div>\n</body>\n\n\n在不设置元素font-size的情况下，em总是根据父元素的font-size来确定长度；即使元素设置了font-size，多次嵌套使用em也往往会造成疏忽，不仅使用前需要大量计算，而且不能保证没有漏网之鱼。这将是一个繁杂而低效率的工作。 于是有了rem.\n\n# rem\n\nrem不是依据父元素——而是依据根元素（root element）来确定其长度。\n\n我们一般给根元素设置一个容易计算的font-size\n\n<style>\n    html {\n        font-size: 62.5%;   /* 10px */\n    }\n    div {\n        font-size: 2.4rem;  /* 24px */\n        width: 64rem;   /* 640px */\n        border: 0.1rem solid #ccc;  /* 1px */\n    }\n</style>\n<body>\n    <div class="div1">\n        <div class="div2"></div>\n    </div>\n</body>\n\n\n# rpx\n\n设备             rpx换算px (屏幕宽度/750)   px换算rpx (750/屏幕宽度)\niphone5        1rpx = 0.42px        1px = 2.34rpx\niphone6        1rpx = 0.5px         1px = 2rpx\niphone6 plus   1rpx = 0.552px       1px = 1.81rpx\n\n * rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iphone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n * 建议小程序的设计稿以750 x 1334 的物理分辨率进行设计\n\n# vw,vh\n\n * vw和vh是css3中的新单位，是一种视窗单位，在小程序中也同样适用。\n * 小程序中，窗口宽度固定为100vw，将窗口宽度平均分成100份，1份是1vw\n * 小程序中，窗口高度固定为100vh ，将窗口高度平均分成100份，1份是1vh\n * 所以，我们在小程序中也可以使用vw、vh作为尺寸单位使用在布局中进行布局，但是一般情况下，百分比+rpx就已经足够使用了,所以它们的出场机会很少。\n\n\n# 移动端 1px\n\n# 原因\n\n * dpr(devicepixelratio) 设备像素比 = 物理像素 / css像素 ，它是默认缩放为100%的屏幕下，设备像素和css像素的比值。\n * 目前比较主流的设备的dpr=2或3，所以： 当我们的dpr为2，也就是2倍屏时，当物理像素（设备像素）为1px的时候，我们的css像素应该是0.5px。当dpr=3，物理像素为1px时，css像素应该为1/3px。\n\n# 解决方案\n\n# scale\n\n如果在一个元素上使用scale时会导致整个元素同时缩放，所以应该在该元素的伪元素下设置scale属性。\n\n// 通过伪元素实现 0.5px border\n.border::after {\n    content: "";\n    box-sizing: border-box; // 为了与原元素等大\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 200%; \n    height: 200%; \n    border: 1px solid gray;\n    transform: scale(0.5); \n    transform-origin: 0 0;\n}\n\n// 通过伪元素实现 0.5px 细线\n.line::after {\n    content: \'\';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 200%;\n    height: 1px;\n    background: #b3b4b8;\n    transform: scale(0.5);\n    transform-origin: 0 0;\n}\n\n\n> 为什么要先放大 200% 再缩小 0.5？\n> \n> 为了只缩放 border 1px 的粗细，而保证 border 的大小不变。如果直接 scale(0.5) 的话 border 整体大小也会变成二分之一，所以先放大 200%（放大的时候 border 的粗细是不会被放大的）再缩放，就能保持原大小不变了。\n\n# linear-gradient\n\n通过线性渐变，也可以实现移动端1px的线。原理大致是使用渐变色，上部分为白色，下部分为黑色。这样就可以将线从视觉上看只有1px。\n\n由于是通过背景颜色渐变实现的，所以这里要使用伪元素并且设置伪元素的高度。 当然，也可以不使用伪元素，但是就会增加一个没有任何意义的空标签了。\n\ndiv.linear::after {\n    display: block;\n    content: \'\';\n    height: 1px;\n    background: linear-gradient(0, #fff, #000);\n}\n\n\n# box-shadow\n\n通过box-shaodow来实现1px也可以，实现原理是将纵坐标的shadow设置为0.5px即可。box-shadow属性在chrome和firefox下支持小数设置，但是在safari下不支持。所以使用该方法设置移动端1px时应该慎重使用。\n\ndiv.shadow {\n    box-shadow: 0 0.5px 0 0 #000;\n}\n\n\n\n# 适配案例\n\n设计给出750px的设计稿，也按照750px来开发h5页面，怎么在小程序的 webview 页面中适配？\n\n * transform: scale\n * hack 为占满全屏的透明盒子，因为小程序存在顶部栏，所以不能用 screenheight\n * tofixed 是为了取整，防止小数出现 bug\n\nfunction autoadapt() {\n  var screenwidth = hack.offsetwidth\n  var screenheight = hack.offsetheight\n  var scale = (screenwidth / 750).tofixed(2)\n  if (scale < 1) {\n    main.style.width = `${(screenwidth / scale).tofixed(0)}px`\n    main.style.height = `${(screenheight / scale).tofixed(0)}px`\n    main.style.overflow = \'auto\'\n    document.body.style.transform = `scale(${scale})`\n    document.body.style.transformorigin = \'0% 0%\'\n    document.body.style.overflow = `hidden`\n  } else {\n    main.style.transform = `scale(${scale})`\n    main.style.transformorigin = \'50% 0%\'\n  }\n}\nautoadapt()\n\nwindow.onresize = function() {\n  autoadapt()\n}\n\n\n\n# 常见移动端适配方案\n\n * media queries\n * flex 布局\n * rem + viewport\n * vh vw\n * 百分比\n\n# 一、meida queries\n\nmeida queries 的方式可以说是我早期采用的布局方式，它主要是通过查询设备的宽度来执行不同的 css 代码，最终达到界面的配置。\n\n核心语法:\n\n@media only screen and (max-width: 374px) {\n  /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置样式*/\n}\n@media only screen and (min-width: 375px) and (max-width: 413px) {\n  /* iphone6/7/8 和 iphone x */\n}\n@media only screen and (min-width: 414px) {\n  /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置样式 */\n}\n\n\n优点：\n\n * media query 可以做到设备像素比的判断，方法简单，成本低，特别是针对移动端和 pc 端维护同一套代码的时候。目前像 bootstrap 等框架使用这种方式布局\n * 图片便于修改，只需修改 css 文件\n * 调整屏幕宽度的时候不用刷新页面即可响应式展示\n\n缺点：\n\n * 代码量比较大，维护不方便\n * 为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源\n * 为了兼顾移动端和 pc 端各自响应式的展示效果，难免会损失各自特有的交互方式\n\n# 二、flex 弹性布局\n\n以天猫的实现方式进行说明：\n\n它的 viewport 是固定的：<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">\n\n高度定死，宽度自适应，元素都采用 px 做单位。\n\n随着屏幕宽度变化，页面也会跟着变化，效果就和 pc 页面的流体布局差不多，在哪个宽度需要调整的时候使用响应式布局调调就行（比如网易新闻），这样就实现了『适配』。\n\n# 三、rem+viewport 缩放\n\n实现原理：\n\n根据 rem 将页面放大 dpr 倍, 然后 viewport 设置为 1/dpr.\n\n * 如 iphone6 plus 的 dpr 为 3, 则页面整体放大 3 倍, 1px(css 单位)在 plus 下默认为 3px(物理像素)\n * 然后 viewport 设置为 1/3, 这样页面整体缩回原始大小. 从而实现高清。\n\n这样整个网页在设备内显示时的页面宽度就会等于设备逻辑像素大小，也就是 device-width。这个 device-width 的计算公式为：\n\n设备的物理分辨率/(devicepixelratio * scale)，在 scale 为 1 的情况下，device-width = 设备的物理分辨率/devicepixelratio。\n\n# 四、rem 实现\n\nrem是相对长度单位，rem方案中的样式设计为相对于根元素font-size计算值的倍数。根据屏幕宽度设置html标签的font-size，在布局时使用 rem 单位布局，达到自适应的目的。\n\nviewport 是固定的：<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">。\n\n通过以下代码来控制 rem 基准值(设计稿以 720px 宽度量取实际尺寸)\n\n!(function (d) {\n  var c = d.document;\n  var a = c.documentelement;\n  var b = d.devicepixelratio;\n  var f;\n  function e() {\n    var h = a.getboundingclientrect().width,\n      g;\n    if (b === 1) {\n      h = 720;\n    }\n    if (h > 720) h = 720; //设置基准值的极限值\n    g = h / 7.2;\n    a.style.fontsize = g + "px";\n  }\n  if (b > 2) {\n    b = 3;\n  } else {\n    if (b > 1) {\n      b = 2;\n    } else {\n      b = 1;\n    }\n  }\n  a.setattribute("data-dpr", b);\n  d.addeventlistener(\n    "resize",\n    function () {\n      cleartimeout(f);\n      f = settimeout(e, 200);\n    },\n    false\n  );\n  e();\n})(window);\n\n\ncss 通过 sass 预编译，设置量取的 px 值转化 rem 的变量$px: (1/100)+rem;\n\n优点：\n\n * 兼容性好，页面不会因为伸缩发生变形，自适应效果更佳。\n\n缺点：\n\n * 不是纯 css 移动适配方案，需要在头部内嵌一段 js脚本监听分辨率的变化来动态改变根元素的字体大小，css样式和 js 代码有一定耦合性，并且必须将改变font-size的代码放在 css 样式之前。\n * 小数像素问题，浏览器渲染最小的单位是像素，元素根据屏幕宽度自适应，通过 rem 计算后可能会出现小数像素，浏览器会对这部分小数四舍五入，按照整数渲染，有可能没那么准确。\n\n# 五、纯 vw 方案\n\n视口是浏览器中用于呈现网页的区域。\n\n * vw : 1vw 等于 视口宽度 的 1%\n * vh : 1vh 等于 视口高度 的 **1% **\n * vmin : 选取 vw 和 vh 中 最小 的那个\n * vmax : 选取 vw 和 vh 中 最大 的那个\n\n虽然 vw 能更优雅的适配，但是还是有点小问题，就是宽，高没法限制。\n\n$base_vw = 375;\n@function vw ($px) {\n    return ($px/$base_vw) * 100vw\n};\n\n\n优点：\n\n * 纯 css 移动端适配方案，不存在脚本依赖问题。\n * 相对于 rem 以根元素字体大小的倍数定义元素大小，逻辑清晰简单。\n\n缺点：\n\n * 存在一些兼容性问题，有些浏览器不支持\n\n# 六、vw + rem 方案\n\n// scss 语法\n// 设置html根元素的大小 750px->75 640px->64\n// 将屏幕分成10份，每份作为根元素的大小。\n$vw_fontsize: 75\n@function rem($px) {\n    // 例如：一个div的宽度为100px，那么它对应的rem单位就是（100/根元素的大小）* 1rem\n    @return ($px / $vw_fontsize) * 1rem;\n}\n$base_design: 750\nhtml {\n    // rem与vw相关联\n    font-size: ($vw_fontsize / ($base_design / 2)) * 100vw;\n    // 同时，通过media queries 限制根元素最大最小值\n    @media screen and (max-width: 320px) {\n        font-size: 64px;\n    }\n    @media screen and (min-width: 540px) {\n        font-size: 108px;\n    }\n}\n\n// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小\nbody {\n    max-width: 540px;\n    min-width: 320px;\n}\n\n\n\n# 七、百分比\n\n使用百分比%定义宽度，高度用px固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用max-width/min-width控制尺寸范围过大或者过小。\n\n优点：\n\n * 原理简单，不存在兼容性问题\n\n缺点：\n\n * 如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。\n * 设置盒模型的不同属性时，其百分比设置的参考元素不唯一，容易使布局问题变得复杂。\n\n> 作者：前端先锋 链接：https://juejin.cn/post/6899291168891207688 来源：掘金',charsets:{cjk:!0}},{title:"模块化编程",frontmatter:{title:"模块化编程",date:"2019-05-01T16:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-2.html",relativePath:"node/node-2.md",key:"v-756dc182",path:"/node/node-2.html",headers:[{level:2,title:"模块化的概念",slug:"模块化的概念",normalizedTitle:"模块化的概念",charIndex:272},{level:2,title:"模块化开发",slug:"模块化开发",normalizedTitle:"模块化开发",charIndex:327},{level:2,title:"全局函数",slug:"全局函数",normalizedTitle:"全局函数",charIndex:736},{level:2,title:"对象命名空间",slug:"对象命名空间",normalizedTitle:"对象命名空间",charIndex:2150},{level:2,title:"函数的作用域（闭包）",slug:"函数的作用域-闭包",normalizedTitle:"函数的作用域（闭包）",charIndex:3376},{level:2,title:"维护和扩展",slug:"维护和扩展",normalizedTitle:"维护和扩展",charIndex:4863}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"模块化的概念 模块化开发 全局函数 对象命名空间 函数的作用域（闭包） 维护和扩展",content:"随着 Web 技术的蓬勃发展和依赖的基础设施日益完善，前端领域逐渐从浏览器扩展至服务端（Node.js），桌面端（PC、Android、iOS），乃至于物联网设备（IoT），其中 JavaScript 承载着这些应用程序的核心部分，随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。\n\nJavaScript 对模块化编程的支持尚未形成规范，难以堪此重任；一时间，江湖侠士挺身而出，一路披荆斩棘，从刀耕火种过渡到面向未来的模块化方案；\n\n\n# 初识模块化思想\n\n\n# 模块化的概念\n\n模块化是一种生产方式，这种方式体现了两个特点\n\n（1）生产效率高\n\n（2）维护成本低\n\n\n# 模块化开发\n\n非模块化开发会遇到哪些问题\n\n 1. 命名冲突\n\n//全局变量中名称重复\nvar foo = 'bar';\nvar foo = 'brz';\n//另外若引用第三方的库，在全局对象中声明了一个属性foo，自己的代码中有同样的名称，后加载的会替换之前的\n\n\n 2. 文件依赖\n\n<srcipt src='./ccc.js'></srcipt>\n<srcipt src='./a.js'></srcipt>\n<srcipt src='./b.js'></srcipt>\n<srcipt src='./c.js'></srcipt>\n<srcipt src='./d.js'></srcipt>\n<srcipt src='./aaa.js'></srcipt>\n\x3c!---\x3e.aaa,js依赖于./a.js,若调换顺序则会出错，模块化开发并不需要将所有的文件引入\x3c!---\x3e\n\n\n\n# 模块化编程的演变\n\n\n# 全局函数\n\n\x3c!---\x3e计算器的例子\x3c!---\x3e\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>模块化开发演变-全局函数</title>\n</head>\n<body>\n\t<input type=\"text\" id='x'>\n\t<select name=\"\" id=\"opt\">\n\t\t<option value=\"0\">+</option>\n\t\t<option value=\"1\">-</option>\n\t\t<option value=\"2\">*</option>\n\t\t<option value=\"3\">/</option>\n\t</select>\n\t<input type=\"text\" id='y'>\n\t<button id='cal'>=</button>\n\t<input type=\"text\" id='result'>\n\n\t<script>\n\n\t\t//定义计算函数\n\t\tfunction add(x,y){\n\t\t\treturn parseInt(x)+parseInt(y);\n\t\t}\n\n\t\tfunction subtract(x,y){\n\t\t\treturn parseInt(x)-parseInt(y);\n\t\t}\n\n\t\tfunction multiply(x,y){\n\t\t\treturn parseInt(x)*parseInt(y);\n\t\t}\n\n\t\tfunction divide(x,y){\n\t\t\treturn parseInt(x)/parseInt(y);\n\t\t}\n\n\t\t//获取Dom\n\t\tvar oX = document.getElementById('x');\n\t\tvar oY = document.getElementById('y');\n\t\tvar oOpt = document.getElementById('opt');\n\t\tvar oCal = document.getElementById('cal');\n\t\tvar oResult = document.getElementById('result');\n\n\t\t//为等号按钮添加单击事件\n\t\toCal.addEventListener('click', function(){\n\t\t\tvar x = oX.value;\n\t\t\tvar y = oY.value;\n\t\t\tvar opt = oOpt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toResult.value = result;\n\t\t})\n\t<\/script>\n</body>\n</html>\n\n\n全局函数这种编程方式很常见，但是不可取，无法保证全局变量不与其他模块的变量冲突。\n\n\n# 对象命名空间\n\n\t<script>\n        \n\t\t//对象命名空间\n        var calculator = {};\n        \n\t\t//定义计算函数\n\t\tcalculator.add(x,y){\n\t\t\treturn parseInt(x)+parseInt(y);\n\t\t}\n\n\t\tcalculator.subtract(x,y){\n\t\t\treturn parseInt(x)-parseInt(y);\n\t\t}\n\n\t\tcalculator.multiply(x,y){\n\t\t\treturn parseInt(x)*parseInt(y);\n\t\t}\n\n\t\tcalculator.divide(x,y){\n\t\t\treturn parseInt(x)/parseInt(y);\n\t\t}\n\n\t\t//获取Dom\n\t\tvar oX = document.getElementById('x');\n\t\tvar oY = document.getElementById('y');\n\t\tvar oOpt = document.getElementById('opt');\n\t\tvar oCal = document.getElementById('cal');\n\t\tvar oResult = document.getElementById('result');\n\n\t\t//为等号按钮添加单击事件\n\t\toCal.addEventListener('click', function(){\n\t\t\tvar x = oX.value;\n\t\t\tvar y = oY.value;\n\t\t\tvar opt = oOpt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toResult.value = result;\n\t\t})\n\t<\/script>\n\n\n用于计算的4个函数的命名冲突问题解决了，但是如果再定义一个名为calculator的命名空间还是会报错，虽然减少了命名冲突的问题，但是命名冲突还是存在。另外还会出现子命名空间的情况。\n\ncalculator.subcal = {};\ncalculator.subcal.foo = 'bar';//命名空间越来越长，代码可读性差\n\n\n\n# 函数的作用域（闭包）\n\n\t<script>\n        \n\t\t//利用匿名自执行函数形成的封闭的函数作用域空间，达到私有化的目的。\n        \n        var calcultor = (function(){\n            function add(x,y){\n\t\t\treturn parseInt(x)+parseInt(y);\n            }\n\n            function subtract(x,y){\n                return parseInt(x)-parseInt(y);\n            }\n\n            function multiply(x,y){\n                return parseInt(x)*parseInt(y);\n            }\n\n            function divide(x,y){\n                return parseInt(x)/parseInt(y);\n            }\n            return{\n                add:add,\n                subtract:subtract,\n                multiply:multiply,\n                divide:divide\n            }\n        })();\n\n\n\t\t//获取Dom\n\t\tvar oX = document.getElementById('x');\n\t\tvar oY = document.getElementById('y');\n\t\tvar oOpt = document.getElementById('opt');\n\t\tvar oCal = document.getElementById('cal');\n\t\tvar oResult = document.getElementById('result');\n\n\t\t//为等号按钮添加单击事件\n\t\toCal.addEventListener('click', function(){\n\t\t\tvar x = oX.value;\n\t\t\tvar y = oY.value;\n\t\t\tvar opt = oOpt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toResult.value = result;\n\t\t})\n\t<\/script>\n\n\n上述方法中，用于计算的4个方法被封装到了立即执行匿名函数中，添加返回值后，在全局可以通过“匿名函数.函数名（）”进行调用，这样有效的公开了公有方法，并且可以隐藏一些私有属性和元素，大部分第三方库都使用这种形式，例如jQuery。\n\n\n# 维护和扩展\n\n若现在需要添加取余方法，传统方式是在匿名函数中添加一个方法\n\nvar calcultor = (function(){\n            function add(x,y){\n\t\t\treturn parseInt(x)+parseInt(y);\n            }\n\n            function subtract(x,y){\n                return parseInt(x)-parseInt(y);\n            }\n\n            function multiply(x,y){\n                return parseInt(x)*parseInt(y);\n            }\n\n            function divide(x,y){\n                return parseInt(x)/parseInt(y);\n            }\n    \t\t\n    \t\tfunction mod(x,y){\n                return parseInt(x)%parseInt(y);\n            }\n    \n            return{\n                add:add,\n                subtract:subtract,\n                multiply:multiply,\n                divide:divide,\n                mod:mod\n            }\n        })();\n\n\n试想一下，如果这个计算模块由第三方库提供，难道要修改源码？\n\n其实可以通过参数的形式将原来的模块和第三方库传递出去。\n\n//传递参数cal\nvar calcultor = (function(cal){\n            function add(x,y){\n\t\t   \t    return parseInt(x)+parseInt(y);\n            }\n\n            function subtract(x,y){\n                return parseInt(x)-parseInt(y);\n            }\n\n            function multiply(x,y){\n                return parseInt(x)*parseInt(y);\n            }\n\n            function divide(x,y){\n                return parseInt(x)/parseInt(y);\n            }\n    \t\t\n    \t\tfunction mod(x,y){\n                return parseInt(x)%parseInt(y);\n            }\n    \n            \n                cal.add = add;\n                cal.subtract = subtract;\n                cal.multiply = multiply;\n                cal.divide = divide;\n                return cal;\n            \n        })(calculator||{});\n\n//下面的calculator已经把上面的给覆盖掉了\n//注意：在进行扩展的时候，优先查找要扩展的对象是否已经存在\nvar calculator = (function(cal){\n    cal.mod = function(x,y){\n        return x%y;\n    }\n})(calculator||{});\n//当扩展该模块时，判断calculator是否存在，存在就使用存在的，不存在就重新创建\n\n\t\t//获取Dom\n\t\tvar oX = document.getElementById('x');\n\t\tvar oY = document.getElementById('y');\n\t\tvar oOpt = document.getElementById('opt');\n\t\tvar oCal = document.getElementById('cal');\n\t\tvar oResult = document.getElementById('result');\n\n\t\t//为等号按钮添加单击事件\n\t\toCal.addEventListener('click', function(){\n\t\t\tvar x = oX.value;\n\t\t\tvar y = oY.value;\n\t\t\tvar opt = oOpt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresult = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toResult.value = result;\n\t\t})\n\n\n把模块化思想带入编程中，可以解决命名冲突和文件依赖等问题，后面会介绍Node.js是一个高度模块化的平台。",normalizedContent:"随着 web 技术的蓬勃发展和依赖的基础设施日益完善，前端领域逐渐从浏览器扩展至服务端（node.js），桌面端（pc、android、ios），乃至于物联网设备（iot），其中 javascript 承载着这些应用程序的核心部分，随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。\n\njavascript 对模块化编程的支持尚未形成规范，难以堪此重任；一时间，江湖侠士挺身而出，一路披荆斩棘，从刀耕火种过渡到面向未来的模块化方案；\n\n\n# 初识模块化思想\n\n\n# 模块化的概念\n\n模块化是一种生产方式，这种方式体现了两个特点\n\n（1）生产效率高\n\n（2）维护成本低\n\n\n# 模块化开发\n\n非模块化开发会遇到哪些问题\n\n 1. 命名冲突\n\n//全局变量中名称重复\nvar foo = 'bar';\nvar foo = 'brz';\n//另外若引用第三方的库，在全局对象中声明了一个属性foo，自己的代码中有同样的名称，后加载的会替换之前的\n\n\n 2. 文件依赖\n\n<srcipt src='./ccc.js'></srcipt>\n<srcipt src='./a.js'></srcipt>\n<srcipt src='./b.js'></srcipt>\n<srcipt src='./c.js'></srcipt>\n<srcipt src='./d.js'></srcipt>\n<srcipt src='./aaa.js'></srcipt>\n\x3c!---\x3e.aaa,js依赖于./a.js,若调换顺序则会出错，模块化开发并不需要将所有的文件引入\x3c!---\x3e\n\n\n\n# 模块化编程的演变\n\n\n# 全局函数\n\n\x3c!---\x3e计算器的例子\x3c!---\x3e\n<!doctype html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"utf-8\">\n\t<title>模块化开发演变-全局函数</title>\n</head>\n<body>\n\t<input type=\"text\" id='x'>\n\t<select name=\"\" id=\"opt\">\n\t\t<option value=\"0\">+</option>\n\t\t<option value=\"1\">-</option>\n\t\t<option value=\"2\">*</option>\n\t\t<option value=\"3\">/</option>\n\t</select>\n\t<input type=\"text\" id='y'>\n\t<button id='cal'>=</button>\n\t<input type=\"text\" id='result'>\n\n\t<script>\n\n\t\t//定义计算函数\n\t\tfunction add(x,y){\n\t\t\treturn parseint(x)+parseint(y);\n\t\t}\n\n\t\tfunction subtract(x,y){\n\t\t\treturn parseint(x)-parseint(y);\n\t\t}\n\n\t\tfunction multiply(x,y){\n\t\t\treturn parseint(x)*parseint(y);\n\t\t}\n\n\t\tfunction divide(x,y){\n\t\t\treturn parseint(x)/parseint(y);\n\t\t}\n\n\t\t//获取dom\n\t\tvar ox = document.getelementbyid('x');\n\t\tvar oy = document.getelementbyid('y');\n\t\tvar oopt = document.getelementbyid('opt');\n\t\tvar ocal = document.getelementbyid('cal');\n\t\tvar oresult = document.getelementbyid('result');\n\n\t\t//为等号按钮添加单击事件\n\t\tocal.addeventlistener('click', function(){\n\t\t\tvar x = ox.value;\n\t\t\tvar y = oy.value;\n\t\t\tvar opt = oopt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toresult.value = result;\n\t\t})\n\t<\/script>\n</body>\n</html>\n\n\n全局函数这种编程方式很常见，但是不可取，无法保证全局变量不与其他模块的变量冲突。\n\n\n# 对象命名空间\n\n\t<script>\n        \n\t\t//对象命名空间\n        var calculator = {};\n        \n\t\t//定义计算函数\n\t\tcalculator.add(x,y){\n\t\t\treturn parseint(x)+parseint(y);\n\t\t}\n\n\t\tcalculator.subtract(x,y){\n\t\t\treturn parseint(x)-parseint(y);\n\t\t}\n\n\t\tcalculator.multiply(x,y){\n\t\t\treturn parseint(x)*parseint(y);\n\t\t}\n\n\t\tcalculator.divide(x,y){\n\t\t\treturn parseint(x)/parseint(y);\n\t\t}\n\n\t\t//获取dom\n\t\tvar ox = document.getelementbyid('x');\n\t\tvar oy = document.getelementbyid('y');\n\t\tvar oopt = document.getelementbyid('opt');\n\t\tvar ocal = document.getelementbyid('cal');\n\t\tvar oresult = document.getelementbyid('result');\n\n\t\t//为等号按钮添加单击事件\n\t\tocal.addeventlistener('click', function(){\n\t\t\tvar x = ox.value;\n\t\t\tvar y = oy.value;\n\t\t\tvar opt = oopt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toresult.value = result;\n\t\t})\n\t<\/script>\n\n\n用于计算的4个函数的命名冲突问题解决了，但是如果再定义一个名为calculator的命名空间还是会报错，虽然减少了命名冲突的问题，但是命名冲突还是存在。另外还会出现子命名空间的情况。\n\ncalculator.subcal = {};\ncalculator.subcal.foo = 'bar';//命名空间越来越长，代码可读性差\n\n\n\n# 函数的作用域（闭包）\n\n\t<script>\n        \n\t\t//利用匿名自执行函数形成的封闭的函数作用域空间，达到私有化的目的。\n        \n        var calcultor = (function(){\n            function add(x,y){\n\t\t\treturn parseint(x)+parseint(y);\n            }\n\n            function subtract(x,y){\n                return parseint(x)-parseint(y);\n            }\n\n            function multiply(x,y){\n                return parseint(x)*parseint(y);\n            }\n\n            function divide(x,y){\n                return parseint(x)/parseint(y);\n            }\n            return{\n                add:add,\n                subtract:subtract,\n                multiply:multiply,\n                divide:divide\n            }\n        })();\n\n\n\t\t//获取dom\n\t\tvar ox = document.getelementbyid('x');\n\t\tvar oy = document.getelementbyid('y');\n\t\tvar oopt = document.getelementbyid('opt');\n\t\tvar ocal = document.getelementbyid('cal');\n\t\tvar oresult = document.getelementbyid('result');\n\n\t\t//为等号按钮添加单击事件\n\t\tocal.addeventlistener('click', function(){\n\t\t\tvar x = ox.value;\n\t\t\tvar y = oy.value;\n\t\t\tvar opt = oopt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresule = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toresult.value = result;\n\t\t})\n\t<\/script>\n\n\n上述方法中，用于计算的4个方法被封装到了立即执行匿名函数中，添加返回值后，在全局可以通过“匿名函数.函数名（）”进行调用，这样有效的公开了公有方法，并且可以隐藏一些私有属性和元素，大部分第三方库都使用这种形式，例如jquery。\n\n\n# 维护和扩展\n\n若现在需要添加取余方法，传统方式是在匿名函数中添加一个方法\n\nvar calcultor = (function(){\n            function add(x,y){\n\t\t\treturn parseint(x)+parseint(y);\n            }\n\n            function subtract(x,y){\n                return parseint(x)-parseint(y);\n            }\n\n            function multiply(x,y){\n                return parseint(x)*parseint(y);\n            }\n\n            function divide(x,y){\n                return parseint(x)/parseint(y);\n            }\n    \t\t\n    \t\tfunction mod(x,y){\n                return parseint(x)%parseint(y);\n            }\n    \n            return{\n                add:add,\n                subtract:subtract,\n                multiply:multiply,\n                divide:divide,\n                mod:mod\n            }\n        })();\n\n\n试想一下，如果这个计算模块由第三方库提供，难道要修改源码？\n\n其实可以通过参数的形式将原来的模块和第三方库传递出去。\n\n//传递参数cal\nvar calcultor = (function(cal){\n            function add(x,y){\n\t\t   \t    return parseint(x)+parseint(y);\n            }\n\n            function subtract(x,y){\n                return parseint(x)-parseint(y);\n            }\n\n            function multiply(x,y){\n                return parseint(x)*parseint(y);\n            }\n\n            function divide(x,y){\n                return parseint(x)/parseint(y);\n            }\n    \t\t\n    \t\tfunction mod(x,y){\n                return parseint(x)%parseint(y);\n            }\n    \n            \n                cal.add = add;\n                cal.subtract = subtract;\n                cal.multiply = multiply;\n                cal.divide = divide;\n                return cal;\n            \n        })(calculator||{});\n\n//下面的calculator已经把上面的给覆盖掉了\n//注意：在进行扩展的时候，优先查找要扩展的对象是否已经存在\nvar calculator = (function(cal){\n    cal.mod = function(x,y){\n        return x%y;\n    }\n})(calculator||{});\n//当扩展该模块时，判断calculator是否存在，存在就使用存在的，不存在就重新创建\n\n\t\t//获取dom\n\t\tvar ox = document.getelementbyid('x');\n\t\tvar oy = document.getelementbyid('y');\n\t\tvar oopt = document.getelementbyid('opt');\n\t\tvar ocal = document.getelementbyid('cal');\n\t\tvar oresult = document.getelementbyid('result');\n\n\t\t//为等号按钮添加单击事件\n\t\tocal.addeventlistener('click', function(){\n\t\t\tvar x = ox.value;\n\t\t\tvar y = oy.value;\n\t\t\tvar opt = oopt.value;\n\t\t\tvar result = 0;\n\t\t\tswitch(opt){\n\t\t\t\tcase '0':\n\t\t\t\t\tresult = calculator.add(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\tresult = calculator.subtract(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tresult = calculator.multiply(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\tresult = calculator.divide(x,y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toresult.value = result;\n\t\t})\n\n\n把模块化思想带入编程中，可以解决命名冲突和文件依赖等问题，后面会介绍node.js是一个高度模块化的平台。",charsets:{cjk:!0}},{title:"Node.js网络编程",frontmatter:{title:"Node.js网络编程",date:"2019-05-05T08:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-4.html",relativePath:"node/node-4.md",key:"v-3c368902",path:"/node/node-4.html",headers:[{level:2,title:"IP地址和端口号",slug:"ip地址和端口号",normalizedTitle:"ip地址和端口号",charIndex:20},{level:2,title:"套接字Socket简单模型",slug:"套接字socket简单模型",normalizedTitle:"套接字socket简单模型",charIndex:117},{level:2,title:"Node.js名字的由来",slug:"node-js名字的由来",normalizedTitle:"node.js名字的由来",charIndex:473},{level:2,title:"Net.Server对象",slug:"net-server对象",normalizedTitle:"net.server对象",charIndex:689},{level:2,title:"Net.Socket对象",slug:"net-socket对象",normalizedTitle:"net.socket对象",charIndex:1205},{level:2,title:"Process模块获取终端输入",slug:"process模块获取终端输入",normalizedTitle:"process模块获取终端输入",charIndex:3242},{level:2,title:"多人广播消息",slug:"多人广播消息",normalizedTitle:"多人广播消息",charIndex:3445}],lastUpdated:"9/29/2021, 7:43:24 PM",lastUpdatedTimestamp:1632915804e3,headersStr:"IP地址和端口号 套接字Socket简单模型 Node.js名字的由来 Net.Server对象 Net.Socket对象 Process模块获取终端输入 多人广播消息",content:"# Node.js网络编程基础\n\n\n# IP地址和端口号\n\n通过IP地址可以找到服务器设备，而端口号可以理解为在发送数据时定位到不同服务器应用程序的标识。\n\nIP地址对于计算机是唯一的，一个端口号也只能被一个应用程序所占用。\n\n\n# 套接字Socket简单模型\n\n先了解一下TCP/IP协议，TCP（Transfer Control Protocol）传输控制协议是一种稳定可靠的传送方式，TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地为止。\n\nSocket原意为孔或插座。在程序方面可理解为接口对象，在网络编程中通常称为套接字，常用于描述IP地址和端口等。Socket是支持TCP/IP的网络通信的基本操作单元。简单理解，Socket就是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口\n\nSocket需要使用套接字地址来展开工作，套接字地址就是IP地址和端口号的组合，套接字服务与其他服务不同，不需要处理网络中的GET或POST请求，而是采用点对点传输数据方式。\n\n\n# Node.js名字的由来\n\nNode.js诞生的目的就是为了更加高效的处理网络数据，因为使用它进行网络编程时不需要使用其他的服务器软件进行支持，Node.js本身就是一个服务器。在进行网络编程时，每一个进程构成网络应用中的一个结点，而Node就是结点的意思，最终web.js更名为Node.js。\n\n\n# Node.js中实现套接字服务\n\n套接字服务由Net模块提供：\n\nlet net = require('net');\n\n\n# Net.Server对象\n\nlet server = net.creatServer()\n\n当Server对象被创建后，在该服务器的生命周期中就存在了一些可触发的事件。\n\n事件           描述\nlistening    当服务器调用server.listen绑定后会触发\nconnection   当新连接创建后会被触发\nclose        服务器关闭时会被触发\nerror        发生错误时触发\n\nlet net = require('net');\nlet server = net.createServer();\nserver.on('connection',function(){\n    console.log('有客户端连接上来了');\n});\nserver.on('listening',function () {\n    console.log('服务器监听成功了，正在等待客户端连接');\n});\nserver.listen(3000,'127.0.0.1');\n\n\n然后启用Telnet客户端服务，命令行中输入：\n\n> telnet 127.0.0.1 3000\n\n就会连接成功。\n\n\n# Net.Socket对象\n\nNet.Socket实例实现了一Duplex（双工）流接口，提供了Writable和Readable所有功能，所以说它既是可读流也是可写流。\n\nNet.Socket对象同时在套接字服务器和客户端上创建，并且会允许数据在他们之间进行读取和写入，一旦Socket对象被创建，就提供了一些触发的事件。\n\n事件        描述\nlookup    解析域名后，连接前触发\nconnect   成功建立socket连接时触发\ndata      当收到数据时触发\nend       当socket另一点发送FIN包时\ntimeout   socket空闲超时\ndrain     写缓存为空的时候触发。\nerror     发生错误。\nclose     socket关闭\n\n 1. 服务器向客户端发送消息\n\nlet net = require('net');\nlet server = net.createServer();\nserver.on('connection',function(socket){\n    console.log('有客户端连接上来了');\n    console.log('客户端IP地址：'+socket.remoteAddress+'连接到了当前服务器');\n    socket.write('hello');\n});\nserver.on('listening',function () {\n    console.log('服务器监听成功了，正在等待客户端连接');\n});\nserver.listen(3000,'127.0.0.1');\n\n//然后启用Telnet客户端服务，命令行中输入：\n//telnet 127.0.0.1 3000\n\n//服务端输出\n//服务器监听成功了，正在等待客户端连接\n//有客户端连接上来了\n//客户端IP地址：127.0.0.1连接到了当前服务器\n\n//客户端输出\n//hello\n\n\n 2. 统计在线人数\n\nlet net = require('net');\nlet server = net.createServer();\nlet count = 0;\nserver.on('connection',function(socket){\n    count++;\n    console.log('welcome,当前在线人数：'+count);\n    socket.write('remoteAddress'+socket.remoteAddress+'\\n');\n    socket.write('remotePort'+socket.remotePort);\n});\nserver.listen(3000,'127.0.0.1',function() {\n    console.log('server listening at port 3000');\n});\n\n//然后启用两个Telnet客户端服务，命令行中输入：\n//telnet 127.0.0.1 3000\n\n//服务端输出\n/*\nserver listening at port 3000\nwelcome,当前在线人数：1\nwelcome,当前在线人数：2\n*/\n\n\n 3. 客户端与服务端双向通信\n\n创建客户端net.creatConnection()执行完毕会返回一个socket对象\n\n//服务端\nlet net = require('net');\nlet server = net.createServer();\nserver.on('connection',function(socket){\n    socket.on('data',function (data) {\n        console.log(data.toString());\n        socket.write('我吃的小豆包');\n    });\n});\nserver.listen(3000,'127.0.0.1',function() {\n    console.log('server listening at port 3000');\n});\n\n//客户端\nlet net = require('net');\nlet client = net.createConnection({\n    port:3000\n});\nclient.on('connect',function () {\n    console.log('客户端与服务器连接成功了');\n    client.write('你吃了吗');\n});\nclient.on('data',function (data) {\n    console.log(data.toString());\n});\n\n\n\n# Node.js进程管理\n\n\n# Process模块获取终端输入\n\n如果需要在客户端输入信息发送到服务器，这样的功能就需要依赖Process模块来完成。\n\nProcess模块是一个无须使用require就可以访问的全局对象。\n\nprocess.stdin.on('data',function(data){\n    console.log(data.toString().trim());//trim是去掉输入后按的空格\n});\n\n\n\n# 多人广播消息\n\n服务端接收客户端消息，将客户端消息发送给其他客户端\n\n//服务端\nlet net = require('net');\nlet server = net.createServer();\n//该数组用来封装所有客户端的scoket\nlet users = [];\nserver.on('connection',function (socket) {\n    users.push(socket);\n    socket.on('data',function (data) {\n        data = data.toString().trim();\n        users.forEach(function (client) {\n            if(client !== socket){\n                //不同客户端端口号不同\n                client.write(client.remotePort+':'+data);\n            }\n        });\n    });\n    socket.on('error',function () {\n        console.log('有客户端退出了');\n    });\n})\nserver.listen(3000,'127.0.0.1',function () {\n    console.log('server listening at port 3000');\n})\n\n//客户端\nlet net = require('net');\n//向服务端创建连接\nlet client = net.createConnection({\n    port:3000,\n    host:'127.0.0.1'\n});\nclient.on('connect',function(){\n    //通过当前进程的标准输入的data事件获取终端的输入\n    process.stdin.on('data',function (data) {\n        data = data.toString().trim();\n        client.write(data);\n    });\n});\nclient.on('data',function (data) {\n    console.log(data.toString());\n});\n\n//打开多个客户端，即可互相发送消息\n",normalizedContent:"# node.js网络编程基础\n\n\n# ip地址和端口号\n\n通过ip地址可以找到服务器设备，而端口号可以理解为在发送数据时定位到不同服务器应用程序的标识。\n\nip地址对于计算机是唯一的，一个端口号也只能被一个应用程序所占用。\n\n\n# 套接字socket简单模型\n\n先了解一下tcp/ip协议，tcp（transfer control protocol）传输控制协议是一种稳定可靠的传送方式，tcp负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地为止。\n\nsocket原意为孔或插座。在程序方面可理解为接口对象，在网络编程中通常称为套接字，常用于描述ip地址和端口等。socket是支持tcp/ip的网络通信的基本操作单元。简单理解，socket就是对tcp/ip协议的封装，socket本身并不是协议，而是一个调用接口\n\nsocket需要使用套接字地址来展开工作，套接字地址就是ip地址和端口号的组合，套接字服务与其他服务不同，不需要处理网络中的get或post请求，而是采用点对点传输数据方式。\n\n\n# node.js名字的由来\n\nnode.js诞生的目的就是为了更加高效的处理网络数据，因为使用它进行网络编程时不需要使用其他的服务器软件进行支持，node.js本身就是一个服务器。在进行网络编程时，每一个进程构成网络应用中的一个结点，而node就是结点的意思，最终web.js更名为node.js。\n\n\n# node.js中实现套接字服务\n\n套接字服务由net模块提供：\n\nlet net = require('net');\n\n\n# net.server对象\n\nlet server = net.creatserver()\n\n当server对象被创建后，在该服务器的生命周期中就存在了一些可触发的事件。\n\n事件           描述\nlistening    当服务器调用server.listen绑定后会触发\nconnection   当新连接创建后会被触发\nclose        服务器关闭时会被触发\nerror        发生错误时触发\n\nlet net = require('net');\nlet server = net.createserver();\nserver.on('connection',function(){\n    console.log('有客户端连接上来了');\n});\nserver.on('listening',function () {\n    console.log('服务器监听成功了，正在等待客户端连接');\n});\nserver.listen(3000,'127.0.0.1');\n\n\n然后启用telnet客户端服务，命令行中输入：\n\n> telnet 127.0.0.1 3000\n\n就会连接成功。\n\n\n# net.socket对象\n\nnet.socket实例实现了一duplex（双工）流接口，提供了writable和readable所有功能，所以说它既是可读流也是可写流。\n\nnet.socket对象同时在套接字服务器和客户端上创建，并且会允许数据在他们之间进行读取和写入，一旦socket对象被创建，就提供了一些触发的事件。\n\n事件        描述\nlookup    解析域名后，连接前触发\nconnect   成功建立socket连接时触发\ndata      当收到数据时触发\nend       当socket另一点发送fin包时\ntimeout   socket空闲超时\ndrain     写缓存为空的时候触发。\nerror     发生错误。\nclose     socket关闭\n\n 1. 服务器向客户端发送消息\n\nlet net = require('net');\nlet server = net.createserver();\nserver.on('connection',function(socket){\n    console.log('有客户端连接上来了');\n    console.log('客户端ip地址：'+socket.remoteaddress+'连接到了当前服务器');\n    socket.write('hello');\n});\nserver.on('listening',function () {\n    console.log('服务器监听成功了，正在等待客户端连接');\n});\nserver.listen(3000,'127.0.0.1');\n\n//然后启用telnet客户端服务，命令行中输入：\n//telnet 127.0.0.1 3000\n\n//服务端输出\n//服务器监听成功了，正在等待客户端连接\n//有客户端连接上来了\n//客户端ip地址：127.0.0.1连接到了当前服务器\n\n//客户端输出\n//hello\n\n\n 2. 统计在线人数\n\nlet net = require('net');\nlet server = net.createserver();\nlet count = 0;\nserver.on('connection',function(socket){\n    count++;\n    console.log('welcome,当前在线人数：'+count);\n    socket.write('remoteaddress'+socket.remoteaddress+'\\n');\n    socket.write('remoteport'+socket.remoteport);\n});\nserver.listen(3000,'127.0.0.1',function() {\n    console.log('server listening at port 3000');\n});\n\n//然后启用两个telnet客户端服务，命令行中输入：\n//telnet 127.0.0.1 3000\n\n//服务端输出\n/*\nserver listening at port 3000\nwelcome,当前在线人数：1\nwelcome,当前在线人数：2\n*/\n\n\n 3. 客户端与服务端双向通信\n\n创建客户端net.creatconnection()执行完毕会返回一个socket对象\n\n//服务端\nlet net = require('net');\nlet server = net.createserver();\nserver.on('connection',function(socket){\n    socket.on('data',function (data) {\n        console.log(data.tostring());\n        socket.write('我吃的小豆包');\n    });\n});\nserver.listen(3000,'127.0.0.1',function() {\n    console.log('server listening at port 3000');\n});\n\n//客户端\nlet net = require('net');\nlet client = net.createconnection({\n    port:3000\n});\nclient.on('connect',function () {\n    console.log('客户端与服务器连接成功了');\n    client.write('你吃了吗');\n});\nclient.on('data',function (data) {\n    console.log(data.tostring());\n});\n\n\n\n# node.js进程管理\n\n\n# process模块获取终端输入\n\n如果需要在客户端输入信息发送到服务器，这样的功能就需要依赖process模块来完成。\n\nprocess模块是一个无须使用require就可以访问的全局对象。\n\nprocess.stdin.on('data',function(data){\n    console.log(data.tostring().trim());//trim是去掉输入后按的空格\n});\n\n\n\n# 多人广播消息\n\n服务端接收客户端消息，将客户端消息发送给其他客户端\n\n//服务端\nlet net = require('net');\nlet server = net.createserver();\n//该数组用来封装所有客户端的scoket\nlet users = [];\nserver.on('connection',function (socket) {\n    users.push(socket);\n    socket.on('data',function (data) {\n        data = data.tostring().trim();\n        users.foreach(function (client) {\n            if(client !== socket){\n                //不同客户端端口号不同\n                client.write(client.remoteport+':'+data);\n            }\n        });\n    });\n    socket.on('error',function () {\n        console.log('有客户端退出了');\n    });\n})\nserver.listen(3000,'127.0.0.1',function () {\n    console.log('server listening at port 3000');\n})\n\n//客户端\nlet net = require('net');\n//向服务端创建连接\nlet client = net.createconnection({\n    port:3000,\n    host:'127.0.0.1'\n});\nclient.on('connect',function(){\n    //通过当前进程的标准输入的data事件获取终端的输入\n    process.stdin.on('data',function (data) {\n        data = data.tostring().trim();\n        client.write(data);\n    });\n});\nclient.on('data',function (data) {\n    console.log(data.tostring());\n});\n\n//打开多个客户端，即可互相发送消息\n",charsets:{cjk:!0}},{title:"Node.js文件操作",frontmatter:{title:"Node.js文件操作",date:"2019-05-04T16:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-5.html",relativePath:"node/node-5.md",key:"v-1f9aecc2",path:"/node/node-5.html",headers:[{level:2,title:"同步文件写入",slug:"同步文件写入",normalizedTitle:"同步文件写入",charIndex:142},{level:2,title:"异步文件写入",slug:"异步文件写入",normalizedTitle:"异步文件写入",charIndex:319},{level:2,title:"控制歌词滚动",slug:"控制歌词滚动",normalizedTitle:"控制歌词滚动",charIndex:587}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"同步文件写入 异步文件写入 控制歌词滚动",content:"Node.js的文件操作API由fs（File System）模块提供，该模块提供的函数均有异步和同步版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。实际开发中建议大家使用异步函数，性能更高，速度更快，而且没有阻塞。\n\n\n# 同步文件写入\n\n//同步API必须使用try...catch来捕获异常\nvar fs = require('fs');\ntry{\n    console.log('写入文件...');\n    fs.writeFileSync('路径','内容');\n}catch(e){\n    console.log('不好意思，文件写入失败了');\n}\n\n\n\n# 异步文件写入\n\n//异步文件写入函数多了一个回调函数\nvar fs = require('fs');\nconsole.log(1);\n//该方法中回调函数的第一个参数为错误对象\nfs.write('路径','内容',function(err){\n    if(err){\n        console.log('不好意思，文件写入失败了');\n    }\n    console.log(2);\n});\nconsole.log(3);\n//输出132\n\n\n其他的一些文件操作在此就不细写了，上网随时可查，下面做一个实际例子。\n\n\n# 控制歌词滚动\n\n歌词格式\n\n> [ti:自由(Live)] [ar:梁咏琪] [al:蒙面歌王第八期] [by:果果1314] [00:00.00]梁咏琪 - 自由(Live) [00:03.00]歌词编辑：果果 [00:06.00]QQ:765708831 [00:09.00]Lrc歌词网：www.90lrc.cn [00:12.00] [00:16.65]也许会恨你 [00:18.66]我知道我的脾气不是很好\n\n歌词随时间逐句输出\n\nlet fs = require('fs');\nfs.readFile('./lrc.txt',function (err,data) {\n    if(err){\n        return console.log('读取歌词文件失败了');\n    }\n    data = data.toString();\n    let lines = data.split('\\n');\n    //正则匹配，解析出毫秒\n    //需要里面的时间和里面的内容\n    let reg = /\\[(\\d{2})\\:(\\d{2})\\.(\\d{2})\\]\\s*(.+)/;\n    for(let i = 0;i < lines.length;i++){\n        //自执行函数\n        ;(function(index){\n            let line = lines[index];\n            let matches = reg.exec(line);\n            if(matches){\n                let m = parseFloat(matches[1]);\n                let s = parseFloat(matches[2]);\n                let ms = parseFloat(matches[3]);\n                let content = matches[4];\n                let time = m*60*1000 + s*1000 +ms;\n                setTimeout(function () {\n                    console.log(content);\n                },time);\n            }\n        })(i);\n    }\n})\n",normalizedContent:"node.js的文件操作api由fs（file system）模块提供，该模块提供的函数均有异步和同步版本，例如读取文件内容的函数有异步的fs.readfile()和同步的fs.readfilesync()。实际开发中建议大家使用异步函数，性能更高，速度更快，而且没有阻塞。\n\n\n# 同步文件写入\n\n//同步api必须使用try...catch来捕获异常\nvar fs = require('fs');\ntry{\n    console.log('写入文件...');\n    fs.writefilesync('路径','内容');\n}catch(e){\n    console.log('不好意思，文件写入失败了');\n}\n\n\n\n# 异步文件写入\n\n//异步文件写入函数多了一个回调函数\nvar fs = require('fs');\nconsole.log(1);\n//该方法中回调函数的第一个参数为错误对象\nfs.write('路径','内容',function(err){\n    if(err){\n        console.log('不好意思，文件写入失败了');\n    }\n    console.log(2);\n});\nconsole.log(3);\n//输出132\n\n\n其他的一些文件操作在此就不细写了，上网随时可查，下面做一个实际例子。\n\n\n# 控制歌词滚动\n\n歌词格式\n\n> [ti:自由(live)] [ar:梁咏琪] [al:蒙面歌王第八期] [by:果果1314] [00:00.00]梁咏琪 - 自由(live) [00:03.00]歌词编辑：果果 [00:06.00]qq:765708831 [00:09.00]lrc歌词网：www.90lrc.cn [00:12.00] [00:16.65]也许会恨你 [00:18.66]我知道我的脾气不是很好\n\n歌词随时间逐句输出\n\nlet fs = require('fs');\nfs.readfile('./lrc.txt',function (err,data) {\n    if(err){\n        return console.log('读取歌词文件失败了');\n    }\n    data = data.tostring();\n    let lines = data.split('\\n');\n    //正则匹配，解析出毫秒\n    //需要里面的时间和里面的内容\n    let reg = /\\[(\\d{2})\\:(\\d{2})\\.(\\d{2})\\]\\s*(.+)/;\n    for(let i = 0;i < lines.length;i++){\n        //自执行函数\n        ;(function(index){\n            let line = lines[index];\n            let matches = reg.exec(line);\n            if(matches){\n                let m = parsefloat(matches[1]);\n                let s = parsefloat(matches[2]);\n                let ms = parsefloat(matches[3]);\n                let content = matches[4];\n                let time = m*60*1000 + s*1000 +ms;\n                settimeout(function () {\n                    console.log(content);\n                },time);\n            }\n        })(i);\n    }\n})\n",charsets:{cjk:!0}},{title:"精读《深入浅出NodeJs》",frontmatter:{},regularPath:"/node/book.html",relativePath:"node/book.md",key:"v-2253c17f",path:"/node/book.html",headers:[{level:2,title:"第一章 Node 简介",slug:"第一章-node-简介",normalizedTitle:"第一章 node 简介",charIndex:21},{level:2,title:"第二章 模块机制",slug:"第二章-模块机制",normalizedTitle:"第二章 模块机制",charIndex:513},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:526},{level:3,title:"模块实现",slug:"模块实现",normalizedTitle:"模块实现",charIndex:846},{level:3,title:"缓存策略",slug:"缓存策略",normalizedTitle:"缓存策略",charIndex:1104},{level:3,title:"模块路径",slug:"模块路径",normalizedTitle:"模块路径",charIndex:1207},{level:3,title:"模块编译",slug:"模块编译",normalizedTitle:"模块编译",charIndex:1623},{level:3,title:"npm",slug:"npm",normalizedTitle:"npm",charIndex:2818},{level:2,title:"第三章 异步 I/O",slug:"第三章-异步-i-o",normalizedTitle:"第三章 异步 i/o",charIndex:2924},{level:3,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:3348},{level:3,title:"观察者",slug:"观察者",normalizedTitle:"观察者",charIndex:3353},{level:3,title:"请求对象",slug:"请求对象",normalizedTitle:"请求对象",charIndex:3357},{level:3,title:"执行回调",slug:"执行回调",normalizedTitle:"执行回调",charIndex:3362},{level:2,title:"非 I/O 的异步 API",slug:"非-i-o-的异步-api",normalizedTitle:"非 i/o 的异步 api",charIndex:4083},{level:3,title:"定时器",slug:"定时器",normalizedTitle:"定时器",charIndex:4220},{level:3,title:"process.nextTick",slug:"process-nexttick",normalizedTitle:"process.nexttick",charIndex:4199},{level:3,title:"setImmediate",slug:"setimmediate",normalizedTitle:"setimmediate",charIndex:4186},{level:2,title:"第五章 内存控制",slug:"第五章-内存控制",normalizedTitle:"第五章 内存控制",charIndex:4931},{level:3,title:"V8内存限制",slug:"v8内存限制",normalizedTitle:"v8内存限制",charIndex:5075},{level:3,title:"V8的对象分配",slug:"v8的对象分配",normalizedTitle:"v8的对象分配",charIndex:5196},{level:3,title:"V8的垃圾回收机制",slug:"v8的垃圾回收机制",normalizedTitle:"v8的垃圾回收机制",charIndex:5594}],lastUpdated:"3/9/2022, 11:41:37 AM",lastUpdatedTimestamp:1646797297e3,headersStr:"第一章 Node 简介 第二章 模块机制 基本概念 模块实现 缓存策略 模块路径 模块编译 npm 第三章 异步 I/O 事件循环 观察者 请求对象 执行回调 非 I/O 的异步 API 定时器 process.nextTick setImmediate 第五章 内存控制 V8内存限制 V8的对象分配 V8的垃圾回收机制",content:"# 精读《深入浅出NodeJs》\n\n\n# 第一章 Node 简介\n\n异步IO\n\n> Node 底层构建了许多异步 IO 的 API，从文件读取到网络请求，这样的意义在于，我们可以从语言层面很自然地进行并行 IO 操作，每个调用之前无须等待之前的 IO 调用结束，极大提升效率。\n\n事件驱动\n\n> Node 将前端浏览器中广泛且成熟的事件引入后端，配合异步 IO，将事件点暴露给业务逻辑。事件编程的方式具有轻量级，松耦合，只关注事务点等优势。\n\n单线程\n\n> 优点：单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来性能上的开销。\n> \n> 缺点：像浏览器中 js 与 UI 共用一个线程，js 长期执行会导致 UI 的渲染和响应被中断。在 Node 中，长时间的 CPU 占用也会导致后续的异步 IO 发不出调用，已完成的异步 IO 回调函数得不到及时执行。\n\n跨平台\n\n> Node 在 v0.6.0 版本支持了 windows 平台，这主要得益于 Node 架构层面的改动，它在操作系统与 Node 上层模块系统之间构建了一层平台层架构，即 libuv。\n\n\n# 第二章 模块机制\n\n\n# 基本概念\n\n模块引用\n\nvar math = require('math');\n\n\n模块定义：在 Node 中一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式\n\n// math.js\nexports.add = function() {};\n\n// program.js\nvar math = require('math');\nexports.increment = function (val) {\n  return math.add(val, 1);\n}\n\n\n模块标识\n\n模块标识其实就是传递给 require 方法的参数，必须符合小驼峰命名，可以是相对路径，绝对路径，可以没有后缀 .js\n\n\n# 模块实现\n\n在 Node 中引入模块，需要经历以下三个步骤：\n\n * 路径分析\n * 文件定位\n * 编译执行\n\n在 Node 中，模块又分为两类\n\n * 核心模块：Node 提供的模块\n * 文件模块：用户编写的模块\n\n> 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件，在 Node 进程启动时，部分核心模块就被直接加载进内存中，省略掉了文件定位和编译执行的步骤，且在路径分析中优先判断，故加载最快。\n> \n> 文件模块则需要完整的路径分析，文件定位，编译执行，速度比核心模块慢。\n\n\n# 缓存策略\n\n与前端浏览器会缓存静态脚本文件提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。\n\n\n# 模块路径\n\n模块标识符在 Node 中主要分为以下几类，核心模块，路径形式的文件模块，自定义模块，加载速度为：\n\n> 缓存过的模块 > 核心模块 > 路径形式文件模块 > 自定义模块\n\n原因是自定义模块 Node 在定位时使用模块路径的查找策略，具体表现为一个路径组成的数组。\n\n[\n  '/home/usr/research/node_modules',\n  '/home/usr/node_modules',\n  '/node_modules'\n]\n\n\n它生成的规则如下：\n\n * 当前文件目录下的 node_modules 目录\n * 父目录下的 node_modules 目录\n * 父目录的父目录下的 node_modules 目录\n * 沿路径向上逐级递归，直到根目录下的 node_modules 目录\n\n并且如果标识符不包含文件扩展名，Node 会按照 .js，.json，.node 的次序补足依次尝试。\n\n\n# 模块编译\n\n编译和执行是引入文件模块的最后一个阶段，对于不同的文件扩展名，载入方法也有所不同。\n\n * .js 文件：通过 fs 同步读取后编译执行\n * .node 文件：C/C++编写的扩展文件\n * .json 文件：通过 fs 同步读取后，JSON.parse 解析\n * 其余扩展名文件：均被当做 .js 文件载入\n\nJavaScript 模块\n\n在 CommonJS 规范中，每个模块文件都存在着 require、exports、modules、__filename、__dirname，它们是从何而来呢？事实上，Node 对获取的 JavaScript 文件进行了头尾包装，一个正常的 JavaScript 文件会被包装成如下：\n\n(function(exports, require, module, __filename, __dirname) {\n\t// 模块代码实际存在于此处\n});\n\n\n在执行之后，模块的 exports 属性被返回给了调用方，exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。\n\nmodule.exports.f = ... 可以更简洁地写成 exports.f = ... ，相当于每个模块中存在一句var exports = module.exports;，exports 对象是通过形参的方式传入的，如果直接赋值形参会改变形参的引用，等于切断了exports 与 module.exports 的联系。\n\nexports.hello = true; // 从模块的 require 中导出\nexports = { hello: false };  // 未导出，仅在模块中可用\n\n\nexports、module.exports和export、export default到底是咋回事\n\nC/C++ 模块\n\n.node的模块文件并不需要编译，因为他是 C/C++ 模块编译生成的，所以只有加载和执行的过程。Node 调用dlopen方法进行加载和执行。\n\n> *nix 下通过 gcc/g++ 等编译器编译为动态链接共享对象文件（.so），在 window 下则需要通过 Visual C++ 的编译器编译为动态链接库库文件（.dll），.node 扩展名其实只是为了看起来自然一些，在 *nix 下它是一个 .so 文件，在 windows 下它是一个 .dll 文件。dlopen 方法内部实现时也区分了平台。\n\n其实在应用中，可能会频繁的出现位运算的需求，包括转码，编码等过程。如果用 JavaScript 来实现，CPU 资源将会耗费很多（JavaScript 的位运算效率较低），此时 C/C++ 模块的优势就体现出来了，我们也可以自己编写 C++ 扩展模块来提升性能。\n\n\n# npm\n\nCommonJS包规范是理论，NPM 是其中的一种实践。对于 Node 而言，NPM 帮助完成了第三方模块的发布，安装和依赖等。借助 NPM ，Node 与第三方模块之间形成了很好的生态系统。\n\n\n# 第三章 异步 I/O\n\n假设业务场景中有一组互不相关的任务需要完成，一般有两种方法：\n\n * 单线程串行依次执行\n * 多线程并行完成\n\n多线程是首选的，但是代价在于创建线程和执行期线程上下文切换的开销较大，且面临锁、状态同步等问题。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率。\n\n单线程顺序执行缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞，在计算机资源中，通常I/O与CPU计算之间是可以并行执行的，但是同步的编程模型导致的问题是，I/O的进行会让后续任务继续等待，造成资源不能被更好地利用。\n\nNode 在两者之间给出了它的方案：利用单线程，远离多线程死锁，状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好得利用 CPU。异步 I/O 可以算作 Node 的特色，因为它是首个大规模将异步 I/O 应用在应用层上的平台，它力求在单线程上将资源分配得更高效。\n\n完成 Node 整个异步 I/O 环节需要：事件循环、观察者、请求对象、执行回调\n\n\n# 事件循环\n\n在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环的过程成为 Tick，每个 Tick 的过程就是查看是否有事件待处理，如果有就取出事件及回调函数并执行。\n\n\n# 观察者\n\n在每个 Tick 的过程中，如何判断是否有事件需要处理呢？这里就需要观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。\n\n\n# 请求对象\n\n如我们调用fs.open时，JavaScript 会调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在调用过程中创建了ESReqWrap请求对象。\n\n至此，JavaScript 调用立即返回，JavaScript 线程可以继续执行当前任务的后续操作。当前的 I/O 操作在线程池中等待执行，不管他是否阻塞 I/O ，都不回影响 JavaScript 线程的后续执行，如此达到了异步的目的。\n\n请求对象是异步 I/O 过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。\n\n\n# 执行回调\n\n组装好请求对象、送入 I/O 线程池等待执行，实际上完成了异步 I/O 的第一步，回调通知是第二步。\n\n这个过程中我们还调用了事件循环的 I/O 观察者，在每次 Tick 的执行中，它会检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。\n\n至此，整个异步 I/O 的流程完全结束。\n\n\n\n\n# 非 I/O 的异步 API\n\n尽管我们在介绍 Node 时，多数情况下都会提到异步 I/O，但是 Node 中其实还存在一些与 I/O 无关的异步 API。\n\nsetTimeout、setInterval、setImmediate、process.nextTick\n\n\n# 定时器\n\nsetTimeout、setInterval 的实现原理与异步 I/O 比较类似，只是不需要 I/O 线程池的参与，创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过立即执行回调函数。\n\n问题在于它并非精确的，尽管事件循环非常快，但是如果某次循环占用的时间过多，那么下次循环时，它也许已经超时很久了。比如 setTimeout 设定一个任务在 10 毫秒后执行，但是在 9 毫秒后，有一个任务占用了 5 毫秒的 CPU 时间片，时间就已经过期 4 毫秒。\n\n\n# process.nextTick\n\n定时器需要动用红黑树，创建定时器对象和迭代等操作，较为浪费性能。实际上，process.nextTick 更为轻量。\n\n每次调用 process.nextTick ，只会将回调函数放入队列，在下一轮 Tick 时取出执行。\n\n\n# setImmediate\n\nsetImmediate 与 process.nextTick 十分类似，只需记住 process.nextTick 观察者优先级高于 setImmediate\n\nprocess.nextTick(function() {\n  console.log('nextTick延迟执行');\n})\n\nsetImmediate(function() {\n  console.log('setImmediate延迟执行');\n})\n\nconsole.log('正常执行')\n\n// 正常执行\n// nextTick延迟执行\n// setImmediate延迟执行\n\n\n\n# 第五章 内存控制\n\nChrome 浏览器优异的性能背后离不开 V8，V8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能，在这样的契机下，Node 的作者选择了 JavaScript，选择了 V8，在事件驱动、非阻塞 I/O 模型的设计下实现了 Node。\n\n\n# V8内存限制\n\n在一般的后端开发语言中，内存使用基本没有什么限制，然而在 Node 中会有内存限制（64位系统下约为 1.4GB，32位系统下约为 0.7 GB），这会导致 Node 无法直接操作大内存对象，如读入 2GB 的文件。\n\n\n# V8的对象分配\n\n在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的，当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。至于 V8 为何要限制堆的大小，主要有两点原因：\n\n * 表层原因：V8 最初是为浏览器而设计，不太可能遇到用大量内存的场景。\n * 深层原因：V8 垃圾回收的限制，因为垃圾回收会引起 JavaScript 线程暂停执行，如果内存过大，垃圾回收需要的时间会越多，应用的性能和响应能力都会直线下降。\n\n当然也可以打开这个限制，不过需要注意这只是在启动时指定，无法在使用时根据情况自动扩充。\n\nnode --max-old-space-size=1700 test.js # 单位为 MB，用于设置老生代内存最大值\nnode --max-new-space-size=1024 test.js # 单位为 KB，用于设置新声代内存最大值\n\n\n\n# V8的垃圾回收机制\n\n在 V8 中主要将内存分为新生代和老生代，新生代中是存活时间较短的对象，老生代中是存活时间较长的或常驻内存的对象。在默认设置下：\n\n * 老生代在 64 位系统下为 1400 MB，在 32 位系统下为 700 MB\n * 新生代在 64 位系统下为 32 MB，在 32 位系统下为 16 MB\n\n这也就解释了为何在 64 位系统下只能使用约 1.4 GB内存和在 32 位系统下只能使用约 0.7 GB内存\n\n# Scavenge 算法\n\n在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 的具体实现中，主要采用了 Cheney 算法：\n\n> 内存一分为二：From 空间和 To 空间\n> \n> 分配对象时先在 From 空间分配，进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间，而非存活对象占用的空间将被释放，完成复制后，From 和 To 发生对换。\n\n这种算法的缺点是只能使用堆内存中的一半，典型的空间换取时间的算法，无法大规模应用到所有垃圾回收中。但是特别适合应用在新生代中，因为新生代中对象生命周期较短，恰恰适合这个算法。\n\n# 晋升\n\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象，这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象晋升的条件有2个：\n\n 1. 对象是否经历过 Scavenge 回收\n 2. To 空间的内存占用比超过限制\n\n> 当对象从 From 空间复制到 To 空间时，会检查它的内存地址是否已经经历过一次 Scavenge 回收，如果经历过了，将该对象从 From 空间复制到老生代空间中。\n> \n> 当对象从 From 空间复制到 To 空间时，如果 To 空间已经使用了超过 25%，则这个对象直接晋升到老生代中。（25% 原因是因为当这次回收完成后，这个 To 空间将变回 From 空间，接下来的内存分配将在这个空间内进行，如果占比过高，会影响后续的内存分配）\n\n# Mark Sweep & Mark-Compact\n\n标记清除\n\nMark Sweep 分为标记和清除两个阶段，在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。\n\n缺点：在进行一次标记清除时，内存空间会出现不连续的状态。如果后续需要分配一个大的对象，碎片空间无法完成分配。\n\n\n\n标记整理\n\n在标记清除的基础上，如果对象被标记死亡，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n\n\n回收算法     MARK-SWEEP   MARK-COMPACT   SCAVENGE\n速度       中等           最慢             最快\n空间开销     少（有碎片）       少（无碎片）         双倍空间（无碎片）\n是否移动对象   否            是              是\n\nMark-Compact 速度比 Mark-Sweep 慢，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足时对从新生代晋升过来的对象进行分配时才使用 Mark-Compact。\n\n# Incremental Marking\n\n为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，这种行为称作\"全停顿\"，为了降低这种停顿时间，V8 先从标记阶段入手，将原本要一口气完成的动作改为增量标记，也就是拆分成许多小\"步进\"，每做完一\"步进\"，就让 JavaScript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行。\n\n",normalizedContent:"# 精读《深入浅出nodejs》\n\n\n# 第一章 node 简介\n\n异步io\n\n> node 底层构建了许多异步 io 的 api，从文件读取到网络请求，这样的意义在于，我们可以从语言层面很自然地进行并行 io 操作，每个调用之前无须等待之前的 io 调用结束，极大提升效率。\n\n事件驱动\n\n> node 将前端浏览器中广泛且成熟的事件引入后端，配合异步 io，将事件点暴露给业务逻辑。事件编程的方式具有轻量级，松耦合，只关注事务点等优势。\n\n单线程\n\n> 优点：单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来性能上的开销。\n> \n> 缺点：像浏览器中 js 与 ui 共用一个线程，js 长期执行会导致 ui 的渲染和响应被中断。在 node 中，长时间的 cpu 占用也会导致后续的异步 io 发不出调用，已完成的异步 io 回调函数得不到及时执行。\n\n跨平台\n\n> node 在 v0.6.0 版本支持了 windows 平台，这主要得益于 node 架构层面的改动，它在操作系统与 node 上层模块系统之间构建了一层平台层架构，即 libuv。\n\n\n# 第二章 模块机制\n\n\n# 基本概念\n\n模块引用\n\nvar math = require('math');\n\n\n模块定义：在 node 中一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式\n\n// math.js\nexports.add = function() {};\n\n// program.js\nvar math = require('math');\nexports.increment = function (val) {\n  return math.add(val, 1);\n}\n\n\n模块标识\n\n模块标识其实就是传递给 require 方法的参数，必须符合小驼峰命名，可以是相对路径，绝对路径，可以没有后缀 .js\n\n\n# 模块实现\n\n在 node 中引入模块，需要经历以下三个步骤：\n\n * 路径分析\n * 文件定位\n * 编译执行\n\n在 node 中，模块又分为两类\n\n * 核心模块：node 提供的模块\n * 文件模块：用户编写的模块\n\n> 核心模块部分在 node 源代码的编译过程中，编译进了二进制执行文件，在 node 进程启动时，部分核心模块就被直接加载进内存中，省略掉了文件定位和编译执行的步骤，且在路径分析中优先判断，故加载最快。\n> \n> 文件模块则需要完整的路径分析，文件定位，编译执行，速度比核心模块慢。\n\n\n# 缓存策略\n\n与前端浏览器会缓存静态脚本文件提高性能一样，node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 node 缓存的是编译和执行之后的对象。\n\n\n# 模块路径\n\n模块标识符在 node 中主要分为以下几类，核心模块，路径形式的文件模块，自定义模块，加载速度为：\n\n> 缓存过的模块 > 核心模块 > 路径形式文件模块 > 自定义模块\n\n原因是自定义模块 node 在定位时使用模块路径的查找策略，具体表现为一个路径组成的数组。\n\n[\n  '/home/usr/research/node_modules',\n  '/home/usr/node_modules',\n  '/node_modules'\n]\n\n\n它生成的规则如下：\n\n * 当前文件目录下的 node_modules 目录\n * 父目录下的 node_modules 目录\n * 父目录的父目录下的 node_modules 目录\n * 沿路径向上逐级递归，直到根目录下的 node_modules 目录\n\n并且如果标识符不包含文件扩展名，node 会按照 .js，.json，.node 的次序补足依次尝试。\n\n\n# 模块编译\n\n编译和执行是引入文件模块的最后一个阶段，对于不同的文件扩展名，载入方法也有所不同。\n\n * .js 文件：通过 fs 同步读取后编译执行\n * .node 文件：c/c++编写的扩展文件\n * .json 文件：通过 fs 同步读取后，json.parse 解析\n * 其余扩展名文件：均被当做 .js 文件载入\n\njavascript 模块\n\n在 commonjs 规范中，每个模块文件都存在着 require、exports、modules、__filename、__dirname，它们是从何而来呢？事实上，node 对获取的 javascript 文件进行了头尾包装，一个正常的 javascript 文件会被包装成如下：\n\n(function(exports, require, module, __filename, __dirname) {\n\t// 模块代码实际存在于此处\n});\n\n\n在执行之后，模块的 exports 属性被返回给了调用方，exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。\n\nmodule.exports.f = ... 可以更简洁地写成 exports.f = ... ，相当于每个模块中存在一句var exports = module.exports;，exports 对象是通过形参的方式传入的，如果直接赋值形参会改变形参的引用，等于切断了exports 与 module.exports 的联系。\n\nexports.hello = true; // 从模块的 require 中导出\nexports = { hello: false };  // 未导出，仅在模块中可用\n\n\nexports、module.exports和export、export default到底是咋回事\n\nc/c++ 模块\n\n.node的模块文件并不需要编译，因为他是 c/c++ 模块编译生成的，所以只有加载和执行的过程。node 调用dlopen方法进行加载和执行。\n\n> *nix 下通过 gcc/g++ 等编译器编译为动态链接共享对象文件（.so），在 window 下则需要通过 visual c++ 的编译器编译为动态链接库库文件（.dll），.node 扩展名其实只是为了看起来自然一些，在 *nix 下它是一个 .so 文件，在 windows 下它是一个 .dll 文件。dlopen 方法内部实现时也区分了平台。\n\n其实在应用中，可能会频繁的出现位运算的需求，包括转码，编码等过程。如果用 javascript 来实现，cpu 资源将会耗费很多（javascript 的位运算效率较低），此时 c/c++ 模块的优势就体现出来了，我们也可以自己编写 c++ 扩展模块来提升性能。\n\n\n# npm\n\ncommonjs包规范是理论，npm 是其中的一种实践。对于 node 而言，npm 帮助完成了第三方模块的发布，安装和依赖等。借助 npm ，node 与第三方模块之间形成了很好的生态系统。\n\n\n# 第三章 异步 i/o\n\n假设业务场景中有一组互不相关的任务需要完成，一般有两种方法：\n\n * 单线程串行依次执行\n * 多线程并行完成\n\n多线程是首选的，但是代价在于创建线程和执行期线程上下文切换的开销较大，且面临锁、状态同步等问题。但是多线程在多核 cpu 上能够有效提升 cpu 的利用率。\n\n单线程顺序执行缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞，在计算机资源中，通常i/o与cpu计算之间是可以并行执行的，但是同步的编程模型导致的问题是，i/o的进行会让后续任务继续等待，造成资源不能被更好地利用。\n\nnode 在两者之间给出了它的方案：利用单线程，远离多线程死锁，状态同步等问题；利用异步 i/o，让单线程远离阻塞，以更好得利用 cpu。异步 i/o 可以算作 node 的特色，因为它是首个大规模将异步 i/o 应用在应用层上的平台，它力求在单线程上将资源分配得更高效。\n\n完成 node 整个异步 i/o 环节需要：事件循环、观察者、请求对象、执行回调\n\n\n# 事件循环\n\n在进程启动时，node 便会创建一个类似于 while(true) 的循环，每执行一次循环的过程成为 tick，每个 tick 的过程就是查看是否有事件待处理，如果有就取出事件及回调函数并执行。\n\n\n# 观察者\n\n在每个 tick 的过程中，如何判断是否有事件需要处理呢？这里就需要观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。\n\n\n# 请求对象\n\n如我们调用fs.open时，javascript 会调用 node 的核心模块，核心模块调用 c++ 内建模块，内建模块通过 libuv 进行系统调用，libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在调用过程中创建了esreqwrap请求对象。\n\n至此，javascript 调用立即返回，javascript 线程可以继续执行当前任务的后续操作。当前的 i/o 操作在线程池中等待执行，不管他是否阻塞 i/o ，都不回影响 javascript 线程的后续执行，如此达到了异步的目的。\n\n请求对象是异步 i/o 过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及i/o操作完毕后的回调处理。\n\n\n# 执行回调\n\n组装好请求对象、送入 i/o 线程池等待执行，实际上完成了异步 i/o 的第一步，回调通知是第二步。\n\n这个过程中我们还调用了事件循环的 i/o 观察者，在每次 tick 的执行中，它会检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 i/o 观察者的队列中，然后将其当作事件处理。\n\n至此，整个异步 i/o 的流程完全结束。\n\n\n\n\n# 非 i/o 的异步 api\n\n尽管我们在介绍 node 时，多数情况下都会提到异步 i/o，但是 node 中其实还存在一些与 i/o 无关的异步 api。\n\nsettimeout、setinterval、setimmediate、process.nexttick\n\n\n# 定时器\n\nsettimeout、setinterval 的实现原理与异步 i/o 比较类似，只是不需要 i/o 线程池的参与，创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 tick 执行时从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过立即执行回调函数。\n\n问题在于它并非精确的，尽管事件循环非常快，但是如果某次循环占用的时间过多，那么下次循环时，它也许已经超时很久了。比如 settimeout 设定一个任务在 10 毫秒后执行，但是在 9 毫秒后，有一个任务占用了 5 毫秒的 cpu 时间片，时间就已经过期 4 毫秒。\n\n\n# process.nexttick\n\n定时器需要动用红黑树，创建定时器对象和迭代等操作，较为浪费性能。实际上，process.nexttick 更为轻量。\n\n每次调用 process.nexttick ，只会将回调函数放入队列，在下一轮 tick 时取出执行。\n\n\n# setimmediate\n\nsetimmediate 与 process.nexttick 十分类似，只需记住 process.nexttick 观察者优先级高于 setimmediate\n\nprocess.nexttick(function() {\n  console.log('nexttick延迟执行');\n})\n\nsetimmediate(function() {\n  console.log('setimmediate延迟执行');\n})\n\nconsole.log('正常执行')\n\n// 正常执行\n// nexttick延迟执行\n// setimmediate延迟执行\n\n\n\n# 第五章 内存控制\n\nchrome 浏览器优异的性能背后离不开 v8，v8 的性能优势使得用 javascript 写高性能后台服务程序成为可能，在这样的契机下，node 的作者选择了 javascript，选择了 v8，在事件驱动、非阻塞 i/o 模型的设计下实现了 node。\n\n\n# v8内存限制\n\n在一般的后端开发语言中，内存使用基本没有什么限制，然而在 node 中会有内存限制（64位系统下约为 1.4gb，32位系统下约为 0.7 gb），这会导致 node 无法直接操作大内存对象，如读入 2gb 的文件。\n\n\n# v8的对象分配\n\n在 v8 中，所有的 javascript 对象都是通过堆来进行分配的，当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。至于 v8 为何要限制堆的大小，主要有两点原因：\n\n * 表层原因：v8 最初是为浏览器而设计，不太可能遇到用大量内存的场景。\n * 深层原因：v8 垃圾回收的限制，因为垃圾回收会引起 javascript 线程暂停执行，如果内存过大，垃圾回收需要的时间会越多，应用的性能和响应能力都会直线下降。\n\n当然也可以打开这个限制，不过需要注意这只是在启动时指定，无法在使用时根据情况自动扩充。\n\nnode --max-old-space-size=1700 test.js # 单位为 mb，用于设置老生代内存最大值\nnode --max-new-space-size=1024 test.js # 单位为 kb，用于设置新声代内存最大值\n\n\n\n# v8的垃圾回收机制\n\n在 v8 中主要将内存分为新生代和老生代，新生代中是存活时间较短的对象，老生代中是存活时间较长的或常驻内存的对象。在默认设置下：\n\n * 老生代在 64 位系统下为 1400 mb，在 32 位系统下为 700 mb\n * 新生代在 64 位系统下为 32 mb，在 32 位系统下为 16 mb\n\n这也就解释了为何在 64 位系统下只能使用约 1.4 gb内存和在 32 位系统下只能使用约 0.7 gb内存\n\n# scavenge 算法\n\n在分代的基础上，新生代的对象主要通过 scavenge 算法进行垃圾回收，在 scavenge 的具体实现中，主要采用了 cheney 算法：\n\n> 内存一分为二：from 空间和 to 空间\n> \n> 分配对象时先在 from 空间分配，进行垃圾回收时，会检查 from 空间中的存活对象，这些存活对象将被复制到 to 空间，而非存活对象占用的空间将被释放，完成复制后，from 和 to 发生对换。\n\n这种算法的缺点是只能使用堆内存中的一半，典型的空间换取时间的算法，无法大规模应用到所有垃圾回收中。但是特别适合应用在新生代中，因为新生代中对象生命周期较短，恰恰适合这个算法。\n\n# 晋升\n\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象，这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象晋升的条件有2个：\n\n 1. 对象是否经历过 scavenge 回收\n 2. to 空间的内存占用比超过限制\n\n> 当对象从 from 空间复制到 to 空间时，会检查它的内存地址是否已经经历过一次 scavenge 回收，如果经历过了，将该对象从 from 空间复制到老生代空间中。\n> \n> 当对象从 from 空间复制到 to 空间时，如果 to 空间已经使用了超过 25%，则这个对象直接晋升到老生代中。（25% 原因是因为当这次回收完成后，这个 to 空间将变回 from 空间，接下来的内存分配将在这个空间内进行，如果占比过高，会影响后续的内存分配）\n\n# mark sweep & mark-compact\n\n标记清除\n\nmark sweep 分为标记和清除两个阶段，在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。\n\n缺点：在进行一次标记清除时，内存空间会出现不连续的状态。如果后续需要分配一个大的对象，碎片空间无法完成分配。\n\n\n\n标记整理\n\n在标记清除的基础上，如果对象被标记死亡，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n\n\n回收算法     mark-sweep   mark-compact   scavenge\n速度       中等           最慢             最快\n空间开销     少（有碎片）       少（无碎片）         双倍空间（无碎片）\n是否移动对象   否            是              是\n\nmark-compact 速度比 mark-sweep 慢，所以在取舍上，v8 主要使用 mark-sweep，在空间不足时对从新生代晋升过来的对象进行分配时才使用 mark-compact。\n\n# incremental marking\n\n为了避免出现 javascript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，这种行为称作\"全停顿\"，为了降低这种停顿时间，v8 先从标记阶段入手，将原本要一口气完成的动作改为增量标记，也就是拆分成许多小\"步进\"，每做完一\"步进\"，就让 javascript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行。\n\n",charsets:{cjk:!0}},{title:"Node.js中处理数据I/O",frontmatter:{title:"Node.js中处理数据I/O",date:"2019-05-05T16:00:54.000Z",categories:"Node.js"},regularPath:"/node/node-6.html",relativePath:"node/node-6.md",key:"v-02ff5082",path:"/node/node-6.html",headers:[{level:2,title:"Buffer的构造函数",slug:"buffer的构造函数",normalizedTitle:"buffer的构造函数",charIndex:153},{level:2,title:"写入缓冲区",slug:"写入缓冲区",normalizedTitle:"写入缓冲区",charIndex:538},{level:2,title:"从缓冲区读取数据",slug:"从缓冲区读取数据",normalizedTitle:"从缓冲区读取数据",charIndex:829},{level:2,title:"拼接缓冲区",slug:"拼接缓冲区",normalizedTitle:"拼接缓冲区",charIndex:1091},{level:2,title:"文件流的概念",slug:"文件流的概念",normalizedTitle:"文件流的概念",charIndex:1367},{level:2,title:"Node.js的可读流和可写流",slug:"node-js的可读流和可写流",normalizedTitle:"node.js的可读流和可写流",charIndex:1820},{level:2,title:"使用pipe()处理大文件",slug:"使用pipe-处理大文件",normalizedTitle:"使用pipe()处理大文件",charIndex:3055}],lastUpdated:"9/29/2021, 7:43:24 PM",lastUpdatedTimestamp:1632915804e3,headersStr:"Buffer的构造函数 写入缓冲区 从缓冲区读取数据 拼接缓冲区 文件流的概念 Node.js的可读流和可写流 使用pipe()处理大文件",content:"Node.js中提供了处理文件和网络I/O的功能，因此需要处理大量的二进制数据。在Node.js中，Buffer缓冲区和Stream文件流对二进制数据的处理提供了很好的支持。\n\n\n# Buffer缓冲区\n\nBuffer类是随Node.js内核一起发布的核心库，用于支持I/O操作中移动的数据处理。\n\n\n# Buffer的构造函数\n\nNode.js中的Buffer缓冲区模块，支持开发者在缓冲区结构中创建，读取，写入和操作二进制数据，该模块是全局性的，所以在使用时不需要require（）函数来加载。\n\n 1. 传入字节\n\nvar buf = new Buffer(size);\n\n\n 2. 传入数组\n\nvar buf = new Buffer([10,20,30,40,50]);\n\n\n 3. 传入字符串和编码\n\nvar buf = new Buffer(\"hello\",\"utf-8\");\n\n\nBuffer同样支持以下编码：\n\n * ascii：7位ASCII字符\n * utf16le：两个字节，16位小端字节序\n * usc2：两个字节，以小尾字节序编码的Unicode字符\n * base64：用于传输8字节代码的编码方式之一\n * hex：Hex字符串编码\n\n\n# 写入缓冲区\n\nbuf.write(string,offset,length,encoding) //字符串，索引值，字节数，编码\n\nvar buf = new Buffer(5);\nconsole.log(buf.length);\nbuf.write('a');\nconsole.log(buf);\n//写入b时需要在第二个参数传入缓冲区开始写入的索引值\nbuf.write('b',1,1,'ascii');\nconsole.log(buf);\n\n//输出\n//5\n//<Buffer 61 00 00 00 00>\n//<Buffer 61 62 00 00 00>\n\n\n\n# 从缓冲区读取数据\n\nbuf.toString(encoding,start,end)\n\nvar buf = new Buffer(26);\nfor(let i = 0; i < 26 ; i++){\n    buf[i] = i + 97;\n}\n//输出全部\nconsole.log(buf.toString('ascii'));\n//输出前5个\nconsole.log(buf.toString('ascii',0,5));\n\n//输出\n//abcdefghijklmnopqrstuvwxyz\n//abcde\n\n\n\n# 拼接缓冲区\n\nvar buf = new Buffer('世上无难事');\nvar buf1 = new Buffer('只怕有心人');\nvar buf2 = Buffer.concat([buf,buf1]);\nconsole.log(buf2.toString());\n//输出：世上无难事只怕有心人\n\n\n\n# Stream文件流\n\n由于Buffer缓冲区限制在1GB，超过1GB的文件无法直接完成读写操作，在读写大文件时，如果读写资源一直持续不停止，Node.js将无法继续其他工作，为此Node.js中提供了Stream文件流模块。\n\n\n# 文件流的概念\n\n例如复制文件的过程，文件流的概念就是文件A中数据以流动的方式通过数据流管道，然后进入到文件B中，采用”读一部分，写一部分“的方式，就像看视频，下一点播一点。\n\n在Node.js中，文件流的操作由Stream模块提供，Stream模块是一个抽象接口，Node.js中还有很多对象实现了这个接口，有4种流类型：\n\n * Readable: 可读流\n * Writeable：可写流\n * Duplex：可读可写流\n * Transform：变换流（操作被写入数据，然后读出结果）\n\nNode.js中的I/O是异步的，因此对磁盘和网络的读/写需要通过回调函数来读取数据，而回调函数需要通过事件来触发，所有的Stream对象都是EventEmitter(时间触发器)的实例。\n\n事件       说明\ndata     当有数据可读时触发\nend      没有更多的数据可读时触发\nerror    在接收和写入过程中发生错误时触发\nfinish   所有数据都已被写入到低层系统时触发\n\n\n# Node.js的可读流和可写流\n\n 1. 可读流\n\n使用文件流进行文件复制，首先需要创建一个可读流，可读流可以让用户在源文件中分块读取文件中的数据，然后再从可读流中读取数据。\n\nfs.createReadStream()\n\n由于流是基于EventEmitter的，从流读取数据最好的方法是监听数据事件（data event），并附加一个回调函数，返回数据，这个操作是循环进制的，一直到读取完毕。在读取错误或读取完毕时触发error或end事件。\n\nlet fs= require(\"fs\");\nlet total = \"\";\n//创建可读流\nlet readableStream = fs.createReadStream('input.txt');//此时流为静止状态\n//设置编码为utf-8\nreadableStream.setEncoding('UTF8');\n//处理流事件\nreadableStream.on('data',function (chunk) {//附加回调函数，流开始流动\n    total += chunk;\n});\nreadableStream.on('end',function () {\n    console.log(total);\n});\nreadableStream.on('error',function (err) {\n    console.log(err.stack);\n});\nconsole.log(\"程序执行完毕\");\n\n//输出：程序执行完毕\n//input.txt中的内容\n\n\n 2. 可写流\n\nfs.createWriteStream()\n\nlet fs= require(\"fs\");\nlet total = \"\";\n//创建可读流\nlet readableStream = fs.createReadStream('input.txt');\n//创建可写流\nlet writableStream = fs.createWriteStream('output.txt');\n//设置编码为utf-8\nreadableStream.setEncoding('UTF8');\nreadableStream.on('data',function (chunk) {\n    writableStream.write(chunk);\n});\nreadableStream.on('error',function (err) {\n    console.log(err.stack);\n});\nreadableStream.on('end',function () {\n    writableStream.end();//将剩下的数据全部写入\n});\nwritableStream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n\n\n# 使用pipe()处理大文件\n\n在使用大文件复制的案例中，通过可读流的chunk参数来传递数据，如果把数据比作是水，chunk相当于盆，使用盆来完成水的传递。可读流中还有一个函数叫做pipe()，这个函数是一个很高效的文件处理方式，简化复制文件的操作，“把盆换成了管子”。\n\nlet fs = require('fs');\nlet srcPath = '';\nlet distPath = '';\nlet readableStream = fs.createReadStream(srcPath);\nlet writableStream = fs.createWriteStream(distPath);\n//可以通过使用可读流函数pipe()接入到可写流中\nif(readableStream.pipe(writableStream)){\n    console.log('复制成功');\n}else{\n    console.log('复制失败');\n}\n\n\n\n# 小结\n\n数据与文件的处理是服务器端编程与客户端编程的本质区别所在。",normalizedContent:"node.js中提供了处理文件和网络i/o的功能，因此需要处理大量的二进制数据。在node.js中，buffer缓冲区和stream文件流对二进制数据的处理提供了很好的支持。\n\n\n# buffer缓冲区\n\nbuffer类是随node.js内核一起发布的核心库，用于支持i/o操作中移动的数据处理。\n\n\n# buffer的构造函数\n\nnode.js中的buffer缓冲区模块，支持开发者在缓冲区结构中创建，读取，写入和操作二进制数据，该模块是全局性的，所以在使用时不需要require（）函数来加载。\n\n 1. 传入字节\n\nvar buf = new buffer(size);\n\n\n 2. 传入数组\n\nvar buf = new buffer([10,20,30,40,50]);\n\n\n 3. 传入字符串和编码\n\nvar buf = new buffer(\"hello\",\"utf-8\");\n\n\nbuffer同样支持以下编码：\n\n * ascii：7位ascii字符\n * utf16le：两个字节，16位小端字节序\n * usc2：两个字节，以小尾字节序编码的unicode字符\n * base64：用于传输8字节代码的编码方式之一\n * hex：hex字符串编码\n\n\n# 写入缓冲区\n\nbuf.write(string,offset,length,encoding) //字符串，索引值，字节数，编码\n\nvar buf = new buffer(5);\nconsole.log(buf.length);\nbuf.write('a');\nconsole.log(buf);\n//写入b时需要在第二个参数传入缓冲区开始写入的索引值\nbuf.write('b',1,1,'ascii');\nconsole.log(buf);\n\n//输出\n//5\n//<buffer 61 00 00 00 00>\n//<buffer 61 62 00 00 00>\n\n\n\n# 从缓冲区读取数据\n\nbuf.tostring(encoding,start,end)\n\nvar buf = new buffer(26);\nfor(let i = 0; i < 26 ; i++){\n    buf[i] = i + 97;\n}\n//输出全部\nconsole.log(buf.tostring('ascii'));\n//输出前5个\nconsole.log(buf.tostring('ascii',0,5));\n\n//输出\n//abcdefghijklmnopqrstuvwxyz\n//abcde\n\n\n\n# 拼接缓冲区\n\nvar buf = new buffer('世上无难事');\nvar buf1 = new buffer('只怕有心人');\nvar buf2 = buffer.concat([buf,buf1]);\nconsole.log(buf2.tostring());\n//输出：世上无难事只怕有心人\n\n\n\n# stream文件流\n\n由于buffer缓冲区限制在1gb，超过1gb的文件无法直接完成读写操作，在读写大文件时，如果读写资源一直持续不停止，node.js将无法继续其他工作，为此node.js中提供了stream文件流模块。\n\n\n# 文件流的概念\n\n例如复制文件的过程，文件流的概念就是文件a中数据以流动的方式通过数据流管道，然后进入到文件b中，采用”读一部分，写一部分“的方式，就像看视频，下一点播一点。\n\n在node.js中，文件流的操作由stream模块提供，stream模块是一个抽象接口，node.js中还有很多对象实现了这个接口，有4种流类型：\n\n * readable: 可读流\n * writeable：可写流\n * duplex：可读可写流\n * transform：变换流（操作被写入数据，然后读出结果）\n\nnode.js中的i/o是异步的，因此对磁盘和网络的读/写需要通过回调函数来读取数据，而回调函数需要通过事件来触发，所有的stream对象都是eventemitter(时间触发器)的实例。\n\n事件       说明\ndata     当有数据可读时触发\nend      没有更多的数据可读时触发\nerror    在接收和写入过程中发生错误时触发\nfinish   所有数据都已被写入到低层系统时触发\n\n\n# node.js的可读流和可写流\n\n 1. 可读流\n\n使用文件流进行文件复制，首先需要创建一个可读流，可读流可以让用户在源文件中分块读取文件中的数据，然后再从可读流中读取数据。\n\nfs.createreadstream()\n\n由于流是基于eventemitter的，从流读取数据最好的方法是监听数据事件（data event），并附加一个回调函数，返回数据，这个操作是循环进制的，一直到读取完毕。在读取错误或读取完毕时触发error或end事件。\n\nlet fs= require(\"fs\");\nlet total = \"\";\n//创建可读流\nlet readablestream = fs.createreadstream('input.txt');//此时流为静止状态\n//设置编码为utf-8\nreadablestream.setencoding('utf8');\n//处理流事件\nreadablestream.on('data',function (chunk) {//附加回调函数，流开始流动\n    total += chunk;\n});\nreadablestream.on('end',function () {\n    console.log(total);\n});\nreadablestream.on('error',function (err) {\n    console.log(err.stack);\n});\nconsole.log(\"程序执行完毕\");\n\n//输出：程序执行完毕\n//input.txt中的内容\n\n\n 2. 可写流\n\nfs.createwritestream()\n\nlet fs= require(\"fs\");\nlet total = \"\";\n//创建可读流\nlet readablestream = fs.createreadstream('input.txt');\n//创建可写流\nlet writablestream = fs.createwritestream('output.txt');\n//设置编码为utf-8\nreadablestream.setencoding('utf8');\nreadablestream.on('data',function (chunk) {\n    writablestream.write(chunk);\n});\nreadablestream.on('error',function (err) {\n    console.log(err.stack);\n});\nreadablestream.on('end',function () {\n    writablestream.end();//将剩下的数据全部写入\n});\nwritablestream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n\n\n# 使用pipe()处理大文件\n\n在使用大文件复制的案例中，通过可读流的chunk参数来传递数据，如果把数据比作是水，chunk相当于盆，使用盆来完成水的传递。可读流中还有一个函数叫做pipe()，这个函数是一个很高效的文件处理方式，简化复制文件的操作，“把盆换成了管子”。\n\nlet fs = require('fs');\nlet srcpath = '';\nlet distpath = '';\nlet readablestream = fs.createreadstream(srcpath);\nlet writablestream = fs.createwritestream(distpath);\n//可以通过使用可读流函数pipe()接入到可写流中\nif(readablestream.pipe(writablestream)){\n    console.log('复制成功');\n}else{\n    console.log('复制失败');\n}\n\n\n\n# 小结\n\n数据与文件的处理是服务器端编程与客户端编程的本质区别所在。",charsets:{cjk:!0}},{title:"开发机常用",frontmatter:{},regularPath:"/re/development.html",relativePath:"re/development.md",key:"v-394e602d",path:"/re/development.html",headers:[{level:2,title:"一些 linux 命令",slug:"一些-linux-命令",normalizedTitle:"一些 linux 命令",charIndex:12},{level:2,title:"扩大内存",slug:"扩大内存",normalizedTitle:"扩大内存",charIndex:354},{level:2,title:"work权限",slug:"work权限",normalizedTitle:"work权限",charIndex:646},{level:2,title:"cenos镜像源",slug:"cenos镜像源",normalizedTitle:"cenos镜像源",charIndex:690},{level:2,title:"安装全局包",slug:"安装全局包",normalizedTitle:"安装全局包",charIndex:754},{level:2,title:"切换 node 版本",slug:"切换-node-版本",normalizedTitle:"切换 node 版本",charIndex:860},{level:2,title:"命令行代理",slug:"命令行代理",normalizedTitle:"命令行代理",charIndex:1148},{level:2,title:"解压命令",slug:"解压命令",normalizedTitle:"解压命令",charIndex:1244},{level:2,title:"sed 命令",slug:"sed-命令",normalizedTitle:"sed 命令",charIndex:1536}],lastUpdated:"4/26/2022, 7:04:16 PM",lastUpdatedTimestamp:1650971056e3,headersStr:"一些 linux 命令 扩大内存 work权限 cenos镜像源 安装全局包 切换 node 版本 命令行代理 解压命令 sed 命令",content:"# 开发机常用\n\n\n# 一些 linux 命令\n\n查找被占用的端口：netstat -lnp|grep 80\n\n查看端口对应的pid：lsof -i:8080\n\nkill 进程：kill -9 xxxx\n\n查看软链：ls -al node_modules/@baidu\n\n本目录下内存占用：du -sh *\n\n整体磁盘占用：df -h\n\n查看整体磁盘使用：df -h\n\n复制a文件内容到b：cp -p a b\n\n查找文件命令 find：find . -name \"*.c\"\n\n移动文件：mv /usr/local/a /usr/\n\n软链：sudo ln -s\n\n安装 git：yum install git\n\n安装 node：官网下载 wget url --no-check-certificate\n\n\n# 扩大内存\n\n开发机上运行项目时可能会卡顿，由于8G内存在使用过程中可能会遇到内存不足的情况，最好一同配置一下swap交换内存。\n\nfree -m：查看内存\n\nmkdir -p /opt/swap/ \ntouch /opt/swap/swap_file \nchmod 600 /opt/swap/swap_file \ndd if=/dev/zero of=/opt/swap/swap_file bs=1024 count=8000000 \n/sbin/mkswap /opt/swap/swap_file \n/sbin/swapon /opt/swap/swap_file\n\n\n\n# work权限\n\nchown -R work:work /home/work/\n\n\n\n# cenos镜像源\n\nhttps://vault.centos.org/6.10/os/x86_64/Packages/\n\n\n# 安装全局包\n\n安装之后记住执行命令使其全局生效，例如安装npx：\n\nsudo ln -s /home/work/node-v12.13.0-linux-x64/bin/npx /usr/bin/npx\n\n\n\n# 切换 node 版本\n\nn 默认安装路径是 /usr/local，若你的 node 不是在此路径下，n 切换版本就不能把bin、lib、include、share 复制该路径中，所以我们必须通过N_PREFIX变量来修改 n 的默认node安装路径。\n\nvim ~/.bash_profile\n\n# 将下面两行代码插入到文件末尾：\nexport N_PREFIX=/usr/local # node实际安装位置\nexport PATH=$N_PREFIX/bin:$PATH\n\n# :wq保存退出\n# 执行 source ~/.bash_profile 使修改生效\n\n\n\n# 命令行代理\n\n配置代理：git config --global http.proxy url\n\n用完重置：git config --global --unset http.proxy\n\n\n# 解压命令\n\ntar命令的常用参数\n\n-c, --create 创建一个新归档：压缩\n-x, --extract, --get 从归档中解出文件：解压\n-f, --file=ARCHIVE 使用归档文件\n-z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档\n-C, --directory=DIR 改变至目录 DIR\n-v, --verbose 详细地列出处理的文件\n\n\ntar -zcvf test.tar.gz test -C /home/ # 压缩 test 到 home 目录下\ntar -zxvf test.tar.gz # 解压\n\n\n\n# sed 命令\n\nsed -i 可以直接对文本文件进行操作 sed -i 's/原字符串/新字符串'，例如以下文本：\n\n# test.txt\nd\nddd\n\n\nsed -i 's/d/1' test.txt\n\n# 文本修改为\n1\n1dd\n\nsed -i 's/d/1/g' test.txt\n\n# 文本修改为\n1\n111\n",normalizedContent:"# 开发机常用\n\n\n# 一些 linux 命令\n\n查找被占用的端口：netstat -lnp|grep 80\n\n查看端口对应的pid：lsof -i:8080\n\nkill 进程：kill -9 xxxx\n\n查看软链：ls -al node_modules/@baidu\n\n本目录下内存占用：du -sh *\n\n整体磁盘占用：df -h\n\n查看整体磁盘使用：df -h\n\n复制a文件内容到b：cp -p a b\n\n查找文件命令 find：find . -name \"*.c\"\n\n移动文件：mv /usr/local/a /usr/\n\n软链：sudo ln -s\n\n安装 git：yum install git\n\n安装 node：官网下载 wget url --no-check-certificate\n\n\n# 扩大内存\n\n开发机上运行项目时可能会卡顿，由于8g内存在使用过程中可能会遇到内存不足的情况，最好一同配置一下swap交换内存。\n\nfree -m：查看内存\n\nmkdir -p /opt/swap/ \ntouch /opt/swap/swap_file \nchmod 600 /opt/swap/swap_file \ndd if=/dev/zero of=/opt/swap/swap_file bs=1024 count=8000000 \n/sbin/mkswap /opt/swap/swap_file \n/sbin/swapon /opt/swap/swap_file\n\n\n\n# work权限\n\nchown -r work:work /home/work/\n\n\n\n# cenos镜像源\n\nhttps://vault.centos.org/6.10/os/x86_64/packages/\n\n\n# 安装全局包\n\n安装之后记住执行命令使其全局生效，例如安装npx：\n\nsudo ln -s /home/work/node-v12.13.0-linux-x64/bin/npx /usr/bin/npx\n\n\n\n# 切换 node 版本\n\nn 默认安装路径是 /usr/local，若你的 node 不是在此路径下，n 切换版本就不能把bin、lib、include、share 复制该路径中，所以我们必须通过n_prefix变量来修改 n 的默认node安装路径。\n\nvim ~/.bash_profile\n\n# 将下面两行代码插入到文件末尾：\nexport n_prefix=/usr/local # node实际安装位置\nexport path=$n_prefix/bin:$path\n\n# :wq保存退出\n# 执行 source ~/.bash_profile 使修改生效\n\n\n\n# 命令行代理\n\n配置代理：git config --global http.proxy url\n\n用完重置：git config --global --unset http.proxy\n\n\n# 解压命令\n\ntar命令的常用参数\n\n-c, --create 创建一个新归档：压缩\n-x, --extract, --get 从归档中解出文件：解压\n-f, --file=archive 使用归档文件\n-z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档\n-c, --directory=dir 改变至目录 dir\n-v, --verbose 详细地列出处理的文件\n\n\ntar -zcvf test.tar.gz test -c /home/ # 压缩 test 到 home 目录下\ntar -zxvf test.tar.gz # 解压\n\n\n\n# sed 命令\n\nsed -i 可以直接对文本文件进行操作 sed -i 's/原字符串/新字符串'，例如以下文本：\n\n# test.txt\nd\nddd\n\n\nsed -i 's/d/1' test.txt\n\n# 文本修改为\n1\n1dd\n\nsed -i 's/d/1/g' test.txt\n\n# 文本修改为\n1\n111\n",charsets:{cjk:!0}},{title:"AB 实验",frontmatter:{},regularPath:"/product/abtest.html",relativePath:"product/abtest.md",key:"v-59238a45",path:"/product/abtest.html",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:12},{level:2,title:"A/B实验中的基础知识",slug:"a-b实验中的基础知识",normalizedTitle:"a/b实验中的基础知识",charIndex:343},{level:3,title:"正交与互斥",slug:"正交与互斥",normalizedTitle:"正交与互斥",charIndex:397},{level:3,title:"流量分层分流",slug:"流量分层分流",normalizedTitle:"流量分层分流",charIndex:672},{level:2,title:"AB 实验分类",slug:"ab-实验分类",normalizedTitle:"ab 实验分类",charIndex:1144},{level:3,title:"分工视角",slug:"分工视角",normalizedTitle:"分工视角",charIndex:1156},{level:3,title:"随版视角",slug:"随版视角",normalizedTitle:"随版视角",charIndex:1246},{level:3,title:"架构视角",slug:"架构视角",normalizedTitle:"架构视角",charIndex:1381},{level:2,title:"AB 实验生命周期",slug:"ab-实验生命周期",normalizedTitle:"ab 实验生命周期",charIndex:1409},{level:3,title:"抽样方式",slug:"抽样方式",normalizedTitle:"抽样方式",charIndex:1570},{level:2,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:1752}],lastUpdated:"10/20/2022, 10:01:50 AM",lastUpdatedTimestamp:166623131e4,headersStr:"前言 A/B实验中的基础知识 正交与互斥 流量分层分流 AB 实验分类 分工视角 随版视角 架构视角 AB 实验生命周期 抽样方式 注意点",content:"# AB 实验\n\n\n# 前言\n\n在产品的开发迭代中，如果 pm 有几个非常好的 idea，但是由于我们线上的资源是有限的，所以必须在几个 idea 中做出取舍，那么如何评估几种 idea 的效果，评估的方式有什么呢？\n\n * 内测：用户群有偏差\n\n * 灰度：用户比例小、干扰因素多，可比性差\n\n * A/B test：\n   \n   * 普通用户、真实反馈\n   * 严格对比、结论可靠\n   * 收益量化\n\n> A/B测试为一种随机测试，将两个不同的东西（即A和B）进行假设比较。该测试运用统计学上的假设检定和双母体假设检定。 A/B测试可以用来测试某一个变量两个不同版本的差异，一般是让A和B只有该变量不同，再测试其他人对于A和B的反应差异，再判断A和B的方式何者较佳。\n\n\n# A/B实验中的基础知识\n\n在开始进行A/B实验之前需要了解一些关于A/B测试的基础知识，包含流量的分层分流、正交与互斥、实验分组、AA实验等。\n\n\n# 正交与互斥\n\n * 互斥：是集合的概念，事件A和B的交集为空，A与B就是互斥事件。\n * 正交：是线性代数的概念，若内积空间中两向量的内积为0，则称它们是正交向量。正交矩阵中所有的列向量、行向量都是正交向量。\n\n----------------------------------------\n\n * 互斥实验：实验在同一层拆分流量，且不论如何拆分，不同组的流量是不重叠的。\n\n * 正交实验：每个独立实验为一层，层与层之间流量是正交的，一份流量穿越每层实验时，都会再次随机打散，且随机效果离散。\n\n\n# 流量分层分流\n\nLayer: 层，Exp：实验，b：分支\n\n\n\n分层：按照不同的方式将用户分为不同的集合，层与层之间是正交（独立无关联）的关系。\n\n分流：在同一层拆分流量，此时流量是互斥的。\n\n为什么要对实验分层？\n\n> 如果每日用户活跃量为100000，如果只有两个实验A和实验B，如果流量平分，则每天进入两个实验的人数为50000左右\n> \n> **如果实验数量变多增加到1000个，如果还是对流量进行平分，则每天进入两个实验的人数为100左右，实验体量太小导致实验结果可信度大幅下降，**此时我们发现流量明显不够用。此时我们在想有没有一种方法可以解决这个问题，那么就是分层。\n> \n> 分层实验有个很重要的概念就是每一层用完的流量进入下一层时，一定会均匀的重新分配。\n\n以手机号为例，第一层是按照手机号的倒数第一位分层，分为了 0 - 9 十组实验。第二层是按照倒数第二位分层，也分为了 0 - 9 十组实验。那么那一个用户的手机号是 18201673876 ，将命中第一层的实验 6，第二层的实验7......具体如下图：\n\n\n\n\n# AB 实验分类\n\n\n# 分工视角\n\n * **产品实验：**验证不同策略对产品指标的影响。\n * **研发实验：**主要是性能调优、资源优化、能力升级等方面验证，但所有此类实验均要围绕产品指标。\n\n\n# 随版视角\n\n * **非随版实验：**一般为后端策略实验，生效时间短，样本收敛时间短，例如：检索召回、排序等。（推荐系统普遍采用召回+排序的两阶段模型）\n * **随版本实验：**必须依赖客户端版本发布，冷启生效、样本收敛时间长，例如：端样式修改、端性能调优。\n\n\n# 架构视角\n\n * 服务端实验\n * 客户端实验\n\n\n# AB 实验生命周期\n\n 1. 抽样阶段：抽取实验组、对照组，并确保各组内用户数据相同人群（用户日志打点信息）\n 2. 实验阶段：实验组上线新功能，对照组保持现状，在线上运行一段时间。\n 3. 回归阶段：对比实验组、对照组在实验期间内的各项数据指标，判断新功能是否符合预期。\n 4. 发布阶段：全量固化新功能效果。\n\n\n# 抽样方式\n\n 1. 随机抽样：按照一定随机算法先划分实验组及对照组，然后在线上运行一段时间（空转），观察实验组及对照组在这段时间内各项指标是否相同。\n 2. 正交平衡抽样：根据前段时间的用户的使用历史，圈定出属性相同，且符合实验流量要求的用户，针对这部分用户，划分出实验组及对照组。\n\n> 正交平衡抽样就是已经正确切分出来实验组和对照组，不需要进行空转。\n\n\n# 注意点\n\n * 人群不同质：AB实验需要切分流量到不同方案，如果不能正确切分，使得分到不同方案的用户群体特征分布一致，那么实验将没有任何意义。\n * 实验不同时：假如实验 A 的作用时间是节日，而实验 B 非节日，那么实验明显对于 B 是不公平的。\n * 没有进行 AA 实验（空转）：AA指的是实验中的各个方案都是一致的，这是为了测试埋点、分流、实验统计的正确性，增加AB实验的实验结论可信度。\n\n> 空转是指先抽样，统计关键数据，而不修改页面样式的流程，相当于AA实验。 虽然随机抽样能够保证两份流量的关键指标相差不大，但毕竟存在抽样不均情况。空转可以明显地发现 抽样不均，摒弃掉这部分流量，保证实验数据的变化仅仅是实验本身(样式改变)引起的。",normalizedContent:"# ab 实验\n\n\n# 前言\n\n在产品的开发迭代中，如果 pm 有几个非常好的 idea，但是由于我们线上的资源是有限的，所以必须在几个 idea 中做出取舍，那么如何评估几种 idea 的效果，评估的方式有什么呢？\n\n * 内测：用户群有偏差\n\n * 灰度：用户比例小、干扰因素多，可比性差\n\n * a/b test：\n   \n   * 普通用户、真实反馈\n   * 严格对比、结论可靠\n   * 收益量化\n\n> a/b测试为一种随机测试，将两个不同的东西（即a和b）进行假设比较。该测试运用统计学上的假设检定和双母体假设检定。 a/b测试可以用来测试某一个变量两个不同版本的差异，一般是让a和b只有该变量不同，再测试其他人对于a和b的反应差异，再判断a和b的方式何者较佳。\n\n\n# a/b实验中的基础知识\n\n在开始进行a/b实验之前需要了解一些关于a/b测试的基础知识，包含流量的分层分流、正交与互斥、实验分组、aa实验等。\n\n\n# 正交与互斥\n\n * 互斥：是集合的概念，事件a和b的交集为空，a与b就是互斥事件。\n * 正交：是线性代数的概念，若内积空间中两向量的内积为0，则称它们是正交向量。正交矩阵中所有的列向量、行向量都是正交向量。\n\n----------------------------------------\n\n * 互斥实验：实验在同一层拆分流量，且不论如何拆分，不同组的流量是不重叠的。\n\n * 正交实验：每个独立实验为一层，层与层之间流量是正交的，一份流量穿越每层实验时，都会再次随机打散，且随机效果离散。\n\n\n# 流量分层分流\n\nlayer: 层，exp：实验，b：分支\n\n\n\n分层：按照不同的方式将用户分为不同的集合，层与层之间是正交（独立无关联）的关系。\n\n分流：在同一层拆分流量，此时流量是互斥的。\n\n为什么要对实验分层？\n\n> 如果每日用户活跃量为100000，如果只有两个实验a和实验b，如果流量平分，则每天进入两个实验的人数为50000左右\n> \n> **如果实验数量变多增加到1000个，如果还是对流量进行平分，则每天进入两个实验的人数为100左右，实验体量太小导致实验结果可信度大幅下降，**此时我们发现流量明显不够用。此时我们在想有没有一种方法可以解决这个问题，那么就是分层。\n> \n> 分层实验有个很重要的概念就是每一层用完的流量进入下一层时，一定会均匀的重新分配。\n\n以手机号为例，第一层是按照手机号的倒数第一位分层，分为了 0 - 9 十组实验。第二层是按照倒数第二位分层，也分为了 0 - 9 十组实验。那么那一个用户的手机号是 18201673876 ，将命中第一层的实验 6，第二层的实验7......具体如下图：\n\n\n\n\n# ab 实验分类\n\n\n# 分工视角\n\n * **产品实验：**验证不同策略对产品指标的影响。\n * **研发实验：**主要是性能调优、资源优化、能力升级等方面验证，但所有此类实验均要围绕产品指标。\n\n\n# 随版视角\n\n * **非随版实验：**一般为后端策略实验，生效时间短，样本收敛时间短，例如：检索召回、排序等。（推荐系统普遍采用召回+排序的两阶段模型）\n * **随版本实验：**必须依赖客户端版本发布，冷启生效、样本收敛时间长，例如：端样式修改、端性能调优。\n\n\n# 架构视角\n\n * 服务端实验\n * 客户端实验\n\n\n# ab 实验生命周期\n\n 1. 抽样阶段：抽取实验组、对照组，并确保各组内用户数据相同人群（用户日志打点信息）\n 2. 实验阶段：实验组上线新功能，对照组保持现状，在线上运行一段时间。\n 3. 回归阶段：对比实验组、对照组在实验期间内的各项数据指标，判断新功能是否符合预期。\n 4. 发布阶段：全量固化新功能效果。\n\n\n# 抽样方式\n\n 1. 随机抽样：按照一定随机算法先划分实验组及对照组，然后在线上运行一段时间（空转），观察实验组及对照组在这段时间内各项指标是否相同。\n 2. 正交平衡抽样：根据前段时间的用户的使用历史，圈定出属性相同，且符合实验流量要求的用户，针对这部分用户，划分出实验组及对照组。\n\n> 正交平衡抽样就是已经正确切分出来实验组和对照组，不需要进行空转。\n\n\n# 注意点\n\n * 人群不同质：ab实验需要切分流量到不同方案，如果不能正确切分，使得分到不同方案的用户群体特征分布一致，那么实验将没有任何意义。\n * 实验不同时：假如实验 a 的作用时间是节日，而实验 b 非节日，那么实验明显对于 b 是不公平的。\n * 没有进行 aa 实验（空转）：aa指的是实验中的各个方案都是一致的，这是为了测试埋点、分流、实验统计的正确性，增加ab实验的实验结论可信度。\n\n> 空转是指先抽样，统计关键数据，而不修改页面样式的流程，相当于aa实验。 虽然随机抽样能够保证两份流量的关键指标相差不大，但毕竟存在抽样不均情况。空转可以明显地发现 抽样不均，摒弃掉这部分流量，保证实验数据的变化仅仅是实验本身(样式改变)引起的。",charsets:{cjk:!0}},{title:"devops",frontmatter:{},regularPath:"/re/devops.html",relativePath:"re/devops.md",key:"v-fbf0dec2",path:"/re/devops.html",headers:[{level:2,title:"devops 是什么",slug:"devops-是什么",normalizedTitle:"devops 是什么",charIndex:42},{level:2,title:"工具使用层",slug:"工具使用层",normalizedTitle:"工具使用层",charIndex:1017},{level:2,title:"瀑布 / 敏捷 / devops",slug:"瀑布-敏捷-devops",normalizedTitle:"瀑布 / 敏捷 / devops",charIndex:1292},{level:3,title:"瀑布开发",slug:"瀑布开发",normalizedTitle:"瀑布开发",charIndex:1313},{level:3,title:"敏捷开发",slug:"敏捷开发",normalizedTitle:"敏捷开发",charIndex:1511},{level:3,title:"devops",slug:"devops-2",normalizedTitle:"devops",charIndex:2},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1810}],lastUpdated:"5/26/2022, 12:54:29 PM",lastUpdatedTimestamp:1653540869e3,headersStr:"devops 是什么 工具使用层 瀑布 / 敏捷 / devops 瀑布开发 敏捷开发 devops 总结",content:"# devops\n\n什么是DevOps？ - CODING的回答 - 知乎\n\n\n# devops 是什么\n\nDevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。\n\n它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。\n\n\n\n举个例子，对于运维来说，稳定压倒一切，新 Feature 越少越好。而对于研发来说，却希望能开发更多的功能。这种矛盾会导致大量的资源和时间的浪费。就像两匹马拉一辆车，如果马头向着的方向不一致，肯定是没法全速前进的。\n\n * 在价值流下游的 Ops 认为价值链上游的 Dev 软件非功能质量不满足要求，因此阻止变更。\n * 在价值流上游的 Dev 无法获得价值链下游的 Ops 的真实运行环境，因此无法提升交付质量。\n\nDevOps 的理念就是希望能打破这种屏障，让研发（Development）和运维（Operations）一体化，让团队从业务需求出发，向着同一个目标前进。\n\n字面意思上说 DevOps 是指“开发运维一体化”，即通过工具辅助开发完成运维的部分工作，减少成本。但深入理解了 DevOps 之后，你会发现 DevOps 其实是一种软件研发管理的思想，方法论，他追求的是一种没有隔阂的理想的研发协作的状态，可能涉及到的角色有开发、测试、产品、项目管理、运维等等。所以我们认为，为了帮助研发团队在保持质量的前提下提高交付效率的方法和方法论都隶属于 DevOps 的范畴。\n\n比如 Google 提出的 5 个 DevOps 原则，这套原则中必须依赖于工具辅助的部分只有后两点，更多的则是对于开发组织形式的内省：\n\n 1. 精简组织架构；\n 2. 愿意承担一部分试错带来的损失；\n 3. 分阶段地一小步一小步地进行转型；\n 4. 最大化地利用工具和自动化流程；\n 5. 对所有的过程和结果进行记录和分析。\n\n所以 DevOps 不是简单的开发软件化，而是企业的学习能力不断提升的结果，将企业改造成敏捷应对的学习型组织，运用新的工具，优化组织架构和流程，不断地进行自我革命和创新的方式。工具是辅助，而非基础。\n\n\n# 工具使用层\n\nDevops 落地，研发交付的每个过程都离不开工具的支撑。传统的方式，是自己搭建零散的弱整合工具系统，比如我们用 gitlab 来管理代码；我们用 Jenkins 来做持续集成；使用 selenium 来做自动化测试；使用 ansible 来自动化部署；使用 chef 或者 puppet 来管理基础环境等等。这种情况的问题是：\n\n 1. 系统完全需要自己维护，成本高，不稳定；\n 2. 子系统之间存在隐形墙，缺少数据共享、权限共享、系统交互等功能；\n\n\n\n目前大型金融以及互联网企业普遍采用强整合的统一 DevOps 平台。\n\n\n# 瀑布 / 敏捷 / devops\n\n\n# 瀑布开发\n\n瀑布式开发是早期被广泛采用的软件开发模型，要求有明确的需求，大家按照需求一步步做好规划，每一阶段工作的完成是下一阶段工作开始的前提，每一阶段都要进行严格的评审，保证各阶段的工作做得足够好时才允许进入下一阶段，它适用于需求明确的项目。其最大的风险是，当产品研发完成后， 到了产品测试阶段如果发现了问题 ，或者发现其无法满足市场需求， 那么就需要重新开发，甚至需要重新规划产品。\n\n\n# 敏捷开发\n\n敏捷开发是一种以用户需求进化为核心、迭代、循序渐进的开发方法。首先把用户最关注的软件原型做出来并交付给用户，用户在实际场景中发现问题并给予反馈，研发人员快速修改弥补需求中的不足。上述过程不断迭代，直到用户满意。敏捷适用于需求不明确、创新性或者需要抢占市场的项目，特别适合互联网项目。\n\n\n# devops\n\nDevOps是一种软件开发实践，它将人员、流程和技术结合在一起，以交付持续的价值。该方法分为计划和跟踪、开发、生成和测试、交付以及监视和操作。DevOps 的独特之处在于开发、IT 运营、质量工程和安全团队协同工作，在发布新产品、版本或更新所涉及的所有任务中创造效率。\n\n\n# 总结\n\nDevOps 不能简单认为是工具、方法、技能或组织结构，DevOps 结合所有这一切元素，去帮助我们让业务更快的开发交付运营以更快地应对变化。\n\nDevOps 强调协作共赢，强调从项目整体上全盘考虑整个软件生命周期的所有事情，产品如何开发、测试、部署、升级、监控、运维、运营等等都要列入项目目标。开发团队和运维运营团队又要深入合作，频繁小颗粒度的完成产品开发、测试、交付、反馈。",normalizedContent:"# devops\n\n什么是devops？ - coding的回答 - 知乎\n\n\n# devops 是什么\n\ndevops（development和operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（qa）部门之间的沟通、协作与整合。\n\n它是一种重视“软件开发人员（dev）”和“it运维技术人员（ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。\n\n\n\n举个例子，对于运维来说，稳定压倒一切，新 feature 越少越好。而对于研发来说，却希望能开发更多的功能。这种矛盾会导致大量的资源和时间的浪费。就像两匹马拉一辆车，如果马头向着的方向不一致，肯定是没法全速前进的。\n\n * 在价值流下游的 ops 认为价值链上游的 dev 软件非功能质量不满足要求，因此阻止变更。\n * 在价值流上游的 dev 无法获得价值链下游的 ops 的真实运行环境，因此无法提升交付质量。\n\ndevops 的理念就是希望能打破这种屏障，让研发（development）和运维（operations）一体化，让团队从业务需求出发，向着同一个目标前进。\n\n字面意思上说 devops 是指“开发运维一体化”，即通过工具辅助开发完成运维的部分工作，减少成本。但深入理解了 devops 之后，你会发现 devops 其实是一种软件研发管理的思想，方法论，他追求的是一种没有隔阂的理想的研发协作的状态，可能涉及到的角色有开发、测试、产品、项目管理、运维等等。所以我们认为，为了帮助研发团队在保持质量的前提下提高交付效率的方法和方法论都隶属于 devops 的范畴。\n\n比如 google 提出的 5 个 devops 原则，这套原则中必须依赖于工具辅助的部分只有后两点，更多的则是对于开发组织形式的内省：\n\n 1. 精简组织架构；\n 2. 愿意承担一部分试错带来的损失；\n 3. 分阶段地一小步一小步地进行转型；\n 4. 最大化地利用工具和自动化流程；\n 5. 对所有的过程和结果进行记录和分析。\n\n所以 devops 不是简单的开发软件化，而是企业的学习能力不断提升的结果，将企业改造成敏捷应对的学习型组织，运用新的工具，优化组织架构和流程，不断地进行自我革命和创新的方式。工具是辅助，而非基础。\n\n\n# 工具使用层\n\ndevops 落地，研发交付的每个过程都离不开工具的支撑。传统的方式，是自己搭建零散的弱整合工具系统，比如我们用 gitlab 来管理代码；我们用 jenkins 来做持续集成；使用 selenium 来做自动化测试；使用 ansible 来自动化部署；使用 chef 或者 puppet 来管理基础环境等等。这种情况的问题是：\n\n 1. 系统完全需要自己维护，成本高，不稳定；\n 2. 子系统之间存在隐形墙，缺少数据共享、权限共享、系统交互等功能；\n\n\n\n目前大型金融以及互联网企业普遍采用强整合的统一 devops 平台。\n\n\n# 瀑布 / 敏捷 / devops\n\n\n# 瀑布开发\n\n瀑布式开发是早期被广泛采用的软件开发模型，要求有明确的需求，大家按照需求一步步做好规划，每一阶段工作的完成是下一阶段工作开始的前提，每一阶段都要进行严格的评审，保证各阶段的工作做得足够好时才允许进入下一阶段，它适用于需求明确的项目。其最大的风险是，当产品研发完成后， 到了产品测试阶段如果发现了问题 ，或者发现其无法满足市场需求， 那么就需要重新开发，甚至需要重新规划产品。\n\n\n# 敏捷开发\n\n敏捷开发是一种以用户需求进化为核心、迭代、循序渐进的开发方法。首先把用户最关注的软件原型做出来并交付给用户，用户在实际场景中发现问题并给予反馈，研发人员快速修改弥补需求中的不足。上述过程不断迭代，直到用户满意。敏捷适用于需求不明确、创新性或者需要抢占市场的项目，特别适合互联网项目。\n\n\n# devops\n\ndevops是一种软件开发实践，它将人员、流程和技术结合在一起，以交付持续的价值。该方法分为计划和跟踪、开发、生成和测试、交付以及监视和操作。devops 的独特之处在于开发、it 运营、质量工程和安全团队协同工作，在发布新产品、版本或更新所涉及的所有任务中创造效率。\n\n\n# 总结\n\ndevops 不能简单认为是工具、方法、技能或组织结构，devops 结合所有这一切元素，去帮助我们让业务更快的开发交付运营以更快地应对变化。\n\ndevops 强调协作共赢，强调从项目整体上全盘考虑整个软件生命周期的所有事情，产品如何开发、测试、部署、升级、监控、运维、运营等等都要列入项目目标。开发团队和运维运营团队又要深入合作，频繁小颗粒度的完成产品开发、测试、交付、反馈。",charsets:{cjk:!0}},{title:"mongodb",frontmatter:{},regularPath:"/re/mongodb.html",relativePath:"re/mongodb.md",key:"v-36417e3f",path:"/re/mongodb.html",headers:[{level:2,title:"安装教程",slug:"安装教程",normalizedTitle:"安装教程",charIndex:75},{level:2,title:"数据备份与恢复",slug:"数据备份与恢复",normalizedTitle:"数据备份与恢复",charIndex:1761},{level:2,title:"数据库连接",slug:"数据库连接",normalizedTitle:"数据库连接",charIndex:1950},{level:2,title:"mongodb compass",slug:"mongodb-compass",normalizedTitle:"mongodb compass",charIndex:2055}],lastUpdated:"1/7/2022, 12:58:52 PM",lastUpdatedTimestamp:1641531532e3,headersStr:"安装教程 数据备份与恢复 数据库连接 mongodb compass",content:'# mongodb\n\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\n\n\n# 安装教程\n\n以下是在 cenos7 开发机上安装的过程，具体参考官网\n\nsudo vim /etc/yum.repos.d/mongodb-org-4.4.repo\n\n# 添加如下配置\n[mongodb-org-4.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc\n\n\n安装\n\nsudo yum install -y mongodb-org\n\n\n验证安装结果\n\nrpm -qa |grep mongodb\nrpm -ql mongodb-org-server\n\n\n锁定版本，避免 yum 更新\n\nsudo vi /etc/yum.conf\n\n# 添加如下内容\nexclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools\n\n\n启动\n\nsudo systemctl start mongod\n\n# 默认端口 27017，查看是否启动\nnetstat -natp | grep 27017\n\n# 查看数据库的进程是否存在\nps -aux | grep mongod    \n\n# 验证服务开启\nmongo\n\n# 设置开机自动启动\nsystemctl enable mongod\n\n\n修改配置\n\nsudo vi /etc/mongod.conf\n\n################################################################\nnet:\n  port: 8811 # 默认为27021端口\n  bindIp: 0.0.0.0 # 127.0.0.1 只允许本地连接\n  \n  \n# 默认情况下 mongodb 的数据和日志存储位置是 /var/log/mongodb/mongod.log 和 /var/lib/mongo\n# 首先在/home/work/mongodb目录下执行：mkdir -p var/log var/database\n# 然后修改以下配置\n\nsystemLog:\n  destination: file\n  logAppend: true\n  path: /home/work/mongodb/var/log/mongodb/mongod.log # 修改这里\n\nstorage:\n  dbPath: /home/work/mongodb/var/lib/mongo # 修改这里\n  \n###############################################################\n\n# 重启服务\nsudo service mongod restart\n\n\n用户配置\n\n# 进入命令行\nmongo\n\n# admin数据库\nuse admin\ndb.createUser({user:"admin",pwd:"***",roles:[{role:"root",db:"admin"}]})\n\n\n重新开启带认证的服务\n\n# 查看之前未认证的时候开启的服务pid\nps -ef | grep mongo\n\n# 杀死pid对应服务\nkill pid\n\ncd /usr/bin/\n\n# fork参数是服务在后台运行，auth是访问需要验证：\n./mongod --bind_ip 0.0.0.0 --port 8811 --dbpath /home/work/mongodb/var/database --logpath /home/work/mongodb/var/log/mongo.log --fork --auth\n\n\n\n# 数据备份与恢复\n\n数据备份到本地\n\nmongodump -h <ip>:<port> -d <dbname> -o <path>\n\n\n * -h：host\n * -d：db\n * -o：output\n\n本地数据恢复到数据库\n\nmongorestore -h <ip>:<port> -u <user> -p=<password> -d <dbname> <path>\n\n\n\n# 数据库连接\n\n# 连接本地\nmongo mongodb://localhost:8811\n\n# 连接开发机\nmongo mongodb://<user>:<password>@<ip>:<port>\n\n\n\n# mongodb compass\n\nmongodb compass 是一款可视化工具，直接在官网安装即可，以下是连接时所填的字段。\n\n * Hostname：开发机的公网IP\n * port：端口号\n * Username/password：用户配置时添加的用户名和密码\n * Authentication Database：数据库默认为 admin\n\n',normalizedContent:'# mongodb\n\nmongodb是一个基于分布式文件存储的数据库。由c++语言编写。旨在为web应用提供可扩展的高性能数据存储解决方案。\n\n\n# 安装教程\n\n以下是在 cenos7 开发机上安装的过程，具体参考官网\n\nsudo vim /etc/yum.repos.d/mongodb-org-4.4.repo\n\n# 添加如下配置\n[mongodb-org-4.4]\nname=mongodb repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc\n\n\n安装\n\nsudo yum install -y mongodb-org\n\n\n验证安装结果\n\nrpm -qa |grep mongodb\nrpm -ql mongodb-org-server\n\n\n锁定版本，避免 yum 更新\n\nsudo vi /etc/yum.conf\n\n# 添加如下内容\nexclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools\n\n\n启动\n\nsudo systemctl start mongod\n\n# 默认端口 27017，查看是否启动\nnetstat -natp | grep 27017\n\n# 查看数据库的进程是否存在\nps -aux | grep mongod    \n\n# 验证服务开启\nmongo\n\n# 设置开机自动启动\nsystemctl enable mongod\n\n\n修改配置\n\nsudo vi /etc/mongod.conf\n\n################################################################\nnet:\n  port: 8811 # 默认为27021端口\n  bindip: 0.0.0.0 # 127.0.0.1 只允许本地连接\n  \n  \n# 默认情况下 mongodb 的数据和日志存储位置是 /var/log/mongodb/mongod.log 和 /var/lib/mongo\n# 首先在/home/work/mongodb目录下执行：mkdir -p var/log var/database\n# 然后修改以下配置\n\nsystemlog:\n  destination: file\n  logappend: true\n  path: /home/work/mongodb/var/log/mongodb/mongod.log # 修改这里\n\nstorage:\n  dbpath: /home/work/mongodb/var/lib/mongo # 修改这里\n  \n###############################################################\n\n# 重启服务\nsudo service mongod restart\n\n\n用户配置\n\n# 进入命令行\nmongo\n\n# admin数据库\nuse admin\ndb.createuser({user:"admin",pwd:"***",roles:[{role:"root",db:"admin"}]})\n\n\n重新开启带认证的服务\n\n# 查看之前未认证的时候开启的服务pid\nps -ef | grep mongo\n\n# 杀死pid对应服务\nkill pid\n\ncd /usr/bin/\n\n# fork参数是服务在后台运行，auth是访问需要验证：\n./mongod --bind_ip 0.0.0.0 --port 8811 --dbpath /home/work/mongodb/var/database --logpath /home/work/mongodb/var/log/mongo.log --fork --auth\n\n\n\n# 数据备份与恢复\n\n数据备份到本地\n\nmongodump -h <ip>:<port> -d <dbname> -o <path>\n\n\n * -h：host\n * -d：db\n * -o：output\n\n本地数据恢复到数据库\n\nmongorestore -h <ip>:<port> -u <user> -p=<password> -d <dbname> <path>\n\n\n\n# 数据库连接\n\n# 连接本地\nmongo mongodb://localhost:8811\n\n# 连接开发机\nmongo mongodb://<user>:<password>@<ip>:<port>\n\n\n\n# mongodb compass\n\nmongodb compass 是一款可视化工具，直接在官网安装即可，以下是连接时所填的字段。\n\n * hostname：开发机的公网ip\n * port：端口号\n * username/password：用户配置时添加的用户名和密码\n * authentication database：数据库默认为 admin\n\n',charsets:{cjk:!0}},{title:"Docker",frontmatter:{},regularPath:"/re/docker.html",relativePath:"re/docker.md",key:"v-1ab45bbf",path:"/re/docker.html",headers:[{level:2,title:"为什么需要 Docker",slug:"为什么需要-docker",normalizedTitle:"为什么需要 docker",charIndex:202},{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:676},{level:3,title:"镜像",slug:"镜像",normalizedTitle:"镜像",charIndex:467},{level:3,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:40},{level:3,title:"仓库",slug:"仓库",normalizedTitle:"仓库",charIndex:1278},{level:2,title:"Docker 操作",slug:"docker-操作",normalizedTitle:"docker 操作",charIndex:1451}],lastUpdated:"9/8/2022, 4:24:45 PM",lastUpdatedTimestamp:1662625485e3,headersStr:"为什么需要 Docker 基本概念 镜像 容器 仓库 Docker 操作",content:"# Docker\n\nDocker - 从入门到实践\n\nDocker 是一种虚拟化容器技术，首先我们需要了解一下虚拟机和容器的区别。\n\n\n\n\n\n * 虚拟机技术是虚拟出一套硬件资源后，在其上运行一个完成操作系统，在该系统上再运行所需应用进程。\n * 容器共享同一个 Host OS，容器内应用直接使用宿主机内核，这使得容器在体积上要比虚拟机小很多，并且部署和启动速度更快，开销更小，也更容易迁移。\n\n\n# 为什么需要 Docker\n\n> 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。\n\n * 持续部署与测试的一致性：Docker 能够保持容器内部所有的配置和依赖关系始终不变。你可以从开发 到产品发布的整个过程中使用相同的容器来确保没有任何差异或者人工干预。\n * 多云平台兼容：可移植性好。可以在任何拥有Docker runtime的环境快速部署，没有迁移的成本。\n * 环境标准化和版本控制：设想某次发布因为完成了一个组件的升级而导致你整个环境都损坏了。Docker 可以在几分钟内轻松地回滚到这个镜像的前一个版本。\n * 隔离性：Docker 可以确保你的应用程序与资源是分隔开的，例如依赖多个不同版本的 tomcat 的时候，不会因为依赖冲突导致崩溃。同时 Docker 还能确保每个容器只使用分配给它的额定资源，不会因为某个进程影hang 住其他容器。\n * 安全性：由于Docker容器是隔离的，并且资源是受限制的，所以即使你其中一个应用程序被黑，也不会影响运行在其它Docker容器上的应用程序。\n\n\n# 基本概念\n\n\n# 镜像\n\n我们都知道，操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。\n\nDocker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。\n\n\n# 容器\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。\n\n\n# 仓库\n\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。\n\n一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n\n\n# Docker 操作\n\n待补充",normalizedContent:"# docker\n\ndocker - 从入门到实践\n\ndocker 是一种虚拟化容器技术，首先我们需要了解一下虚拟机和容器的区别。\n\n\n\n\n\n * 虚拟机技术是虚拟出一套硬件资源后，在其上运行一个完成操作系统，在该系统上再运行所需应用进程。\n * 容器共享同一个 host os，容器内应用直接使用宿主机内核，这使得容器在体积上要比虚拟机小很多，并且部署和启动速度更快，开销更小，也更容易迁移。\n\n\n# 为什么需要 docker\n\n> 作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。\n\n * 持续部署与测试的一致性：docker 能够保持容器内部所有的配置和依赖关系始终不变。你可以从开发 到产品发布的整个过程中使用相同的容器来确保没有任何差异或者人工干预。\n * 多云平台兼容：可移植性好。可以在任何拥有docker runtime的环境快速部署，没有迁移的成本。\n * 环境标准化和版本控制：设想某次发布因为完成了一个组件的升级而导致你整个环境都损坏了。docker 可以在几分钟内轻松地回滚到这个镜像的前一个版本。\n * 隔离性：docker 可以确保你的应用程序与资源是分隔开的，例如依赖多个不同版本的 tomcat 的时候，不会因为依赖冲突导致崩溃。同时 docker 还能确保每个容器只使用分配给它的额定资源，不会因为某个进程影hang 住其他容器。\n * 安全性：由于docker容器是隔离的，并且资源是受限制的，所以即使你其中一个应用程序被黑，也不会影响运行在其它docker容器上的应用程序。\n\n\n# 基本概念\n\n\n# 镜像\n\n我们都知道，操作系统分为 内核 和 用户空间。对于 linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 docker 镜像（image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 ubuntu 18.04 最小系统的 root 文件系统。\n\ndocker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。\n\n\n# 容器\n\n镜像（image）和容器（container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 id 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 docker 时常常会混淆容器和虚拟机。\n\n\n# 仓库\n\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，docker registry 就是这样的服务。\n\n一个 docker registry 中可以包含多个 仓库（repository）；每个仓库可以包含多个 标签（tag）；每个标签对应一个镜像。\n\n\n# docker 操作\n\n待补充",charsets:{cjk:!0}},{title:"nginx",frontmatter:{},regularPath:"/re/nginx.html",relativePath:"re/nginx.md",key:"v-cae08c22",path:"/re/nginx.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:143},{level:2,title:"配置文件",slug:"配置文件",normalizedTitle:"配置文件",charIndex:330},{level:2,title:"多个配置文件",slug:"多个配置文件",normalizedTitle:"多个配置文件",charIndex:1641},{level:2,title:"查看 nginx 进程",slug:"查看-nginx-进程",normalizedTitle:"查看 nginx 进程",charIndex:1855},{level:2,title:"Nginx 主要应用",slug:"nginx-主要应用",normalizedTitle:"nginx 主要应用",charIndex:2111},{level:3,title:"动静分离",slug:"动静分离",normalizedTitle:"动静分离",charIndex:2126},{level:3,title:"反向代理",slug:"反向代理",normalizedTitle:"反向代理",charIndex:127},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:132}],lastUpdated:"11/7/2023, 7:15:29 PM",lastUpdatedTimestamp:1699355729e3,headersStr:"安装 配置文件 多个配置文件 查看 nginx 进程 Nginx 主要应用 动静分离 反向代理 负载均衡",content:'# nginx\n\n本文参考自：https://juejin.cn/post/6844904129987526663\n\n> “Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。”\n\n\n# 安装\n\n在 mac 上按照以下来安装：\n\nbrew install nginx\nnginx -v # 查看版本\n\n\n * 启动 Nginx：sudo nginx\n\n * 停止 Nginx：sudo nginx -s stop\n\n * 热重启 Nginx：sudo nginx -s reload\n\n * 强制停止 Nginx：sudo pkill -9 nginx\n\n\n# 配置文件\n\n 1. /usr/local/etc/nginx/nginx.conf （nginx配置文件路径）\n 2. /usr/local/var/www （nginx服务器默认的根目录）\n 3. /usr/local/Cellar/nginx/1.17.9 （nginx的安装路径）\n 4. /usr/local/var/log/nginx/error.log (nginx默认的日志路径)\n\nNginx 默认配置文件\n\nserver {  \n        # 当nginx接到请求后，会匹配其配置中的service模块\n        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配\n        listen       8080;        \n        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名\n\n        location / {\n            root   html; # Nginx默认值\n            # 设定Nginx服务器返回的文档名\n            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm\n        }\n}\n\n\n当访问 localhost:8080 时，对应的即是 /usr/local/var/www 路径下的 index.html 文件，如下：\n\n\n\n可以在 vscode 中打开对应的 html 文件：\n\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\nCommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n\n\n# 多个配置文件\n\n我们在使用nginx时，会遇到有多个服务要进行代理，如果我们直接在nginx.conf文件中添加，配置文件会显得\n\n比较臃肿且不好维护。此时我们可以通过include的方式，为每个服务建立nginx的配置文件，这样也便于后期维护。\n\nhttp {\n    # ...\n    include /etc/nginx/conf/*.conf;\n}\n\n\nconf 目录下可以有 a.conf 和 b.conf\n\n\n# 查看 nginx 进程\n\nps -ef | grep nginx\n\n * ps -ef 表示显示所有进程的消息。\n * | 是管道命令。通常需要借助管道命令”|”多个命令的组合\n * grep 是Linux 下的文本过滤工具\n\n输出为：\n\n\n\n> 启动nginx以后，有两个nginx进程，一个master进程，一个worker进程，worker进程的父进程 ID 即是master进程，可以在输出的第2列和第3列验证。\n\n根据进程号重启nginx：kill -HUP 进程号（master 的进程号）\n\n\n# Nginx 主要应用\n\n\n# 动静分离\n\n动静分离其实就是 Nginx 服务器将接收到的请求分为动态请求和静态请求。\n\n动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求 nginx 服务器，达到动静分离的目标。\n\nserver {  \n        listen       8080;        \n        server_name  localhost;\n\n        location / {\n            root   html; # Nginx默认值\n            index  index.html index.htm;\n        }\n        \n        # 静态化配置，所有静态请求都转发给 nginx 处理\n        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {\n            root /usr/local/var/www; # 静态请求所代理到的根目录\n        }\n        \n        # 动态请求匹配到 path 为 myblog 的就转发到 8081 端口处理\n        location /myblog/ {  \n            proxy_pass http://localhost:8081; # 充当服务代理\n        }\n}\n\n\n * 静：访问 localhost:8080/index.html 会直接从代理的根目录中去取。\n * 动：访问localhost:8080/myblog/ 请求会转发到 http://localhost:8081 处理。\n\n# 场景一\n\n此时假如我本地启动了一个博客服务，地址为：http://localhost:8081，经过以上配置那么当我请求 localhost:8080/myblog/ 就会转发到 http://localhost:8081 上，也会打开博客页面。\n\nhttp://localhost:8088/myblog/ => http://localhost:8081\n\n\n正常情况下静态配置用于获取资源文件，动态配置用于转发接口请求给真正的服务。\n\n# 场景二\n\n如果项目分别部署在同一台机器上时，由于无法使用相同的端口，故后端一般会将端口号设置成不同的值（例如8080、8081），但是当前端向后端请求资源时还要加上端口号，未免显得麻烦，故利用可以 nginx 将前端的指定路径代理到后端的8080、8081端口上。\n\nhttp: {\n  server {\n    server_name example.com\n\n    location /mail {\n    \tproxy_pass http:example.com:8080;\n    }\n\n    location /user {\n    \tproxy_pass http:example.com:8081;\n    }\n  }\n}\n\n\n * 将 http://example.com/mail/ 下的请求转发到 http://example.com:8080/\n * http://example.com/mail/index.html -> http://example.com:8080/index.html\n * 将 http://example.com/user/ 下的请求转发到 http://example.com:8081/\n * http://example.com/user/index.html -> http://example.com:8081/index.html\n\n\n# 反向代理\n\n> 这个功能也就是 nginx 的反向代理功能，即客户端不知道真正请求的服务端，我们可以用反向代理来解决跨域问题。\n\n例如：\n\n * 前端server的域名为：fe.server.com\n * 后端服务的域名为：dev.server.com\n\n现在我在fe.server.com 对 dev.server.com发起请求一定会出现跨域。\n\n现在我们只需要启动一个nginx服务器，将 server_name 设置为 fe.server.com ,然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置：\n\nserver {\n        listen       80;\n        server_name  fe.server.com;\n        location / {\n                proxy_pass dev.server.com;\n        }\n}\n\n\n这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。\n\n# 场景一\n\n访问某一台机器的域名时，我希望返回我上传到 bos 上的 html 地址。\n\nserver {  \n  listen       8088;        \n  server_name  xxx.com;\n\n  location / {\n  \tproxy_pass   http://bos/index.html;\n  }\n\n}\n\n\n此时访问的虽然是 xxx.com，但是实际请求的是 http://bos/index.html，对客户端隐藏了真实请求地址。\n\n\n# 负载均衡\n\n随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器集群。\n\n在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。\n\n# 负载均衡：设置domain\nupstream domain {\n    server localhost:8000;\n    server localhost:8001;\n}\nserver {  \n        listen       8080;        \n        server_name  localhost;\n\n        location / {\n            # root   html; # Nginx默认值\n            # index  index.html index.htm;\n            \n            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口\n            proxy_set_header Host $host:$server_port;\n        }\n}\n\n\n8000和8001是我本地起的两个页面，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。',normalizedContent:'# nginx\n\n本文参考自：https://juejin.cn/post/6844904129987526663\n\n> “nginx 是一款轻量级的 http 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 io 性能，时常用于服务端的反向代理和负载均衡。”\n\n\n# 安装\n\n在 mac 上按照以下来安装：\n\nbrew install nginx\nnginx -v # 查看版本\n\n\n * 启动 nginx：sudo nginx\n\n * 停止 nginx：sudo nginx -s stop\n\n * 热重启 nginx：sudo nginx -s reload\n\n * 强制停止 nginx：sudo pkill -9 nginx\n\n\n# 配置文件\n\n 1. /usr/local/etc/nginx/nginx.conf （nginx配置文件路径）\n 2. /usr/local/var/www （nginx服务器默认的根目录）\n 3. /usr/local/cellar/nginx/1.17.9 （nginx的安装路径）\n 4. /usr/local/var/log/nginx/error.log (nginx默认的日志路径)\n\nnginx 默认配置文件\n\nserver {  \n        # 当nginx接到请求后，会匹配其配置中的service模块\n        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配\n        listen       8080;        \n        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名\n\n        location / {\n            root   html; # nginx默认值\n            # 设定nginx服务器返回的文档名\n            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm\n        }\n}\n\n\n当访问 localhost:8080 时，对应的即是 /usr/local/var/www 路径下的 index.html 文件，如下：\n\n\n\n可以在 vscode 中打开对应的 html 文件：\n\n<!doctype html>\n<html>\n<head>\n<title>welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: tahoma, verdana, arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>welcome to nginx!</h1>\n<p>if you see this page, the nginx web server is successfully installed and\nworking. further configuration is required.</p>\n\n<p>for online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\ncommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n\n\n# 多个配置文件\n\n我们在使用nginx时，会遇到有多个服务要进行代理，如果我们直接在nginx.conf文件中添加，配置文件会显得\n\n比较臃肿且不好维护。此时我们可以通过include的方式，为每个服务建立nginx的配置文件，这样也便于后期维护。\n\nhttp {\n    # ...\n    include /etc/nginx/conf/*.conf;\n}\n\n\nconf 目录下可以有 a.conf 和 b.conf\n\n\n# 查看 nginx 进程\n\nps -ef | grep nginx\n\n * ps -ef 表示显示所有进程的消息。\n * | 是管道命令。通常需要借助管道命令”|”多个命令的组合\n * grep 是linux 下的文本过滤工具\n\n输出为：\n\n\n\n> 启动nginx以后，有两个nginx进程，一个master进程，一个worker进程，worker进程的父进程 id 即是master进程，可以在输出的第2列和第3列验证。\n\n根据进程号重启nginx：kill -hup 进程号（master 的进程号）\n\n\n# nginx 主要应用\n\n\n# 动静分离\n\n动静分离其实就是 nginx 服务器将接收到的请求分为动态请求和静态请求。\n\n动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求 nginx 服务器，达到动静分离的目标。\n\nserver {  \n        listen       8080;        \n        server_name  localhost;\n\n        location / {\n            root   html; # nginx默认值\n            index  index.html index.htm;\n        }\n        \n        # 静态化配置，所有静态请求都转发给 nginx 处理\n        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {\n            root /usr/local/var/www; # 静态请求所代理到的根目录\n        }\n        \n        # 动态请求匹配到 path 为 myblog 的就转发到 8081 端口处理\n        location /myblog/ {  \n            proxy_pass http://localhost:8081; # 充当服务代理\n        }\n}\n\n\n * 静：访问 localhost:8080/index.html 会直接从代理的根目录中去取。\n * 动：访问localhost:8080/myblog/ 请求会转发到 http://localhost:8081 处理。\n\n# 场景一\n\n此时假如我本地启动了一个博客服务，地址为：http://localhost:8081，经过以上配置那么当我请求 localhost:8080/myblog/ 就会转发到 http://localhost:8081 上，也会打开博客页面。\n\nhttp://localhost:8088/myblog/ => http://localhost:8081\n\n\n正常情况下静态配置用于获取资源文件，动态配置用于转发接口请求给真正的服务。\n\n# 场景二\n\n如果项目分别部署在同一台机器上时，由于无法使用相同的端口，故后端一般会将端口号设置成不同的值（例如8080、8081），但是当前端向后端请求资源时还要加上端口号，未免显得麻烦，故利用可以 nginx 将前端的指定路径代理到后端的8080、8081端口上。\n\nhttp: {\n  server {\n    server_name example.com\n\n    location /mail {\n    \tproxy_pass http:example.com:8080;\n    }\n\n    location /user {\n    \tproxy_pass http:example.com:8081;\n    }\n  }\n}\n\n\n * 将 http://example.com/mail/ 下的请求转发到 http://example.com:8080/\n * http://example.com/mail/index.html -> http://example.com:8080/index.html\n * 将 http://example.com/user/ 下的请求转发到 http://example.com:8081/\n * http://example.com/user/index.html -> http://example.com:8081/index.html\n\n\n# 反向代理\n\n> 这个功能也就是 nginx 的反向代理功能，即客户端不知道真正请求的服务端，我们可以用反向代理来解决跨域问题。\n\n例如：\n\n * 前端server的域名为：fe.server.com\n * 后端服务的域名为：dev.server.com\n\n现在我在fe.server.com 对 dev.server.com发起请求一定会出现跨域。\n\n现在我们只需要启动一个nginx服务器，将 server_name 设置为 fe.server.com ,然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置：\n\nserver {\n        listen       80;\n        server_name  fe.server.com;\n        location / {\n                proxy_pass dev.server.com;\n        }\n}\n\n\n这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。\n\n# 场景一\n\n访问某一台机器的域名时，我希望返回我上传到 bos 上的 html 地址。\n\nserver {  \n  listen       8088;        \n  server_name  xxx.com;\n\n  location / {\n  \tproxy_pass   http://bos/index.html;\n  }\n\n}\n\n\n此时访问的虽然是 xxx.com，但是实际请求的是 http://bos/index.html，对客户端隐藏了真实请求地址。\n\n\n# 负载均衡\n\n随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器集群。\n\n在服务器集群中，nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做负载均衡。\n\n# 负载均衡：设置domain\nupstream domain {\n    server localhost:8000;\n    server localhost:8001;\n}\nserver {  \n        listen       8080;        \n        server_name  localhost;\n\n        location / {\n            # root   html; # nginx默认值\n            # index  index.html index.htm;\n            \n            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口\n            proxy_set_header host $host:$server_port;\n        }\n}\n\n\n8000和8001是我本地起的两个页面，负载均衡成功后可以看到访问 localhost:8080 有时会访问到8000端口的页面，有时会访问到8001端口的页面。',charsets:{cjk:!0}},{title:"sh 脚本",frontmatter:{},regularPath:"/re/shell.html",relativePath:"re/shell.md",key:"v-12faf143",path:"/re/shell.html",headers:[{level:2,title:"Shell 变量",slug:"shell-变量",normalizedTitle:"shell 变量",charIndex:185},{level:3,title:"局部变量",slug:"局部变量",normalizedTitle:"局部变量",charIndex:247},{level:3,title:"环境变量(全局变量)",slug:"环境变量-全局变量",normalizedTitle:"环境变量(全局变量)",charIndex:429},{level:3,title:"path 环境变量",slug:"path-环境变量",normalizedTitle:"path 环境变量",charIndex:665},{level:3,title:"位置参数变量",slug:"位置参数变量",normalizedTitle:"位置参数变量",charIndex:1165},{level:3,title:"预定义变量",slug:"预定义变量",normalizedTitle:"预定义变量",charIndex:1609},{level:2,title:"括号",slug:"括号",normalizedTitle:"括号",charIndex:1214},{level:3,title:"双中括号",slug:"双中括号",normalizedTitle:"双中括号",charIndex:1771}],lastUpdated:"7/5/2022, 7:19:29 PM",lastUpdatedTimestamp:1657019969e3,headersStr:"Shell 变量 局部变量 环境变量(全局变量) path 环境变量 位置参数变量 预定义变量 括号 双中括号",content:"# sh 脚本\n\nsh 脚本即 shell 脚本，就是由 Shell 命令组成的执行文件。我们可以通过shell命令来操作和控制操作系统，比如Linux中的 Shell 命令就包括ls、cd、pwd等等。shell 脚本和 linux 命令的区别是 shell 是一个用 C 语言编写的程序，既是一种命令语言，又是一种程序设计语言，相当于有了一定的逻辑和过程。\n\n\n# Shell 变量\n\nShell 变量分为系统变量和自定义变量。系统变量有$HOME、$PWD、$USER等。自定义变量又分为局部变量和环境变量（全局变量）\n\n * 显示所有变量：set\n * 删除变量：unset 变量名\n * 使用变量：$变量名、${变量名}\n * 打印变量：echo ${变量名}\n\n\n# 局部变量\n\n * 定义变量：变量名=变量值，等号两侧不能有空格，变量名一般习惯用大写。\n * 声明静态变量：readonly 变量名=变量值，静态变量不能 unset。\n\n\n# 环境变量(全局变量)\n\n> 与局部变量的区别是子 shell 继承可以当前父 shell 的环境变量，并能一直传承下去\n\n 1. export 变量名=变量值，将 Shell 变量输出为环境变量。\n 2. source 配置文件路径，让修改后的配置信息立即生效。\n 3. echo $变量名，检查环境变量是否生效\n\nexport var=1 # 注意等号两边不能有空格\necho ${var}\n\nbash # 开启子 shell\necho ${var} # 1\n\n\n\n# path 环境变量\n\n首先介绍一下 which 命令，它用于查找某个命令所在的绝对路径。\n\nwhich node #/usr/local/bin/node\nwhich npm #/usr/local/bin/npm\nwhich rm #/bin/rm\n\n\n为什么前面在使用 rm、node、npm 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置，这是 PATH 环境变量在起作用。\n\necho $PATH\n# /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin\n\n\nPATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件。\n\nexport APATH = /user/a/bin\nexport PATH=$APATH:$PATH\n\n# 在原有的 path 基础上添加新的目录\n# 注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。\n\n\n\n# 位置参数变量\n\n * $n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。\n * $* ：传递给脚本或者函数的所有参数，且把所有参数看成一个整体输出。\n * $@ ：传递给脚本或者函数的所有参数，且把每个参数区分对待输出。\n * $# ：所有参数个数。\n\n# test.sh 输出各个参数 \necho $0 $1 $2 \necho $* test.sh\necho $@ \necho 参数个数=$#\n\n\nchmod +x test.sh # 赋予文件的执行权限\n./test.sh 1 2 3 4\n\n# ./test.sh 1 2\n# 1 2 3 4 test.sh\n# 1 2 3 4\n# 参数个数=4\n\n\n将命令行参数传递到脚本，再传递到函数内：\n\n# test.sh\nfunction main() {\n    echo $@ # 接收函数传入参数\n}\n\nmain $@ # 接收命令行传入参数\n\n\n./test.sh 123\n\n\n\n# 预定义变量\n\n * $$ ：当前进程的 PID 进程号。\n * $! ：后台运行的最后一个进程的 PID 进程号。\n * $? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。\n\nnpm install # 假如执行了安装依赖的命令并报错\necho $? # 则会打印非0，代表执行失败\n\n\n\n# 括号\n\n\n# 双中括号\n\n * [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在 [[ 和 ]] 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。\n * 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。\n * 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]]。\n * bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。\n\n# 判断上一条命令返回状态是否为 0（正确），为 0 则输出\n\n[[ $? = 0 ]] && echo $?\n",normalizedContent:"# sh 脚本\n\nsh 脚本即 shell 脚本，就是由 shell 命令组成的执行文件。我们可以通过shell命令来操作和控制操作系统，比如linux中的 shell 命令就包括ls、cd、pwd等等。shell 脚本和 linux 命令的区别是 shell 是一个用 c 语言编写的程序，既是一种命令语言，又是一种程序设计语言，相当于有了一定的逻辑和过程。\n\n\n# shell 变量\n\nshell 变量分为系统变量和自定义变量。系统变量有$home、$pwd、$user等。自定义变量又分为局部变量和环境变量（全局变量）\n\n * 显示所有变量：set\n * 删除变量：unset 变量名\n * 使用变量：$变量名、${变量名}\n * 打印变量：echo ${变量名}\n\n\n# 局部变量\n\n * 定义变量：变量名=变量值，等号两侧不能有空格，变量名一般习惯用大写。\n * 声明静态变量：readonly 变量名=变量值，静态变量不能 unset。\n\n\n# 环境变量(全局变量)\n\n> 与局部变量的区别是子 shell 继承可以当前父 shell 的环境变量，并能一直传承下去\n\n 1. export 变量名=变量值，将 shell 变量输出为环境变量。\n 2. source 配置文件路径，让修改后的配置信息立即生效。\n 3. echo $变量名，检查环境变量是否生效\n\nexport var=1 # 注意等号两边不能有空格\necho ${var}\n\nbash # 开启子 shell\necho ${var} # 1\n\n\n\n# path 环境变量\n\n首先介绍一下 which 命令，它用于查找某个命令所在的绝对路径。\n\nwhich node #/usr/local/bin/node\nwhich npm #/usr/local/bin/npm\nwhich rm #/bin/rm\n\n\n为什么前面在使用 rm、node、npm 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置，这是 path 环境变量在起作用。\n\necho $path\n# /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/library/apple/usr/bin\n\n\npath 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，linux 会依照 path 中包含的目录依次搜寻该命令的可执行文件。\n\nexport apath = /user/a/bin\nexport path=$apath:$path\n\n# 在原有的 path 基础上添加新的目录\n# 注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$path 就恢复成了默认值。\n\n\n\n# 位置参数变量\n\n * $n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。\n * $* ：传递给脚本或者函数的所有参数，且把所有参数看成一个整体输出。\n * $@ ：传递给脚本或者函数的所有参数，且把每个参数区分对待输出。\n * $# ：所有参数个数。\n\n# test.sh 输出各个参数 \necho $0 $1 $2 \necho $* test.sh\necho $@ \necho 参数个数=$#\n\n\nchmod +x test.sh # 赋予文件的执行权限\n./test.sh 1 2 3 4\n\n# ./test.sh 1 2\n# 1 2 3 4 test.sh\n# 1 2 3 4\n# 参数个数=4\n\n\n将命令行参数传递到脚本，再传递到函数内：\n\n# test.sh\nfunction main() {\n    echo $@ # 接收函数传入参数\n}\n\nmain $@ # 接收命令行传入参数\n\n\n./test.sh 123\n\n\n\n# 预定义变量\n\n * $$ ：当前进程的 pid 进程号。\n * $! ：后台运行的最后一个进程的 pid 进程号。\n * $? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。\n\nnpm install # 假如执行了安装依赖的命令并报错\necho $? # 则会打印非0，代表执行失败\n\n\n\n# 括号\n\n\n# 双中括号\n\n * [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在 [[ 和 ]] 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。\n * 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。\n * 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]]。\n * bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。\n\n# 判断上一条命令返回状态是否为 0（正确），为 0 则输出\n\n[[ $? = 0 ]] && echo $?\n",charsets:{cjk:!0}},{title:"React Fiber",frontmatter:{},regularPath:"/react/fiber.html",relativePath:"react/fiber.md",key:"v-96cebf82",path:"/react/fiber.html",headers:[{level:2,title:"ReactElement",slug:"reactelement",normalizedTitle:"reactelement",charIndex:135},{level:2,title:"为什么会出现 React fiber 架构",slug:"为什么会出现-react-fiber-架构",normalizedTitle:"为什么会出现 react fiber 架构",charIndex:1342},{level:2,title:"浏览器渲染",slug:"浏览器渲染",normalizedTitle:"浏览器渲染",charIndex:2165},{level:3,title:"渲染帧",slug:"渲染帧",normalizedTitle:"渲染帧",charIndex:2205},{level:3,title:"RequestIdleCallback",slug:"requestidlecallback",normalizedTitle:"requestidlecallback",charIndex:2770},{level:2,title:"Fiber Reconciler 如何工作",slug:"fiber-reconciler-如何工作",normalizedTitle:"fiber reconciler 如何工作",charIndex:3006},{level:2,title:"为什么没有 vue-fiber?",slug:"为什么没有-vue-fiber",normalizedTitle:"为什么没有 vue-fiber?",charIndex:3883}],lastUpdated:"5/22/2025, 11:29:40 AM",lastUpdatedTimestamp:174788458e4,headersStr:"ReactElement 为什么会出现 React fiber 架构 浏览器渲染 渲染帧 RequestIdleCallback Fiber Reconciler 如何工作 为什么没有 vue-fiber?",content:'# React Fiber\n\n本文转载自：\n\n * 你不知道的 React Virtual DOM\n * 面试官：React 为什么需要 Fiber？\n * 有React fiber，为什么不需要Vue fiber呢？\n * react fiber 到底有多细\n\n\n# ReactElement\n\n本质上 Virtual DOM 对应的是一个 JavaScript 对象，那么 React 是如何通过一个 js 对象将 Virtual DOM 和真实 DOM 对应起来的呢？这里面的关键就是 ReactElement。\n\nReactElement 即 react 元素，描述了我们在屏幕上所看到的内容，它是构成 React 应用的最小单元。比如下面的 jsx 代码：\n\nconst element = <h1 id="hello">Hello, world</h1>\n\n// 上面的代码经过编译后生成 React Api, createElement 有三个参数，标签，属性，内容\nReact.createElement("h1", {\n  id: "hello"\n}, "Hello, world");\n\n// 执行 React.createElement 函数，会返回类似于下面的一个 js 对象，这个对象就是我们所说的 React 元素：\nconst element = {\n  type: \'h1\',\n  props: {\n    id: \'hello\',\n    children: \'hello world\'\n  }\n}\n\n\nReact 元素也可以是用户自定义的组件：\n\nfunction Button(props) {\n  return <button style={{ color }}>{props.children}</button>;\n}\n\nconst buttonComp = <Button color="red">点击我</Button>\n\n// 以上 JSX 代码经过 Babel 编译后的代码如下，注意自定义组件为大写\nReact.createElement("Button", {\n  color: "red"\n}, "点击我");\n\n\n> 因此我们就可以说 React 元素其实就是一个普通的 js 对象(plain object)，这个对象用来描述一个 DOM 节点及其属性或者组件的实例，当我们在 JSX 中使用 Button 组件时，就相当于调用了React.createElement()方法对组件进行了实例化。由于组件可以在其输出中引用其他组件，当我们在构建复杂逻辑的组件时，会形成一个树形结构的组件树，React 便会一层层的递归的将其转化为 React 元素，当遇见 type 为大写的类型时，react 就会知道这是一个自定义的组件元素，然后执行组件的 render 方法或者执行该组件函数（根据是类组件或者函数组件的不同），最终返回 、描述 DOM 的元素进行渲染。\n\n综上：react 是通过 jsx 描述界面的，它会被 babel 或 tsc 等编译工具编译成 render function，然后执行产生 vdom\n\n\n# 为什么会出现 React fiber 架构\n\n一个 React 组件的渲染主要经历两个阶段：\n\n * 调度阶段（Reconciler）：用新的数据生成一棵新的树，然后通过 Diff 算法，遍历旧的树，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。\n * 渲染阶段（Renderer）：遍历更新队列，通过调用宿主环境的 API，实际更新渲染对应的元素。宿主环境如 DOM，Native 等。\n\nReact 15 Stack Reconciler （栈协调器）是通过递归更新子组件 。由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。在setState后，react 会立即开始reconciler过程，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的DOM树来说，reconciliation过程会很长(x00ms)，在这期间，主线程是被 js 占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。\n\n\n\nReact 16 及以后使用的是 Fiber Reconciler（纤维协调器），将递归中无法中断的更新重构为迭代中的异步可中断更新过程，这样就能够更好的控制组件的渲染。\n\n简单理解就是把一个耗时长的任务分解为一个个的工作单元（每个工作单元运行时间很短，不过总时间依然很长）。在执行工作单元之前，由浏览器判断是否有空余时间执行，有时间就执行工作单元，执行完成后，继续判断是否还有空闲时间。没有时间就终止执行让浏览器执行其他任务（如 GUI 线程等）。等到下一帧执行时判断是否有空余时间，有时间就从终止的地方继续执行工作单元,一直重复到任务结束。\n\n\n\n\n# 浏览器渲染\n\n介绍 Fiber 前，我们先了解下浏览器渲染的一些概念。\n\n\n# 渲染帧\n\n我们知道，在浏览器中，页面是一帧一帧绘制出来的，渲染的帧率与设备的刷新率保持一致。一般情况下，设备的屏幕刷新率为 1s 60次，当每秒内绘制的帧数（FPS）超过60时，页面渲染是流畅的；而当 FPS 小于60时，会出现一定程度的卡顿现象。下面来看完整的一帧中，具体做了哪些：\n\n\n\n 1. 首先需要处理输入事件，能够让用户得到最早的反馈\n 2. 接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调\n 3. 接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等\n 4. 接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调\n 5. 紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示\n 6. 接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充\n\n到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行requestIdleCallback里注册的任务（它就是 React Fiber 任务调度实现的基础）\n\n\n# RequestIdleCallback\n\nRequestIdleCallback 是 react Fiber 实现的基础 api 。该方法将在浏览器的空闲时段内调用的函数排队，使开发者在主事件循环上执行后台和低优先级的工作，而不影响延迟关键事件，如动画和输入响应。正常帧任务完成后没超过16ms，说明有多余的空闲时间，此时就会执行requestIdleCallback里注册的任务。\n\n可以参考下图来理解requestIdleCallback在每帧中的调用：\n\n\n\n\n# Fiber Reconciler 如何工作\n\n为了实现渐进渲染的目的，Fiber 架构中引入了新的数据结构：Fiber Node，Fiber Node Tree 根据 React Element Tree 生成，并用来驱动真实 DOM 的渲染。\n\nFiber 节点的大致结构：\n\n{\n    tag: TypeOfWork, // 标识 fiber 类型\n    type: \'div\', // 和 fiber 相关的组件类型\n    return: Fiber | null, // 父节点\n    child: Fiber | null, // 子节点\n    sibling: Fiber | null, // 同级节点\n    alternate: Fiber | null, // diff 的变化记录在这个节点上\n    ...\n}\n\n\n双缓存 Fiber Tree 是 React Fiber 架构中的核心机制，用于实现高效的 UI 更新与渲染。它的核心思想是通过两个交替的 Fiber 树（当前树和待更新树）实现无阻塞渲染，确保用户交互的流畅性。\n\n 1. 当前树（Current Tree）： 对应屏幕上当前显示的 UI 结构，每个 Fiber 节点（组件）保存了当前状态的引用。\n\n 2. 待更新树（WorkInProgress Tree）： 后台构建的新树，用于描述下一次渲染的 UI 结构。当构建完成且无更高优先级任务时，会替换当前树。\n\n 3. 交替机制： 每次更新时，React 复用当前树的 Fiber 节点生成待更新树，最终通过切换树指针完成更新，避免直接操作当前树导致的渲染阻塞。\n\n关键优势\n\n 1. 无阻塞渲染： 构建待更新树的过程可中断（时间分片），浏览器可优先处理高优先级任务（如用户输入）。\n\n 2. 高效复用： 通过复用 Fiber 节点减少内存分配，提升性能（如 key 相同的节点仅更新属性而非重建）。\n\n 3. 一致性保证： 提交阶段一次性提交所有变更，避免渲染中间状态导致的 UI 不一致。\n\n\n# 为什么没有 vue-fiber?\n\n * 在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存；\n * vue则是直接修改保存状态的那块原始内存。\n\n所以经常能看到react相关的文章里经常会出现一个词"immutable"，翻译过来就是不可变的。数据修改了，接下来要解决视图的更新：\n\n> react中，调用setState方法后，会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染；\n> \n> 而 vue 使用 Object.defineProperty（vue@3迁移到了Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。\n\n所以当一个数据改变，react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到当前组件的粒度。\n\n\n\nreact fiber是在弥补更新时“无脑”刷新，不够精确带来的缺陷。这是不是能说明react性能更差呢？\n\n并不是。孰优孰劣是一个很有争议的话题，在此不做评价。因为vue实现精准更新也是有代价的，一方面是需要给每一个组件配置一个“监视器”，管理着视图的依赖收集和数据更新时的发布通知，这对性能同样是有消耗的；另一方面vue能实现依赖收集得益于它的模版语法，实现静态编译，这是使用更灵活的 JSX 语法的 react 做不到的。\n\n在react fiber出现之前，react也提供了PureComponent、shouldComponentUpdate、useMemo、useCallback等方法给我们，来声明哪些是不需要连带更新子组件。',normalizedContent:'# react fiber\n\n本文转载自：\n\n * 你不知道的 react virtual dom\n * 面试官：react 为什么需要 fiber？\n * 有react fiber，为什么不需要vue fiber呢？\n * react fiber 到底有多细\n\n\n# reactelement\n\n本质上 virtual dom 对应的是一个 javascript 对象，那么 react 是如何通过一个 js 对象将 virtual dom 和真实 dom 对应起来的呢？这里面的关键就是 reactelement。\n\nreactelement 即 react 元素，描述了我们在屏幕上所看到的内容，它是构成 react 应用的最小单元。比如下面的 jsx 代码：\n\nconst element = <h1 id="hello">hello, world</h1>\n\n// 上面的代码经过编译后生成 react api, createelement 有三个参数，标签，属性，内容\nreact.createelement("h1", {\n  id: "hello"\n}, "hello, world");\n\n// 执行 react.createelement 函数，会返回类似于下面的一个 js 对象，这个对象就是我们所说的 react 元素：\nconst element = {\n  type: \'h1\',\n  props: {\n    id: \'hello\',\n    children: \'hello world\'\n  }\n}\n\n\nreact 元素也可以是用户自定义的组件：\n\nfunction button(props) {\n  return <button style={{ color }}>{props.children}</button>;\n}\n\nconst buttoncomp = <button color="red">点击我</button>\n\n// 以上 jsx 代码经过 babel 编译后的代码如下，注意自定义组件为大写\nreact.createelement("button", {\n  color: "red"\n}, "点击我");\n\n\n> 因此我们就可以说 react 元素其实就是一个普通的 js 对象(plain object)，这个对象用来描述一个 dom 节点及其属性或者组件的实例，当我们在 jsx 中使用 button 组件时，就相当于调用了react.createelement()方法对组件进行了实例化。由于组件可以在其输出中引用其他组件，当我们在构建复杂逻辑的组件时，会形成一个树形结构的组件树，react 便会一层层的递归的将其转化为 react 元素，当遇见 type 为大写的类型时，react 就会知道这是一个自定义的组件元素，然后执行组件的 render 方法或者执行该组件函数（根据是类组件或者函数组件的不同），最终返回 、描述 dom 的元素进行渲染。\n\n综上：react 是通过 jsx 描述界面的，它会被 babel 或 tsc 等编译工具编译成 render function，然后执行产生 vdom\n\n\n# 为什么会出现 react fiber 架构\n\n一个 react 组件的渲染主要经历两个阶段：\n\n * 调度阶段（reconciler）：用新的数据生成一棵新的树，然后通过 diff 算法，遍历旧的树，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。\n * 渲染阶段（renderer）：遍历更新队列，通过调用宿主环境的 api，实际更新渲染对应的元素。宿主环境如 dom，native 等。\n\nreact 15 stack reconciler （栈协调器）是通过递归更新子组件 。由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。在setstate后，react 会立即开始reconciler过程，从父节点（virtual dom）开始遍历，以找出不同。将所有的virtual dom遍历完成后，reconciler才能给出当前需要修改真实dom的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的dom树来说，reconciliation过程会很长(x00ms)，在这期间，主线程是被 js 占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。\n\n\n\nreact 16 及以后使用的是 fiber reconciler（纤维协调器），将递归中无法中断的更新重构为迭代中的异步可中断更新过程，这样就能够更好的控制组件的渲染。\n\n简单理解就是把一个耗时长的任务分解为一个个的工作单元（每个工作单元运行时间很短，不过总时间依然很长）。在执行工作单元之前，由浏览器判断是否有空余时间执行，有时间就执行工作单元，执行完成后，继续判断是否还有空闲时间。没有时间就终止执行让浏览器执行其他任务（如 gui 线程等）。等到下一帧执行时判断是否有空余时间，有时间就从终止的地方继续执行工作单元,一直重复到任务结束。\n\n\n\n\n# 浏览器渲染\n\n介绍 fiber 前，我们先了解下浏览器渲染的一些概念。\n\n\n# 渲染帧\n\n我们知道，在浏览器中，页面是一帧一帧绘制出来的，渲染的帧率与设备的刷新率保持一致。一般情况下，设备的屏幕刷新率为 1s 60次，当每秒内绘制的帧数（fps）超过60时，页面渲染是流畅的；而当 fps 小于60时，会出现一定程度的卡顿现象。下面来看完整的一帧中，具体做了哪些：\n\n\n\n 1. 首先需要处理输入事件，能够让用户得到最早的反馈\n 2. 接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调\n 3. 接下来处理 begin frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等\n 4. 接下来执行请求动画帧 requestanimationframe（raf），即在每次绘制之前，会执行 raf 回调\n 5. 紧接着进行 layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示\n 6. 接着进行 paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充\n\n到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（idle peroid），可以在这时执行requestidlecallback里注册的任务（它就是 react fiber 任务调度实现的基础）\n\n\n# requestidlecallback\n\nrequestidlecallback 是 react fiber 实现的基础 api 。该方法将在浏览器的空闲时段内调用的函数排队，使开发者在主事件循环上执行后台和低优先级的工作，而不影响延迟关键事件，如动画和输入响应。正常帧任务完成后没超过16ms，说明有多余的空闲时间，此时就会执行requestidlecallback里注册的任务。\n\n可以参考下图来理解requestidlecallback在每帧中的调用：\n\n\n\n\n# fiber reconciler 如何工作\n\n为了实现渐进渲染的目的，fiber 架构中引入了新的数据结构：fiber node，fiber node tree 根据 react element tree 生成，并用来驱动真实 dom 的渲染。\n\nfiber 节点的大致结构：\n\n{\n    tag: typeofwork, // 标识 fiber 类型\n    type: \'div\', // 和 fiber 相关的组件类型\n    return: fiber | null, // 父节点\n    child: fiber | null, // 子节点\n    sibling: fiber | null, // 同级节点\n    alternate: fiber | null, // diff 的变化记录在这个节点上\n    ...\n}\n\n\n双缓存 fiber tree 是 react fiber 架构中的核心机制，用于实现高效的 ui 更新与渲染。它的核心思想是通过两个交替的 fiber 树（当前树和待更新树）实现无阻塞渲染，确保用户交互的流畅性。\n\n 1. 当前树（current tree）： 对应屏幕上当前显示的 ui 结构，每个 fiber 节点（组件）保存了当前状态的引用。\n\n 2. 待更新树（workinprogress tree）： 后台构建的新树，用于描述下一次渲染的 ui 结构。当构建完成且无更高优先级任务时，会替换当前树。\n\n 3. 交替机制： 每次更新时，react 复用当前树的 fiber 节点生成待更新树，最终通过切换树指针完成更新，避免直接操作当前树导致的渲染阻塞。\n\n关键优势\n\n 1. 无阻塞渲染： 构建待更新树的过程可中断（时间分片），浏览器可优先处理高优先级任务（如用户输入）。\n\n 2. 高效复用： 通过复用 fiber 节点减少内存分配，提升性能（如 key 相同的节点仅更新属性而非重建）。\n\n 3. 一致性保证： 提交阶段一次性提交所有变更，避免渲染中间状态导致的 ui 不一致。\n\n\n# 为什么没有 vue-fiber?\n\n * 在react中，组件的状态是不能被修改的，setstate没有修改原来那块内存中的变量，而是去新开辟一块内存；\n * vue则是直接修改保存状态的那块原始内存。\n\n所以经常能看到react相关的文章里经常会出现一个词"immutable"，翻译过来就是不可变的。数据修改了，接下来要解决视图的更新：\n\n> react中，调用setstate方法后，会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染；\n> \n> 而 vue 使用 object.defineproperty（vue@3迁移到了proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。\n\n所以当一个数据改变，react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到当前组件的粒度。\n\n\n\nreact fiber是在弥补更新时“无脑”刷新，不够精确带来的缺陷。这是不是能说明react性能更差呢？\n\n并不是。孰优孰劣是一个很有争议的话题，在此不做评价。因为vue实现精准更新也是有代价的，一方面是需要给每一个组件配置一个“监视器”，管理着视图的依赖收集和数据更新时的发布通知，这对性能同样是有消耗的；另一方面vue能实现依赖收集得益于它的模版语法，实现静态编译，这是使用更灵活的 jsx 语法的 react 做不到的。\n\n在react fiber出现之前，react也提供了purecomponent、shouldcomponentupdate、usememo、usecallback等方法给我们，来声明哪些是不需要连带更新子组件。',charsets:{cjk:!0}},{title:"React基础",frontmatter:{title:"React基础",date:"2021-06-17T11:27:54.000Z",categories:"React"},regularPath:"/react/react-1.html",relativePath:"react/react-1.md",key:"v-1a9ac042",path:"/react/react-1.html",headers:[{level:3,title:"1. React 介绍",slug:"_1-react-介绍",normalizedTitle:"1. react 介绍",charIndex:2},{level:3,title:"2. JSX 语法",slug:"_2-jsx-语法",normalizedTitle:"2. jsx 语法",charIndex:110},{level:3,title:"3. 组件",slug:"_3-组件",normalizedTitle:"3. 组件",charIndex:6091},{level:3,title:"4. 表单",slug:"_4-表单",normalizedTitle:"4. 表单",charIndex:10483},{level:3,title:"5. 路由",slug:"_5-路由",normalizedTitle:"5. 路由",charIndex:11306}],lastUpdated:"6/26/2023, 7:15:43 PM",lastUpdatedTimestamp:1687778143e3,headersStr:"1. React 介绍 2. JSX 语法 3. 组件 4. 表单 5. 路由",content:'# 1. React 介绍\n\nReact 是一个用于构建用户界面的 JavaScript 库，它只负责应用的视图层，帮助开发人员构建快速且交互式的 web 应用程序。\n\nReact 使用组件的方式构建用户界面。\n\n\n# 2. JSX 语法\n\n它是一种 JavaScript 语法的扩展，React 使用它来描述用户界面长成什么样子。在 React 代码执行之前，Babel 会对将 JSX 编译为 React API。React.createElement会返回Virtual DOM，然后再转换为真实DOM\n\n\x3c!-- JSX --\x3e\n<div className="container">\n  <h3>Hello React</h3>\n  <p>React is great </p>\n</div>\n\n\n// Babel 会对将 JSX 编译为 React API\nReact.createElement(\n  "div",\n  {\n    className: "container"\n  },\n  React.createElement("h3", null, "Hello React"), // 三个参数，标签，属性，内容\n  React.createElement("p", null, "React is great")\n);\n\n\n// 返回对应的 Virtual DOM，三个属性type, props, children\n{\n  type: "div",\n  props: { className: "container" },\n  children: [\n    {\n      type: "h3",\n      props: null,\n      children: [\n        {\n          type: "text",\n          props: {\n            textContent: "Hello React"\n          }\n        }\n      ]\n    },\n    {\n      type: "p",\n      props: null,\n      children: [\n        {\n          type: "text",\n          props: {\n            textContent: "React is great"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n\n从两种语法对比来看，JSX 语法的出现是为了让 React 开发人员编写用户界面代码更加轻松。\n\nBabel REPL\n\n# 2.1 在 JSX 中使用表达式\n\nconst user = {\n  firstName: \'Harper\',\n  lastName: \'Perez\'\n}\nfunction formatName(user) {\n  return user.firstName + \' \' + user.lastName;\n}\nconst element = <h1>Hello, {formatName(user)}!</h1>;\n\n\nJSX 本身其实也是一种表达式，将它赋值给变量，当作参数传入，作为返回值都可以。\n\nfunction getGreeting(user) {\n  if (user) {\n    return <h1>Hello, {formatName(user)}!</h1>;\n  }\n  return <h1>Hello, Stranger.</h1>;\n}\n\n\n# 2.2 属性\n\n如果属性值为字符串类型，需要加引号，属性名称推荐采用驼峰式命名法。\n\nconst element = <div greeting="hello"></div>;\n\n\n如果属性值为JavaScript表达式，属性值外面加大括号。\n\nconst element = <img src={user.avatarUrl} />;\n// 注意大括号外面不能加引号，JSX 会将引号当中的内容识别为字符串而不是表达式\n\n\n# 2.3 JSX 单标记必须闭合\n\n如果 JSX 是单标记，必须闭合，否则报错。\n\nconst element = <img src={user.avatarUrl} />\nconst element = <input type="text"/>\n\n\n# 2.4 className\n\n为 JSX 标记添加类名需要使用 className，而不是class。\n\nconst element = <img src={user.avatarUrl} className="rounded"/>;\n\n\n# 2.5 JSX 自动展开数组\n\nconst ary = [<p>哈哈</p>, <p>呵呵</p>, <p>嘿嘿</p>];\nconst element = (\n\t<div>{ary}</div>\n);\n// 解析后\n/*\n\t<div>\n\t\t<p>哈哈</p>\n\t\t<p>呵呵</p>\n\t\t<p>嘿嘿</p>\n\t</div>\n*/\n\n\n# 2.6 三元运算\n\n{ boolean ? <div>Hello React</div> : null }\n{ boolean && <div>Hello React</div> }\n\n\n# 2.7 循环\n\nconst persons = [{\n  id: 1,\n  name: \'张三\',\n  age: 20\n}, {\n  id: 2,\n  name: \'李四\',\n  age: 15\n}, {\n  id: 3,\n  name: \'王五\',\n  age: 22\n}]\n\n\n<ul>\n  { persons.map(person => <li key={person.id}> {person.name} {person.age} </li>) }\n</ul>\n\n\n# 2.8 事件\n\n{/* 第一个参数即是事件对象 不需传递 */}\n<button onClick={this.eventHandler}>按钮</button>\n{/* 需要传递事件对象 */}\n<button onClick={e=>this.eventHandler(\'arg\',e)}>按钮</button>\n{/* 最后一个参数即是事件对象 不需传递 */}\n<button onClick={this.eventHandler.bind(this, \'arg\')}>按钮</button>\n\n\nconstructor () {\n  this.eventHandler = this.eventHandler.bind(this)\n}\neventHandler () {}\n<button onClick={this.eventHandler}>按钮</button>\n\n\nReact事件处理函数必须使用bind(this)的原因\n\n// 上面链接中的例子详解\nexport default class Demo extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = {\n            count:4\n        };\n    }\n    render(){\n        return (\n            <div>\n                <button onClick={this.handleAdd}>点击一下</button>\n                <button onClick={this.handleClick.bind(this)}>点击一下</button>\n                <p>{this.state.count}</p>\n            </div>\n        )\n    }\n    // 要么使用箭头函数 此时 this 指向是当前实例对象\n    handleAdd = () => {\n        console.log(this)\n        this.setState({\n            count:5\n        })\n    }\n    // 要么使用普通函数，但是需要 bind(this)\n    handleClick() {\n        console.log(this)\n        this.setState({\n            count:6\n        })\n    }\n}\n\n\n# 2.9 样式\n\n# 2.9.1 行内样式\n\nclass App extends Component {\n  render() {\n    const style = {width: 200, height: 200, backgroundColor: \'red\'};\n    return <div style={style}></div>\n  }\n}\n\n\n# 2.9.2 外链样式\n\n// Button.js\nimport styles from \'./Button.module.css\';\nclass Button extends Component {\n  render() {\n    return <button className={styles.error}>Error Button</button>;\n  }\n}\n\n\n# 2.9.3 全局样式\n\nimport \'./styles.css\'\n\n\n# 2.10 ref 属性\n\n# 2.10.1 createRef\n\nclass Input extends Component {\n  constructor() {\n    super()\n    this.inputRef = React.createRef()\n  }\n  render() {\n    return (\n      <div>\n        <input type="text" ref={this.inputRef} />\n        <button onClick={() => console.log(this.inputRef.current)}> button </button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.2 函数参数\n\n// 参数input指向当前节点\nclass Input extends Component {\n  render() {\n    return (\n      <div>\n        <input type="text" ref={input => (this.input = input)} />\n        <button onClick={() => console.log(this.input)}>button</button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.3 ref 字符串\n\n不推荐使用，在严格模式下报错。\n\nclass Input extends Component {\n  render() {\n    return (\n      <div>\n        <input type="text" ref="username" />\n        <button onClick={() => console.log(this.refs.username)}>button</button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.4 获取组件实例\n\n点击按钮让 input 文本框获取焦点。\n\ninput 文本框以及让文本框获取焦点的方法定义在 Input 组件中，在 App 组件中引入 Input 组件，按钮定义在 App 组件中。\n\n// Input.js\nclass Input extends Component {\n  constructor() {\n    super()\n    this.inputRef = React.createRef()\n    this.focusInput = this.focusInput.bind(this)\n  }\n  focusInput() {\n    this.inputRef.current.focus()\n  }\n  render() {\n    return (\n      <div>\n        <input type="text" ref={this.inputRef} />\n      </div>\n    )\n  }\n}\n\n\n// App.js\nclass App extends Component {\n  constructor() {\n    super()\n    this.InputComponentRef = React.createRef()\n  }\n  render() {\n    return (\n      <div className="App">\n        <Input ref={this.InputComponentRef} />\n        <button onClick={() => this.InputComponentRef.current.focusInput()}>button</button>\n      </div>\n    )\n}\n\n\n# 2.11 括号\n\nreturn 后面带着一个圆括号，只是为了换行显示，也可以是中括号[]。不使用括号不能换行。\n\n// ok\nconst Person = () => {\n\treturn <div>\n    \thello world;\n    </div>\n}\n\n// ok\nconst Person = () => {\n\treturn (\n  \t<div>\n    \thello world;\n    </div>\n  );\n}\n\n// ok\nconst Person = () => {\n\treturn [\n    <div>\n    \thello world;\n    </div>\n  ];\n}\n\n// error\nconst Person = () => {\n\treturn\n    <div>\n    \thello world;\n    </div>\n}\n\n\n\n# 3. 组件\n\n# 3.1 什么是组件\n\nReact 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。\n\n# 3.2 创建组件\n\n# 3.2.1 创建类组件\n\nimport React, { Component } from \'react\';\nclass App extends Component {\n    render () {\n        return <div>Hello, 我是类组件</div>\n    }\n}\n// render函数会转换成 React.createElement，所以需要引入 React\n\n\n# 3.2.2 创建函数组件\n\nconst Person = () => {\n     return <div>Hello, 我是函数型组件</div>;\n}\n\n\n注意事项\n\n 1. 组件名称首字母必须大写，用以区分组件和普通标签。\n 2. jsx语法外层必须有一个根元素\n\n# 3.3 组件 props\n\n# 3.3.1 props 传递数据\n\n在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。\n\n<Person name="乔治" age="20"/>\n<Person name="玛丽" age="10"/>\n\n\n// 类组件\nclass Person extends Component {\n  render() {\n    return (\n      <div>\n        <h3>姓名：{this.props.name}</h3>\n        <h4>年龄：{this.props.age}</h4>\n      </div>\n    );\n  }\n}\n\n\n// 函数组件\nconst Person = props => {\n  return (\n    <div>\n      <h3>姓名：{props.name}</h3>\n      <h4>年龄：{props.age}</h4>\n    </div>\n  );\n}\n\n\n注意：\n\n 1. props 对象中存储的数据是只读的，不能在组件内部被修改。\n 2. 当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动DOM )\n 3. 类组件render函数的this指向组件实例对象，function函数组件中的this是undefined\n\n# 3.3.2 设置 props 默认值\n\nclass App extends Component {\n    static defaultProps = {}\n}\n\n\nfunction ThemedButton(props) {\n}\nThemedButton.defaultProps = {\n  theme: "secondary",\n  label: "Button Text"\n};\n\n\n# 3.3.3 组件 children\n\n通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。\n\n<Person>组件内部的内容</Person>\n\n\nconst Person = (props) => {\n    return (\n    \t<div>{props.children}</div>\n    );\n}\n\n\n# 3.3.4 单向数据流\n\n 1. 在React中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件.\n\n 2. 单向数据流特性要求我们共享数据要放置在上层组件中.\n\n 3. 子组件通过调用父组件传递过来的方法更改数据.\n\n 4. 当数据发生更改时, React会重新渲染组件树.\n\n 5. 单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单.\n\n# 3.4 类组件状态 state\n\n# 3.4.1 定义组件状态\n\n类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 DOM 更新。\n\n组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为对象类型，属性名称固定不可更改。\n\nclass App extends Component {\n  constructor () {\n    super()\n    this.state = {\n      person: { name: \'张三\', age: 20 },\n    }\n  }\n  render () {\n    return (\n      <div>\n        {this.state.person.name}\n        {this.state.person.age}\n      </div>\n    );\n  }\n}\n\n\n# 3.4.2 更改组件状态\n\nstate 状态对象中的数据不可直接更改，如果直接更改 DOM 不会被更新，要更改 state 状态数据需要使用 setState方法。\n\nclass App extends Component {\n  constructor () {\n    this.state = {\n      person: { name: \'张三\', age: 20 },\n    }\n    this.changePerson = this.changePerson.bind(this)\n  }\n\tchangePerson () {\n    this.setState({\n      person: {\n        name: \'李四\',\n        age: 15\n      }\n    })\n  }\n  render() {\n    return (\n      <div>\n        {this.state.person.name}\n        {this.state.person.age}\n        <button onClick={this.changePerson}>按钮</button>\n      </div>\n    );\n  }\n}\n\n\n# 3.4.3 双向数据绑定\n\n双向数据绑定是指，组件类中更新了状态，DOM 状态同步更新，DOM 更改了状态，组件类中同步更新。组件 <=> 视图。\n\n要实现双向数据绑定需要用到表单元素和 state 状态对象。\n\nclass App extends Component {\n  constructor () {\n    this.state = {\n      name: "张三"\n    }\n    this.nameChanged = this.nameChanged.bind(this)\n  }\n  nameChanged (event) {\n    this.setState({name: event.target.value});\n  }\n  render() {\n    return (\n      <div>\n        <div>{this.state.name}</div>\n        <Person name={this.state.name} changed={this.nameChanged}/>\n      </div>\n    )\n  }\n}\n\n\nconst Person = props => {\n\treturn <input type="text" value={props.name} onChange={props.changed}/>;\n}\n\n\n# 3.5 类组件生命周期函数\n\n\n\n在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照\n\ncomponentDidUpdate(prevProps, prevState, snapshot) {}\n\n\ngetSnapshotBeforeUpdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentDidUpdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  return \'snapshot\'\n}\n\n\n# 3.6 Context\n\n通过 Context 可以跨层级传递数据\n\n// userContext.js\nimport React from "react"\n\nconst { Provider, Consumer } = React.createContext(defaultValue)\n\nexport { Provider, Consumer }\n\n\n// App.js\nimport { Provider } from "./userContext"\nclass App extends Component {\n  render() {\n    return (\n      <Provider value="Hello React Context(这是共享的数据)">\n        /*里面可以渲染对应的内容*/\n      </Provider>\n    )\n  }\n}\n\n\n// C.js\nimport { Consumer } from "./userContext"\n\nexport class C extends Component {\n  render() {\n    return (\n      <div>\n        <Consumer>\n          {value => /*根据上下文  进行渲染相应内容*/}\n        </Consumer>\n      </div>\n    )\n  }\n}\n\n\ncontext 的另一种用法\n\n// userContext.js\nexport default userContext\n\n\n// C.js\nimport userContext from "./userContext"\n\nexport class C extends Component {\n  static contextType = userContext\n  render() {\n    return (\n      <div>\n        {this.context}\n      </div>\n    )\n  }\n}\n\n\n\n# 4. 表单\n\n# 4.1 受控表单\n\n表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的\n\nclass App extends Component {\n  constructor () {\n    this.state = { username: "" }\n    this.nameChanged = this.nameChanged.bind(this)\n  }\n  \n  nameChanged (e) {\n    this.setState({username: e.target.value})\n  }\n  render() {\n    return (\n      <form>\n        <p>{this.state.username}</p>\n        <input type="text" value={this.state.username} onChange={this.nameChanged}/>\n      </form>\n    )\n  }\n}\n\n\n# 4.2 非受控表单\n\n表单元素的值由 DOM 元素本身管理。\n\nclass App extends Component {\n  constructor () {\n    this.onSubmit = this.onSubmit.bind(this)\n  }\n  onSubmit(e) {\n    console.log(this.username.value)\n    e.preventDefault();\n  }\n  render(\n    <form onSubmit={this.onSubmit}>\n      <input type="text" ref={username => this.username = username}/>\n    </form>\n  )\n}\n\n\n\n# 5. 路由\n\nurl地址与组件之间的对应关系，访问不同的url地址显示不同的组件。\n\n下载：npm install react-router-dom\n\n# 5.1.1 路由基本使用\n\n * Router放置在最外层\n\n * Link创建链接\n\n * Route设置和匹配路由规则 <Route path="/index" component={Index}/>，访问index路径时，显示Index组件。\n\n// App.js\nimport React from \'react\';\nimport { BrowserRouter as Router, Route, Link } from \'react-router-dom\';\nfunction Index() {\n\treturn <div>首页</div>;\n}\nfunction News() {\n\treturn <div>新闻</div>;\n}\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <Link to="/index">首页</Link>  \n        <Link to="/news">新闻</Link>\n      </div>\n      <div>\n        <Route path="/index" component={Index}/>\n        <Route path="/news" component={News}/>\n      </div>\n    </Router>\n  );\n}\n\n\n# 5.1.2 路由嵌套\n\nfunction News(props) {\n  return (\n    <div>\n      <div>\n        <Link to={`${props.match.url}/company`}>公司新闻</Link>\n        <Link to={`${props.match.url}/industry`}>行业新闻</Link>\n      </div>\n      <div>\n        <Route path={`${props.match.path}/company`} component={CompanyNews} />\n        <Route path={`${props.match.path}/industry`} component={IndustryNews}/>  \n      </div>\t\n    </div>\n  );\n}\n\nfunction CompanyNews() {\n\treturn <div>公司新闻</div>\n}\nfunction IndustryNews() {\n\treturn <div>行业新闻</div>\n}\n\n\n# 5.1.3 路由传参\n\nimport url from \'url\';\nclass News extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      list: [\n        {id: 1, title: \'新闻1\'},\n        {id: 2, title: \'新闻2\'},\n      ]\n    }\n  }\n    \n  render() {\n    return (\n      <div>\n        <div>新闻列表组件</div>\n        <ul>\n          this.state.list.map((item, index) => {\n            return (\n              <li key={index}>\n                <Link to={`/detail?id=${item.id}`}>{item.title}</Link>\n              </li>\n            );\n          })\n        </ul>\n      </div>\n    );\n  }\n}\n\nclass Detail extends Component {\n  constructor(props) {\n    super(props);\n  }\n\tconst { query } = url.parse(this.props.location.search, true); // 参数为true，结果转换为对象\n\tconsole.log(query); // {id: 1}\n  render() {\n    return <div>新闻详情</div>\n  }\n}\n\n\n# 5.1.4 路由重定向\n\nimport { Redirect } from \'react-router-dom\';\n\nclass Login extends Component {\n  render() {\n    if (this.state.isLogin) {\n      return <Redirect to="/"/>\n    }\n  }\n}\n',normalizedContent:'# 1. react 介绍\n\nreact 是一个用于构建用户界面的 javascript 库，它只负责应用的视图层，帮助开发人员构建快速且交互式的 web 应用程序。\n\nreact 使用组件的方式构建用户界面。\n\n\n# 2. jsx 语法\n\n它是一种 javascript 语法的扩展，react 使用它来描述用户界面长成什么样子。在 react 代码执行之前，babel 会对将 jsx 编译为 react api。react.createelement会返回virtual dom，然后再转换为真实dom\n\n\x3c!-- jsx --\x3e\n<div classname="container">\n  <h3>hello react</h3>\n  <p>react is great </p>\n</div>\n\n\n// babel 会对将 jsx 编译为 react api\nreact.createelement(\n  "div",\n  {\n    classname: "container"\n  },\n  react.createelement("h3", null, "hello react"), // 三个参数，标签，属性，内容\n  react.createelement("p", null, "react is great")\n);\n\n\n// 返回对应的 virtual dom，三个属性type, props, children\n{\n  type: "div",\n  props: { classname: "container" },\n  children: [\n    {\n      type: "h3",\n      props: null,\n      children: [\n        {\n          type: "text",\n          props: {\n            textcontent: "hello react"\n          }\n        }\n      ]\n    },\n    {\n      type: "p",\n      props: null,\n      children: [\n        {\n          type: "text",\n          props: {\n            textcontent: "react is great"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n\n从两种语法对比来看，jsx 语法的出现是为了让 react 开发人员编写用户界面代码更加轻松。\n\nbabel repl\n\n# 2.1 在 jsx 中使用表达式\n\nconst user = {\n  firstname: \'harper\',\n  lastname: \'perez\'\n}\nfunction formatname(user) {\n  return user.firstname + \' \' + user.lastname;\n}\nconst element = <h1>hello, {formatname(user)}!</h1>;\n\n\njsx 本身其实也是一种表达式，将它赋值给变量，当作参数传入，作为返回值都可以。\n\nfunction getgreeting(user) {\n  if (user) {\n    return <h1>hello, {formatname(user)}!</h1>;\n  }\n  return <h1>hello, stranger.</h1>;\n}\n\n\n# 2.2 属性\n\n如果属性值为字符串类型，需要加引号，属性名称推荐采用驼峰式命名法。\n\nconst element = <div greeting="hello"></div>;\n\n\n如果属性值为javascript表达式，属性值外面加大括号。\n\nconst element = <img src={user.avatarurl} />;\n// 注意大括号外面不能加引号，jsx 会将引号当中的内容识别为字符串而不是表达式\n\n\n# 2.3 jsx 单标记必须闭合\n\n如果 jsx 是单标记，必须闭合，否则报错。\n\nconst element = <img src={user.avatarurl} />\nconst element = <input type="text"/>\n\n\n# 2.4 classname\n\n为 jsx 标记添加类名需要使用 classname，而不是class。\n\nconst element = <img src={user.avatarurl} classname="rounded"/>;\n\n\n# 2.5 jsx 自动展开数组\n\nconst ary = [<p>哈哈</p>, <p>呵呵</p>, <p>嘿嘿</p>];\nconst element = (\n\t<div>{ary}</div>\n);\n// 解析后\n/*\n\t<div>\n\t\t<p>哈哈</p>\n\t\t<p>呵呵</p>\n\t\t<p>嘿嘿</p>\n\t</div>\n*/\n\n\n# 2.6 三元运算\n\n{ boolean ? <div>hello react</div> : null }\n{ boolean && <div>hello react</div> }\n\n\n# 2.7 循环\n\nconst persons = [{\n  id: 1,\n  name: \'张三\',\n  age: 20\n}, {\n  id: 2,\n  name: \'李四\',\n  age: 15\n}, {\n  id: 3,\n  name: \'王五\',\n  age: 22\n}]\n\n\n<ul>\n  { persons.map(person => <li key={person.id}> {person.name} {person.age} </li>) }\n</ul>\n\n\n# 2.8 事件\n\n{/* 第一个参数即是事件对象 不需传递 */}\n<button onclick={this.eventhandler}>按钮</button>\n{/* 需要传递事件对象 */}\n<button onclick={e=>this.eventhandler(\'arg\',e)}>按钮</button>\n{/* 最后一个参数即是事件对象 不需传递 */}\n<button onclick={this.eventhandler.bind(this, \'arg\')}>按钮</button>\n\n\nconstructor () {\n  this.eventhandler = this.eventhandler.bind(this)\n}\neventhandler () {}\n<button onclick={this.eventhandler}>按钮</button>\n\n\nreact事件处理函数必须使用bind(this)的原因\n\n// 上面链接中的例子详解\nexport default class demo extends react.component{\n    constructor(props){\n        super(props);\n        this.state = {\n            count:4\n        };\n    }\n    render(){\n        return (\n            <div>\n                <button onclick={this.handleadd}>点击一下</button>\n                <button onclick={this.handleclick.bind(this)}>点击一下</button>\n                <p>{this.state.count}</p>\n            </div>\n        )\n    }\n    // 要么使用箭头函数 此时 this 指向是当前实例对象\n    handleadd = () => {\n        console.log(this)\n        this.setstate({\n            count:5\n        })\n    }\n    // 要么使用普通函数，但是需要 bind(this)\n    handleclick() {\n        console.log(this)\n        this.setstate({\n            count:6\n        })\n    }\n}\n\n\n# 2.9 样式\n\n# 2.9.1 行内样式\n\nclass app extends component {\n  render() {\n    const style = {width: 200, height: 200, backgroundcolor: \'red\'};\n    return <div style={style}></div>\n  }\n}\n\n\n# 2.9.2 外链样式\n\n// button.js\nimport styles from \'./button.module.css\';\nclass button extends component {\n  render() {\n    return <button classname={styles.error}>error button</button>;\n  }\n}\n\n\n# 2.9.3 全局样式\n\nimport \'./styles.css\'\n\n\n# 2.10 ref 属性\n\n# 2.10.1 createref\n\nclass input extends component {\n  constructor() {\n    super()\n    this.inputref = react.createref()\n  }\n  render() {\n    return (\n      <div>\n        <input type="text" ref={this.inputref} />\n        <button onclick={() => console.log(this.inputref.current)}> button </button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.2 函数参数\n\n// 参数input指向当前节点\nclass input extends component {\n  render() {\n    return (\n      <div>\n        <input type="text" ref={input => (this.input = input)} />\n        <button onclick={() => console.log(this.input)}>button</button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.3 ref 字符串\n\n不推荐使用，在严格模式下报错。\n\nclass input extends component {\n  render() {\n    return (\n      <div>\n        <input type="text" ref="username" />\n        <button onclick={() => console.log(this.refs.username)}>button</button>\n      </div>\n    )\n  }\n}\n\n\n# 2.10.4 获取组件实例\n\n点击按钮让 input 文本框获取焦点。\n\ninput 文本框以及让文本框获取焦点的方法定义在 input 组件中，在 app 组件中引入 input 组件，按钮定义在 app 组件中。\n\n// input.js\nclass input extends component {\n  constructor() {\n    super()\n    this.inputref = react.createref()\n    this.focusinput = this.focusinput.bind(this)\n  }\n  focusinput() {\n    this.inputref.current.focus()\n  }\n  render() {\n    return (\n      <div>\n        <input type="text" ref={this.inputref} />\n      </div>\n    )\n  }\n}\n\n\n// app.js\nclass app extends component {\n  constructor() {\n    super()\n    this.inputcomponentref = react.createref()\n  }\n  render() {\n    return (\n      <div classname="app">\n        <input ref={this.inputcomponentref} />\n        <button onclick={() => this.inputcomponentref.current.focusinput()}>button</button>\n      </div>\n    )\n}\n\n\n# 2.11 括号\n\nreturn 后面带着一个圆括号，只是为了换行显示，也可以是中括号[]。不使用括号不能换行。\n\n// ok\nconst person = () => {\n\treturn <div>\n    \thello world;\n    </div>\n}\n\n// ok\nconst person = () => {\n\treturn (\n  \t<div>\n    \thello world;\n    </div>\n  );\n}\n\n// ok\nconst person = () => {\n\treturn [\n    <div>\n    \thello world;\n    </div>\n  ];\n}\n\n// error\nconst person = () => {\n\treturn\n    <div>\n    \thello world;\n    </div>\n}\n\n\n\n# 3. 组件\n\n# 3.1 什么是组件\n\nreact 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。\n\n# 3.2 创建组件\n\n# 3.2.1 创建类组件\n\nimport react, { component } from \'react\';\nclass app extends component {\n    render () {\n        return <div>hello, 我是类组件</div>\n    }\n}\n// render函数会转换成 react.createelement，所以需要引入 react\n\n\n# 3.2.2 创建函数组件\n\nconst person = () => {\n     return <div>hello, 我是函数型组件</div>;\n}\n\n\n注意事项\n\n 1. 组件名称首字母必须大写，用以区分组件和普通标签。\n 2. jsx语法外层必须有一个根元素\n\n# 3.3 组件 props\n\n# 3.3.1 props 传递数据\n\n在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。\n\n<person name="乔治" age="20"/>\n<person name="玛丽" age="10"/>\n\n\n// 类组件\nclass person extends component {\n  render() {\n    return (\n      <div>\n        <h3>姓名：{this.props.name}</h3>\n        <h4>年龄：{this.props.age}</h4>\n      </div>\n    );\n  }\n}\n\n\n// 函数组件\nconst person = props => {\n  return (\n    <div>\n      <h3>姓名：{props.name}</h3>\n      <h4>年龄：{props.age}</h4>\n    </div>\n  );\n}\n\n\n注意：\n\n 1. props 对象中存储的数据是只读的，不能在组件内部被修改。\n 2. 当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动dom )\n 3. 类组件render函数的this指向组件实例对象，function函数组件中的this是undefined\n\n# 3.3.2 设置 props 默认值\n\nclass app extends component {\n    static defaultprops = {}\n}\n\n\nfunction themedbutton(props) {\n}\nthemedbutton.defaultprops = {\n  theme: "secondary",\n  label: "button text"\n};\n\n\n# 3.3.3 组件 children\n\n通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。\n\n<person>组件内部的内容</person>\n\n\nconst person = (props) => {\n    return (\n    \t<div>{props.children}</div>\n    );\n}\n\n\n# 3.3.4 单向数据流\n\n 1. 在react中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件.\n\n 2. 单向数据流特性要求我们共享数据要放置在上层组件中.\n\n 3. 子组件通过调用父组件传递过来的方法更改数据.\n\n 4. 当数据发生更改时, react会重新渲染组件树.\n\n 5. 单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单.\n\n# 3.4 类组件状态 state\n\n# 3.4.1 定义组件状态\n\n类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 dom 更新。\n\n组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为对象类型，属性名称固定不可更改。\n\nclass app extends component {\n  constructor () {\n    super()\n    this.state = {\n      person: { name: \'张三\', age: 20 },\n    }\n  }\n  render () {\n    return (\n      <div>\n        {this.state.person.name}\n        {this.state.person.age}\n      </div>\n    );\n  }\n}\n\n\n# 3.4.2 更改组件状态\n\nstate 状态对象中的数据不可直接更改，如果直接更改 dom 不会被更新，要更改 state 状态数据需要使用 setstate方法。\n\nclass app extends component {\n  constructor () {\n    this.state = {\n      person: { name: \'张三\', age: 20 },\n    }\n    this.changeperson = this.changeperson.bind(this)\n  }\n\tchangeperson () {\n    this.setstate({\n      person: {\n        name: \'李四\',\n        age: 15\n      }\n    })\n  }\n  render() {\n    return (\n      <div>\n        {this.state.person.name}\n        {this.state.person.age}\n        <button onclick={this.changeperson}>按钮</button>\n      </div>\n    );\n  }\n}\n\n\n# 3.4.3 双向数据绑定\n\n双向数据绑定是指，组件类中更新了状态，dom 状态同步更新，dom 更改了状态，组件类中同步更新。组件 <=> 视图。\n\n要实现双向数据绑定需要用到表单元素和 state 状态对象。\n\nclass app extends component {\n  constructor () {\n    this.state = {\n      name: "张三"\n    }\n    this.namechanged = this.namechanged.bind(this)\n  }\n  namechanged (event) {\n    this.setstate({name: event.target.value});\n  }\n  render() {\n    return (\n      <div>\n        <div>{this.state.name}</div>\n        <person name={this.state.name} changed={this.namechanged}/>\n      </div>\n    )\n  }\n}\n\n\nconst person = props => {\n\treturn <input type="text" value={props.name} onchange={props.changed}/>;\n}\n\n\n# 3.5 类组件生命周期函数\n\n\n\n在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照\n\ncomponentdidupdate(prevprops, prevstate, snapshot) {}\n\n\ngetsnapshotbeforeupdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentdidupdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。\n\ngetsnapshotbeforeupdate(prevprops, prevstate) {\n  return \'snapshot\'\n}\n\n\n# 3.6 context\n\n通过 context 可以跨层级传递数据\n\n// usercontext.js\nimport react from "react"\n\nconst { provider, consumer } = react.createcontext(defaultvalue)\n\nexport { provider, consumer }\n\n\n// app.js\nimport { provider } from "./usercontext"\nclass app extends component {\n  render() {\n    return (\n      <provider value="hello react context(这是共享的数据)">\n        /*里面可以渲染对应的内容*/\n      </provider>\n    )\n  }\n}\n\n\n// c.js\nimport { consumer } from "./usercontext"\n\nexport class c extends component {\n  render() {\n    return (\n      <div>\n        <consumer>\n          {value => /*根据上下文  进行渲染相应内容*/}\n        </consumer>\n      </div>\n    )\n  }\n}\n\n\ncontext 的另一种用法\n\n// usercontext.js\nexport default usercontext\n\n\n// c.js\nimport usercontext from "./usercontext"\n\nexport class c extends component {\n  static contexttype = usercontext\n  render() {\n    return (\n      <div>\n        {this.context}\n      </div>\n    )\n  }\n}\n\n\n\n# 4. 表单\n\n# 4.1 受控表单\n\n表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的\n\nclass app extends component {\n  constructor () {\n    this.state = { username: "" }\n    this.namechanged = this.namechanged.bind(this)\n  }\n  \n  namechanged (e) {\n    this.setstate({username: e.target.value})\n  }\n  render() {\n    return (\n      <form>\n        <p>{this.state.username}</p>\n        <input type="text" value={this.state.username} onchange={this.namechanged}/>\n      </form>\n    )\n  }\n}\n\n\n# 4.2 非受控表单\n\n表单元素的值由 dom 元素本身管理。\n\nclass app extends component {\n  constructor () {\n    this.onsubmit = this.onsubmit.bind(this)\n  }\n  onsubmit(e) {\n    console.log(this.username.value)\n    e.preventdefault();\n  }\n  render(\n    <form onsubmit={this.onsubmit}>\n      <input type="text" ref={username => this.username = username}/>\n    </form>\n  )\n}\n\n\n\n# 5. 路由\n\nurl地址与组件之间的对应关系，访问不同的url地址显示不同的组件。\n\n下载：npm install react-router-dom\n\n# 5.1.1 路由基本使用\n\n * router放置在最外层\n\n * link创建链接\n\n * route设置和匹配路由规则 <route path="/index" component={index}/>，访问index路径时，显示index组件。\n\n// app.js\nimport react from \'react\';\nimport { browserrouter as router, route, link } from \'react-router-dom\';\nfunction index() {\n\treturn <div>首页</div>;\n}\nfunction news() {\n\treturn <div>新闻</div>;\n}\nfunction app() {\n  return (\n    <router>\n      <div>\n        <link to="/index">首页</link>  \n        <link to="/news">新闻</link>\n      </div>\n      <div>\n        <route path="/index" component={index}/>\n        <route path="/news" component={news}/>\n      </div>\n    </router>\n  );\n}\n\n\n# 5.1.2 路由嵌套\n\nfunction news(props) {\n  return (\n    <div>\n      <div>\n        <link to={`${props.match.url}/company`}>公司新闻</link>\n        <link to={`${props.match.url}/industry`}>行业新闻</link>\n      </div>\n      <div>\n        <route path={`${props.match.path}/company`} component={companynews} />\n        <route path={`${props.match.path}/industry`} component={industrynews}/>  \n      </div>\t\n    </div>\n  );\n}\n\nfunction companynews() {\n\treturn <div>公司新闻</div>\n}\nfunction industrynews() {\n\treturn <div>行业新闻</div>\n}\n\n\n# 5.1.3 路由传参\n\nimport url from \'url\';\nclass news extends component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      list: [\n        {id: 1, title: \'新闻1\'},\n        {id: 2, title: \'新闻2\'},\n      ]\n    }\n  }\n    \n  render() {\n    return (\n      <div>\n        <div>新闻列表组件</div>\n        <ul>\n          this.state.list.map((item, index) => {\n            return (\n              <li key={index}>\n                <link to={`/detail?id=${item.id}`}>{item.title}</link>\n              </li>\n            );\n          })\n        </ul>\n      </div>\n    );\n  }\n}\n\nclass detail extends component {\n  constructor(props) {\n    super(props);\n  }\n\tconst { query } = url.parse(this.props.location.search, true); // 参数为true，结果转换为对象\n\tconsole.log(query); // {id: 1}\n  render() {\n    return <div>新闻详情</div>\n  }\n}\n\n\n# 5.1.4 路由重定向\n\nimport { redirect } from \'react-router-dom\';\n\nclass login extends component {\n  render() {\n    if (this.state.islogin) {\n      return <redirect to="/"/>\n    }\n  }\n}\n',charsets:{cjk:!0}},{title:"React Diff 算法",frontmatter:{},regularPath:"/react/diff.html",relativePath:"react/diff.md",key:"v-207c297e",path:"/react/diff.html",headers:[{level:2,title:"Diff 算法的特点",slug:"diff-算法的特点",normalizedTitle:"diff 算法的特点",charIndex:303},{level:2,title:"key",slug:"key",normalizedTitle:"key",charIndex:418},{level:2,title:"Diff 流程 两轮遍历",slug:"diff-流程-两轮遍历",normalizedTitle:"diff 流程 两轮遍历",charIndex:909},{level:3,title:"第一轮遍历",slug:"第一轮遍历",normalizedTitle:"第一轮遍历",charIndex:926},{level:3,title:"第二轮遍历",slug:"第二轮遍历",normalizedTitle:"第二轮遍历",charIndex:946},{level:3,title:"举例",slug:"举例",normalizedTitle:"举例",charIndex:1162}],lastUpdated:"6/20/2025, 5:49:03 PM",lastUpdatedTimestamp:1750412943e3,headersStr:"Diff 算法的特点 key Diff 流程 两轮遍历 第一轮遍历 第二轮遍历 举例",content:'# React Diff 算法\n\n一个 React 组件的渲染主要经历两个阶段，diff 算法发生在调度阶段。\n\n * 调度阶段（Reconciler）：用新的数据生成一棵新的树，然后通过 Diff 算法，遍历旧的树，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。\n * 渲染阶段（Renderer）：遍历更新队列，通过调用宿主环境的 API，实际更新渲染对应的元素。宿主环境如 DOM，Native 等。\n\n> 第一次渲染不需要 diff，直接 vdom 转 fiber。再次渲染的时候，会产生新的 vdom，这时候要和之前的 fiber 做下对比，决定怎么产生新的 fiber。\n\n\n# Diff 算法的特点\n\nDiff 算法具有以下特点：\n\n 1. 分层，同级比较：React 将整个 DOM 树分为多个层级，然后逐层比较，只比较同一层级的节点，从而减少比较的复杂度。同级比较时按照从左到右的顺序进行比较。\n 2. key 属性：React 使用 key 属性来标识节点的唯一性，从而在比较时能够快速定位到需要更新的节点。\n\n\n# key\n\nkey 是 React 中用于标识节点的唯一性的一种机制。在 Diff 算法中，React 使用 key属性来快速定位到需要更新的节点，从而提高 Diff 算法的性能。\n\n我们经常强调在列表渲染中要使用 key 来提高性能，那么 key 到底是怎么帮助我们识别的呢？看一个简单的例子：\n\n<div>\n\t<p key="a">a</p>\n\t<span key="b">b</span>\n</div>\n\n<div>\n\t<span key="b">b</span>\n\t<p key="a">a</p>\n</div>\n\n\n在上面的例子中，React 在比较两个 JSX 对象时，会按照从左到右的顺序进行比较。那么两个 JSX 在比较第一个子节点时，发现 p 和 span 的元素类型不同，因此会销毁旧树并创建新树。\n\n但是由于他们有 key，React 会认为他们只是位置发生了变化，而不是元素类型发生了变化，因此会复用旧树中的节点，只是改变他们的位置。\n\n\n# Diff 流程 两轮遍历\n\n * 第一轮遍历，处理可复用的节点。\n\n * 第二轮遍历，遍历第一轮剩下的 fiber。\n\n\n# 第一轮遍历\n\n对比新旧节点，如果可以复用就处理下一个节点，否则就结束遍历。结束遍历时如果还有旧的节点没处理完，那就进行第二次遍历。\n\n\n# 第二轮遍历\n\n把第一轮剩下的 老 fiber 节点放到 map 里，然后遍历新的 vdom 节点，从 map 中能找到的话，就是可复用，移动过来打上更新的标记。遍历完之后，剩下的老 fiber 节点删掉，剩下的新 vdom 新增。\n\n\n# 举例\n\n\x3c!-- 更新前 --\x3e\n<ul>\n\t<li key="a">a</li>\n\t<li key="b">b</li>\n\t<li key="c">c</li>\n\t<li key="d">d</li>\n</ul>\n\x3c!-- 更新后 --\x3e\n<ul>\n\t<li key="a">a</li>\n\t<li key="c">c</li>\n\t<li key="b">b</li>\n\t<li key="e">e</li>\n</ul>\n\n\n> 对比新的 vdom 和 老的 fiber，发现 A 是可以复用的。继续向后遍历发现 C 不可复用，所以结束第一轮遍历，进入第二轮遍历。把剩下的 老 fiber 节点 b, c, d 放到 map 里，然后遍历新的 vdom 节点，从 map 中能找到 b 和 c，则代表可复用，移动过来打上更新的标记。剩下的 d 删除，e 为新增。',normalizedContent:'# react diff 算法\n\n一个 react 组件的渲染主要经历两个阶段，diff 算法发生在调度阶段。\n\n * 调度阶段（reconciler）：用新的数据生成一棵新的树，然后通过 diff 算法，遍历旧的树，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。\n * 渲染阶段（renderer）：遍历更新队列，通过调用宿主环境的 api，实际更新渲染对应的元素。宿主环境如 dom，native 等。\n\n> 第一次渲染不需要 diff，直接 vdom 转 fiber。再次渲染的时候，会产生新的 vdom，这时候要和之前的 fiber 做下对比，决定怎么产生新的 fiber。\n\n\n# diff 算法的特点\n\ndiff 算法具有以下特点：\n\n 1. 分层，同级比较：react 将整个 dom 树分为多个层级，然后逐层比较，只比较同一层级的节点，从而减少比较的复杂度。同级比较时按照从左到右的顺序进行比较。\n 2. key 属性：react 使用 key 属性来标识节点的唯一性，从而在比较时能够快速定位到需要更新的节点。\n\n\n# key\n\nkey 是 react 中用于标识节点的唯一性的一种机制。在 diff 算法中，react 使用 key属性来快速定位到需要更新的节点，从而提高 diff 算法的性能。\n\n我们经常强调在列表渲染中要使用 key 来提高性能，那么 key 到底是怎么帮助我们识别的呢？看一个简单的例子：\n\n<div>\n\t<p key="a">a</p>\n\t<span key="b">b</span>\n</div>\n\n<div>\n\t<span key="b">b</span>\n\t<p key="a">a</p>\n</div>\n\n\n在上面的例子中，react 在比较两个 jsx 对象时，会按照从左到右的顺序进行比较。那么两个 jsx 在比较第一个子节点时，发现 p 和 span 的元素类型不同，因此会销毁旧树并创建新树。\n\n但是由于他们有 key，react 会认为他们只是位置发生了变化，而不是元素类型发生了变化，因此会复用旧树中的节点，只是改变他们的位置。\n\n\n# diff 流程 两轮遍历\n\n * 第一轮遍历，处理可复用的节点。\n\n * 第二轮遍历，遍历第一轮剩下的 fiber。\n\n\n# 第一轮遍历\n\n对比新旧节点，如果可以复用就处理下一个节点，否则就结束遍历。结束遍历时如果还有旧的节点没处理完，那就进行第二次遍历。\n\n\n# 第二轮遍历\n\n把第一轮剩下的 老 fiber 节点放到 map 里，然后遍历新的 vdom 节点，从 map 中能找到的话，就是可复用，移动过来打上更新的标记。遍历完之后，剩下的老 fiber 节点删掉，剩下的新 vdom 新增。\n\n\n# 举例\n\n\x3c!-- 更新前 --\x3e\n<ul>\n\t<li key="a">a</li>\n\t<li key="b">b</li>\n\t<li key="c">c</li>\n\t<li key="d">d</li>\n</ul>\n\x3c!-- 更新后 --\x3e\n<ul>\n\t<li key="a">a</li>\n\t<li key="c">c</li>\n\t<li key="b">b</li>\n\t<li key="e">e</li>\n</ul>\n\n\n> 对比新的 vdom 和 老的 fiber，发现 a 是可以复用的。继续向后遍历发现 c 不可复用，所以结束第一轮遍历，进入第二轮遍历。把剩下的 老 fiber 节点 b, c, d 放到 map 里，然后遍历新的 vdom 节点，从 map 中能找到 b 和 c，则代表可复用，移动过来打上更新的标记。剩下的 d 删除，e 为新增。',charsets:{cjk:!0}},{title:"扩展阅读",frontmatter:{title:"扩展阅读",date:"2021-09-09T11:27:54.000Z"},regularPath:"/read/read.html",relativePath:"read/read.md",key:"v-488d7642",path:"/read/read.html",lastUpdated:"9/9/2021, 10:41:03 AM",lastUpdatedTimestamp:1631155263e3,headersStr:null,content:"# 扩展阅读\n\n * 领域驱动模型（DDD）",normalizedContent:"# 扩展阅读\n\n * 领域驱动模型（ddd）",charsets:{cjk:!0}},{title:"Redux",frontmatter:{title:"Redux",date:"2021-10-11T11:27:54.000Z",categories:"React"},regularPath:"/react/redux.html",relativePath:"react/redux.md",key:"v-ec255d82",path:"/react/redux.html",headers:[{level:2,title:"Action",slug:"action",normalizedTitle:"action",charIndex:32},{level:2,title:"Reducer",slug:"reducer",normalizedTitle:"reducer",charIndex:59},{level:2,title:"Store",slug:"store",normalizedTitle:"store",charIndex:86},{level:3,title:"store方法",slug:"store方法",normalizedTitle:"store方法",charIndex:1712},{level:2,title:"计数器案例",slug:"计数器案例",normalizedTitle:"计数器案例",charIndex:1813},{level:2,title:"Redux、Vuex 区别",slug:"redux、vuex-区别",normalizedTitle:"redux、vuex 区别",charIndex:2449}],lastUpdated:"2/23/2023, 2:16:54 PM",lastUpdatedTimestamp:1677133014e3,headersStr:"Action Reducer Store store方法 计数器案例 Redux、Vuex 区别",content:"# Rudux\n\n\n\n * View：视图，html页面\n * Actions：对象，描述对状态进行怎样的操作\n * Reducers：函数，操作状态并返回新的状态\n * Store：对象，存储状态的容器\n\n> 整体流程：视图不可直接更改 Store 数据，触发 Actions （描述要对Store进行怎样的操作），Actions 被 Ruducer 接收到，根据 Actions 的 type 属性进行判断，对状态进行操作，进而更新 Store，同步给视图。\n\n\n# Action\n\naction 是一个具有 type 字段的普通 JavaScript 对象。你可以将 action 视为描述应用程序中发生了什么的事件.\n\ntype 字段是一个字符串，给这个 action 一个描述性的名字，比如\"todos/todoAdded\"。我们通常把那个类型的字符串写成“域/事件名称”，其中第一部分是这个 action 所属的特征或类别，第二部分是发生的具体事情。\n\nconst addTodoAction = {\n  type: 'todos/todoAdded',\n  payload: 'Buy milk'\n}\n\n\naction creator 是一个创建并返回一个 action 对象的函数。它的作用是让你不必每次都手动编写 action 对象：\n\nconst addTodo = text => {\n  return {\n    type: 'todos/todoAdded',\n    payload: text\n  }\n}\n\n\n\n# Reducer\n\nreducer 是一个函数，接收当前的 state 和一个 action 对象，必要时决定如何更新状态，并返回新状态。函数签名是：(state, action) => newState。 你可以将 reducer 视为一个事件监听器，它根据接收到的 action（事件）类型处理事件。\n\n> \"Reducer\" 函数的名字来源是因为它和 Array.reduce() 函数使用的回调函数很类似。\n> \n> Array.reduce() 方法处理数组的方式是，一次处理数组中的每一项，并返回一个最终结果。您可以将其视为“将数组减少到一个值”。\n> \n> Redux reducer 函数与这个“reduce 回调函数”函数的想法完全相同！ 它接受上一个结果（state）和当前项（action 对象），根据这些参数计算出一个新 state，并返回该新 state。\n\n * 仅使用 state 和 action 参数计算新的状态值\n * 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）。\n * 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码\n\nconst initialState = { value: 0 }\n\nfunction counterReducer(state = initialState, action) {\n  // Check to see if the reducer cares about this action\n  if (action.type === 'counter/increment') {\n    // If so, make a copy of `state`\n    return {\n      ...state,\n      // and update the copy with the new value\n      value: state.value + 1\n    }\n  }\n  // otherwise return the existing state unchanged\n  return state\n}\n\n\n\n# Store\n\nStore 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。\n\n\n# store方法\n\n * getState()\n * dispatch(action)\n * subscribe(listener)\n * replaceReducer(nextReducer)\n\n\n# 计数器案例\n\nconst initialState = { count: 0 };\n\n// 定义 reducer\nfunction reducer(state = initialState, action) {\n\tswitch (action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1};\n    case 'decrement':\n      return { ...state, count: state.count - 1};\n    default:\n      return state;\n  }  \n}\n\n// 创建 store\nconst store = Redux.createStore(reducer);\n\n// 定义 action\nconst increment = { type: 'increment' };\nconst decrement = { type: 'decrement' };\n\n// 触发 action\nstore.dispatch(increment); // {count : 1}\nstore.dispatch(decrement); // {count : 0}\n\n// 订阅\nstore.subscribe(() => {\n  console.log(store.getState());\n})\n\n\n\n# Redux、Vuex 区别\n\n         REDUX                                            VUEX\n核心概念     action、reducer、store、state                       action、mutation、store、state、getters\n状态更新计算   reducer                                          mutation\n是否可变性    不可变，reducer 内部禁止直接修改 state。必须通过复制现有的 state       可变，mutation 可以直接修改 state\n         并对复制的值进行更改的方式来做（reducer 为纯函数）\n同步与异步    action 中可同步可异步（依赖 redux-thunk 插件）                commit 触发mutation同步操作，dispatch 触发 action 异步操作\n与组件结合    组件不能直接使用，使用 Provider 和 connect 把组件和 Redux 关联起来   VUE 通过VUEX 全局插件的使用，结合将 store传入根实例的过程，就可以使得 store\n                                                          对象在运行时存在于任何vue组件中\n\n一文总结redux、react-redux、redux-thunk、redux-sage",normalizedContent:"# rudux\n\n\n\n * view：视图，html页面\n * actions：对象，描述对状态进行怎样的操作\n * reducers：函数，操作状态并返回新的状态\n * store：对象，存储状态的容器\n\n> 整体流程：视图不可直接更改 store 数据，触发 actions （描述要对store进行怎样的操作），actions 被 ruducer 接收到，根据 actions 的 type 属性进行判断，对状态进行操作，进而更新 store，同步给视图。\n\n\n# action\n\naction 是一个具有 type 字段的普通 javascript 对象。你可以将 action 视为描述应用程序中发生了什么的事件.\n\ntype 字段是一个字符串，给这个 action 一个描述性的名字，比如\"todos/todoadded\"。我们通常把那个类型的字符串写成“域/事件名称”，其中第一部分是这个 action 所属的特征或类别，第二部分是发生的具体事情。\n\nconst addtodoaction = {\n  type: 'todos/todoadded',\n  payload: 'buy milk'\n}\n\n\naction creator 是一个创建并返回一个 action 对象的函数。它的作用是让你不必每次都手动编写 action 对象：\n\nconst addtodo = text => {\n  return {\n    type: 'todos/todoadded',\n    payload: text\n  }\n}\n\n\n\n# reducer\n\nreducer 是一个函数，接收当前的 state 和一个 action 对象，必要时决定如何更新状态，并返回新状态。函数签名是：(state, action) => newstate。 你可以将 reducer 视为一个事件监听器，它根据接收到的 action（事件）类型处理事件。\n\n> \"reducer\" 函数的名字来源是因为它和 array.reduce() 函数使用的回调函数很类似。\n> \n> array.reduce() 方法处理数组的方式是，一次处理数组中的每一项，并返回一个最终结果。您可以将其视为“将数组减少到一个值”。\n> \n> redux reducer 函数与这个“reduce 回调函数”函数的想法完全相同！ 它接受上一个结果（state）和当前项（action 对象），根据这些参数计算出一个新 state，并返回该新 state。\n\n * 仅使用 state 和 action 参数计算新的状态值\n * 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）。\n * 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码\n\nconst initialstate = { value: 0 }\n\nfunction counterreducer(state = initialstate, action) {\n  // check to see if the reducer cares about this action\n  if (action.type === 'counter/increment') {\n    // if so, make a copy of `state`\n    return {\n      ...state,\n      // and update the copy with the new value\n      value: state.value + 1\n    }\n  }\n  // otherwise return the existing state unchanged\n  return state\n}\n\n\n\n# store\n\nstore 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。\n\n\n# store方法\n\n * getstate()\n * dispatch(action)\n * subscribe(listener)\n * replacereducer(nextreducer)\n\n\n# 计数器案例\n\nconst initialstate = { count: 0 };\n\n// 定义 reducer\nfunction reducer(state = initialstate, action) {\n\tswitch (action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1};\n    case 'decrement':\n      return { ...state, count: state.count - 1};\n    default:\n      return state;\n  }  \n}\n\n// 创建 store\nconst store = redux.createstore(reducer);\n\n// 定义 action\nconst increment = { type: 'increment' };\nconst decrement = { type: 'decrement' };\n\n// 触发 action\nstore.dispatch(increment); // {count : 1}\nstore.dispatch(decrement); // {count : 0}\n\n// 订阅\nstore.subscribe(() => {\n  console.log(store.getstate());\n})\n\n\n\n# redux、vuex 区别\n\n         redux                                            vuex\n核心概念     action、reducer、store、state                       action、mutation、store、state、getters\n状态更新计算   reducer                                          mutation\n是否可变性    不可变，reducer 内部禁止直接修改 state。必须通过复制现有的 state       可变，mutation 可以直接修改 state\n         并对复制的值进行更改的方式来做（reducer 为纯函数）\n同步与异步    action 中可同步可异步（依赖 redux-thunk 插件）                commit 触发mutation同步操作，dispatch 触发 action 异步操作\n与组件结合    组件不能直接使用，使用 provider 和 connect 把组件和 redux 关联起来   vue 通过vuex 全局插件的使用，结合将 store传入根实例的过程，就可以使得 store\n                                                          对象在运行时存在于任何vue组件中\n\n一文总结redux、react-redux、redux-thunk、redux-sage",charsets:{cjk:!0}},{title:"React 版本",frontmatter:{},regularPath:"/react/time.html",relativePath:"react/time.md",key:"v-8f73d49e",path:"/react/time.html",headers:[{level:2,title:"1. React 16（2017）：Fiber 架构革命",slug:"_1-react-16-2017-fiber-架构革命",normalizedTitle:"1. react 16（2017）：fiber 架构革命",charIndex:174},{level:2,title:"2. React 17（2020）：平稳过渡版本",slug:"_2-react-17-2020-平稳过渡版本",normalizedTitle:"2. react 17（2020）：平稳过渡版本",charIndex:508},{level:3,title:"JSX 转换器",slug:"jsx-转换器",normalizedTitle:"jsx 转换器",charIndex:624},{level:3,title:"副作用清理",slug:"副作用清理",normalizedTitle:"副作用清理",charIndex:66},{level:2,title:"React 18（2022）：并发模式时代",slug:"react-18-2022-并发模式时代",normalizedTitle:"react 18（2022）：并发模式时代",charIndex:1282},{level:2,title:"并发渲染",slug:"并发渲染",normalizedTitle:"并发渲染",charIndex:91},{level:3,title:"Suspense 支持 SSR",slug:"suspense-支持-ssr",normalizedTitle:"suspense 支持 ssr",charIndex:2622},{level:2,title:"React 19（2024 Beta）：开发体验飞跃",slug:"react-19-2024-beta-开发体验飞跃",normalizedTitle:"react 19（2024 beta）：开发体验飞跃",charIndex:3011},{level:2,title:"Next.js 14 vs Next.js 15 核心差异",slug:"next-js-14-vs-next-js-15-核心差异",normalizedTitle:"next.js 14 vs next.js 15 核心差异",charIndex:3424},{level:2,title:"Next.js",slug:"next-js",normalizedTitle:"next.js",charIndex:3424},{level:3,title:"Next.js 核心解决的问题",slug:"next-js-核心解决的问题",normalizedTitle:"next.js 核心解决的问题",charIndex:4375},{level:3,title:"2. 解决路由配置繁琐：文件即路由 (File-system based Routing)",slug:"_2-解决路由配置繁琐-文件即路由-file-system-based-routing",normalizedTitle:"2. 解决路由配置繁琐：文件即路由 (file-system based routing)",charIndex:5572},{level:3,title:"3. 解决构建优化复杂：开箱即用的优化工具链",slug:"_3-解决构建优化复杂-开箱即用的优化工具链",normalizedTitle:"3. 解决构建优化复杂：开箱即用的优化工具链",charIndex:6224},{level:3,title:"4. 解决前后端分离的割裂感：API Routes (全栈能力)",slug:"_4-解决前后端分离的割裂感-api-routes-全栈能力",normalizedTitle:"4. 解决前后端分离的割裂感：api routes (全栈能力)",charIndex:6920},{level:3,title:"核心价值再提炼",slug:"核心价值再提炼",normalizedTitle:"核心价值再提炼",charIndex:7641}],lastUpdated:"6/17/2025, 7:54:56 PM",lastUpdatedTimestamp:1750161296e3,headersStr:"1. React 16（2017）：Fiber 架构革命 2. React 17（2020）：平稳过渡版本 JSX 转换器 副作用清理 React 18（2022）：并发模式时代 并发渲染 Suspense 支持 SSR React 19（2024 Beta）：开发体验飞跃 Next.js 14 vs Next.js 15 核心差异 Next.js Next.js 核心解决的问题 2. 解决路由配置繁琐：文件即路由 (File-system based Routing) 3. 解决构建优化复杂：开箱即用的优化工具链 4. 解决前后端分离的割裂感：API Routes (全栈能力) 核心价值再提炼",content:"# React 版本\n\n * React 16 - Fiber 架构\n * React 17 - 过渡版本：事件委托、jsx转换器、副作用清理\n * React 18 - 并发模式：并发渲染、transition api、流式服务端渲染\n * React 19 - 开发体验革命：Actions api、use、自动记忆化、预加载 api\n\n\n# 1. React 16（2017）：Fiber 架构革命\n\n突破点         解决的问题             技术实现\n异步渲染        大型应用渲染卡顿（主线程阻塞）   Fiber 节点拆分任务为可中断单元\n增量渲染        长时间任务导致掉帧         浏览器空闲时段分片渲染组件\n错误边界        组件崩溃导致整个应用崩溃      componentDidCatch() 捕获子组件错误\nPortal 支持   渲染到 DOM 树外节点      ReactDOM.createPortal()\n新生命周期       废弃不安全生命周期         新增 getDerivedStateFromProps()\n\n\n# 2. React 17（2020）：平稳过渡版本\n\n核心改进        影响\n事件委托重构      事件绑定到根容器而非 document，解决多版本共存冲突\n渐进升级支持      允许应用内混合使用 v17 和旧版本组件\nJSX 转换器独立   编译器自动引入 jsx-runtime，减少 import React 冗余\n副作用清理时机     useEffect 清理函数异步执行，避免阻塞屏幕更新\n\n> ⚠️ 无新特性：专注为 React 18 铺路，被开发者称为“隐形桥梁版本”\n\n\n# JSX 转换器\n\n在v16中，我们写一个React组件，总要引入\n\nimport React from 'react'\n\n\n这是因为在浏览器中无法直接使用 jsx，所以要借助工具如@babel/preset-react将 jsx 语法转换为 React.createElement 的 js 代码，所以需要显式引入 React，才能正常调用 createElement。\n\n通过React.createElement() 创建元素是比较频繁的操作，本身也存在一些问题，无法做到性能优化，具体可见官方优化的 动机\n\nv17之后，React 与 Babel 官方进行合作，直接通过将 react/jsx-runtime 对 jsx 语法进行了新的转换而不依赖 React.createElement，因此v17使用 jsx 语法可以不引入 React，应用程序依然能正常运行。\n\n\n# 副作用清理\n\n * v17前，组件被卸载时，useEffect的清理函数都是同步运行的；对于大型应用程序来说，同步会减缓屏幕的过渡（如切换标签）\n * v17后，useEffect 副作用清理函数是异步执行的，如果要卸载组件，则清理会在屏幕更新后运行\n\n\n# React 18（2022）：并发模式时代\n\n特性                 功能                      代码示例\n并发渲染（Concurrent）   可中断渲染优先响应用户交互           <React.StrictMode> 中启用\n自动批处理              合并多状态更新减少渲染次数           异步操作中自动生效\nTransition API     区分紧急/非紧急更新              const [isPending, startTransition] = useTransition()\nSuspense SSR       流式服务端渲染 + 选择性 hydrate   <Suspense fallback={<Spinner/>}>\n新 Root API         取代 ReactDOM.render()    ReactDOM.createRoot().render(<App />)\n\n\n# 并发渲染\n\nReact 中 每次 setState 都会进行 render 渲染流程。有个场景，比如用户在 input 输入内容的时候，会通过 setState 设置到状态里，会触发重新渲染。这时候如果还有一个列表也会根据 input 输入的值来处理显示的数据，也会 setState 修改自己的状态。这两个 setState 会一起发生，那么同步模式下也就会按照顺序依次执行。\n\n但如果这个渲染流程中处理的 fiber 节点比较多，渲染一次就比较慢，这时候用户输入的内容可能就不能及时的渲染出来，用户就会感觉卡，体验不好。怎么解决这个问题呢？\n\n能不能指定这俩 setState 的重要程度不一样，用户输入的 setState 的更新重要程度更高，如果有这种更新就把别的先暂停，执行这次更新，执行完之后再继续处理。\n\nfunction Search() {\n  const [keywords, setKeywords] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    // 紧急：立即更新输入框\n    setKeywords(e.target.value);\n    \n    // 非紧急：延迟处理搜索（可中断）\n    startTransition(() => {\n      fetchResults(e.target.value).then(setResults);\n    });\n  };\n\n  return (\n    <>\n      <input value={keywords} onChange={handleChange} />\n      {isPending ? <Spinner /> : <Results data={results} />}\n    </>\n  );\n}\n\n\n\n# Suspense 支持 SSR\n\nSSR 一次页面渲染的流程：\n\n 1. 服务器获取页面所需数据\n 2. 将组件渲染成 HTML 形式作为响应返回\n 3. 客户端加载资源\n 4. （hydrate）执行 JS，并生成页面最终内容\n\n上述流程是串行执行的，v18前的 SSR 有一个问题就是它不允许组件\"等待数据\"，必须收集好所有的数据，才能开始向客户端发送HTML。如果其中有一步比较慢，都会影响整体的渲染速度。\n\nv18 中使用并发渲染特性扩展了Suspense的功能，使其支持流式 SSR，将 React 组件分解成更小的块，允许服务端一点一点返回页面，尽早发送 HTML和选择性的 hydrate， 从而可以使SSR更快的加载页面\n\n<Suspense fallback={<Spinner />}>  \n  <Comments /> \n</Suspense>\n\n\n\n# React 19（2024 Beta）：开发体验飞跃\n\n特性                     解决的问题                   REACT 18 对比\nActions API            表单状态管理样板代码              手动处理 loading/error 状态\nuse() Hook             直接消费 Promise/Suspense   需 useEffect + 状态管理\n自动记忆化编译器               手动 useMemo 优化负担         开发者需显式记忆化\n原生 Document Metadata   动态修改 <title> 需第三方库      依赖 react-helmet\n资源预加载 API              关键资源加载优化碎片化             手动 link rel=preload\n\n\n# Next.js 14 vs Next.js 15 核心差异\n\n能力模块          NEXT.JS 14                          **NEXT.JS 15 **\nReact 基础      React 18.3                          React 19 (首个官方集成版本)\n渲染引擎          Pages Router + App Router 共存        App Router 为默认模式\n数据获取          getServerSideProps/getStaticProps   Actions + use() 主导\n元数据处理         generateMetadata 函数                 原生 <title> 组件支持\n资源优化          next/image/next/font                整合 React 19 预加载 API\n中间件           middleware.ts 基于 Edge Runtime       支持 Node.js 运行时\n打包工具          Webpack (默认) / Turbopack (可选)       Turbopack 为默认构建引擎\n增量静态生成        revalidate 字段控制                     动态 ISR：按请求流量触发重建\nMonorepo 支持   需手动配置 Turbo 或 Nx                    内置 Turborepo 集成\n部署适配          Vercel/Netlify/Node 服务器             新增 Serverless 函数冷启动优化\n\n\n# Next.js\n\nNext.js 是一个基于 React 的全栈前端框架，核心目标是简化高性能 Web 应用的开发（尤其解决 React 的 SEO 弱、首屏加载慢等问题）。它通过开箱即用的功能（如服务端渲染、路由、打包优化等）大幅提升开发效率。\n\n----------------------------------------\n\n\n# Next.js 核心解决的问题\n\n传统 React (CSR - Client-Side Rendering) 的问题：\n\n * 过程： 浏览器下载一个近乎空的 HTML → 下载庞大的 JS Bundle → JS 执行 → React 渲染页面内容。\n * 致命伤：\n   * SEO 不友好： 搜索引擎爬虫看到的是空 HTML 或加载动画，无法抓取有效内容。\n   * 首屏加载慢 (FCP/LCP)： 用户需要等待 JS 下载执行完才能看到主要内容，体验差。\n   * 低端设备体验差： JS 解析和执行在性能弱的设备上耗时更长。\n\nNext.js 的解决方案： 服务端渲染 (SSR) 与 静态站点生成 (SSG)\n\n * SSR (Server-Side Rendering) - 动态内容实时渲染：\n   * 过程： 用户请求 → Next.js 服务器实时执行 React 组件，获取数据 → 生成包含完整内容的 HTML 发送给浏览器 → 浏览器立即展示内容 → React 再“注水”(Hydrate) 接管交互。\n   * 优势：\n     * 完美 SEO： 爬虫拿到的是包含完整数据的 HTML。\n     * 瞬间首屏： 用户第一时间看到完整内容，无需等待 JS 执行。\n     * 适合： 用户仪表盘、实时数据页面、个性化内容页（需要知道用户是谁）。\n * SSG (Static Site Generation) - 构建时预渲染：\n   * 过程： 在 npm run build 时，Next.js 提前执行 React 组件，获取数据 → 生成纯静态 HTML/CSS/JS 文件 → 部署到 CDN。\n   * 优势：\n     * 极致性能： CDN 直接返回预渲染好的 HTML，速度最快。\n     * 超高扩展性： CDN 轻松应对高并发，成本低。\n     * 安全性高： 静态文件无服务器运行时风险。\n     * 适合： 博客、文档、营销页、电商产品列表/详情页（数据变化不频繁）。\n * ISR (Incremental Static Regeneration) - SSG 的智能升级：\n   * 过程： 在 SSG 基础上，可以为每个页面设置一个 revalidate 时间（秒）。首次访问触发构建，之后在设定的时间间隔内，访问仍返回缓存的静态页面；超过时间后的首次访问，Next.js 在后台异步重新生成该页面，下次访问得到新页面，同时旧页面仍可被访问（无中断）。\n   * 优势： 兼具 SSG 的速度与接近 SSR 的数据新鲜度，无需全站重建。\n   * 适合： 新闻资讯、商品价格（允许短暂延迟）、用户生成内容（UGC）列表页。\n\n总结：Next.js 让你按需选择渲染方式，从根本上解决 SEO 和首屏性能瓶颈。\n\n\n# 2. 解决路由配置繁琐：文件即路由 (File-system based Routing)\n\n传统 React 的问题：\n\n * 需要手动安装 react-router-dom 库。\n * 需要编写复杂的路由配置文件 (<Routes>, <Route>, <Link>)，定义路径与组件的映射关系。\n * 嵌套路由、动态路由、路由守卫等配置较繁琐。\n\nNext.js 的解决方案：\n\n * 约定优于配置： 在 pages 目录下的文件结构自动映射为 URL 路由。\n   * pages/index.js → /\n   * pages/about.js → /about\n   * pages/blog/index.js → /blog\n   * pages/blog/[slug].js → /blog/:slug (e.g., /blog/nextjs-is-awesome)\n   * pages/user/[id]/profile.js → /user/:id/profile (嵌套动态路由)\n * 无需手动配置： 创建文件即创建路由，极大简化开发流程。\n * 内置 <Link>： 提供高性能的客户端导航（无整页刷新）。\n * 自动代码分割： 每个页面自动生成独立的 JS Bundle，按需加载。\n\n总结：文件即路由是 Next.js 最直观、最高效的特性之一，显著提升开发速度和代码可维护性。\n\n----------------------------------------\n\n\n# 3. 解决构建优化复杂：开箱即用的优化工具链\n\n传统 React (CRA) 的问题：\n\n * 虽然封装了 Webpack 配置，但深度定制（如修改 Loader、Plugin、分包策略）需要 eject（不可逆）或使用 react-app-rewired 等第三方工具，门槛高。\n * 性能优化（如代码分割、懒加载、图片优化）需要开发者手动配置或集成额外库。\n\nNext.js 的解决方案：\n\n * 零配置优化：\n   * 自动代码分割： 基于页面和动态 import()。\n   * SWC 编译器： 替代 Babel + Terser，编译速度快 17 倍以上，支持 Rust 插件。\n   * Image 组件 (next/image): 自动优化图片（格式转换 - WebP/AVIF、尺寸调整、懒加载），大幅提升 LCP 指标和节省带宽。\n   * Font 组件 (next/font): 自动托管和优化字体文件，消除布局偏移 (CLS)，提高隐私性（无 Google Fonts 请求）。\n   * Script 组件 (next/script): 优化第三方脚本加载策略（如 afterInteractive, lazyOnLoad）。\n * 可扩展配置 (next.config.js): 提供简单 API 覆盖默认 Webpack 配置、配置环境变量、反向代理等，无需 eject。\n\n总结：Next.js 内置了生产环境所需的几乎所有性能优化手段，开发者可以专注于业务逻辑。\n\n----------------------------------------\n\n\n# 4. 解决前后端分离的割裂感：API Routes (全栈能力)\n\n传统 React 的问题：\n\n * 前端项目需要单独部署。\n * 需要另外搭建和维护一个后端服务（Node.js/Express, Python/Django, Go 等）来提供 API。\n * 开发环境配置 CORS、代理等解决跨域问题。\n * 增加了项目复杂度和协作成本。\n\nNext.js 的解决方案： API Routes\n\n * 概念： 在 pages/api 目录下创建 .js/.ts 文件，该文件默认导出一个函数（请求处理程序），它就是一个 API 端点。\n   * pages/api/hello.js → 对应 /api/hello 接口。\n * 优势：\n   * 前后端同项目： API 和前端页面在同一个 Next.js 项目中编写、构建和部署。\n   * 无 CORS 问题： 同源请求，前端调用 /api/xxx 就像调用本地函数一样简单。\n   * 使用熟悉的 Node.js 环境： 可以直接访问文件系统、数据库（ORM）、环境变量等。\n   * 简化部署： Vercel/Netlify/Node 服务器等一键部署整个应用（前端 + API）。\n * 适合场景： 处理表单提交、Webhook 接收器、轻量级数据库 CRUD、身份验证端点、代理第三方 API（隐藏密钥）等。不适合： 计算密集型任务、需要长连接（WebSocket）的场景。\n\n总结：API Routes 让 Next.js 具备了全栈能力，极大简化了需要简单后端逻辑的应用开发。\n\n----------------------------------------\n\n\n# 核心价值再提炼\n\n问题领域      传统 REACT 痛点    NEXT.JS 核心解决方案                      带来的核心价值\n渲染 & 性能   SEO 差、首屏慢      SSR / SSG / ISR                     极致性能、SEO 友好\n开发体验      路由配置繁琐         文件即路由 (pages/)                      开发高效、结构清晰\n构建 & 优化   配置复杂、优化需手动     开箱即用优化 (SWC, Image, Font, Script)   高性能、最佳实践内置\n应用架构      前后端分离、部署运维复杂   API Routes (pages/api/)             全栈一体化、简化部署运维\n\n**一句话理解 Next.js：它是对 React 的“生产环境强化”，通过约定优于配置、开箱即用的服务端渲染/静态生成、一体化路由和 API 方案，让开发者能高效构建高性能、SEO 友好、体验卓越的现代化 Web 应用。",normalizedContent:"# react 版本\n\n * react 16 - fiber 架构\n * react 17 - 过渡版本：事件委托、jsx转换器、副作用清理\n * react 18 - 并发模式：并发渲染、transition api、流式服务端渲染\n * react 19 - 开发体验革命：actions api、use、自动记忆化、预加载 api\n\n\n# 1. react 16（2017）：fiber 架构革命\n\n突破点         解决的问题             技术实现\n异步渲染        大型应用渲染卡顿（主线程阻塞）   fiber 节点拆分任务为可中断单元\n增量渲染        长时间任务导致掉帧         浏览器空闲时段分片渲染组件\n错误边界        组件崩溃导致整个应用崩溃      componentdidcatch() 捕获子组件错误\nportal 支持   渲染到 dom 树外节点      reactdom.createportal()\n新生命周期       废弃不安全生命周期         新增 getderivedstatefromprops()\n\n\n# 2. react 17（2020）：平稳过渡版本\n\n核心改进        影响\n事件委托重构      事件绑定到根容器而非 document，解决多版本共存冲突\n渐进升级支持      允许应用内混合使用 v17 和旧版本组件\njsx 转换器独立   编译器自动引入 jsx-runtime，减少 import react 冗余\n副作用清理时机     useeffect 清理函数异步执行，避免阻塞屏幕更新\n\n> ⚠️ 无新特性：专注为 react 18 铺路，被开发者称为“隐形桥梁版本”\n\n\n# jsx 转换器\n\n在v16中，我们写一个react组件，总要引入\n\nimport react from 'react'\n\n\n这是因为在浏览器中无法直接使用 jsx，所以要借助工具如@babel/preset-react将 jsx 语法转换为 react.createelement 的 js 代码，所以需要显式引入 react，才能正常调用 createelement。\n\n通过react.createelement() 创建元素是比较频繁的操作，本身也存在一些问题，无法做到性能优化，具体可见官方优化的 动机\n\nv17之后，react 与 babel 官方进行合作，直接通过将 react/jsx-runtime 对 jsx 语法进行了新的转换而不依赖 react.createelement，因此v17使用 jsx 语法可以不引入 react，应用程序依然能正常运行。\n\n\n# 副作用清理\n\n * v17前，组件被卸载时，useeffect的清理函数都是同步运行的；对于大型应用程序来说，同步会减缓屏幕的过渡（如切换标签）\n * v17后，useeffect 副作用清理函数是异步执行的，如果要卸载组件，则清理会在屏幕更新后运行\n\n\n# react 18（2022）：并发模式时代\n\n特性                 功能                      代码示例\n并发渲染（concurrent）   可中断渲染优先响应用户交互           <react.strictmode> 中启用\n自动批处理              合并多状态更新减少渲染次数           异步操作中自动生效\ntransition api     区分紧急/非紧急更新              const [ispending, starttransition] = usetransition()\nsuspense ssr       流式服务端渲染 + 选择性 hydrate   <suspense fallback={<spinner/>}>\n新 root api         取代 reactdom.render()    reactdom.createroot().render(<app />)\n\n\n# 并发渲染\n\nreact 中 每次 setstate 都会进行 render 渲染流程。有个场景，比如用户在 input 输入内容的时候，会通过 setstate 设置到状态里，会触发重新渲染。这时候如果还有一个列表也会根据 input 输入的值来处理显示的数据，也会 setstate 修改自己的状态。这两个 setstate 会一起发生，那么同步模式下也就会按照顺序依次执行。\n\n但如果这个渲染流程中处理的 fiber 节点比较多，渲染一次就比较慢，这时候用户输入的内容可能就不能及时的渲染出来，用户就会感觉卡，体验不好。怎么解决这个问题呢？\n\n能不能指定这俩 setstate 的重要程度不一样，用户输入的 setstate 的更新重要程度更高，如果有这种更新就把别的先暂停，执行这次更新，执行完之后再继续处理。\n\nfunction search() {\n  const [keywords, setkeywords] = usestate('');\n  const [results, setresults] = usestate([]);\n  const [ispending, starttransition] = usetransition();\n\n  const handlechange = (e) => {\n    // 紧急：立即更新输入框\n    setkeywords(e.target.value);\n    \n    // 非紧急：延迟处理搜索（可中断）\n    starttransition(() => {\n      fetchresults(e.target.value).then(setresults);\n    });\n  };\n\n  return (\n    <>\n      <input value={keywords} onchange={handlechange} />\n      {ispending ? <spinner /> : <results data={results} />}\n    </>\n  );\n}\n\n\n\n# suspense 支持 ssr\n\nssr 一次页面渲染的流程：\n\n 1. 服务器获取页面所需数据\n 2. 将组件渲染成 html 形式作为响应返回\n 3. 客户端加载资源\n 4. （hydrate）执行 js，并生成页面最终内容\n\n上述流程是串行执行的，v18前的 ssr 有一个问题就是它不允许组件\"等待数据\"，必须收集好所有的数据，才能开始向客户端发送html。如果其中有一步比较慢，都会影响整体的渲染速度。\n\nv18 中使用并发渲染特性扩展了suspense的功能，使其支持流式 ssr，将 react 组件分解成更小的块，允许服务端一点一点返回页面，尽早发送 html和选择性的 hydrate， 从而可以使ssr更快的加载页面\n\n<suspense fallback={<spinner />}>  \n  <comments /> \n</suspense>\n\n\n\n# react 19（2024 beta）：开发体验飞跃\n\n特性                     解决的问题                   react 18 对比\nactions api            表单状态管理样板代码              手动处理 loading/error 状态\nuse() hook             直接消费 promise/suspense   需 useeffect + 状态管理\n自动记忆化编译器               手动 usememo 优化负担         开发者需显式记忆化\n原生 document metadata   动态修改 <title> 需第三方库      依赖 react-helmet\n资源预加载 api              关键资源加载优化碎片化             手动 link rel=preload\n\n\n# next.js 14 vs next.js 15 核心差异\n\n能力模块          next.js 14                          **next.js 15 **\nreact 基础      react 18.3                          react 19 (首个官方集成版本)\n渲染引擎          pages router + app router 共存        app router 为默认模式\n数据获取          getserversideprops/getstaticprops   actions + use() 主导\n元数据处理         generatemetadata 函数                 原生 <title> 组件支持\n资源优化          next/image/next/font                整合 react 19 预加载 api\n中间件           middleware.ts 基于 edge runtime       支持 node.js 运行时\n打包工具          webpack (默认) / turbopack (可选)       turbopack 为默认构建引擎\n增量静态生成        revalidate 字段控制                     动态 isr：按请求流量触发重建\nmonorepo 支持   需手动配置 turbo 或 nx                    内置 turborepo 集成\n部署适配          vercel/netlify/node 服务器             新增 serverless 函数冷启动优化\n\n\n# next.js\n\nnext.js 是一个基于 react 的全栈前端框架，核心目标是简化高性能 web 应用的开发（尤其解决 react 的 seo 弱、首屏加载慢等问题）。它通过开箱即用的功能（如服务端渲染、路由、打包优化等）大幅提升开发效率。\n\n----------------------------------------\n\n\n# next.js 核心解决的问题\n\n传统 react (csr - client-side rendering) 的问题：\n\n * 过程： 浏览器下载一个近乎空的 html → 下载庞大的 js bundle → js 执行 → react 渲染页面内容。\n * 致命伤：\n   * seo 不友好： 搜索引擎爬虫看到的是空 html 或加载动画，无法抓取有效内容。\n   * 首屏加载慢 (fcp/lcp)： 用户需要等待 js 下载执行完才能看到主要内容，体验差。\n   * 低端设备体验差： js 解析和执行在性能弱的设备上耗时更长。\n\nnext.js 的解决方案： 服务端渲染 (ssr) 与 静态站点生成 (ssg)\n\n * ssr (server-side rendering) - 动态内容实时渲染：\n   * 过程： 用户请求 → next.js 服务器实时执行 react 组件，获取数据 → 生成包含完整内容的 html 发送给浏览器 → 浏览器立即展示内容 → react 再“注水”(hydrate) 接管交互。\n   * 优势：\n     * 完美 seo： 爬虫拿到的是包含完整数据的 html。\n     * 瞬间首屏： 用户第一时间看到完整内容，无需等待 js 执行。\n     * 适合： 用户仪表盘、实时数据页面、个性化内容页（需要知道用户是谁）。\n * ssg (static site generation) - 构建时预渲染：\n   * 过程： 在 npm run build 时，next.js 提前执行 react 组件，获取数据 → 生成纯静态 html/css/js 文件 → 部署到 cdn。\n   * 优势：\n     * 极致性能： cdn 直接返回预渲染好的 html，速度最快。\n     * 超高扩展性： cdn 轻松应对高并发，成本低。\n     * 安全性高： 静态文件无服务器运行时风险。\n     * 适合： 博客、文档、营销页、电商产品列表/详情页（数据变化不频繁）。\n * isr (incremental static regeneration) - ssg 的智能升级：\n   * 过程： 在 ssg 基础上，可以为每个页面设置一个 revalidate 时间（秒）。首次访问触发构建，之后在设定的时间间隔内，访问仍返回缓存的静态页面；超过时间后的首次访问，next.js 在后台异步重新生成该页面，下次访问得到新页面，同时旧页面仍可被访问（无中断）。\n   * 优势： 兼具 ssg 的速度与接近 ssr 的数据新鲜度，无需全站重建。\n   * 适合： 新闻资讯、商品价格（允许短暂延迟）、用户生成内容（ugc）列表页。\n\n总结：next.js 让你按需选择渲染方式，从根本上解决 seo 和首屏性能瓶颈。\n\n\n# 2. 解决路由配置繁琐：文件即路由 (file-system based routing)\n\n传统 react 的问题：\n\n * 需要手动安装 react-router-dom 库。\n * 需要编写复杂的路由配置文件 (<routes>, <route>, <link>)，定义路径与组件的映射关系。\n * 嵌套路由、动态路由、路由守卫等配置较繁琐。\n\nnext.js 的解决方案：\n\n * 约定优于配置： 在 pages 目录下的文件结构自动映射为 url 路由。\n   * pages/index.js → /\n   * pages/about.js → /about\n   * pages/blog/index.js → /blog\n   * pages/blog/[slug].js → /blog/:slug (e.g., /blog/nextjs-is-awesome)\n   * pages/user/[id]/profile.js → /user/:id/profile (嵌套动态路由)\n * 无需手动配置： 创建文件即创建路由，极大简化开发流程。\n * 内置 <link>： 提供高性能的客户端导航（无整页刷新）。\n * 自动代码分割： 每个页面自动生成独立的 js bundle，按需加载。\n\n总结：文件即路由是 next.js 最直观、最高效的特性之一，显著提升开发速度和代码可维护性。\n\n----------------------------------------\n\n\n# 3. 解决构建优化复杂：开箱即用的优化工具链\n\n传统 react (cra) 的问题：\n\n * 虽然封装了 webpack 配置，但深度定制（如修改 loader、plugin、分包策略）需要 eject（不可逆）或使用 react-app-rewired 等第三方工具，门槛高。\n * 性能优化（如代码分割、懒加载、图片优化）需要开发者手动配置或集成额外库。\n\nnext.js 的解决方案：\n\n * 零配置优化：\n   * 自动代码分割： 基于页面和动态 import()。\n   * swc 编译器： 替代 babel + terser，编译速度快 17 倍以上，支持 rust 插件。\n   * image 组件 (next/image): 自动优化图片（格式转换 - webp/avif、尺寸调整、懒加载），大幅提升 lcp 指标和节省带宽。\n   * font 组件 (next/font): 自动托管和优化字体文件，消除布局偏移 (cls)，提高隐私性（无 google fonts 请求）。\n   * script 组件 (next/script): 优化第三方脚本加载策略（如 afterinteractive, lazyonload）。\n * 可扩展配置 (next.config.js): 提供简单 api 覆盖默认 webpack 配置、配置环境变量、反向代理等，无需 eject。\n\n总结：next.js 内置了生产环境所需的几乎所有性能优化手段，开发者可以专注于业务逻辑。\n\n----------------------------------------\n\n\n# 4. 解决前后端分离的割裂感：api routes (全栈能力)\n\n传统 react 的问题：\n\n * 前端项目需要单独部署。\n * 需要另外搭建和维护一个后端服务（node.js/express, python/django, go 等）来提供 api。\n * 开发环境配置 cors、代理等解决跨域问题。\n * 增加了项目复杂度和协作成本。\n\nnext.js 的解决方案： api routes\n\n * 概念： 在 pages/api 目录下创建 .js/.ts 文件，该文件默认导出一个函数（请求处理程序），它就是一个 api 端点。\n   * pages/api/hello.js → 对应 /api/hello 接口。\n * 优势：\n   * 前后端同项目： api 和前端页面在同一个 next.js 项目中编写、构建和部署。\n   * 无 cors 问题： 同源请求，前端调用 /api/xxx 就像调用本地函数一样简单。\n   * 使用熟悉的 node.js 环境： 可以直接访问文件系统、数据库（orm）、环境变量等。\n   * 简化部署： vercel/netlify/node 服务器等一键部署整个应用（前端 + api）。\n * 适合场景： 处理表单提交、webhook 接收器、轻量级数据库 crud、身份验证端点、代理第三方 api（隐藏密钥）等。不适合： 计算密集型任务、需要长连接（websocket）的场景。\n\n总结：api routes 让 next.js 具备了全栈能力，极大简化了需要简单后端逻辑的应用开发。\n\n----------------------------------------\n\n\n# 核心价值再提炼\n\n问题领域      传统 react 痛点    next.js 核心解决方案                      带来的核心价值\n渲染 & 性能   seo 差、首屏慢      ssr / ssg / isr                     极致性能、seo 友好\n开发体验      路由配置繁琐         文件即路由 (pages/)                      开发高效、结构清晰\n构建 & 优化   配置复杂、优化需手动     开箱即用优化 (swc, image, font, script)   高性能、最佳实践内置\n应用架构      前后端分离、部署运维复杂   api routes (pages/api/)             全栈一体化、简化部署运维\n\n**一句话理解 next.js：它是对 react 的“生产环境强化”，通过约定优于配置、开箱即用的服务端渲染/静态生成、一体化路由和 api 方案，让开发者能高效构建高性能、seo 友好、体验卓越的现代化 web 应用。",charsets:{cjk:!0}},{title:"正则表达式",frontmatter:{},regularPath:"/regular/regular.html",relativePath:"regular/regular.md",key:"v-fdfdbb42",path:"/regular/regular.html",headers:[{level:2,title:"捕获组、非捕获组、命名捕获组",slug:"捕获组、非捕获组、命名捕获组",normalizedTitle:"捕获组、非捕获组、命名捕获组",charIndex:56}],lastUpdated:"2/6/2023, 6:11:44 PM",lastUpdatedTimestamp:1675678304e3,headersStr:"捕获组、非捕获组、命名捕获组",content:"# 正则表达式\n\nhttps://juejin.cn/post/6844903487155732494\n\n\n# 捕获组、非捕获组、命名捕获组\n\nhttps://segmentfault.com/a/1190000021043947\n\n// 捕获组\n'1,2,3,4'.split(/(,)/)\n// ['1', ',', '2', ',', '3', ',', '4']\n\n// 非捕获组\n'1,2,3,4'.split(/(?:,)/) \n // ['1', '2', '3', '4']\n\n// 命名分组捕获，ES2018允许命名捕获组使用符号?<name>, 可以指定小括号中匹配内容的名称放在groups里\nconst reg = /(\\d{4})-(\\d{2})-(\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched[0];  // 2018-12-12\nmatched[1];  // 2018\nmatched[2];  // 12\nmatched[3];  // 31\n\nconst reg = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched.groups.year;   // 2018\nmatched.groups.month;  // 12\nmatched.groups.day;    // 31\n",normalizedContent:"# 正则表达式\n\nhttps://juejin.cn/post/6844903487155732494\n\n\n# 捕获组、非捕获组、命名捕获组\n\nhttps://segmentfault.com/a/1190000021043947\n\n// 捕获组\n'1,2,3,4'.split(/(,)/)\n// ['1', ',', '2', ',', '3', ',', '4']\n\n// 非捕获组\n'1,2,3,4'.split(/(?:,)/) \n // ['1', '2', '3', '4']\n\n// 命名分组捕获，es2018允许命名捕获组使用符号?<name>, 可以指定小括号中匹配内容的名称放在groups里\nconst reg = /(\\d{4})-(\\d{2})-(\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched[0];  // 2018-12-12\nmatched[1];  // 2018\nmatched[2];  // 12\nmatched[3];  // 31\n\nconst reg = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nconst matched = reg.exec('2018-12-31');\nmatched.groups.year;   // 2018\nmatched.groups.month;  // 12\nmatched.groups.day;    // 31\n",charsets:{cjk:!0}},{title:"React Hooks",frontmatter:{title:"React Hooks",date:"2021-06-21T11:27:54.000Z",categories:"React"},regularPath:"/react/react-hooks.html",relativePath:"react/react-hooks.md",key:"v-fa561802",path:"/react/react-hooks.html",headers:[{level:2,title:"函数组件与类组件的区别",slug:"函数组件与类组件的区别",normalizedTitle:"函数组件与类组件的区别",charIndex:128},{level:3,title:"函数式组件",slug:"函数式组件",normalizedTitle:"函数式组件",charIndex:144},{level:3,title:"类组件",slug:"类组件",normalizedTitle:"类组件",charIndex:133},{level:2,title:"什么是 React Hooks",slug:"什么是-react-hooks",normalizedTitle:"什么是 react hooks",charIndex:380},{level:3,title:"useState",slug:"usestate",normalizedTitle:"usestate",charIndex:621},{level:3,title:"useEffect",slug:"useeffect",normalizedTitle:"useeffect",charIndex:633},{level:3,title:"useReducer",slug:"usereducer",normalizedTitle:"usereducer",charIndex:647},{level:3,title:"useContext",slug:"usecontext",normalizedTitle:"usecontext",charIndex:661},{level:3,title:"useMemo",slug:"usememo",normalizedTitle:"usememo",charIndex:675},{level:3,title:"memo 方法",slug:"memo-方法",normalizedTitle:"memo 方法",charIndex:6747},{level:3,title:"useCallback",slug:"usecallback",normalizedTitle:"usecallback",charIndex:686},{level:3,title:"useRef",slug:"useref",normalizedTitle:"useref",charIndex:701}],lastUpdated:"5/22/2025, 11:29:40 AM",lastUpdatedTimestamp:174788458e4,headersStr:"函数组件与类组件的区别 函数式组件 类组件 什么是 React Hooks useState useEffect useReducer useContext useMemo memo 方法 useCallback useRef",content:"# React Hooks\n\nReact 框架在 v16.8 版本引入了全新的 API，叫做 React Hooks，颠覆了以前的用法。React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码\"钩\"进来。\n\n\n# 函数组件与类组件的区别\n\n\n# 函数式组件\n\n * 函数式编程思想\n\n * 不需要声明 class，不需要使用 this，没有生命周期方法，没有实例化。代码简洁，具有更佳的性能。\n\n * 可以写成无副作用的纯函数。\n\n * 没有 shouldComponentUpdate，不能避免重复渲染。\n\n\n# 类组件\n\n * 面向对象编程思想\n * 包含生命周期，state，this，功能更加完善，但是不能保证 this 指向正确性\n * 代码较为繁琐复杂，例如生命周期函数中存在多个不相干的业务逻辑\n\n\n# 什么是 React Hooks\n\nReact Hooks 解析\n\n> React Hooks就是加强版的函数式组件，让函数型组件可以存储状态，可以拥有处理副作用的能力。让开发者不使用类组件的情况下实现相同的功能\n> \n> 副作用：不是用来转换视图的代码，例如 ajax 请求，获取 dom，我们一般在生命周期中处理这些代码。\n\nHooks 意为钩子，React Hooks 就是一堆钩子函数，React 通过这些钩子函数对函数型组件进行增强，不同的钩子函数提供不同的功能。\n\n * useState\n * useEffects\n * useReducer\n * useContext\n * useMemo\n * useCallback\n * useRef\n\n\n# useState\n\n> 为什么需要 useState？因为一般函数内部的变量在使用完就会被释放掉，useState 内部使用闭包来实现保存状态数据，用于为函数组件引入状态\n\n * 接收唯一的参数即状态初始值，可以为任意数据类型\n * 返回值为数组，存储状态值和更改状态的方法，方法名约定为 set 开头\n * 方法可以被调用多次用以保存不同的状态值\n * 参数可以是一个函数，函数返回值就是初始状态。函数只会被调用一次，用于初始值为动态值的情况\n\nimport React, { useState } from 'react';\n\nfunction Example(props) {\n  const [foo, setFoo] = useState(() => {\n    // 获取初始值 foo 这一段代码只需在组件初始化时执行一次，可以写在函数里\n    return props.foo || 'xx'\n  });\n  const [count, setCount] = useState(0);\n  const [person, setPerson] = useState({name: '张三', age: 20});\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n\t\t\t// 注意解构这种写法 {name: '张三', age: 20, name:''李四} name 会取最后一项\n\t\t\t<button onClick={() => setPerson({...person, name:'李四'})}>setPerson</button>\n    </div>\n  );\n}\n\n\n> 在点击按钮后 count + 1，组件状态改变，为了在页面上展示组件会重新渲染，此时状态数据会被保留，useState 的作用就体现了出来。\n\n * 设置状态值方法的参数可以是一个值也可以是一个函数\n * 设置状态值方法的方法本身是异步的\n\nimport React, { useState } from 'react';\n\nfunction Example(props) {\n  const [count, setCount] = useState(0);\n\t\n  function handleCount() {\n    setCount(count => count + 1);\n    document.title = count; // setCount异步,所以会先执行这句,解决办法是放在setCount方法里\n  }\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={handleCount}>+1</button>\n    </div>\n  );\n}\n\n\n\n# useEffect\n\n> 类组件在生命周期中处理副作用，函数型组件使用 useEffect 来处理\n> \n> 可以把 useEffect 看做 componentDidMount，componentDidUpdate，componentWillUnmount 的组合\n> \n> 解决的问题：相干业务逻辑归置到同一副作用函数中，简化重复代码，使组件内部代码更加清晰\n\n# 执行时机\n\nuseEffect 必然会在 render 的时候执行一次，其他的运行时机取决于以下情况：\n\n * 有没有第二个参数。useEffect hook 接受两个参数，第一个是要执行的代码，第二个是一个数组，指定一组依赖的变量，其中的变量发生变化时，此 effect 会重新执行一次。\n * 有没有返回值。 useEffect 的执行代码中可以返回一个函数，在每一次新的 render 进行前或者组件 unmount 之时，都会执行此函数，进行清理工作。\n\n例如：\n\n * useEffect(() => {})：在 componentDidMount，componentDidUpdate 执行\n * useEffect(() => {}, [])：空数组，只在 componentDidMount 执行\n * useEffect(() => {}, [count])：在 componentDidMount，componentDidUpdate（count变化） 执行\n * useEffect(() => () => {})：返回函数在 componentWillUnmount 执行\n\n原来的类组件写法\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  \n  componentWillUnmount() {\n    // 卸载前进行 clear()\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n\n\ncomponentDidMount和componentDidUpdate中的代码是一样的。可以使用 useEffect 来改写。\n\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n    return function clear() {\n      // clear\n    }\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n\n有的情况下我们希望只有在 state 或 props 改变的情况下才执行。如果是Class Component，我们会这么做：\n\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n}\n\n\n使用 Hook 的时候，我们只需要传入第二个参数：\n\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 只有在 count 改变的时候才执行 Effect\n\n// 第二个参数是一个数组，可以传多个值，一般会将 Effect 用到的所有 props 和 state 都传进去。\n\n\n# useEffect 结合异步函数\n\nuseEffect 中的参数函数不能是异步函数，因为 useEffect 要返回清理资源的函数，如果是异步函数就变成了返回Promise\n\n// err\nuseEffect(async () => {\n  const result = axios.get();\n})\n\n// ok\nuseEffect(() => {\n  (async () => {\n    const result = axios.get();\n  })()\n})\n\n\n\n# useReducer\n\n> useReducer 是另一种让函数组件保存状态的方式，类似于 redux\n\nimport React, { useReducer } from 'react';\n\nfunction reducer (state, action) {\n  swtich (action.type) {\n    case 'increment':\n    \treturn state + 1;\n    case 'decrement':\n    \treturn state - 1;\n    default:\n    \treturn state;\n  }\n}\n\nfunction App () {\n  const [count, dispatch] = useReducer(reducer, 0);\n  return (\n    <div>\n      <span>{count}</span>\n      <button onClick={() => dispatch({type: 'increment'})}>+1</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-1</button>\n    </div>\n  )\n}\n\n\n\n# useContext\n\n> 一般组件传值可以使用 props，但是涉及很多层级时可以使用 context 来解决\n\n * React.createContext\n\ncont MyContext  = React.createContext(defaultValue);\n\n\n创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n\n * Context.Provider\n\n<MyContext.Provider value={/* 某个值 */}>\n\n\n每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n\nProvider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\n\n * Context.Consumer\n\n<MyContext.Consumer>\n  {value => /* 基于 context 值进行渲染*/}\n</MyContext.Consumer>\n\n\n一个简单的例子\n\nimport React, { createContext } from 'react';\n\nconst countContext = createContext();\n\nfunction App() {\n  return (\n  \t<countContext.Provider value={100}>\n      <Foo />\n    </countContext.Provider>\n  )\n}\n\nfunction Foo() {\n\treturn (\n  \t<countContext.Consumer>\n      { value => <div>{value}</div> }\n    </countContext.Consumer>\n  )\n}\n\n\n> 使用 useContext 在跨组件层级获取数据时简化获取数据的代码\n\nimport React, { createContext, useContext } from 'react';\n\nconst countContext = createContext();\n\nfunction App() {\n  return (\n  \t<countContext.Provider value={100}>\n      <Foo />\n    </countContext.Provider>\n  )\n}\n\nfunction Foo() {\n  const value = useContext(countContext);\n  return <div>{value}</div>\n}\n\n\n\n# useMemo\n\n> 类似于 vue 中的计算属性，可以监测某个值的变化，根据变化计算新值。\n> \n> useMemo 会缓存计算结果，如果监测值没有发生变化，即使组件重新渲染，也不会重新计算。此行为可以有助于避免在每个渲染上进行昂贵的计算。\n\nimport React, { useState, useMemo } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const result = useMemo(() => {\n    return count * 2;\n  }, [count]);\n  return (\n  \t<div>\n      <span>{count} {result}</span>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </div>\n  )\n}\n\n\n\n# memo 方法\n\n> 性能优化，如果本组件中的数据没有发生变化，阻止组件更新。类似于类组件中的 PureComponent 和 shouldComponentUpdate\n\nimport React, { useState, memo } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n  \t<div>\n    \t<span>{count}</span>\n\t\t\t<button onClick={() => setCount(count + 1)}>+1</button>\n\t\t\t<Foo />\n    </div>\n  )\n}\n\nconst Foo = memo(function Foo() {\n  console.log(\"Foo组件重新渲染了\");\n  return <div>我是Foo组件</div>\n})\n\nexport default App;\n\n// 当点击按钮时，正常来说 App 组件会被重新渲染，相应地 Foo 组件也被重新渲染，但是使用 memo 后，Foo 组件中的数据没有发生变化，所以不会重新渲染。\n\n\n\n# useCallback\n\n> useCallback 是 React 中的一个 Hook，它的核心作用是缓存函数引用，避免组件重新渲染时重新创建函数。\n\n 1. useCallback 接受两个参数：\n\n一个需要缓存的函数； 一个依赖数组（dependencies）。 只有当依赖项发生变化时，才会返回新的函数；否则，返回上一次缓存的函数。\n\nconst memoizedCallback = useCallback(\n  () => {\n    // 函数逻辑（依赖某些变量，例如 state 或 props）\n  },\n  [dependency1, dependency2] // 依赖项数组\n);\n\n\n 2. 解决的问题: 避免子组件不必要的渲染\n\n当父组件传递一个函数作为 props 给子组件（尤其是用 React.memo 优化的子组件）时，如果父组件每次渲染都生成新函数，子组件会认为 props 变化，从而触发重新渲染。 useCallback 可以缓存函数，确保子组件只在依赖项变化时才会重新渲染。 jsx\n\n// 父组件\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  // 使用 useCallback 缓存函数\n  const handleClick = useCallback(() => {\n    console.log(\"Count:\", count);\n  }, [count]); // 依赖 count\n  return <Child onClick={handleClick} />;\n};\n// 子组件（用 React.memo 优化）\nconst Child = React.memo(({ onClick }) => {\n  // 只有在 onClick 函数变化时才会重新渲染\n  return <button onClick={onClick}>Click</button>;\n});\n\n\n 3. 性能优化的代价\n\nuseCallback 本身需要内存缓存函数，滥用可能导致性能反而下降。\n\n只在必要场景使用：\n\n * 函数作为 props 传递给 React.memo 优化的子组件；\n * 函数作为其他 Hook 的依赖项（如 useEffect）；\n * 需要稳定的函数引用（例如事件监听器的绑定与解绑）。\n\n 4. 与 useMemo 的区别\n\n * useCallback 缓存的是函数本身。\n * useMemo 缓存的是函数执行后的返回值。\n\n// 代码功能：App 组件中 setCount，Foo 组件中 resetCount\n\n// 表现效果：每次 resetCount 时都会输出 \"Foo组件重新渲染了\"\n\n// 原因：App 组件 setCount 时，组件被重新渲染，resetCount 函数也重新生成，所以当一个新的函数以 props 传入 Foo 组件时，相当于 Foo 组件中的数据改变，重新渲染\n\nimport React, { useState, memo } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const resetCount = () => {\n    setCount(0);\n  }\n  return (\n  \t<div>\n    \t<span>{count}</span>\n\t\t\t<button onClick={() => setCount(count + 1)}>+1</button>\n\t\t\t<Foo resetCount={resetCount}/>\n    </div>\n  )\n}\n\nconst Foo = memo(function Foo(props) {\n  console.log(\"Foo组件重新渲染了\");\n  return (\n    <div>\n    \t我是Foo组件\n    \t<button onClick={props.resetCount}>resetCount</button>\n    </div>\n  )\n})\n\nexport default App;\n\n\n使用 useCallback 改写 resetCount\n\nconst resetCount = useCallback(() => setCount(0), [setCount]);\n// setCount 不会改变，resetCount 也不会改变\n\n\n> 总结一下，使用场景是：有一个父组件，其中包含子组件，子组件接收一个函数作为props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助 useCallback 来返回函数，然后把这个函数作为props传递给子组件；这样，子组件就能避免不必要的更新。\n\n\n# useRef\n\n> 获取 Dom 元素对象\n\nimport React, { useRef } from 'react';\n\nfunction App() {\n  const box = useRef();\n  return (\n  \t<div ref={box}>\n      <button onClick={() => console.log(box)}>获取DIV</button>\n    </div>\n  )\n}\n\n\n> useRef还有另一个功能就是保存数据（跨组件周期）：即使组件重新渲染，保存的数据仍然还在。保存的数据被更改不会触发组件重新渲染。",normalizedContent:"# react hooks\n\nreact 框架在 v16.8 版本引入了全新的 api，叫做 react hooks，颠覆了以前的用法。react hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码\"钩\"进来。\n\n\n# 函数组件与类组件的区别\n\n\n# 函数式组件\n\n * 函数式编程思想\n\n * 不需要声明 class，不需要使用 this，没有生命周期方法，没有实例化。代码简洁，具有更佳的性能。\n\n * 可以写成无副作用的纯函数。\n\n * 没有 shouldcomponentupdate，不能避免重复渲染。\n\n\n# 类组件\n\n * 面向对象编程思想\n * 包含生命周期，state，this，功能更加完善，但是不能保证 this 指向正确性\n * 代码较为繁琐复杂，例如生命周期函数中存在多个不相干的业务逻辑\n\n\n# 什么是 react hooks\n\nreact hooks 解析\n\n> react hooks就是加强版的函数式组件，让函数型组件可以存储状态，可以拥有处理副作用的能力。让开发者不使用类组件的情况下实现相同的功能\n> \n> 副作用：不是用来转换视图的代码，例如 ajax 请求，获取 dom，我们一般在生命周期中处理这些代码。\n\nhooks 意为钩子，react hooks 就是一堆钩子函数，react 通过这些钩子函数对函数型组件进行增强，不同的钩子函数提供不同的功能。\n\n * usestate\n * useeffects\n * usereducer\n * usecontext\n * usememo\n * usecallback\n * useref\n\n\n# usestate\n\n> 为什么需要 usestate？因为一般函数内部的变量在使用完就会被释放掉，usestate 内部使用闭包来实现保存状态数据，用于为函数组件引入状态\n\n * 接收唯一的参数即状态初始值，可以为任意数据类型\n * 返回值为数组，存储状态值和更改状态的方法，方法名约定为 set 开头\n * 方法可以被调用多次用以保存不同的状态值\n * 参数可以是一个函数，函数返回值就是初始状态。函数只会被调用一次，用于初始值为动态值的情况\n\nimport react, { usestate } from 'react';\n\nfunction example(props) {\n  const [foo, setfoo] = usestate(() => {\n    // 获取初始值 foo 这一段代码只需在组件初始化时执行一次，可以写在函数里\n    return props.foo || 'xx'\n  });\n  const [count, setcount] = usestate(0);\n  const [person, setperson] = usestate({name: '张三', age: 20});\n\n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={() => setcount(count + 1)}>+1</button>\n\t\t\t// 注意解构这种写法 {name: '张三', age: 20, name:''李四} name 会取最后一项\n\t\t\t<button onclick={() => setperson({...person, name:'李四'})}>setperson</button>\n    </div>\n  );\n}\n\n\n> 在点击按钮后 count + 1，组件状态改变，为了在页面上展示组件会重新渲染，此时状态数据会被保留，usestate 的作用就体现了出来。\n\n * 设置状态值方法的参数可以是一个值也可以是一个函数\n * 设置状态值方法的方法本身是异步的\n\nimport react, { usestate } from 'react';\n\nfunction example(props) {\n  const [count, setcount] = usestate(0);\n\t\n  function handlecount() {\n    setcount(count => count + 1);\n    document.title = count; // setcount异步,所以会先执行这句,解决办法是放在setcount方法里\n  }\n  \n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={handlecount}>+1</button>\n    </div>\n  );\n}\n\n\n\n# useeffect\n\n> 类组件在生命周期中处理副作用，函数型组件使用 useeffect 来处理\n> \n> 可以把 useeffect 看做 componentdidmount，componentdidupdate，componentwillunmount 的组合\n> \n> 解决的问题：相干业务逻辑归置到同一副作用函数中，简化重复代码，使组件内部代码更加清晰\n\n# 执行时机\n\nuseeffect 必然会在 render 的时候执行一次，其他的运行时机取决于以下情况：\n\n * 有没有第二个参数。useeffect hook 接受两个参数，第一个是要执行的代码，第二个是一个数组，指定一组依赖的变量，其中的变量发生变化时，此 effect 会重新执行一次。\n * 有没有返回值。 useeffect 的执行代码中可以返回一个函数，在每一次新的 render 进行前或者组件 unmount 之时，都会执行此函数，进行清理工作。\n\n例如：\n\n * useeffect(() => {})：在 componentdidmount，componentdidupdate 执行\n * useeffect(() => {}, [])：空数组，只在 componentdidmount 执行\n * useeffect(() => {}, [count])：在 componentdidmount，componentdidupdate（count变化） 执行\n * useeffect(() => () => {})：返回函数在 componentwillunmount 执行\n\n原来的类组件写法\n\nclass example extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentdidmount() {\n    document.title = `you clicked ${this.state.count} times`;\n  }\n\n  componentdidupdate() {\n    document.title = `you clicked ${this.state.count} times`;\n  }\n  \n  componentwillunmount() {\n    // 卸载前进行 clear()\n  }\n\n  render() {\n    return (\n      <div>\n        <p>you clicked {this.state.count} times</p>\n        <button onclick={() => this.setstate({ count: this.state.count + 1 })}>\n          click me\n        </button>\n      </div>\n    );\n  }\n}\n\n\ncomponentdidmount和componentdidupdate中的代码是一样的。可以使用 useeffect 来改写。\n\nimport react, { usestate, useeffect } from 'react';\n\nfunction example() {\n  const [count, setcount] = usestate(0);\n\n  useeffect(() => {\n    document.title = `you clicked ${count} times`;\n    return function clear() {\n      // clear\n    }\n  });\n\n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={() => setcount(count + 1)}>\n        click me\n      </button>\n    </div>\n  );\n}\n\n\n有的情况下我们希望只有在 state 或 props 改变的情况下才执行。如果是class component，我们会这么做：\n\ncomponentdidupdate(prevprops, prevstate) {\n  if (prevstate.count !== this.state.count) {\n    document.title = `you clicked ${this.state.count} times`;\n  }\n}\n\n\n使用 hook 的时候，我们只需要传入第二个参数：\n\nuseeffect(() => {\n  document.title = `you clicked ${count} times`;\n}, [count]); // 只有在 count 改变的时候才执行 effect\n\n// 第二个参数是一个数组，可以传多个值，一般会将 effect 用到的所有 props 和 state 都传进去。\n\n\n# useeffect 结合异步函数\n\nuseeffect 中的参数函数不能是异步函数，因为 useeffect 要返回清理资源的函数，如果是异步函数就变成了返回promise\n\n// err\nuseeffect(async () => {\n  const result = axios.get();\n})\n\n// ok\nuseeffect(() => {\n  (async () => {\n    const result = axios.get();\n  })()\n})\n\n\n\n# usereducer\n\n> usereducer 是另一种让函数组件保存状态的方式，类似于 redux\n\nimport react, { usereducer } from 'react';\n\nfunction reducer (state, action) {\n  swtich (action.type) {\n    case 'increment':\n    \treturn state + 1;\n    case 'decrement':\n    \treturn state - 1;\n    default:\n    \treturn state;\n  }\n}\n\nfunction app () {\n  const [count, dispatch] = usereducer(reducer, 0);\n  return (\n    <div>\n      <span>{count}</span>\n      <button onclick={() => dispatch({type: 'increment'})}>+1</button>\n      <button onclick={() => dispatch({type: 'decrement'})}>-1</button>\n    </div>\n  )\n}\n\n\n\n# usecontext\n\n> 一般组件传值可以使用 props，但是涉及很多层级时可以使用 context 来解决\n\n * react.createcontext\n\ncont mycontext  = react.createcontext(defaultvalue);\n\n\n创建一个 context 对象。当 react 渲染一个订阅了这个 context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 provider 中读取到当前的 context 值。\n\n * context.provider\n\n<mycontext.provider value={/* 某个值 */}>\n\n\n每个 context 对象都会返回一个 provider react 组件，它允许消费组件订阅 context 的变化。\n\nprovider 接收一个 value 属性，传递给消费组件。一个 provider 可以和多个消费组件有对应关系。多个 provider 也可以嵌套使用，里层的会覆盖外层的数据。\n\n当 provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\n\n * context.consumer\n\n<mycontext.consumer>\n  {value => /* 基于 context 值进行渲染*/}\n</mycontext.consumer>\n\n\n一个简单的例子\n\nimport react, { createcontext } from 'react';\n\nconst countcontext = createcontext();\n\nfunction app() {\n  return (\n  \t<countcontext.provider value={100}>\n      <foo />\n    </countcontext.provider>\n  )\n}\n\nfunction foo() {\n\treturn (\n  \t<countcontext.consumer>\n      { value => <div>{value}</div> }\n    </countcontext.consumer>\n  )\n}\n\n\n> 使用 usecontext 在跨组件层级获取数据时简化获取数据的代码\n\nimport react, { createcontext, usecontext } from 'react';\n\nconst countcontext = createcontext();\n\nfunction app() {\n  return (\n  \t<countcontext.provider value={100}>\n      <foo />\n    </countcontext.provider>\n  )\n}\n\nfunction foo() {\n  const value = usecontext(countcontext);\n  return <div>{value}</div>\n}\n\n\n\n# usememo\n\n> 类似于 vue 中的计算属性，可以监测某个值的变化，根据变化计算新值。\n> \n> usememo 会缓存计算结果，如果监测值没有发生变化，即使组件重新渲染，也不会重新计算。此行为可以有助于避免在每个渲染上进行昂贵的计算。\n\nimport react, { usestate, usememo } from 'react';\n\nfunction app() {\n  const [count, setcount] = usestate(0);\n  const result = usememo(() => {\n    return count * 2;\n  }, [count]);\n  return (\n  \t<div>\n      <span>{count} {result}</span>\n      <button onclick={() => setcount(count + 1)}>+1</button>\n    </div>\n  )\n}\n\n\n\n# memo 方法\n\n> 性能优化，如果本组件中的数据没有发生变化，阻止组件更新。类似于类组件中的 purecomponent 和 shouldcomponentupdate\n\nimport react, { usestate, memo } from 'react';\n\nfunction app() {\n  const [count, setcount] = usestate(0);\n  return (\n  \t<div>\n    \t<span>{count}</span>\n\t\t\t<button onclick={() => setcount(count + 1)}>+1</button>\n\t\t\t<foo />\n    </div>\n  )\n}\n\nconst foo = memo(function foo() {\n  console.log(\"foo组件重新渲染了\");\n  return <div>我是foo组件</div>\n})\n\nexport default app;\n\n// 当点击按钮时，正常来说 app 组件会被重新渲染，相应地 foo 组件也被重新渲染，但是使用 memo 后，foo 组件中的数据没有发生变化，所以不会重新渲染。\n\n\n\n# usecallback\n\n> usecallback 是 react 中的一个 hook，它的核心作用是缓存函数引用，避免组件重新渲染时重新创建函数。\n\n 1. usecallback 接受两个参数：\n\n一个需要缓存的函数； 一个依赖数组（dependencies）。 只有当依赖项发生变化时，才会返回新的函数；否则，返回上一次缓存的函数。\n\nconst memoizedcallback = usecallback(\n  () => {\n    // 函数逻辑（依赖某些变量，例如 state 或 props）\n  },\n  [dependency1, dependency2] // 依赖项数组\n);\n\n\n 2. 解决的问题: 避免子组件不必要的渲染\n\n当父组件传递一个函数作为 props 给子组件（尤其是用 react.memo 优化的子组件）时，如果父组件每次渲染都生成新函数，子组件会认为 props 变化，从而触发重新渲染。 usecallback 可以缓存函数，确保子组件只在依赖项变化时才会重新渲染。 jsx\n\n// 父组件\nconst parent = () => {\n  const [count, setcount] = usestate(0);\n  // 使用 usecallback 缓存函数\n  const handleclick = usecallback(() => {\n    console.log(\"count:\", count);\n  }, [count]); // 依赖 count\n  return <child onclick={handleclick} />;\n};\n// 子组件（用 react.memo 优化）\nconst child = react.memo(({ onclick }) => {\n  // 只有在 onclick 函数变化时才会重新渲染\n  return <button onclick={onclick}>click</button>;\n});\n\n\n 3. 性能优化的代价\n\nusecallback 本身需要内存缓存函数，滥用可能导致性能反而下降。\n\n只在必要场景使用：\n\n * 函数作为 props 传递给 react.memo 优化的子组件；\n * 函数作为其他 hook 的依赖项（如 useeffect）；\n * 需要稳定的函数引用（例如事件监听器的绑定与解绑）。\n\n 4. 与 usememo 的区别\n\n * usecallback 缓存的是函数本身。\n * usememo 缓存的是函数执行后的返回值。\n\n// 代码功能：app 组件中 setcount，foo 组件中 resetcount\n\n// 表现效果：每次 resetcount 时都会输出 \"foo组件重新渲染了\"\n\n// 原因：app 组件 setcount 时，组件被重新渲染，resetcount 函数也重新生成，所以当一个新的函数以 props 传入 foo 组件时，相当于 foo 组件中的数据改变，重新渲染\n\nimport react, { usestate, memo } from 'react';\n\nfunction app() {\n  const [count, setcount] = usestate(0);\n  const resetcount = () => {\n    setcount(0);\n  }\n  return (\n  \t<div>\n    \t<span>{count}</span>\n\t\t\t<button onclick={() => setcount(count + 1)}>+1</button>\n\t\t\t<foo resetcount={resetcount}/>\n    </div>\n  )\n}\n\nconst foo = memo(function foo(props) {\n  console.log(\"foo组件重新渲染了\");\n  return (\n    <div>\n    \t我是foo组件\n    \t<button onclick={props.resetcount}>resetcount</button>\n    </div>\n  )\n})\n\nexport default app;\n\n\n使用 usecallback 改写 resetcount\n\nconst resetcount = usecallback(() => setcount(0), [setcount]);\n// setcount 不会改变，resetcount 也不会改变\n\n\n> 总结一下，使用场景是：有一个父组件，其中包含子组件，子组件接收一个函数作为props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助 usecallback 来返回函数，然后把这个函数作为props传递给子组件；这样，子组件就能避免不必要的更新。\n\n\n# useref\n\n> 获取 dom 元素对象\n\nimport react, { useref } from 'react';\n\nfunction app() {\n  const box = useref();\n  return (\n  \t<div ref={box}>\n      <button onclick={() => console.log(box)}>获取div</button>\n    </div>\n  )\n}\n\n\n> useref还有另一个功能就是保存数据（跨组件周期）：即使组件重新渲染，保存的数据仍然还在。保存的数据被更改不会触发组件重新渲染。",charsets:{cjk:!0}},{title:"san-composition",frontmatter:{title:"san-composition",date:"2021-10-09T11:27:54.000Z",categories:"San"},regularPath:"/san/composition.html",relativePath:"san/composition.md",key:"v-140d9f9f",path:"/san/composition.html",headers:[{level:2,title:"常用 api",slug:"常用-api",normalizedTitle:"常用 api",charIndex:95},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:228},{level:2,title:"DataProxy",slug:"dataproxy",normalizedTitle:"dataproxy",charIndex:656},{level:2,title:"完整的例子",slug:"完整的例子",normalizedTitle:"完整的例子",charIndex:798}],lastUpdated:"10/9/2021, 7:50:19 PM",lastUpdatedTimestamp:1633780219e3,headersStr:"常用 api 生命周期 DataProxy 完整的例子",content:"# san-composition\n\nVue3.0 提出了组合式 api 的概念，san-composition 是 san 框架实现组合式 api 的方式，下面列出一些基础用法。\n\n\n# 常用 api\n\n * template：定义组件模板的方法\n * data：初始化数据\n * components：子组件\n * method：定义组件中的方法\n * watch：监听数据变化\n * computed：计算属性\n * filters：过滤器\n\n\n# 生命周期\n\n * onConstruct：在 construct （组件初始化开始）过程到达时触发的钩子函数\n * onCompiled：在 compiled （组件视图模板编译完成）过程到达时触发的钩子函数\n * onInited：在 inited （组件实例初始化完成）过程到达时触发的钩子函数\n * onCreated：在 created （组件元素创建完成）过程到达时触发的钩子函数\n * onAttached：在 attached （组件已被附加到页面）过程到达时触发的钩子函数\n * onDetached：在 detached （组件从页面中移除）过程到达时触发的钩子函数\n * onDisposed：在 disposed （组件卸载完成）过程到达时触发的钩子函数\n * onUpdated：在 updated （组件视图刷新后）过程到达时触发的钩子函数\n * onError：在 error （处理组件异常）过程到达时触发的钩子函数\n\n\n# DataProxy\n\nDataProxy是data初始化返回的实例，支持如下方法：\n\n * get\n * set\n * merge\n * apply\n * push / pop / unshift / shift\n * remove / removeAt\n * splice\n\n\n# 完整的例子\n\nsan-composition 进阶篇",normalizedContent:"# san-composition\n\nvue3.0 提出了组合式 api 的概念，san-composition 是 san 框架实现组合式 api 的方式，下面列出一些基础用法。\n\n\n# 常用 api\n\n * template：定义组件模板的方法\n * data：初始化数据\n * components：子组件\n * method：定义组件中的方法\n * watch：监听数据变化\n * computed：计算属性\n * filters：过滤器\n\n\n# 生命周期\n\n * onconstruct：在 construct （组件初始化开始）过程到达时触发的钩子函数\n * oncompiled：在 compiled （组件视图模板编译完成）过程到达时触发的钩子函数\n * oninited：在 inited （组件实例初始化完成）过程到达时触发的钩子函数\n * oncreated：在 created （组件元素创建完成）过程到达时触发的钩子函数\n * onattached：在 attached （组件已被附加到页面）过程到达时触发的钩子函数\n * ondetached：在 detached （组件从页面中移除）过程到达时触发的钩子函数\n * ondisposed：在 disposed （组件卸载完成）过程到达时触发的钩子函数\n * onupdated：在 updated （组件视图刷新后）过程到达时触发的钩子函数\n * onerror：在 error （处理组件异常）过程到达时触发的钩子函数\n\n\n# dataproxy\n\ndataproxy是data初始化返回的实例，支持如下方法：\n\n * get\n * set\n * merge\n * apply\n * push / pop / unshift / shift\n * remove / removeat\n * splice\n\n\n# 完整的例子\n\nsan-composition 进阶篇",charsets:{cjk:!0}},{title:"history模式和hash模式",frontmatter:{},regularPath:"/route/route.html",relativePath:"route/route.md",key:"v-b9f651c2",path:"/route/route.html",headers:[{level:2,title:"hash模式",slug:"hash模式",normalizedTitle:"hash模式",charIndex:12},{level:2,title:"history模式",slug:"history模式",normalizedTitle:"history模式",charIndex:2},{level:3,title:"length",slug:"length",normalizedTitle:"length",charIndex:2049},{level:3,title:"history.pushState()",slug:"history-pushstate",normalizedTitle:"history.pushstate()",charIndex:2432},{level:3,title:"history.replaceState()",slug:"history-replacestate",normalizedTitle:"history.replacestate()",charIndex:3203},{level:3,title:"popState 事件",slug:"popstate-事件",normalizedTitle:"popstate 事件",charIndex:3637},{level:2,title:"根据权限动态添加路由列表",slug:"根据权限动态添加路由列表",normalizedTitle:"根据权限动态添加路由列表",charIndex:5760},{level:2,title:"配置路由meta属性",slug:"配置路由meta属性",normalizedTitle:"配置路由meta属性",charIndex:6451},{level:2,title:"router跳转两次的问题",slug:"router跳转两次的问题",normalizedTitle:"router跳转两次的问题",charIndex:7519}],lastUpdated:"2/24/2023, 5:42:01 PM",lastUpdatedTimestamp:1677231721e3,headersStr:"hash模式 history模式 length history.pushState() history.replaceState() popState 事件 根据权限动态添加路由列表 配置路由meta属性 router跳转两次的问题",content:"# history模式和hash模式\n\n前端随着 ajax 的流行，数据请求可以在不刷新浏览器的情况下进行。异步交互体验中最盛行的就是 SPA —— 单页应用。单页应用不仅仅是在页面交互时无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。\n\n\n# hash模式\n\n#的涵义\n\n * #代表网页中的一个位置,右面的字符就是代表的位置\n * http://localhost：8081/cbuild/index.html#first就代表网页index.html的first位置。浏览器读取这个URL后，会自动将first位置滚动至可视区域。\n\n#后的字符\n\n * 在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n * 比如，下面URL的原意是指定一个颜色值：http://www.example.com/?color=#fff但是，浏览器实际发出的请求是\"#fff\"被省略了。只有将#转码为%23，浏览器才会将其作为实义字符处理。也就是说，上面的网址应该被写成：http://example.com/?color=%23fff\n\n改变#不触发网页重载\n\n * 单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。\n * 比如，从http://www.example.com/index.html#location1改成http://www.example.com/index.html#location2浏览器不会重新向服务器请求index.html。\n\n改变#会改变浏览器的访问历史\n\n * 每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n\nwindow.location.hash读取#值\n\n * window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。\n\nonhashchange事件\n\n * 这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。\n * window.addEventListener(\"hashchange\",func, false);\n\n思路\n\n> 当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号),然后根据hash值做些路由跳转处理的操作.具体参数可以访问location查看\n\n\x3c!-- hashchange 触发页面改变 --\x3e\n\t<ul>\n      <li>\n        <a href=\"#/a\">a</a>\n      </li>\n      <li>\n        <a href=\"#/b\">b</a>\n      </li>\n      <li>\n        <a href=\"#/c\">c</a>\n      </li>\n    </ul>\n    <div id=\"view\"></div>\n\n    <script>\n      var view = null;\n      // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件\n      // 该事件快于onLoad,所以需要在这里操作\n      window.addEventListener('DOMContentLoaded', function () {\n        view = document.querySelector('#view');\n        viewChange();\n      });\n      // 监听路由变化\n      window.addEventListener('hashchange', viewChange);\n\n      // 渲染视图\n      function viewChange() {\n        switch (location.hash) {\n          case '#/b':\n            view.innerHTML = 'b';\n            break;\n          case '#/c':\n            view.innerHTML = 'c';\n            break;\n          default:\n            view.innerHTML = 'a';\n            break;\n        }\n      }\n<\/script>\n\n\n\n# history模式\n\nwindow.history(可直接写成history)指向History对象，它表示当前窗口的浏览历史。\n\nHistory对象保存了当前窗口访问过的所有页面网址\n\n\n# length\n\n * history.length属性保存着历史记录的url数量，初始时该值为1，如果当前窗口先后访问了三个网址，那么history对象就包括3项，history.length=3\n\n跳转方法\n\n * go() 接受一个整数为参数，移动到该整数指定的页面，比如history.go(1)相当于history.forward(),history.go(-1)相当于history.back(),history.go(0)相当于刷新当前页面\n * back() 移动到上一个访问页面，等同于浏览器的后退键,常见的返回上一页就可以用back()，是从浏览器缓存中加载，而不是重新要求服务器发送新的网页\n * forward() 移动到下一个访问页面，等同于浏览器的前进键\n\n如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败\n\n\n# history.pushState()\n\nhistory.pushstate() 方法接受三个参数，以此为：\n\n * state: 一个与指定网址相关的状态对象，popState事件触发时，该对象会传入回调函数，如果不需要这个对象，此处可填null\n * title: 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null\n * url: 新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示这个网址\n\n// 假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录(history对象)中添加一个记录\n\nvar stateObj = {foo:'bar'};\nhistory.pushState(stateObj,'page 2','2.html')\n\n\n> 添加上边这个新纪录后，浏览器地址栏立刻显示example.com/2.html，但不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的新纪录。这时，你在地址栏输入一个新的地址，然后点击了后退按钮，页面的url将显示2.html；你再点击以此后退按钮，url将显示1.html\n\n总之，pushState方法不会触发页面刷新，只是导致了history对象发生变化，地址栏会有反应\n\n如果pushState的url参数，设置了一个新的锚点值（即hash），并不会触发hashChange事件，如果设置了一个跨域网址，则会报错。\n\n//报错\nhistory.pushState(null,null,'https://twitter.com/hello')\n\n\n上边代码中，pushState()想要插入一个跨域的网址，导致报错，这样设计的目的是防止恶意代码让用户以为他们是在另一个网站上.\n\n\n# history.replaceState()\n\nhistory.replaceState() 方法的参数和 pushState() 方法一摸一样，区别是它修改浏览器历史当中的记录\n\n假定当前页面是example.com/example.html\n\nhistory.pushState({page:1},'title 1','?page=1')\nhistory.pushState({page:2},'title 2','?page=2')\nhistory.replaceState({page:3},'title 3','?page=3')\n\nhistory.back() //url显示为example.com/example.html?page=1\nhistory.back() //url显示为example.com/example.html\nhistory.go(2) //url显示为example.com/example.html?page=3\n\n\n\n# popState 事件\n\n * history.pushState和history.replaceState方法是不会触发popstate事件的\n * 但是浏览器的某些行为会导致popstate，比如go、back、forward\n * popstate事件对象中的state属性，可以理解是我们在通过history.pushState或history.replaceState方法时，传入的指定的数据，可以为popState事件指定回调函数\n\nwindow.onpopstate = function (event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' +JSON.stringify(event.state));\n};\n\n// 或者\nwindow.addEventListener('popstate', function(event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + JSON.stringify(event.state));\n});\n\n\n所以，我们可以罗列出所有可能触发 history 改变的情况，并且将这些方式一一进行拦截，变相地监听 history 的改变。\n\n对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：\n\n 1. 点击浏览器的前进或后退按钮\n 2. 点击 a 标签\n 3. 在 JS 代码中触发 history.pushState 函数\n 4. 在 JS 代码中触发 history.replaceState 函数\n\n\x3c!-- popstate 和点击事件 触发页面改变 --\x3e\n\t<ul>\n      <li>\n        <a href=\"/a\">a</a>\n      </li>\n      <li>\n        <a href=\"/b\">b</a>\n      </li>\n      <li>\n        <a href=\"/c\">c</a>\n      </li>\n    </ul>\n    <div id=\"view\"></div>\n\n    <script>\n      var view = null;\n      \n      window.addEventListener('DOMContentLoaded', function () {\n        view = document.querySelector('#view');\n        document\n          .querySelectorAll('a[href]')\n          .forEach(e => e.addEventListener('click', function (_e) {\n            _e.preventDefault();\n            history.pushState(null, '', e.getAttribute('href'));\n            viewChange();\n          }));\n\n        viewChange();\n      });\n      // 监听路由变化\n      window.addEventListener('popstate', viewChange);\n\n      // 渲染视图\n      function viewChange() {\n        switch (location.pathname) {\n          case '/b':\n            view.innerHTML = 'b';\n            break;\n          case '/c':\n            view.innerHTML = 'c';\n            break;\n          default:\n            view.innerHTML = 'a';\n            break;\n        }\n      }\n<\/script>\n\n\n优点：\n\n * 该模式的路由不带#，看起来更美观\n * pushState设置的URL可以是任意的与当前URL同源的URL，而hash只能改变#后面的内容\n\n缺点：\n\n * 当我们使用 history 模式路由时，比如有这么一个 url：www.test.com/home，如果我们刷新页面的话，浏览器会发送新的请求 www.test.com/home, 如果后端服务器没有 /home 对应的接口，那么就会返回404。\n * 刷新 404 的解决办法：在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，接口则应该返回首页 index.html。\n\n\n# 根据权限动态添加路由列表\n\n * 业务场景：不同用户调用权限接口获得的权限是不同的，根据用户权限动态展示路由列表\n\n\t\t api.getAuditInfo({\n             account: username,\n         }).then(res => {\n             console.log('权限代码:', res)\n             // 高级权限：可以查看某一块路由\n             if (res.includes('auth0')) {\n                 window.authInfo = true\n                 // 添加路由\n                 this.$router.addRoutes(videoRoutes)\n                 this.$router.options.routes.push(...videoRoutes)\n             // 普通权限\n             } else if (res.includes('auth1') && !res.includes('auth0')) {\n                 window.authInfo = false\n             // 没有权限时返回\n             } else {\n                 window.location.href = `\n             }\n         })\n\n\n\n# 配置路由meta属性\n\n * 业务场景：同一个组件在不同路由下的展示状态是不同的，这时可以配置路由meta属性来实现\n\nconst routes = [\n    {\n        path: '/audit/video',\n        name: '视频管理',\n        component: Layout,\n        children: [\n            {\n                path: 'videoList',\n                name: '视频列表',\n                meta: {\n                    noCache: true,\n                    cityChange: true,\n                },\n                component: auditvideoList\n            },\n            {\n                path: 'auditList',\n                name: '审核列表',\n                // 配置 meta 属性\n                meta: {\n                    noCache: true,\n                    cityDefault: true \n                },\n                component: auditList\n            }\n        ]\n    },\n    {\n        path: '*',\n        redirect: '/audit/agent',\n        hidden: true\n    }\n]\n\n\n * 比如说 header 中的一个组件，不同路由页面均展示，只是状态不同\n\n<template>\n    <div v-if=\"!cityDefault\"></div>\n\t  <div v-else ></div>\n</template>\t\n\t\n<script>\ncomputed: {\n        cityDefault() {\n            return this.$route.meta.cityDefault;\n        }\n    },\n<\/script>\n\n\n\n# router跳转两次的问题\n\n> 浏览器会自动对中文进行转码，会导致router的监听方法监听到浏览器地址栏变化。也就是说当我们跳转链接存在中文字符时，浏览器地址会变化两次，然后导致页面组件也会加载两次；",normalizedContent:"# history模式和hash模式\n\n前端随着 ajax 的流行，数据请求可以在不刷新浏览器的情况下进行。异步交互体验中最盛行的就是 spa —— 单页应用。单页应用不仅仅是在页面交互时无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。\n\n\n# hash模式\n\n#的涵义\n\n * #代表网页中的一个位置,右面的字符就是代表的位置\n * http://localhost：8081/cbuild/index.html#first就代表网页index.html的first位置。浏览器读取这个url后，会自动将first位置滚动至可视区域。\n\n#后的字符\n\n * 在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n * 比如，下面url的原意是指定一个颜色值：http://www.example.com/?color=#fff但是，浏览器实际发出的请求是\"#fff\"被省略了。只有将#转码为%23，浏览器才会将其作为实义字符处理。也就是说，上面的网址应该被写成：http://example.com/?color=%23fff\n\n改变#不触发网页重载\n\n * 单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。\n * 比如，从http://www.example.com/index.html#location1改成http://www.example.com/index.html#location2浏览器不会重新向服务器请求index.html。\n\n改变#会改变浏览器的访问历史\n\n * 每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n\nwindow.location.hash读取#值\n\n * window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。\n\nonhashchange事件\n\n * 这是一个html 5新增的事件，当#值发生变化时，就会触发这个事件。\n * window.addeventlistener(\"hashchange\",func, false);\n\n思路\n\n> 当url的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的url部分，包括＃符号),然后根据hash值做些路由跳转处理的操作.具体参数可以访问location查看\n\n\x3c!-- hashchange 触发页面改变 --\x3e\n\t<ul>\n      <li>\n        <a href=\"#/a\">a</a>\n      </li>\n      <li>\n        <a href=\"#/b\">b</a>\n      </li>\n      <li>\n        <a href=\"#/c\">c</a>\n      </li>\n    </ul>\n    <div id=\"view\"></div>\n\n    <script>\n      var view = null;\n      // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件\n      // 该事件快于onload,所以需要在这里操作\n      window.addeventlistener('domcontentloaded', function () {\n        view = document.queryselector('#view');\n        viewchange();\n      });\n      // 监听路由变化\n      window.addeventlistener('hashchange', viewchange);\n\n      // 渲染视图\n      function viewchange() {\n        switch (location.hash) {\n          case '#/b':\n            view.innerhtml = 'b';\n            break;\n          case '#/c':\n            view.innerhtml = 'c';\n            break;\n          default:\n            view.innerhtml = 'a';\n            break;\n        }\n      }\n<\/script>\n\n\n\n# history模式\n\nwindow.history(可直接写成history)指向history对象，它表示当前窗口的浏览历史。\n\nhistory对象保存了当前窗口访问过的所有页面网址\n\n\n# length\n\n * history.length属性保存着历史记录的url数量，初始时该值为1，如果当前窗口先后访问了三个网址，那么history对象就包括3项，history.length=3\n\n跳转方法\n\n * go() 接受一个整数为参数，移动到该整数指定的页面，比如history.go(1)相当于history.forward(),history.go(-1)相当于history.back(),history.go(0)相当于刷新当前页面\n * back() 移动到上一个访问页面，等同于浏览器的后退键,常见的返回上一页就可以用back()，是从浏览器缓存中加载，而不是重新要求服务器发送新的网页\n * forward() 移动到下一个访问页面，等同于浏览器的前进键\n\n如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败\n\n\n# history.pushstate()\n\nhistory.pushstate() 方法接受三个参数，以此为：\n\n * state: 一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数，如果不需要这个对象，此处可填null\n * title: 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null\n * url: 新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示这个网址\n\n// 假定当前网址是example.com/1.html，我们使用pushstate方法在浏览记录(history对象)中添加一个记录\n\nvar stateobj = {foo:'bar'};\nhistory.pushstate(stateobj,'page 2','2.html')\n\n\n> 添加上边这个新纪录后，浏览器地址栏立刻显示example.com/2.html，但不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的新纪录。这时，你在地址栏输入一个新的地址，然后点击了后退按钮，页面的url将显示2.html；你再点击以此后退按钮，url将显示1.html\n\n总之，pushstate方法不会触发页面刷新，只是导致了history对象发生变化，地址栏会有反应\n\n如果pushstate的url参数，设置了一个新的锚点值（即hash），并不会触发hashchange事件，如果设置了一个跨域网址，则会报错。\n\n//报错\nhistory.pushstate(null,null,'https://twitter.com/hello')\n\n\n上边代码中，pushstate()想要插入一个跨域的网址，导致报错，这样设计的目的是防止恶意代码让用户以为他们是在另一个网站上.\n\n\n# history.replacestate()\n\nhistory.replacestate() 方法的参数和 pushstate() 方法一摸一样，区别是它修改浏览器历史当中的记录\n\n假定当前页面是example.com/example.html\n\nhistory.pushstate({page:1},'title 1','?page=1')\nhistory.pushstate({page:2},'title 2','?page=2')\nhistory.replacestate({page:3},'title 3','?page=3')\n\nhistory.back() //url显示为example.com/example.html?page=1\nhistory.back() //url显示为example.com/example.html\nhistory.go(2) //url显示为example.com/example.html?page=3\n\n\n\n# popstate 事件\n\n * history.pushstate和history.replacestate方法是不会触发popstate事件的\n * 但是浏览器的某些行为会导致popstate，比如go、back、forward\n * popstate事件对象中的state属性，可以理解是我们在通过history.pushstate或history.replacestate方法时，传入的指定的数据，可以为popstate事件指定回调函数\n\nwindow.onpopstate = function (event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' +json.stringify(event.state));\n};\n\n// 或者\nwindow.addeventlistener('popstate', function(event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + json.stringify(event.state));\n});\n\n\n所以，我们可以罗列出所有可能触发 history 改变的情况，并且将这些方式一一进行拦截，变相地监听 history 的改变。\n\n对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起：\n\n 1. 点击浏览器的前进或后退按钮\n 2. 点击 a 标签\n 3. 在 js 代码中触发 history.pushstate 函数\n 4. 在 js 代码中触发 history.replacestate 函数\n\n\x3c!-- popstate 和点击事件 触发页面改变 --\x3e\n\t<ul>\n      <li>\n        <a href=\"/a\">a</a>\n      </li>\n      <li>\n        <a href=\"/b\">b</a>\n      </li>\n      <li>\n        <a href=\"/c\">c</a>\n      </li>\n    </ul>\n    <div id=\"view\"></div>\n\n    <script>\n      var view = null;\n      \n      window.addeventlistener('domcontentloaded', function () {\n        view = document.queryselector('#view');\n        document\n          .queryselectorall('a[href]')\n          .foreach(e => e.addeventlistener('click', function (_e) {\n            _e.preventdefault();\n            history.pushstate(null, '', e.getattribute('href'));\n            viewchange();\n          }));\n\n        viewchange();\n      });\n      // 监听路由变化\n      window.addeventlistener('popstate', viewchange);\n\n      // 渲染视图\n      function viewchange() {\n        switch (location.pathname) {\n          case '/b':\n            view.innerhtml = 'b';\n            break;\n          case '/c':\n            view.innerhtml = 'c';\n            break;\n          default:\n            view.innerhtml = 'a';\n            break;\n        }\n      }\n<\/script>\n\n\n优点：\n\n * 该模式的路由不带#，看起来更美观\n * pushstate设置的url可以是任意的与当前url同源的url，而hash只能改变#后面的内容\n\n缺点：\n\n * 当我们使用 history 模式路由时，比如有这么一个 url：www.test.com/home，如果我们刷新页面的话，浏览器会发送新的请求 www.test.com/home, 如果后端服务器没有 /home 对应的接口，那么就会返回404。\n * 刷新 404 的解决办法：在服务端增加一个覆盖所有情况的候选资源：如果 url 匹配不到任何静态资源，接口则应该返回首页 index.html。\n\n\n# 根据权限动态添加路由列表\n\n * 业务场景：不同用户调用权限接口获得的权限是不同的，根据用户权限动态展示路由列表\n\n\t\t api.getauditinfo({\n             account: username,\n         }).then(res => {\n             console.log('权限代码:', res)\n             // 高级权限：可以查看某一块路由\n             if (res.includes('auth0')) {\n                 window.authinfo = true\n                 // 添加路由\n                 this.$router.addroutes(videoroutes)\n                 this.$router.options.routes.push(...videoroutes)\n             // 普通权限\n             } else if (res.includes('auth1') && !res.includes('auth0')) {\n                 window.authinfo = false\n             // 没有权限时返回\n             } else {\n                 window.location.href = `\n             }\n         })\n\n\n\n# 配置路由meta属性\n\n * 业务场景：同一个组件在不同路由下的展示状态是不同的，这时可以配置路由meta属性来实现\n\nconst routes = [\n    {\n        path: '/audit/video',\n        name: '视频管理',\n        component: layout,\n        children: [\n            {\n                path: 'videolist',\n                name: '视频列表',\n                meta: {\n                    nocache: true,\n                    citychange: true,\n                },\n                component: auditvideolist\n            },\n            {\n                path: 'auditlist',\n                name: '审核列表',\n                // 配置 meta 属性\n                meta: {\n                    nocache: true,\n                    citydefault: true \n                },\n                component: auditlist\n            }\n        ]\n    },\n    {\n        path: '*',\n        redirect: '/audit/agent',\n        hidden: true\n    }\n]\n\n\n * 比如说 header 中的一个组件，不同路由页面均展示，只是状态不同\n\n<template>\n    <div v-if=\"!citydefault\"></div>\n\t  <div v-else ></div>\n</template>\t\n\t\n<script>\ncomputed: {\n        citydefault() {\n            return this.$route.meta.citydefault;\n        }\n    },\n<\/script>\n\n\n\n# router跳转两次的问题\n\n> 浏览器会自动对中文进行转码，会导致router的监听方法监听到浏览器地址栏变化。也就是说当我们跳转链接存在中文字符时，浏览器地址会变化两次，然后导致页面组件也会加载两次；",charsets:{cjk:!0}},{title:"服务端渲染",frontmatter:{title:"服务端渲染",date:"2020-11-08T11:27:54.000Z",categories:"SSR"},regularPath:"/ssr/ssr.html",relativePath:"ssr/ssr.md",key:"v-c4186e42",path:"/ssr/ssr.html",headers:[{level:2,title:"渲染模式",slug:"渲染模式",normalizedTitle:"渲染模式",charIndex:104},{level:3,title:"传统服务端渲染",slug:"传统服务端渲染",normalizedTitle:"传统服务端渲染",charIndex:113},{level:3,title:"SPA单页应用",slug:"spa单页应用",normalizedTitle:"spa单页应用",charIndex:515},{level:3,title:"同构应用",slug:"同构应用",normalizedTitle:"同构应用",charIndex:696},{level:2,title:"为什么要 SSR",slug:"为什么要-ssr",normalizedTitle:"为什么要 ssr",charIndex:1224},{level:3,title:"1. SEO",slug:"_1-seo",normalizedTitle:"1. seo",charIndex:1237},{level:3,title:"2. 性能",slug:"_2-性能",normalizedTitle:"2. 性能",charIndex:1398},{level:2,title:"SSR 的代价",slug:"ssr-的代价",normalizedTitle:"ssr 的代价",charIndex:1821},{level:2,title:"不适合 SSR 的场景",slug:"不适合-ssr-的场景",normalizedTitle:"不适合 ssr 的场景",charIndex:2046},{level:2,title:"vue-ssr",slug:"vue-ssr",normalizedTitle:"vue-ssr",charIndex:2139},{level:2,title:"san-ssr",slug:"san-ssr",normalizedTitle:"san-ssr",charIndex:2629},{level:2,title:"关于 hydration (客户端激活)的解释",slug:"关于-hydration-客户端激活-的解释",normalizedTitle:"关于 hydration (客户端激活)的解释",charIndex:2937}],lastUpdated:"2/23/2022, 7:39:28 PM",lastUpdatedTimestamp:1645616368e3,headersStr:"渲染模式 传统服务端渲染 SPA单页应用 同构应用 为什么要 SSR 1. SEO 2. 性能 SSR 的代价 不适合 SSR 的场景 vue-ssr san-ssr 关于 hydration (客户端激活)的解释",content:"# 服务端渲染\n\nSSR（Server Side Render）是指在服务端把数据填充到模板形成完整的页面，减少了客户端的工作优化了首屏（FMP：first meaningful paint）性能。\n\n\n# 渲染模式\n\n\n# 传统服务端渲染\n\n * 最早期，Web 页面渲染都是在服务端完成的，即服务端运行过程中将所需的数据结合页面模板渲染为\n   \n   HTML，响应给客户端浏览器。所以浏览器呈现出来的是直接包含内容的页面。\n\n * 这种方式的代表性技术有：ASP、PHP、JSP，再到后来的一些相对高级一点的服务端框架配合一些模板\n   \n   引擎\n\n * 在今天看来，这种渲染模式是不合理或者说不先进的。因为在当下这种网页越来越复杂的情况下，这种\n   \n   模式存在很多明显的不足：\n   \n   * 应用的前后端部分完全耦合在一起，在前后端协同开发方面会有非常大的阻力；\n   \n   * 前端没有足够的发挥空间，无法充分利用现在前端生态下的一些更优秀的方案；\n   \n   * 由于内容都是在服务端动态生成的，所以服务端的压力较大；\n   \n   * 相比目前流行的 SPA 应用来说，用户体验一般；\n\n\n# SPA单页应用\n\n * 随着ajax的发展（AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下）以及前端框架的发展，Vue，React，Angular 都是基于客户端渲染的前端框架，这类框架所构建的都是单页应用（SPA）\n * 优点：用户体验好、开发效率高、渲染性能好、可维护性好\n * 缺点：首屏渲染时间长、不利于 SEO\n\n\n# 同构应用\n\n * 同构服务端渲染首屏直出，解决 SPA 应用首屏渲染慢以及不利于 SEO 问题\n * 然后通过客户端渲染接管页面内容交互得到更好的用户体验\n * 实际是【服务端渲染】 + 【客户端渲染】的结合\n * 优点：首屏渲染速度快、有利于 SEO\n * 缺点：\n   * 开发成本高。\n   * 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，一般需要处于 Node.js server 运行环境。\n   * 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略\n\n后面我们介绍的服务端渲染一般是指同构应用，前端组件化框架的服务端渲染，比如 React SSR、Vue SSR、San SSR。\n\n\n\n * 上面为 CSR：加载 HTML、加载 JS、渲染/FMP\n * 下面为 SSR：加载HTML、渲染/FMP、加载 JS\n\n\n# 为什么要 SSR\n\n\n# 1. SEO\n\n多数搜索引擎都可以读取 SPA 内容，但异步内容仍然不容易索引。\n\n * 抓取异步内容 10-20s Timeout[1]\n * 爬虫不一定认识前端路由[2]，尤其是 Hash\n * JavaScript 错误等 Edge Case\n * 用户体验会影响排名，尤其是页面性能：TTI、FMP、……\n\n\n# 2. 性能\n\n首先看 CSR 的性能\n\n\n\n再看 SSR 的性能\n\n\n\n * 曲线图中黄色和箭头指向为脚本执行，紫色为渲染，如果有多个紫色则是发生了重绘。\n * 名词解释\n   * FP (First Paint)首次绘制\n   * FCP (First Contentful Paint) 首次内容绘制\n   * LCP (Largest Contentful Paint) 最大内容渲染\n   * DCL (DomContentloaded)\n   * FMP(First Meaningful Paint) 首次有效绘制\n   * L (onLoad)\n   * TTI (Time to Interactive) 可交互时间\n * SSR 的 DCL 时间会变长，因为服务端做的事情变多了，返回的不是空的 Html。\n * SSR 的 DCL 和 FMP 是同时到达的，即获取到 html 后就可以展示到页面上，用户可以看的见。\n\n\n# SSR 的代价\n\n * TTFB 更晚，服务器端时间更长\n   * DCL、FP 指标应当调整为 FMP、TTI。\n   * 考虑离线预渲染替代服务端渲染\n * TTI 不一定更早\n   * 用户首次看到的只是静态页面，但此时还不能交互。\n   * 下一步需要执行脚本，这个过程 vue 中称为 Hydration（客户端激活），不一定比重新渲染更快。\n * 维护成本更高\n   * 组件需要同时考虑 Node.js 和浏览器两种宿主环境。\n\n\n# 不适合 SSR 的场景\n\n 1. 后台系统：CMS、MIS、Dashboard\n 2. 功能型页面：个人中心、我的收藏\n 3. 静态内容：用户无关的页面、静态的页面、考虑预渲染\n\n\n# vue-ssr\n\n官方文档：https://vuejs.org/guide/scaling-up/ssr.html#rendering-an-app\n\n * Vue SSR 指南\n\n * Vue SSR 官网\n\n// this runs in Node.js on the server.\nimport { createSSRApp } from 'vue'\n// Vue's server-rendering API is exposed under `vue/server-renderer`.\nimport { renderToString } from 'vue/server-renderer'\n\nconst app = createSSRApp({\n  data: () => ({ count: 1 }),\n  template: `<button @click=\"count++\">{{ count }}</button>`\n})\n\nrenderToString(app).then((html) => {\n  console.log(html)\n})\n\n\n\n# san-ssr\n\n官网：https://github.com/baidu/san-ssr\n\nconst { defineComponent } = require('san');\nconst { compileToRenderer } = require('san-ssr');\n\nconst MyApp = defineComponent({\n  template: '<div>Hello {{ name }} !</div>'\n});\n\nconst render = compileToRenderer(MyApp);\nconst html = render({ name: 'San' });  \n\n\n\n# 关于 hydration (客户端激活)的解释\n\n思考：如何通过 ssr 的方式将以下组件展示到页面上：\n\n\x3c!-- App.san --\x3e\n<template>\n    <div id=\"app\" on-click=\"onClick\">\n      <p>Hello {{name}}!</p>\n      <p class=\"count\">Click count: {{ count }}</p>\n    </div>\n</template>\n<script>\nimport {Component} from 'san'\nclass x extends Component {}\n    export default {\n        initData() {\n            return {\n                name: 'San',\n                count: 0\n            };\n        },\n        onClick() {\n            const count = this.data.get('count')\n            this.data.set('count', count + 1)\n        }\n    };\n<\/script>\n<style lang=\"less\">\n    @highlight: #f00;\n\n    div {\n        .count {\n            color: @highlight;\n        }\n    }\n</style>\n\n\n首先在服务端，san-ssr 对该组件处理后得到如下，即为服务端通过 html 直接返回给浏览器展示的\n\n<div id=\"app\">\x3c!--s-data:{\"count\":1,\"name\":\"San\"}--\x3e\n  <p>Hello San!</p>\n  <p class=\"count\">Click count: 1</p>\n</div>\n\n\n但是其中的点击事件不会生效，所以下面需要客户端激活，以下代码在打包之后会引入到浏览器中执行。注意这里是直接 new App ，而不是 attach 进行添加。\n\n// client.js\nimport App from './App.san'\n\nconst app = new App({\n    el: document.querySelector('#app')\n});\n\n\n如果客户端 new App 能够和服务端返回的 html 匹配得上，则会激活成功，客户端代码生效，点击事件即可执行。这个过程中还涉及到 webpack 的配置，express 服务的启动，详见demo",normalizedContent:"# 服务端渲染\n\nssr（server side render）是指在服务端把数据填充到模板形成完整的页面，减少了客户端的工作优化了首屏（fmp：first meaningful paint）性能。\n\n\n# 渲染模式\n\n\n# 传统服务端渲染\n\n * 最早期，web 页面渲染都是在服务端完成的，即服务端运行过程中将所需的数据结合页面模板渲染为\n   \n   html，响应给客户端浏览器。所以浏览器呈现出来的是直接包含内容的页面。\n\n * 这种方式的代表性技术有：asp、php、jsp，再到后来的一些相对高级一点的服务端框架配合一些模板\n   \n   引擎\n\n * 在今天看来，这种渲染模式是不合理或者说不先进的。因为在当下这种网页越来越复杂的情况下，这种\n   \n   模式存在很多明显的不足：\n   \n   * 应用的前后端部分完全耦合在一起，在前后端协同开发方面会有非常大的阻力；\n   \n   * 前端没有足够的发挥空间，无法充分利用现在前端生态下的一些更优秀的方案；\n   \n   * 由于内容都是在服务端动态生成的，所以服务端的压力较大；\n   \n   * 相比目前流行的 spa 应用来说，用户体验一般；\n\n\n# spa单页应用\n\n * 随着ajax的发展（ajax 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下）以及前端框架的发展，vue，react，angular 都是基于客户端渲染的前端框架，这类框架所构建的都是单页应用（spa）\n * 优点：用户体验好、开发效率高、渲染性能好、可维护性好\n * 缺点：首屏渲染时间长、不利于 seo\n\n\n# 同构应用\n\n * 同构服务端渲染首屏直出，解决 spa 应用首屏渲染慢以及不利于 seo 问题\n * 然后通过客户端渲染接管页面内容交互得到更好的用户体验\n * 实际是【服务端渲染】 + 【客户端渲染】的结合\n * 优点：首屏渲染速度快、有利于 seo\n * 缺点：\n   * 开发成本高。\n   * 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (spa) 不同，服务器渲染应用程序，一般需要处于 node.js server 运行环境。\n   * 更多的服务器端负载。在 node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的server 更加大量占用 cpu 资源 (cpu-intensive - cpu 密集)，因此如果你预料在高流量环境(high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略\n\n后面我们介绍的服务端渲染一般是指同构应用，前端组件化框架的服务端渲染，比如 react ssr、vue ssr、san ssr。\n\n\n\n * 上面为 csr：加载 html、加载 js、渲染/fmp\n * 下面为 ssr：加载html、渲染/fmp、加载 js\n\n\n# 为什么要 ssr\n\n\n# 1. seo\n\n多数搜索引擎都可以读取 spa 内容，但异步内容仍然不容易索引。\n\n * 抓取异步内容 10-20s timeout[1]\n * 爬虫不一定认识前端路由[2]，尤其是 hash\n * javascript 错误等 edge case\n * 用户体验会影响排名，尤其是页面性能：tti、fmp、……\n\n\n# 2. 性能\n\n首先看 csr 的性能\n\n\n\n再看 ssr 的性能\n\n\n\n * 曲线图中黄色和箭头指向为脚本执行，紫色为渲染，如果有多个紫色则是发生了重绘。\n * 名词解释\n   * fp (first paint)首次绘制\n   * fcp (first contentful paint) 首次内容绘制\n   * lcp (largest contentful paint) 最大内容渲染\n   * dcl (domcontentloaded)\n   * fmp(first meaningful paint) 首次有效绘制\n   * l (onload)\n   * tti (time to interactive) 可交互时间\n * ssr 的 dcl 时间会变长，因为服务端做的事情变多了，返回的不是空的 html。\n * ssr 的 dcl 和 fmp 是同时到达的，即获取到 html 后就可以展示到页面上，用户可以看的见。\n\n\n# ssr 的代价\n\n * ttfb 更晚，服务器端时间更长\n   * dcl、fp 指标应当调整为 fmp、tti。\n   * 考虑离线预渲染替代服务端渲染\n * tti 不一定更早\n   * 用户首次看到的只是静态页面，但此时还不能交互。\n   * 下一步需要执行脚本，这个过程 vue 中称为 hydration（客户端激活），不一定比重新渲染更快。\n * 维护成本更高\n   * 组件需要同时考虑 node.js 和浏览器两种宿主环境。\n\n\n# 不适合 ssr 的场景\n\n 1. 后台系统：cms、mis、dashboard\n 2. 功能型页面：个人中心、我的收藏\n 3. 静态内容：用户无关的页面、静态的页面、考虑预渲染\n\n\n# vue-ssr\n\n官方文档：https://vuejs.org/guide/scaling-up/ssr.html#rendering-an-app\n\n * vue ssr 指南\n\n * vue ssr 官网\n\n// this runs in node.js on the server.\nimport { createssrapp } from 'vue'\n// vue's server-rendering api is exposed under `vue/server-renderer`.\nimport { rendertostring } from 'vue/server-renderer'\n\nconst app = createssrapp({\n  data: () => ({ count: 1 }),\n  template: `<button @click=\"count++\">{{ count }}</button>`\n})\n\nrendertostring(app).then((html) => {\n  console.log(html)\n})\n\n\n\n# san-ssr\n\n官网：https://github.com/baidu/san-ssr\n\nconst { definecomponent } = require('san');\nconst { compiletorenderer } = require('san-ssr');\n\nconst myapp = definecomponent({\n  template: '<div>hello {{ name }} !</div>'\n});\n\nconst render = compiletorenderer(myapp);\nconst html = render({ name: 'san' });  \n\n\n\n# 关于 hydration (客户端激活)的解释\n\n思考：如何通过 ssr 的方式将以下组件展示到页面上：\n\n\x3c!-- app.san --\x3e\n<template>\n    <div id=\"app\" on-click=\"onclick\">\n      <p>hello {{name}}!</p>\n      <p class=\"count\">click count: {{ count }}</p>\n    </div>\n</template>\n<script>\nimport {component} from 'san'\nclass x extends component {}\n    export default {\n        initdata() {\n            return {\n                name: 'san',\n                count: 0\n            };\n        },\n        onclick() {\n            const count = this.data.get('count')\n            this.data.set('count', count + 1)\n        }\n    };\n<\/script>\n<style lang=\"less\">\n    @highlight: #f00;\n\n    div {\n        .count {\n            color: @highlight;\n        }\n    }\n</style>\n\n\n首先在服务端，san-ssr 对该组件处理后得到如下，即为服务端通过 html 直接返回给浏览器展示的\n\n<div id=\"app\">\x3c!--s-data:{\"count\":1,\"name\":\"san\"}--\x3e\n  <p>hello san!</p>\n  <p class=\"count\">click count: 1</p>\n</div>\n\n\n但是其中的点击事件不会生效，所以下面需要客户端激活，以下代码在打包之后会引入到浏览器中执行。注意这里是直接 new app ，而不是 attach 进行添加。\n\n// client.js\nimport app from './app.san'\n\nconst app = new app({\n    el: document.queryselector('#app')\n});\n\n\n如果客户端 new app 能够和服务端返回的 html 匹配得上，则会激活成功，客户端代码生效，点击事件即可执行。这个过程中还涉及到 webpack 的配置，express 服务的启动，详见demo",charsets:{cjk:!0}},{title:"前端安全简介",frontmatter:{title:"前端安全简介",date:"2021-01-01T09:21:01.000Z",categories:"前端安全"},regularPath:"/safe/safe.html",relativePath:"safe/safe.md",key:"v-28afe8df",path:"/safe/safe.html",headers:[{level:2,title:"XSS",slug:"xss",normalizedTitle:"xss",charIndex:13},{level:3,title:"XSS危害",slug:"xss危害",normalizedTitle:"xss危害",charIndex:443},{level:3,title:"XSS 攻击注入点",slug:"xss-攻击注入点",normalizedTitle:"xss 攻击注入点",charIndex:2109},{level:3,title:"XSS 防御",slug:"xss-防御",normalizedTitle:"xss 防御",charIndex:2335},{level:2,title:"CSRF",slug:"csrf",normalizedTitle:"csrf",charIndex:20},{level:2,title:"点击劫持",slug:"点击劫持",normalizedTitle:"点击劫持",charIndex:28},{level:2,title:"HTTP传输安全",slug:"http传输安全",normalizedTitle:"http传输安全",charIndex:36},{level:2,title:"中间人攻击",slug:"中间人攻击",normalizedTitle:"中间人攻击",charIndex:48},{level:2,title:"第三方依赖安全",slug:"第三方依赖安全",normalizedTitle:"第三方依赖安全",charIndex:57},{level:2,title:"控制台注入代码",slug:"控制台注入代码",normalizedTitle:"控制台注入代码",charIndex:68},{level:2,title:"钓鱼",slug:"钓鱼",normalizedTitle:"钓鱼",charIndex:79},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:85}],lastUpdated:"2/21/2023, 11:13:47 AM",lastUpdatedTimestamp:1676949227e3,headersStr:"XSS XSS危害 XSS 攻击注入点 XSS 防御 CSRF 点击劫持 HTTP传输安全 中间人攻击 第三方依赖安全 控制台注入代码 钓鱼 扩展",content:'# 前端安全简介\n\n * XSS\n * CSRF\n * 点击劫持\n * HTTP传输安全\n * 中间人攻击\n * 第三方依赖安全\n * 控制台注入代码\n * 钓鱼\n * 扩展\n\n\n# XSS\n\n> XSS指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。简单举一个例子（dom型）\n\n<div v-html="content"></div>\n\n<script>\n  new Vue({\n    el: \'#app\',\n    data: {\n      // src 不存在从而触发 onerror\n      content: `<img src="xxx" onerror="alert(document.cookie)">`\n      content: `<script>alert(document.cookie)<\/script>`\n\t\t}\n})\n<\/script>\n\n\n\n# XSS危害\n\n * 窃取 cookie\n * 按键记录和钓鱼\n * 未授权操作\n * 获取页面数据\n * 劫持前端逻辑\n * 偷取用户资料\n * ...\n\n> XSS的攻击一般分为以下几类：反射型XSS，存储型XSS，DOM XSS。\n> \n> 反射型和存储型在纯前端渲染中已经很少见了，尤其在第三方框架下\n\n# 反射型XSS\n\n> 用户在一个不防范 XSS 的网站中搜索内容，关键字为 XXX，如果网站内包含 XXX的内容，那么该内容就会被展示出来，如果网站中不包含相关，那么可能会提示 XXX 相关内容不存在。也就是，用户的搜索内容最终都会以某种方式反射到搜索结果中。如果搜索内容为：<script>alert(1)<\/script>，那么页面就会执行这段 JavaScript 代码，也即该网站存在 XSS 漏洞。\n\n// node 服务端 app.js\nconst express = require(\'express\')\n\nconst app = express()\n\napp.get(\'/\', (req, res) => {\n    // 1. 读取渲染页面的内容\n    // 2, 将渲染结果发送给客户端\n    res.render(\'index.html\', {\n        search: req.query.search // 通过地址栏传递\n    })\n})\n\napp.listen(3000, () => console.log(\'http://loalhost:3000/\'))\n\n\n\x3c!-- index.html --\x3e\n\n<form action="/" method="GET">\n    \x3c!-- 输入框内输入 <script>alert(document.cookie)<\/script> --\x3e\n\t<input name="search" type="text">\n    <button>搜索</button>\n</form>\n\n{{ if search }}\n</div> 展示搜索内容 </div>\t\n{{ /if }}\n\n\n# 存储型XSS\n\n * 攻击者将恶意代码提交到目标网站的数据库中\n * 用户打开目标网站时，服务端将恶意代码从数据库中取出，拼接在html中返回给浏览器\n * 用户浏览器接收响应解析时，取出恶意代码执行\n * 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n> 比如一个富文本编辑器，产生的结果：html格式的字符串，web后台存储到数据库中\n> \n> 当其他用户查看文章详情时，就会渲染文章内容，将恶意代码执行\n\n# DOM型XSS\n\n> DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n> \n> 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n> \n> 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\n> \n> DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\n> \n> DOM 型和前两种的区别：DOM 型 XSS中，取出和执行恶意代码由浏览器端完成，其他两种都属于服务端安全漏洞\n\n\n# XSS 攻击注入点\n\n * HTML中内嵌文本，恶意代码以 script 标签注入\n * 标签的 href, src 等属性中，包含 javascript 等可执行代码\n * 在 onload, onerror, onclick 等事件中\n * style 属性和标签中，包含 background-image: url("javascript")\n * style 属性和标签中，包含 expression(...) 的 CSS 表达式代码\n\n\n# XSS 防御\n\nXSS 攻击有两大要素：\n\n * 攻击者提交恶意代码\n * 浏览器执行恶意代码\n\n常见解决办法：\n\n * 服务端可以通过设置 HttpOnly 来防止XSS代码获取到用户的cookie\n\n * 纯前端渲染，将代码和数据分隔开\n   \n   * 浏览器先加载一个静态HTML，此HTML不包含任何跟业务相关数据\n   * 然后浏览器执行 HTML 中的 Javascript\n   * Javascript 通过 Ajax加载业务数据，调用 DOM API 更新到页面上\n   * 避免在前端代码中出现html拼接的情况\n   * 我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。\n\n * 对 HTML 做充分转义\n   \n   * & < > " \' /\'\n   * 转义库 js-xss\n\n * CSP：内容安全策略(HTTP响应头、meta标签)\n   \n   * 一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本\n   * https://www.ruanyifeng.com/blog/2016/09/csp.html\n\n * X-Xss-Protection(HTTP响应头)\n   \n   * HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。\n\n\n# CSRF\n\n * XSS 利用的是网站对用户（输入）的信任，而CSRF 利用的是网站对用户网页浏览器的信任。\n\n * CSRF图示\n\n * CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性\n\n * CSRF的两个特点：\n   \n   * CSRF（通常）发生在第三方域名。\n   \n   * CSRF攻击者不能获取到Cookie等信息，只是使用。\n\n如何防御\n\n * 同源检测\n   \n   * Referer：但攻击者可以隐藏 Referer\n   * Origin：但在 ie11 或者 302 时 origin 不存在\n   \n   <img src="http://bank.example/withdraw?amount=10000&for=hacker" referrerpolicy="no-referrer"> \n   \n   \n   > 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。\n   > \n   > 如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值 。\n   > \n   > 然而，这种方法并非万无一失。Referer 的值是由浏览器提供的 ，目前已经有一些方法可以篡改 Referer 值 。\n   > \n   > 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。\n\n * Samesite Cookie\n   \n   * strict：完全禁止第三方 Cookie\n   \n   * lax：大多数情况也是不发送第三方 Cookie\n   \n   * None：Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。\n   \n   * goole浏览器的设置（chrome 91版本后已移除，默认值为 lax）\n     \n     # SameSite by default cookies\n     \n     > Treat cookies that don\'t specify a SameSite attribute as if they were SameSite=Lax. Sites must specify SameSite=None in order to enable third-party usage. – Mac, Windows, Linux, Chrome OS, Android\n     > \n     > 将未指定SameSite属性的cookie视为SameSite=Lax(默认),网站必须指定SameSite=None才能启用第三方cookie。 把这个设置关了就允许所有的第三方cookie\n     \n     # Cookies without SameSite must be secure\n     \n     > If enabled, cookies without SameSite restrictions must also be Secure. If a cookie without SameSite restrictions is set without the Secure attribute, it will be rejected. This flag only has an effect if "SameSite by default cookies" is also enabled. – Mac, Windows, Linux, Chrome OS, Android\n     > \n     > 如果启用，没有SameSite限制的cookie也必须是安全的。如果没有设置SameSite限制的cookie没有Secure属性，它将被拒绝。此标志仅在启用\'sameSite by default cookies\'时有效。\n     \n     如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。\n   \n   * iframe samesite问题\n\n * CSRF Token\n   \n   > CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n   > \n   > 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的\n\n * 验证码\n   \n   > CSRF攻击是伪造成用户的身份，自动发起恶意的请求。那么我们可以强迫攻击者与我们的网站进行交互。在一些操作之前加入验证码校验，可以抵御一部分的CSRF攻击。但是加入验证码会影响用户的体验，所以验证码不能作为主要的防御手段。\n\n\n# 点击劫持\n\n * 点击劫持图示\n\n> 点击劫持是一种视觉欺骗的攻击手段。\n> \n> 黑客创建一个网页利用 iframe 包含目标网站；\n> \n> 构造网页，诱变用户点击特点按钮。\n\n * 防御手段\n   \n   * JavaScript 禁止内嵌\n     \n     * window.top 属性返回当前窗口的最顶层浏览器窗口对象，在 iframe 中的 window 指的是 iframe 窗口对象\n     \n     * if (top.location !== window.location) {\n         top.location = window.location\n       }\n       \n   \n   * X-FRAME-OPTIONS 响应头禁止内嵌\n     \n     * DENY：表示页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。\n     * SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示。\n     * ALLOW-FROM url：表示该页面可以在指定来源的 frame 中展示。\n\n\n# HTTP传输安全\n\n * http 明文传输不安全\n * 网络协议相关\n\n\n# 中间人攻击\n\n1)客户端发送请求到服务端，请求被中间人截获。\n\n2)服务器向客户端发送公钥。\n\n3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端。\n\n4)客户端收到伪造的公钥后，生成密文发给服务器。\n\n5)中间人获得密文，用自己的私钥解密。同时用真正的公钥发给服务器。\n\n6)服务器获得加密信息，用自己的私钥解密。\n\n\n\n# 第三方依赖安全\n\n现如今进行应用开发，无论是后端服务器应用还是前端应用开发，绝大多数时候我们都是在借助开发框架和各种类库进行快速开发。然而，一些第三方的依赖或者插件存在很多安全性问题，也会存在这样那样的漏洞，所以使用起来得谨慎。\n\n * 尽量减少第三方依赖，选用相对成熟的依赖包\n * 定期使用 npm audit 检测依赖包的风险\n\n为了提高 npm 依赖的安全，npm 6.1 后添加了 npm audit 工具，这个工具可以搜索当前项目中使用的依赖是否存在安全问题，并提供了 npm audit fix 工具修复。\n\n它的工作原理是维护了一个已知不良依赖的名单，如果代码中使用了直接从 GitHub 而不是 npm 仓库中获取依赖，或不知名的依赖。npm audit 也是无法发现威胁。总的来说在加入第三方依赖时，需要谨慎考虑，不滥用依赖在前端开发也是非常重要的。\n\n\n# 控制台注入代码\n\n详见天猫官网控制台\n\n\n# 钓鱼\n\n点击不可信链接输入用户名密码\n\n\n# 扩展\n\n * Vue 的安全措施',normalizedContent:'# 前端安全简介\n\n * xss\n * csrf\n * 点击劫持\n * http传输安全\n * 中间人攻击\n * 第三方依赖安全\n * 控制台注入代码\n * 钓鱼\n * 扩展\n\n\n# xss\n\n> xss指的是恶意攻击者往web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。简单举一个例子（dom型）\n\n<div v-html="content"></div>\n\n<script>\n  new vue({\n    el: \'#app\',\n    data: {\n      // src 不存在从而触发 onerror\n      content: `<img src="xxx" onerror="alert(document.cookie)">`\n      content: `<script>alert(document.cookie)<\/script>`\n\t\t}\n})\n<\/script>\n\n\n\n# xss危害\n\n * 窃取 cookie\n * 按键记录和钓鱼\n * 未授权操作\n * 获取页面数据\n * 劫持前端逻辑\n * 偷取用户资料\n * ...\n\n> xss的攻击一般分为以下几类：反射型xss，存储型xss，dom xss。\n> \n> 反射型和存储型在纯前端渲染中已经很少见了，尤其在第三方框架下\n\n# 反射型xss\n\n> 用户在一个不防范 xss 的网站中搜索内容，关键字为 xxx，如果网站内包含 xxx的内容，那么该内容就会被展示出来，如果网站中不包含相关，那么可能会提示 xxx 相关内容不存在。也就是，用户的搜索内容最终都会以某种方式反射到搜索结果中。如果搜索内容为：<script>alert(1)<\/script>，那么页面就会执行这段 javascript 代码，也即该网站存在 xss 漏洞。\n\n// node 服务端 app.js\nconst express = require(\'express\')\n\nconst app = express()\n\napp.get(\'/\', (req, res) => {\n    // 1. 读取渲染页面的内容\n    // 2, 将渲染结果发送给客户端\n    res.render(\'index.html\', {\n        search: req.query.search // 通过地址栏传递\n    })\n})\n\napp.listen(3000, () => console.log(\'http://loalhost:3000/\'))\n\n\n\x3c!-- index.html --\x3e\n\n<form action="/" method="get">\n    \x3c!-- 输入框内输入 <script>alert(document.cookie)<\/script> --\x3e\n\t<input name="search" type="text">\n    <button>搜索</button>\n</form>\n\n{{ if search }}\n</div> 展示搜索内容 </div>\t\n{{ /if }}\n\n\n# 存储型xss\n\n * 攻击者将恶意代码提交到目标网站的数据库中\n * 用户打开目标网站时，服务端将恶意代码从数据库中取出，拼接在html中返回给浏览器\n * 用户浏览器接收响应解析时，取出恶意代码执行\n * 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n> 比如一个富文本编辑器，产生的结果：html格式的字符串，web后台存储到数据库中\n> \n> 当其他用户查看文章详情时，就会渲染文章内容，将恶意代码执行\n\n# dom型xss\n\n> dom 型 xss 攻击，实际上就是网站前端 javascript 代码本身不够严谨，把不可信的数据当作代码执行了。\n> \n> 在使用 .innerhtml、.outerhtml、document.write() 时要特别小心，不要把不可信的数据作为 html 插到页面上，而应尽量使用 .textcontent、.setattribute() 等。\n> \n> 如果用 vue/react 技术栈，并且不使用 v-html/dangerouslysetinnerhtml 功能，就在前端 render 阶段避免 innerhtml、outerhtml 的 xss 隐患。\n> \n> dom 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，javascript 的 eval()、settimeout()、setinterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 api，很容易产生安全隐患，请务必避免。\n> \n> dom 型和前两种的区别：dom 型 xss中，取出和执行恶意代码由浏览器端完成，其他两种都属于服务端安全漏洞\n\n\n# xss 攻击注入点\n\n * html中内嵌文本，恶意代码以 script 标签注入\n * 标签的 href, src 等属性中，包含 javascript 等可执行代码\n * 在 onload, onerror, onclick 等事件中\n * style 属性和标签中，包含 background-image: url("javascript")\n * style 属性和标签中，包含 expression(...) 的 css 表达式代码\n\n\n# xss 防御\n\nxss 攻击有两大要素：\n\n * 攻击者提交恶意代码\n * 浏览器执行恶意代码\n\n常见解决办法：\n\n * 服务端可以通过设置 httponly 来防止xss代码获取到用户的cookie\n\n * 纯前端渲染，将代码和数据分隔开\n   \n   * 浏览器先加载一个静态html，此html不包含任何跟业务相关数据\n   * 然后浏览器执行 html 中的 javascript\n   * javascript 通过 ajax加载业务数据，调用 dom api 更新到页面上\n   * 避免在前端代码中出现html拼接的情况\n   * 我们会明确的告诉浏览器：下面要设置的内容是文本（.innertext），还是属性（.setattribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。\n\n * 对 html 做充分转义\n   \n   * & < > " \' /\'\n   * 转义库 js-xss\n\n * csp：内容安全策略(http响应头、meta标签)\n   \n   * 一个csp兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本\n   * https://www.ruanyifeng.com/blog/2016/09/csp.html\n\n * x-xss-protection(http响应头)\n   \n   * http x-xss-protection 响应头是 internet explorer，chrome 和 safari 的一个特性，当检测到跨站脚本攻击 (xss)时，浏览器将停止加载页面。\n\n\n# csrf\n\n * xss 利用的是网站对用户（输入）的信任，而csrf 利用的是网站对用户网页浏览器的信任。\n\n * csrf图示\n\n * csrf通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对csrf的防护能力来提升安全性\n\n * csrf的两个特点：\n   \n   * csrf（通常）发生在第三方域名。\n   \n   * csrf攻击者不能获取到cookie等信息，只是使用。\n\n如何防御\n\n * 同源检测\n   \n   * referer：但攻击者可以隐藏 referer\n   * origin：但在 ie11 或者 302 时 origin 不存在\n   \n   <img src="http://bank.example/withdraw?amount=10000&for=hacker" referrerpolicy="no-referrer"> \n   \n   \n   > 根据 http 协议，在 http 头中有一个字段叫 referer，它记录了该 http 请求的来源地址。\n   > \n   > 如果黑客要对银行网站实施 csrf 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 referer 是指向黑客自己的网站。因此，要防御 csrf 攻击，银行网站只需要对于每一个转账请求验证其 referer 值 。\n   > \n   > 然而，这种方法并非万无一失。referer 的值是由浏览器提供的 ，目前已经有一些方法可以篡改 referer 值 。\n   > \n   > 即便是使用最新的浏览器，黑客无法篡改 referer 值，这种方法仍然有问题。因为 referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，因此，用户自己可以设置浏览器使其在发送请求时不再提供 referer。当他们正常访问银行网站时，网站会因为请求没有 referer 值而认为是 csrf 攻击，拒绝合法用户的访问。\n\n * samesite cookie\n   \n   * strict：完全禁止第三方 cookie\n   \n   * lax：大多数情况也是不发送第三方 cookie\n   \n   * none：chrome 计划将lax变为默认设置。这时，网站可以选择显式关闭samesite属性，将其设为none。不过，前提是必须同时设置secure属性（cookie 只能通过 https 协议发送），否则无效。\n   \n   * goole浏览器的设置（chrome 91版本后已移除，默认值为 lax）\n     \n     # samesite by default cookies\n     \n     > treat cookies that don\'t specify a samesite attribute as if they were samesite=lax. sites must specify samesite=none in order to enable third-party usage. – mac, windows, linux, chrome os, android\n     > \n     > 将未指定samesite属性的cookie视为samesite=lax(默认),网站必须指定samesite=none才能启用第三方cookie。 把这个设置关了就允许所有的第三方cookie\n     \n     # cookies without samesite must be secure\n     \n     > if enabled, cookies without samesite restrictions must also be secure. if a cookie without samesite restrictions is set without the secure attribute, it will be rejected. this flag only has an effect if "samesite by default cookies" is also enabled. – mac, windows, linux, chrome os, android\n     > \n     > 如果启用，没有samesite限制的cookie也必须是安全的。如果没有设置samesite限制的cookie没有secure属性，它将被拒绝。此标志仅在启用\'samesite by default cookies\'时有效。\n     \n     如果你想加 samesite=none 属性，那么该 cookie 就必须同时加上 secure 属性，表示只有在 https 协议下该 cookie 才会被发送。\n   \n   * iframe samesite问题\n\n * csrf token\n   \n   > csrf 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 csrf，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 http 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 csrf 攻击而拒绝该请求。\n   > \n   > 这种方法要比检查 referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的\n\n * 验证码\n   \n   > csrf攻击是伪造成用户的身份，自动发起恶意的请求。那么我们可以强迫攻击者与我们的网站进行交互。在一些操作之前加入验证码校验，可以抵御一部分的csrf攻击。但是加入验证码会影响用户的体验，所以验证码不能作为主要的防御手段。\n\n\n# 点击劫持\n\n * 点击劫持图示\n\n> 点击劫持是一种视觉欺骗的攻击手段。\n> \n> 黑客创建一个网页利用 iframe 包含目标网站；\n> \n> 构造网页，诱变用户点击特点按钮。\n\n * 防御手段\n   \n   * javascript 禁止内嵌\n     \n     * window.top 属性返回当前窗口的最顶层浏览器窗口对象，在 iframe 中的 window 指的是 iframe 窗口对象\n     \n     * if (top.location !== window.location) {\n         top.location = window.location\n       }\n       \n   \n   * x-frame-options 响应头禁止内嵌\n     \n     * deny：表示页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。\n     * sameorigin：表示该页面可以在相同域名页面的 frame 中展示。\n     * allow-from url：表示该页面可以在指定来源的 frame 中展示。\n\n\n# http传输安全\n\n * http 明文传输不安全\n * 网络协议相关\n\n\n# 中间人攻击\n\n1)客户端发送请求到服务端，请求被中间人截获。\n\n2)服务器向客户端发送公钥。\n\n3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端。\n\n4)客户端收到伪造的公钥后，生成密文发给服务器。\n\n5)中间人获得密文，用自己的私钥解密。同时用真正的公钥发给服务器。\n\n6)服务器获得加密信息，用自己的私钥解密。\n\n\n\n# 第三方依赖安全\n\n现如今进行应用开发，无论是后端服务器应用还是前端应用开发，绝大多数时候我们都是在借助开发框架和各种类库进行快速开发。然而，一些第三方的依赖或者插件存在很多安全性问题，也会存在这样那样的漏洞，所以使用起来得谨慎。\n\n * 尽量减少第三方依赖，选用相对成熟的依赖包\n * 定期使用 npm audit 检测依赖包的风险\n\n为了提高 npm 依赖的安全，npm 6.1 后添加了 npm audit 工具，这个工具可以搜索当前项目中使用的依赖是否存在安全问题，并提供了 npm audit fix 工具修复。\n\n它的工作原理是维护了一个已知不良依赖的名单，如果代码中使用了直接从 github 而不是 npm 仓库中获取依赖，或不知名的依赖。npm audit 也是无法发现威胁。总的来说在加入第三方依赖时，需要谨慎考虑，不滥用依赖在前端开发也是非常重要的。\n\n\n# 控制台注入代码\n\n详见天猫官网控制台\n\n\n# 钓鱼\n\n点击不可信链接输入用户名密码\n\n\n# 扩展\n\n * vue 的安全措施',charsets:{cjk:!0}},{title:"eslint-plugin-san",frontmatter:{title:"eslint-plugin-san",date:"2021-09-11T11:27:54.000Z",categories:"San"},regularPath:"/san/eslint-plugin-san.html",relativePath:"san/eslint-plugin-san.md",key:"v-4e5f06df",path:"/san/eslint-plugin-san.html",headers:[{level:2,title:"eslint 使用及配置",slug:"eslint-使用及配置",normalizedTitle:"eslint 使用及配置",charIndex:87},{level:3,title:"plugins、extends有什么区别？",slug:"plugins、extends有什么区别",normalizedTitle:"plugins、extends有什么区别？",charIndex:1440},{level:2,title:"eslint-plugin-san 使用及配置",slug:"eslint-plugin-san-使用及配置",normalizedTitle:"eslint-plugin-san 使用及配置",charIndex:103},{level:3,title:"如何配置",slug:"如何配置",normalizedTitle:"如何配置",charIndex:2025},{level:3,title:"如何检测",slug:"如何检测",normalizedTitle:"如何检测",charIndex:2447},{level:3,title:"利用 husky 和 lint-staged 构建工作流",slug:"利用-husky-和-lint-staged-构建工作流",normalizedTitle:"利用 husky 和 lint-staged 构建工作流",charIndex:2522},{level:3,title:"新版 husky 配置",slug:"新版-husky-配置",normalizedTitle:"新版 husky 配置",charIndex:2766},{level:2,title:"源码解析",slug:"源码解析",normalizedTitle:"源码解析",charIndex:130},{level:3,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:3820},{level:3,title:"如何创建规自己的规则",slug:"如何创建规自己的规则",normalizedTitle:"如何创建规自己的规则",charIndex:6311},{level:2,title:"san-eslint-parser",slug:"san-eslint-parser",normalizedTitle:"san-eslint-parser",charIndex:5195},{level:2,title:"如何调试",slug:"如何调试",normalizedTitle:"如何调试",charIndex:172},{level:2,title:"常见的 AST 节点类型",slug:"常见的-ast-节点类型",normalizedTitle:"常见的 ast 节点类型",charIndex:180}],lastUpdated:"7/7/2022, 6:20:47 PM",lastUpdatedTimestamp:1657189247e3,headersStr:"eslint 使用及配置 plugins、extends有什么区别？ eslint-plugin-san 使用及配置 如何配置 如何检测 利用 husky 和 lint-staged 构建工作流 新版 husky 配置 源码解析 目录结构 如何创建规自己的规则 san-eslint-parser 如何调试 常见的 AST 节点类型",content:'# eslint-plugin-san\n\neslint-plugin-san 是专门为 san 制定的基于 eslint 的规则校验插件。我会从以下几个方面来介绍：\n\n * eslint 使用及配置\n * eslint-plugin-san 使用及配置\n * 源码解析\n * 如何创建自己的规则\n * San-eslint-parser\n * 如何调试\n * 常见的 AST 节点类型\n\n\n# eslint 使用及配置\n\n安装：yarn add eslint\n\n配置：eslint --init，此时会有一些命令行交互问题，按需回答即可，一般选用 Standard 规范，安装一些依赖之后，使用eslint foo.js检查目标文件即可。\n\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true,\n    es6: true\n  },\n  extends: [\n    \'standard\'\n  ],\n  parser: "babel-eslint",\n  parserOptions: {\n    ecmaVersion: 6,\n    sourceType: "module",\n    ecmaFeature:{\n\t\t\t"jsx":true,\n\t\t\t"globalReturn":true,\n\t\t\t"impliedStrict":true,\n\t\t}\n  },\n  plugins: [\n    \'eslint-plugin-react\',\n    \'@typescript-eslint\'\n  ],\n  // \n  rules: {\n    \'no-alert\': "error"\n  },\n  globals: {\n    "jQuery": "readonly"\n  }\n}\n\n\n * env：标记运行环境，可选 browser/node/commonjs 等，可以同时使用\n   * browser: true：启用 browser 特性：代码中可以使用 document, window 全局对象\n   * es6: true：启用 ES6 特性\n * extends：扩展，集成配置方案\n * parser：指定语法分析器，例如babel-parser，也可以选用其他的如：eslint-san-parser\n * parserOptions：默认的 parser，只转换js且默认支持ES5的语法，可以通过 parserOptions 传递选项。\n   * ecmaVersion: 6：ecmaVersion 可以开启更高 ES 版本的校验\n   * sourceType: "module"：可以设置为 "script"，如果使用 ESModule 可以设置为 "module"\n   * ecmaFeature：想使用额外的语言特性\n     * "jsx":true： 启用jsx\n * plugins：插件，例如想增加校验 react, ts 的规则，可配置如下\n   * eslint-plugin-react\n   * @typescript-eslint\n * rules：可以自定义配置校验规则\n   * \'no-alert\': "error" ： 有 off/warn/error 选项\n * globals：声明可以使用的全局成员\n\n> 官网eslint 配置\n\n\n# plugins、extends有什么区别？\n\n     EXTENDS                                                   PLUGIN\n命名   eslint-config-或 @scope/eslint-config 或                    eslint-plugin-<plugin-name>\n     @scope/eslint-config-myconfig                             或@scope/eslint-plugin-<plugin-name>\n用途   扩展，集成一个个配置方案的最佳实践，即别人配置好的.exlintrc.js，里面不只有 rules，比如可能有   插件，一般是一堆自定义的规则的集合，加载插件即是引入了额外的自定义规则。也可能会包含其他配置项。\n     env，global 配置\n\n 1. plugin 插件主要涉及自定义规则的具体实现，同时还能够提供配置\n 2. extend 配置主要涉及规则的具体配置\n\n\n# eslint-plugin-san 使用及配置\n\neslint-plugin-san 本质上是 eslint 的一个插件，类似于 eslint-plugin-vue，自定义了 san 的检验规则。\n\n\n# 如何配置\n\nyarn add -D eslint eslint-plugin-san\n\n\n用extends方式可以配置想要的规则集，例如plugin:san/recommended，recommended内部已经在rules配置好了相应的规则。如果配置到plugins中，还需在rules中自己添加规则。\n\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    // add more generic rulesets here, such as:\n    // \'eslint:recommended\',\n    \'plugin:san/recommended\'\n  ],\n  rules: {\n    // override/add rules settings here, such as:\n    // \'san/no-unused-vars\': \'error\'\n  }\n}\n\n\n\n# 如何检测\n\neslint --ext .js,.san ./src\n\n\n--ext命令可以明确校验文件扩展：.js和.san文件都可以校验。\n\n\n# 利用 husky 和 lint-staged 构建工作流\n\n * husky：git hooks 工具，可以配置在 commit 之前执行检查。\n * lint-staged：只对暂存区的文件进行操作。\n\n"lint-staged": {\n  "**/*.{js,jsx,san}": "eslint --ext .js,.san ./src"\n},\n"husky": {\n  "hooks": {\n    "pre-commit": "lint-staged"\n  }\n},\n\n\n\n# 新版 husky 配置\n\n新版的 husky 取消了在 package.json 中配置的方式，可以使用 husky install 来创建 .husky 目录，我们不妨写个脚本：\n\n# install-husky.sh\n#!/bin/sh\n\nnpx husky install\n\n# 删除已有的 git hooks\nrm .husky/commit-msg\nrm .husky/pre-commit\n\n# 添加 pre-commit hook\nnpx husky add .husky/pre-commit "npx --no-install lint-staged"\n\n# commit-msg hook 添加 commitlint 调用\nnpx husky add .husky/commit-msg \'npx --no-install commitlint --edit "$1"\'\n\n\n在项目中执行这个脚本生成.husky目录，里面分别包含 pre-commit 和 commit-msg。在每次 commit 时：\n\n * 运行 lint-staged ，可以配置来同时校验 eslint 和 stylelint\n\n"scripts": {\n  "lint-staged": "lint-staged"\n},\n"lint-staged": {\n  "**/*.{js,jsx,san}": "eslint",\n  "**/*.{css,less}": "stylelint"\n},\n\n\n * 运行 commitlint，需要在项目中创建 commitlint.config.js 进行配置\n\n这样就完成了使用 husky 来集成 eslint & stylelint & commitlint。\n\n\n# 源码解析\n\n> 源码地址：https://github.com/ecomfe/eslint-plugin-san\n\n首先解释一下plugin:san/recommended的含义，eslint-plugin-san的规范分为四种：\n\n * 基础（base）\n * 必要（essential）\n * 强烈推荐（strongly-recommended）\n * 推荐（recommended）\n\n由前到后，后面的规则范围会涵盖前面的，例如recommended包含strongly-recommended的规则，而strongly-recommended又包含essential的规则。\n\n\n# 目录结构\n\n├── README.md\n├── lib\n│   ├── configs \n│   │   ├── base.js\n│   │   ├── essential.js\n│   │   ├── no-layout-rules.js\n│   │   ├── recommended.js\n│   │   └── strongly-recommended.js\n│   ├── index.js\n│   ├── processor.js\n│   ├── rules\n│   │   ├── attribute-hyphenation.js\n│   │   ├── attributes-order.js\n│   │   ├── boolean-value.js\n│   │   ├── ...\n│   │   └── valid-template-root.js \n│   └── utils\n│       └── index.js\n└── package.json\n\n\nindex.js中包含着插件默认导出的对象：\n\nmodule.exports = {\n    rules: extend(rules), // 校验规则\n    configs: { // 配置不同的规范，通过 eslint-plugin-san/recommended 来使用\n        base: require(\'./configs/base\'),\n        essential: require(\'./configs/essential\'),\n        recommended: require(\'./configs/recommended\'),\n        strongly-recommended: require(\'./configs/strongly-recommended\')\n    },\n    processors: {\n        \'.san\': require(\'./processor\'),\n        \'.ts\': require(\'./processor\'),\n        \'.js\': require(\'./processor\')\n    }\n};\n\n\n# rules\n\n在 ESLint 中，插件可以暴露额外的规则以供使用。为此，插件必须输出一个 rules对象，包含规则 ID 和对应规则的一个键值对。例如：\n\nrules: {\n  "no-dupe-keys": {\n    create: function (context) {\n      // rule implementation ...\n    }\n  }\n}\n\n\n# config\n\nconfig目录下主要有以下几项：\n\n * base.js\n * essential.js\n * strongly-recommended.js\n * recommended.js\n\n// base.js：包含基础配置项\nmodule.exports = {\n    // 在这里已经配置了 parser，所以项目中的 ..eslintrc.js 不用去配置，作用是解析代码生成 AST\n    parser: require.resolve(\'san-eslint-parser\'),\n    parserOptions: {\n        ecmaVersion: 2020,\n        sourceType: \'module\'\n    },\n    env: {\n        browser: true,\n        es6: true\n    },\n    plugins: [\'san\'], // 插件 eslint-plugin-san，san是简写\n    rules: {\n        \'san/comment-directive\': \'error\'\n    }\n};\n\n// essential.js: 就是在 base.js 的基础上添加一些规则\nmodule.exports = {\n    extends: require.resolve(\'./base\'),\n    rules: {\n        \'san/valid-components-name\': \'error\',\n        \'san/custom-event-name-casing\': \'error\',\n        // ...\n    }\n};\n\n// strongly-recommended.js: 就是在 essential.js 基础上添加一些规则\nmodule.exports = {\n    extends: require.resolve(\'./essential\'),\n    rules: {\n        \'san/boolean-value\': \'warn\',\n        \'san/attribute-hyphenation\': \'warn\',\n        // ...\n    }\n};\n\n\n# processor\n\n处理器，在 parser 之前和最后输出结果之前可以利用 processor 作一些额外处理。\n\n创建一个处理器，从你的模块中输出的对象必须符合以下接口：\n\nprocessors: {\n  ".san": {\n    preprocess: function(text, filename) {\n      return [string]; \n    },\n\t\t\n    postprocess: function(messages, filename) {\n\t\t\t// ...\n\t\t\treturn messages[0];\n\t\t},\n\n    supportsAutofix: true \n  }\n}\n\n\n下图可以看到整体流程以及 preprocess和postcess 的触发时机。\n\n\n\n\n# 如何创建规自己的规则\n\n规则的基本格式：\n\n"use strict";\n\nmodule.exports = {\n    meta: {\n        type: "suggestion",\n        docs: {\n            description: "disallow unnecessary semicolons",\n            category: "Possible Errors",\n            recommended: true,\n            url: "https://eslint.org/docs/rules/no-extra-semi"\n        },\n        fixable: "code",\n        schema: []\n    },\n    create: function(context) {\n        return {\n            // 语法节点：import \n            ImportDeclaration(node) {\n              context.report({\n                node: node,\n                messageId: "readonlyMember",\n                data: {name: \'xxx\'}\n              });\n            },\n            \n            // 选择器：参数 > 3个的函数节点\n          \t"FunctionDeclaration[params.length>3]": function(functionDeclarationNode) {\n              // ...your logic here\n            }\n          \n            // 事件\n          \t"onCodePathStart": function(codePath, node) {\n                // do something with codePath\n            },\n        };\n    }\n};\n\n\n * meta：包含规则的元数据：\n   * type (string) 指示规则的类型，值为 "problem"、"suggestion" 或 "layout"\n   * docs (object) 对 ESLint 核心规则来说是必需的\n     * description (字符串) 提供规则的简短描述\n     * category (string) 指定规则处于的分类\n     * recommended (boolean) 配置文件中的 "extends": "eslint:recommended"属性是否启用该规则\n     * url (string) 指定可以访问完整文档的 url。\n   * scheme：用来描述一个规则的选项，ESLint 会用它来验证配置中的选项是否有效。在传入到规则中之前，避免 context.options 出现无效或非法输入。\n * create (function) 返回一个对象，其中包含了 ESLint 在遍历 JavaScript 代码的抽象语法树 AST (ESTree 定义的 AST) 时，用来访问节点的方法。\n   * 如果一个 key 是个节点类型或 selector，在 向下 遍历树时，ESLint 调用 visitor 函数\n   * 如果一个 key 是个节点类型或 selector，并带有 :exit，在遍历退出该节点时（DFS），ESLint 调用 visitor 函数\n   * 如果一个 key 是个事件名字，ESLint 为代码路径分析调用 handler 函数\n\nTIP\n\n建议仔细看下这两篇文档，解释了什么是选择器和路径分析 selector 代码路径分析\n\nAST演示 AST explorer\n\n\n# san-eslint-parser\n\nsan-eslint-parser 会将我们.san 的文件内容利用分成三个 block，其中利用 parserOptions.parser 指定的解析器来处理 script 部分的内容，script中如果是 JavaScript 代码则 parserOPtions.parser 为 @babel/eslint-parser，如果是 Typescript 代码则为 @typescript-eslint/parser。style 部分不会处理，template 部分当作 HTML 来解析。\n\n\n\n上图所示为自定义 parser 生成的 AST，根节点的 type 为 Program，根节点的 body 属性存储了 script 代码的 ast，根节点上的 templateBody 为 template 部分的 ast。由于 ESlint 只会遍历根节点以及 body 上的节点，因此如果我们想为 templateBody 注册 visitor，那么可以通过 services 来实现。\n\n----------------------------------------\n\nservices：自定义 parser 为 rule 提供的服务，每条规则可以通过 context.parserServices 访问到\n\nsan-eslint-parser 会在 services 属性上定义 defineTemplateBodyVisitor 方法：\n\nlet emitter = null; // 发布订阅器\nfunction defineTemplateBodyVisitor(templateBodyVisitor) {\n    let scriptVisitor = {};\n    if (!emitter) {\n        emitter = new EventEmitter();\n        scriptVisitor["Program"] = node => {\n            traverseNodes(rootAST.templateBody)\n        };\n    }\n    for (const selector of Object.keys(templateBodyVisitor)) {\n        emitter.on(selector, templateBodyVisitor[selector]);\n    }\n    return scriptVisitor;\n}\n\n\n该方法主要完成了两部分的工作：\n\n 1. 收集每条 rule 中针对 templateBody 的 visitor：该方法接收的参数为 templateBodyVisitor，该对象存储了所有针对 templateBody 的 visitor，这些 visitor 会注册到自定义 parser 内部的发布订阅器上。\n 2. 返回一个针对 script 对应的 AST 的 visitor：该 visitor 的 type 为 Program，根据上文中 ESlint 工作原理一节，我们可以知道，ESlint 在遍历 AST 的过程中，当遇到类型为 Program 的根节点时，会执行该 visitor，并且该 visitor 会调用自定义 parser 内部方法对 templateBody 存储的 AST 进行遍历。\n\n因此，我们可以利用上述方法在每条 rule 中编写相关的 visitor 来处理 templateBody 中不同 type 类型语法节点，如下代码所示：\n\nmodule.exports = {\n    meta: {...},\n    create(context) {\n        return context.parserServices.defineTemplateBodyVisitor(context, {\n            \'VElement\'(node) {\n                // do something\n            },\n            \'VText\'(node) {\n                // do something\n            }\n        });\n    }\n};\n\n\n\n# 如何调试\n\n 1. 下载eslint-plugin-san源码\n\ngit clone https://github.com/ecomfe/eslint-plugin-san.git\n\n\n 2. 本地新建个项目，配置.eslintrc.js 和package.json脚本，然后进行正常安装依赖eslint 和 eslint-plugin-san。\n\n// eslintrc.js\nmodule.exports = {\n  extends: [\n    \'plugin:san/recommended\'\n  ],\n  rules: {}\n}\n\n// package.json\n{\n    "scripts": {\n      "test": "echo \\"Error: no test specified\\" && exit 1",\n        "dev": "eslint ./test.san"\n    },\n    "dependencies": {\n      "eslint": "^7.32.0",\n      "eslint-plugin-san": "^1.0.2"\n    }\n}\n\n\n 3. npm link\n\n> 调试源码可以从 node_modules 中去直接修改 eslint-plugin-san，但是这样做不是在源代码上改的，没有改动提示，如果想提交新的改动会很麻烦。\n> \n> 所以本地开发 npm 模块时一般要 npm link 命令，他的主要作用是，将本地下载好的包链接到项目中的node_modules中去，这样直接在源码包中修改即可。\n\n# 进入 eslint-plugin-san 中\nnpm link\n# 进入项目中\nnpm link eslint-plugin-san\n\n\n 4. Nodejs 远程调试\n\n# 运行 node --inspect-brk 命令\nnode --inspect-brk index.js\n# 打开 chrome 输入 chrome://inspect 打开调试面板\n\n\n修改package.json中的脚本\n\n> 其实上面的 eslint ./test.san 中的 eslint就是 ./node_modules/.bin/eslint的简写，这里由于前面加了node --inspect-brk，所以这里不能简写了，要把路径写全。\n\n{\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1",\n    "dev": "node --inspect-brk ./node_modules/.bin/eslint ./test.san"\n  }\n}\n\n\n 5. vscode配置\n\n * 下载 eslint 插件\n * 配置 settings.json\n\n\n# 常见的 AST 节点类型\n\n类型原名称                      中文名称        描述\nProgram                    程序主体        整段代码的主体\nVariableDeclaration        变量声明        声明一个变量，例如 var let const\nFunctionDeclaration        函数声明        声明一个函数，例如 function\nExpressionStatement        表达式语句       通常是调用一个函数，例如 console.log()\nImportDeclaration          Import 声明   import\nExportDefaultDeclaration   Export 声明   export default\nBlockStatement             块语句         包裹在 {} 块内的代码，例如 if (condition){var a = 1;}\nIdentifier                 标识符         标识，例如声明变量时 var identi = 5 中的 identi\nCallExpression             调用表达式       通常指调用一个函数，例如 console.log()\nBinaryExpression           二进制表达式      通常指运算，例如 1+2\nMemberExpression           成员表达式       通常指调用对象的成员，例如 console 对象的 log 成员\nNewExpression              New 表达式     通常指使用 New 关键词\nAssignmentExpression       赋值表达式       通常指将函数的返回值赋值给变量\nUpdateExpression           更新表达式       通常指更新成员值，例如 i++\nObjectExpression           对象表达式       {a: 1}\nLiteral                    字面量         字面量\nBooleanLiteral             布尔型字面量      布尔值，例如 true false\nNumericLiteral             数字型字面量      数字，例如 100\nStringLiteral              字符型字面量      字符串，例如 vansenb\nSwitchCase                 Case 语句     通常指 Switch 语句中的 Case\n\n参考：百度工程师手把手教你实现代码规范检测工具',normalizedContent:'# eslint-plugin-san\n\neslint-plugin-san 是专门为 san 制定的基于 eslint 的规则校验插件。我会从以下几个方面来介绍：\n\n * eslint 使用及配置\n * eslint-plugin-san 使用及配置\n * 源码解析\n * 如何创建自己的规则\n * san-eslint-parser\n * 如何调试\n * 常见的 ast 节点类型\n\n\n# eslint 使用及配置\n\n安装：yarn add eslint\n\n配置：eslint --init，此时会有一些命令行交互问题，按需回答即可，一般选用 standard 规范，安装一些依赖之后，使用eslint foo.js检查目标文件即可。\n\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true,\n    es6: true\n  },\n  extends: [\n    \'standard\'\n  ],\n  parser: "babel-eslint",\n  parseroptions: {\n    ecmaversion: 6,\n    sourcetype: "module",\n    ecmafeature:{\n\t\t\t"jsx":true,\n\t\t\t"globalreturn":true,\n\t\t\t"impliedstrict":true,\n\t\t}\n  },\n  plugins: [\n    \'eslint-plugin-react\',\n    \'@typescript-eslint\'\n  ],\n  // \n  rules: {\n    \'no-alert\': "error"\n  },\n  globals: {\n    "jquery": "readonly"\n  }\n}\n\n\n * env：标记运行环境，可选 browser/node/commonjs 等，可以同时使用\n   * browser: true：启用 browser 特性：代码中可以使用 document, window 全局对象\n   * es6: true：启用 es6 特性\n * extends：扩展，集成配置方案\n * parser：指定语法分析器，例如babel-parser，也可以选用其他的如：eslint-san-parser\n * parseroptions：默认的 parser，只转换js且默认支持es5的语法，可以通过 parseroptions 传递选项。\n   * ecmaversion: 6：ecmaversion 可以开启更高 es 版本的校验\n   * sourcetype: "module"：可以设置为 "script"，如果使用 esmodule 可以设置为 "module"\n   * ecmafeature：想使用额外的语言特性\n     * "jsx":true： 启用jsx\n * plugins：插件，例如想增加校验 react, ts 的规则，可配置如下\n   * eslint-plugin-react\n   * @typescript-eslint\n * rules：可以自定义配置校验规则\n   * \'no-alert\': "error" ： 有 off/warn/error 选项\n * globals：声明可以使用的全局成员\n\n> 官网eslint 配置\n\n\n# plugins、extends有什么区别？\n\n     extends                                                   plugin\n命名   eslint-config-或 @scope/eslint-config 或                    eslint-plugin-<plugin-name>\n     @scope/eslint-config-myconfig                             或@scope/eslint-plugin-<plugin-name>\n用途   扩展，集成一个个配置方案的最佳实践，即别人配置好的.exlintrc.js，里面不只有 rules，比如可能有   插件，一般是一堆自定义的规则的集合，加载插件即是引入了额外的自定义规则。也可能会包含其他配置项。\n     env，global 配置\n\n 1. plugin 插件主要涉及自定义规则的具体实现，同时还能够提供配置\n 2. extend 配置主要涉及规则的具体配置\n\n\n# eslint-plugin-san 使用及配置\n\neslint-plugin-san 本质上是 eslint 的一个插件，类似于 eslint-plugin-vue，自定义了 san 的检验规则。\n\n\n# 如何配置\n\nyarn add -d eslint eslint-plugin-san\n\n\n用extends方式可以配置想要的规则集，例如plugin:san/recommended，recommended内部已经在rules配置好了相应的规则。如果配置到plugins中，还需在rules中自己添加规则。\n\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    // add more generic rulesets here, such as:\n    // \'eslint:recommended\',\n    \'plugin:san/recommended\'\n  ],\n  rules: {\n    // override/add rules settings here, such as:\n    // \'san/no-unused-vars\': \'error\'\n  }\n}\n\n\n\n# 如何检测\n\neslint --ext .js,.san ./src\n\n\n--ext命令可以明确校验文件扩展：.js和.san文件都可以校验。\n\n\n# 利用 husky 和 lint-staged 构建工作流\n\n * husky：git hooks 工具，可以配置在 commit 之前执行检查。\n * lint-staged：只对暂存区的文件进行操作。\n\n"lint-staged": {\n  "**/*.{js,jsx,san}": "eslint --ext .js,.san ./src"\n},\n"husky": {\n  "hooks": {\n    "pre-commit": "lint-staged"\n  }\n},\n\n\n\n# 新版 husky 配置\n\n新版的 husky 取消了在 package.json 中配置的方式，可以使用 husky install 来创建 .husky 目录，我们不妨写个脚本：\n\n# install-husky.sh\n#!/bin/sh\n\nnpx husky install\n\n# 删除已有的 git hooks\nrm .husky/commit-msg\nrm .husky/pre-commit\n\n# 添加 pre-commit hook\nnpx husky add .husky/pre-commit "npx --no-install lint-staged"\n\n# commit-msg hook 添加 commitlint 调用\nnpx husky add .husky/commit-msg \'npx --no-install commitlint --edit "$1"\'\n\n\n在项目中执行这个脚本生成.husky目录，里面分别包含 pre-commit 和 commit-msg。在每次 commit 时：\n\n * 运行 lint-staged ，可以配置来同时校验 eslint 和 stylelint\n\n"scripts": {\n  "lint-staged": "lint-staged"\n},\n"lint-staged": {\n  "**/*.{js,jsx,san}": "eslint",\n  "**/*.{css,less}": "stylelint"\n},\n\n\n * 运行 commitlint，需要在项目中创建 commitlint.config.js 进行配置\n\n这样就完成了使用 husky 来集成 eslint & stylelint & commitlint。\n\n\n# 源码解析\n\n> 源码地址：https://github.com/ecomfe/eslint-plugin-san\n\n首先解释一下plugin:san/recommended的含义，eslint-plugin-san的规范分为四种：\n\n * 基础（base）\n * 必要（essential）\n * 强烈推荐（strongly-recommended）\n * 推荐（recommended）\n\n由前到后，后面的规则范围会涵盖前面的，例如recommended包含strongly-recommended的规则，而strongly-recommended又包含essential的规则。\n\n\n# 目录结构\n\n├── readme.md\n├── lib\n│   ├── configs \n│   │   ├── base.js\n│   │   ├── essential.js\n│   │   ├── no-layout-rules.js\n│   │   ├── recommended.js\n│   │   └── strongly-recommended.js\n│   ├── index.js\n│   ├── processor.js\n│   ├── rules\n│   │   ├── attribute-hyphenation.js\n│   │   ├── attributes-order.js\n│   │   ├── boolean-value.js\n│   │   ├── ...\n│   │   └── valid-template-root.js \n│   └── utils\n│       └── index.js\n└── package.json\n\n\nindex.js中包含着插件默认导出的对象：\n\nmodule.exports = {\n    rules: extend(rules), // 校验规则\n    configs: { // 配置不同的规范，通过 eslint-plugin-san/recommended 来使用\n        base: require(\'./configs/base\'),\n        essential: require(\'./configs/essential\'),\n        recommended: require(\'./configs/recommended\'),\n        strongly-recommended: require(\'./configs/strongly-recommended\')\n    },\n    processors: {\n        \'.san\': require(\'./processor\'),\n        \'.ts\': require(\'./processor\'),\n        \'.js\': require(\'./processor\')\n    }\n};\n\n\n# rules\n\n在 eslint 中，插件可以暴露额外的规则以供使用。为此，插件必须输出一个 rules对象，包含规则 id 和对应规则的一个键值对。例如：\n\nrules: {\n  "no-dupe-keys": {\n    create: function (context) {\n      // rule implementation ...\n    }\n  }\n}\n\n\n# config\n\nconfig目录下主要有以下几项：\n\n * base.js\n * essential.js\n * strongly-recommended.js\n * recommended.js\n\n// base.js：包含基础配置项\nmodule.exports = {\n    // 在这里已经配置了 parser，所以项目中的 ..eslintrc.js 不用去配置，作用是解析代码生成 ast\n    parser: require.resolve(\'san-eslint-parser\'),\n    parseroptions: {\n        ecmaversion: 2020,\n        sourcetype: \'module\'\n    },\n    env: {\n        browser: true,\n        es6: true\n    },\n    plugins: [\'san\'], // 插件 eslint-plugin-san，san是简写\n    rules: {\n        \'san/comment-directive\': \'error\'\n    }\n};\n\n// essential.js: 就是在 base.js 的基础上添加一些规则\nmodule.exports = {\n    extends: require.resolve(\'./base\'),\n    rules: {\n        \'san/valid-components-name\': \'error\',\n        \'san/custom-event-name-casing\': \'error\',\n        // ...\n    }\n};\n\n// strongly-recommended.js: 就是在 essential.js 基础上添加一些规则\nmodule.exports = {\n    extends: require.resolve(\'./essential\'),\n    rules: {\n        \'san/boolean-value\': \'warn\',\n        \'san/attribute-hyphenation\': \'warn\',\n        // ...\n    }\n};\n\n\n# processor\n\n处理器，在 parser 之前和最后输出结果之前可以利用 processor 作一些额外处理。\n\n创建一个处理器，从你的模块中输出的对象必须符合以下接口：\n\nprocessors: {\n  ".san": {\n    preprocess: function(text, filename) {\n      return [string]; \n    },\n\t\t\n    postprocess: function(messages, filename) {\n\t\t\t// ...\n\t\t\treturn messages[0];\n\t\t},\n\n    supportsautofix: true \n  }\n}\n\n\n下图可以看到整体流程以及 preprocess和postcess 的触发时机。\n\n\n\n\n# 如何创建规自己的规则\n\n规则的基本格式：\n\n"use strict";\n\nmodule.exports = {\n    meta: {\n        type: "suggestion",\n        docs: {\n            description: "disallow unnecessary semicolons",\n            category: "possible errors",\n            recommended: true,\n            url: "https://eslint.org/docs/rules/no-extra-semi"\n        },\n        fixable: "code",\n        schema: []\n    },\n    create: function(context) {\n        return {\n            // 语法节点：import \n            importdeclaration(node) {\n              context.report({\n                node: node,\n                messageid: "readonlymember",\n                data: {name: \'xxx\'}\n              });\n            },\n            \n            // 选择器：参数 > 3个的函数节点\n          \t"functiondeclaration[params.length>3]": function(functiondeclarationnode) {\n              // ...your logic here\n            }\n          \n            // 事件\n          \t"oncodepathstart": function(codepath, node) {\n                // do something with codepath\n            },\n        };\n    }\n};\n\n\n * meta：包含规则的元数据：\n   * type (string) 指示规则的类型，值为 "problem"、"suggestion" 或 "layout"\n   * docs (object) 对 eslint 核心规则来说是必需的\n     * description (字符串) 提供规则的简短描述\n     * category (string) 指定规则处于的分类\n     * recommended (boolean) 配置文件中的 "extends": "eslint:recommended"属性是否启用该规则\n     * url (string) 指定可以访问完整文档的 url。\n   * scheme：用来描述一个规则的选项，eslint 会用它来验证配置中的选项是否有效。在传入到规则中之前，避免 context.options 出现无效或非法输入。\n * create (function) 返回一个对象，其中包含了 eslint 在遍历 javascript 代码的抽象语法树 ast (estree 定义的 ast) 时，用来访问节点的方法。\n   * 如果一个 key 是个节点类型或 selector，在 向下 遍历树时，eslint 调用 visitor 函数\n   * 如果一个 key 是个节点类型或 selector，并带有 :exit，在遍历退出该节点时（dfs），eslint 调用 visitor 函数\n   * 如果一个 key 是个事件名字，eslint 为代码路径分析调用 handler 函数\n\ntip\n\n建议仔细看下这两篇文档，解释了什么是选择器和路径分析 selector 代码路径分析\n\nast演示 ast explorer\n\n\n# san-eslint-parser\n\nsan-eslint-parser 会将我们.san 的文件内容利用分成三个 block，其中利用 parseroptions.parser 指定的解析器来处理 script 部分的内容，script中如果是 javascript 代码则 parseroptions.parser 为 @babel/eslint-parser，如果是 typescript 代码则为 @typescript-eslint/parser。style 部分不会处理，template 部分当作 html 来解析。\n\n\n\n上图所示为自定义 parser 生成的 ast，根节点的 type 为 program，根节点的 body 属性存储了 script 代码的 ast，根节点上的 templatebody 为 template 部分的 ast。由于 eslint 只会遍历根节点以及 body 上的节点，因此如果我们想为 templatebody 注册 visitor，那么可以通过 services 来实现。\n\n----------------------------------------\n\nservices：自定义 parser 为 rule 提供的服务，每条规则可以通过 context.parserservices 访问到\n\nsan-eslint-parser 会在 services 属性上定义 definetemplatebodyvisitor 方法：\n\nlet emitter = null; // 发布订阅器\nfunction definetemplatebodyvisitor(templatebodyvisitor) {\n    let scriptvisitor = {};\n    if (!emitter) {\n        emitter = new eventemitter();\n        scriptvisitor["program"] = node => {\n            traversenodes(rootast.templatebody)\n        };\n    }\n    for (const selector of object.keys(templatebodyvisitor)) {\n        emitter.on(selector, templatebodyvisitor[selector]);\n    }\n    return scriptvisitor;\n}\n\n\n该方法主要完成了两部分的工作：\n\n 1. 收集每条 rule 中针对 templatebody 的 visitor：该方法接收的参数为 templatebodyvisitor，该对象存储了所有针对 templatebody 的 visitor，这些 visitor 会注册到自定义 parser 内部的发布订阅器上。\n 2. 返回一个针对 script 对应的 ast 的 visitor：该 visitor 的 type 为 program，根据上文中 eslint 工作原理一节，我们可以知道，eslint 在遍历 ast 的过程中，当遇到类型为 program 的根节点时，会执行该 visitor，并且该 visitor 会调用自定义 parser 内部方法对 templatebody 存储的 ast 进行遍历。\n\n因此，我们可以利用上述方法在每条 rule 中编写相关的 visitor 来处理 templatebody 中不同 type 类型语法节点，如下代码所示：\n\nmodule.exports = {\n    meta: {...},\n    create(context) {\n        return context.parserservices.definetemplatebodyvisitor(context, {\n            \'velement\'(node) {\n                // do something\n            },\n            \'vtext\'(node) {\n                // do something\n            }\n        });\n    }\n};\n\n\n\n# 如何调试\n\n 1. 下载eslint-plugin-san源码\n\ngit clone https://github.com/ecomfe/eslint-plugin-san.git\n\n\n 2. 本地新建个项目，配置.eslintrc.js 和package.json脚本，然后进行正常安装依赖eslint 和 eslint-plugin-san。\n\n// eslintrc.js\nmodule.exports = {\n  extends: [\n    \'plugin:san/recommended\'\n  ],\n  rules: {}\n}\n\n// package.json\n{\n    "scripts": {\n      "test": "echo \\"error: no test specified\\" && exit 1",\n        "dev": "eslint ./test.san"\n    },\n    "dependencies": {\n      "eslint": "^7.32.0",\n      "eslint-plugin-san": "^1.0.2"\n    }\n}\n\n\n 3. npm link\n\n> 调试源码可以从 node_modules 中去直接修改 eslint-plugin-san，但是这样做不是在源代码上改的，没有改动提示，如果想提交新的改动会很麻烦。\n> \n> 所以本地开发 npm 模块时一般要 npm link 命令，他的主要作用是，将本地下载好的包链接到项目中的node_modules中去，这样直接在源码包中修改即可。\n\n# 进入 eslint-plugin-san 中\nnpm link\n# 进入项目中\nnpm link eslint-plugin-san\n\n\n 4. nodejs 远程调试\n\n# 运行 node --inspect-brk 命令\nnode --inspect-brk index.js\n# 打开 chrome 输入 chrome://inspect 打开调试面板\n\n\n修改package.json中的脚本\n\n> 其实上面的 eslint ./test.san 中的 eslint就是 ./node_modules/.bin/eslint的简写，这里由于前面加了node --inspect-brk，所以这里不能简写了，要把路径写全。\n\n{\n  "scripts": {\n    "test": "echo \\"error: no test specified\\" && exit 1",\n    "dev": "node --inspect-brk ./node_modules/.bin/eslint ./test.san"\n  }\n}\n\n\n 5. vscode配置\n\n * 下载 eslint 插件\n * 配置 settings.json\n\n\n# 常见的 ast 节点类型\n\n类型原名称                      中文名称        描述\nprogram                    程序主体        整段代码的主体\nvariabledeclaration        变量声明        声明一个变量，例如 var let const\nfunctiondeclaration        函数声明        声明一个函数，例如 function\nexpressionstatement        表达式语句       通常是调用一个函数，例如 console.log()\nimportdeclaration          import 声明   import\nexportdefaultdeclaration   export 声明   export default\nblockstatement             块语句         包裹在 {} 块内的代码，例如 if (condition){var a = 1;}\nidentifier                 标识符         标识，例如声明变量时 var identi = 5 中的 identi\ncallexpression             调用表达式       通常指调用一个函数，例如 console.log()\nbinaryexpression           二进制表达式      通常指运算，例如 1+2\nmemberexpression           成员表达式       通常指调用对象的成员，例如 console 对象的 log 成员\nnewexpression              new 表达式     通常指使用 new 关键词\nassignmentexpression       赋值表达式       通常指将函数的返回值赋值给变量\nupdateexpression           更新表达式       通常指更新成员值，例如 i++\nobjectexpression           对象表达式       {a: 1}\nliteral                    字面量         字面量\nbooleanliteral             布尔型字面量      布尔值，例如 true false\nnumericliteral             数字型字面量      数字，例如 100\nstringliteral              字符型字面量      字符串，例如 vansenb\nswitchcase                 case 语句     通常指 switch 语句中的 case\n\n参考：百度工程师手把手教你实现代码规范检测工具',charsets:{cjk:!0}},{title:"san-loader 原理",frontmatter:{},regularPath:"/san/san-loader.html",relativePath:"san/san-loader.md",key:"v-f77072e6",path:"/san/san-loader.html",headers:[{level:2,title:"第一阶段",slug:"第一阶段",normalizedTitle:"第一阶段",charIndex:502},{level:2,title:"第二阶段",slug:"第二阶段",normalizedTitle:"第二阶段",charIndex:4959},{level:2,title:"第三阶段",slug:"第三阶段",normalizedTitle:"第三阶段",charIndex:6809},{level:2,title:"第四阶段",slug:"第四阶段",normalizedTitle:"第四阶段",charIndex:8276}],lastUpdated:"2/16/2022, 6:55:14 PM",lastUpdatedTimestamp:1645008914e3,headersStr:"第一阶段 第二阶段 第三阶段 第四阶段",content:"# san-loader 原理\n\nSan-Loader 是基于 webpack 的工具，允许开发者书写 San 单文件的方式来进行组件开发。如最基本的一个 San 单文件 app.san：\n\n<template>\n  <div>Hello {{name}}!</div>\n</template>\n\n<script>\nexport default {\n  initData() {\n    return {\n      name: 'San',\n    };\n  },\n};\n<\/script>\n\n<style>\ndiv {\n  font-size: 40px;\n}\n</style>\n\n\nSan-loader 的核心作用是将单文件中的 template、script、style 提取出来并交给其他 loader 进行处理。\n\n比如：\n\n * template交给html-loader处理\n * script交给babel-loader处理\n * style交给css-loader和style-loader处理\n\n那么 San-loader 是如何完成这一过程的呢？下面分为四个阶段来介绍：\n\n\n# 第一阶段\n\n**SanLoaderPlugin 在 webpack 正式构建之前修改原有的配置 rules。 **\n\n首先复习一下 compiler 钩子 和 webpack Plugin 的工作原理，：\n\n 1. 读取配置的过程中会先执行 new SanLoaderPlugin(options) 初始化一个 SanLoaderPlugin 获得其实例。\n\n 2. 初始化 compiler 对象后调用 SanLoaderPlugin.apply(compiler) 给插件实例传入 compiler 对象。\n\n 3. 插件实例在获取到 compiler 对象后，就可以通过 compiler 对象去操作 Webpack。\n\nclass SanLoaderPlugin {\n  static NS?: string;\n  apply(compiler) {\n\n    // 通过 compiler 获取原始配置的规则并处理\n    const rawRules = compiler.options.module.rules;\n    const { rules } = new RuleSet(rawRules);\n\n    // 生成 clonedRules\n    const sanRule = rules[sanRuleIndex];\n    const clonedRules = rules.filter((r) => r !== sanRule).map(cloneRule);\n\n    // 通过 compiler 对象更改 rules\n    compiler.options.module.rules = [...clonedRules, ...rules];\n  }\n}\n\n\nSanLoaderPlugin 主要做了以下几件事：\n\n 1. 通过 compiler 获取原始配置的规则并进行处理\n\n 2. 通过 rules 来生成 cloneRules\n\n 3. 通过 compiler 对象修改了原有的规则，在 rules 前面加上了 cloneRules（注意这里的顺序后面会讲到）\n\n假如这是项目中已经配置好的规则：\n\n[\n  {\n    test: /\\.san$/,\n    use: ['san-loader-next']\n  },\n  {\n    test: /\\.js$/i,\n    loader: 'babel-loader'\n  },\n  {\n    test: /\\.css$/,\n    use: ['style-loader', 'css-loader']\n  },\n  {\n    test: /\\.html$/i,\n    use: ['html-loader']\n  }\n]\n\n\n那么这就是处理后的规则：\n\n[\n  {use: ['babel-loader'], resource: ƒ, resourceQuery: ƒ}\n  {use: ['style-loader', 'css-loader'], resource: ƒ,  resourceQuery: ƒ}\n  {use: ['html-loader'], resource: ƒ,  resourceQuery: ƒ}\n\n  {use: ['san-loader-next'], resource: ƒ}\n  {use: ['babel-loader'], resource: ƒ}\n  {use: ['style-loader', 'css-loader'], resource: ƒ}\n  {use: ['html-loader'], resource: ƒ}\n]\n\n\n其中后四条是原来的规则，只是在new RuleSet阶段把 test 字段规范成了 resource 字段：\n\n{\n    use: ['babel-loader'],\n    test: /\\.js$/\n}\n\n// 等价于\n{\n    use: ['babel-loader'],\n    resource: {\n      test: /\\.js$/\n    }\n}\n\n\n前三条是新增的cloneRules，那么为什么要添加这些规则呢？其实是因为我们的目的是让 san 单文件中的语言块也能被对应规则所识别然后交给对应的 loader 处理，比如 script 代码块需要被 babel-loader 来处理。所以需要把除了 .san 之外其他的规则复制一遍添加一些属性方法，让它们能够识别 san 文件中的代码块。\n\n这里需要注意另一个用来匹配资源查询（从问号开始）的字段： resourceQuery\n\nrules: [\n  {\n    test: /\\.css$/,\n    resourceQuery: /inline/,\n    use: 'url-loader',\n  },\n],\n  \n// 可以匹配\nimport Foo from './foo.css?inline'\n\n\nresource 和 resourceQuery 具体定义在 cloneRule 方法中：\n\nfunction cloneRule(rule) {\n  const { resource, resourceQuery } = rule;\n  let currentResource;\n  const res = Object.assign({}, rule, {\n    resource: {\n      test: (resource) => {\n        currentResource = resource;\n        return true;\n      },\n    },\n    resourceQuery: (query) => {\n      // 首先，经过san-loader拆分之后的style、template、script会变成：\n      // xxx.san?san=&lang=js&type=script\n      // lang=js/css/less/html...，来自element的lang attribute\n      const parsed = qs.parse(query.slice(1));\n      // 跳过不是san=的，即不是san-loader拆分的文件\n      if (parsed.san == null) {\n        return false;\n      }\n      // 跳过san-loader拆分后，没有lang的，lang=js/css/less/html...\n      if (resource && parsed.lang == null) {\n        return false;\n      }\n      // 得到一个假的uri，用于判断之前的rule是否匹配\n      // /src/App.san.js\n      // /src/App.san.html\n      // /src/App.san.css\n      const fakeResourcePath = `${currentResource}.${parsed.lang}`;\n\n      // 复制之前的loader rule，规则匹配不上的，例如babel的test/\\.js$/，如果匹配不上，则跳过\n      // js文件，则xxx.js，resource(xxx.js) => true => false，则继续\n      if (resource && !resource(fakeResourcePath)) {\n        return false;\n      }\n      // 同上，匹配的是babel写了resourceQuery的情况\n      if (resourceQuery && !resourceQuery(query)) {\n        return false;\n      }\n      if (parsed.type === 'style' && parsed.module !== undefined) {\n        const conf = findMatchedLoader(\n          'css-loader',\n          rule,\n          currentResource,\n          resourceQuery\n        );\n        // style 会经过很多规则，检查 css-loader 的那一个\n        if (conf && (!conf.options || !conf.options.modules)) {\n          throw new Error(\n            `css-loader#module not set, required by ${currentResource}${query}`\n          );\n        }\n      }\n      // 经过过滤，则这个babel的rule，必须是query: san=&lang=js 才会过\n      // 同时跟babel的rule必须resource/resourceQuery是匹配上的\n      // 这样可以避免给san-loader处理后的文件单独配置后续loader\n      // 实现共享项目的loader rule\n      return true;\n    },\n  });\n\n  if (rule.rules) {\n    res.rules = rule.rules.map(cloneRule);\n  }\n\n  if (rule.oneOf) {\n    res.oneOf = rule.oneOf.map(cloneRule);\n  }\n\n  return res;\n}\n\n\n比如原本的.js规则可以识别 .js 结尾的文件，clone 后的规则加上了 resourcequery 就会识别 *.san?san&type=script&lang=js 这样的语句\n\n// 原有\n{ test: /\\.js$/i, loader: 'babel-loader'}\n\n// clone 后\n{use: ['babel-loader'], resource: ƒ, resourceQuery: ƒ}\n\n\n到这里，webpack 正式构建之前的准备工作就做好了，我们通过插件修改了规则的配置。\n\n\n# 第二阶段\n\nsan-loader 第一次处理 San 单文件。\n\nwebpack 从入口文件出发，当遇到 app.san 文件时，会匹配到规则中的：\n\n{\n  test: /\\.san$/,\n  use: ['san-loader-next']\n}\n\n\n到这里我们第一次调用 san-loader 来处理 san 单文件，具体的处理流程为：\n\n源码地址：https://github.com/wanwu/san-loader/blob/next/src/loader.ts#L62\n\nconst shortFilePath = path\n  .relative(sourceRoot, filename)\n  .replace(/^(\\.\\.[\\/\\\\])+/, '')\n  .replace(/\\\\/g, '/');\nconst scopeId = hash(shortFilePath);\n\n// 解析 SFC\nconst descriptor = parseSFC({\n  source,\n  filename,\n  sourceRoot,\n  needMap: true,\n});\n\nsetDescriptor(filename, descriptor);\n\n// 生成入口文件\nconst templateImport = generateTemplateImport(descriptor, scopeId, options);\nconst stylesImport = generateStyleImport(descriptor, scopeId, options);\nconst scriptImport = generateScriptImport(descriptor, scopeId, options);\n\n// normalize.js 的绝对路径\nconst normalizePath = stringifyRequest(\n  this,\n  require.resolve('./normalize.js')\n);\n\nconst importStr = `import normalize from ${normalizePath};`\nconst exportStr = 'export default normalize(script, template, $style);'\n\nconst output = [\n  importStr,\n  scriptImport,\n  templateImport,\n  stylesImport,\n  exportStr,\n  '/* san-hmr component */',\n];\n\nthis.callback(null, output.join('\\n'));\n\n\n这里主要做了三件事：\n\n 1. 调用 san-sfc-compiler 库的 parseSFC 方法来解析文件内容\n\n 2. 生成 import 语句\n\n 3. 使用 this.callback 返回结果给 webpack\n\n处理后的结果如下：\n\nimport normalize from \"../../../dist/normalize.js\";\nimport script from \"/src/App.san?san&type=script&id=472cf1bd&lang=js\";\nexport * from \"/src/App.san?san&type=script&id=472cf1bd&lang=js\";\nimport template from \"src/App.san?san&type=template&id=472cf1bd&lang=html\";\n\nvar $style = [];\nimport \"/src/App.san?san&type=style&index=0&id=472cf1bd&lang=css\";$style = [];\n\nexport default normalize(script, template, $style);\n/* san-hmr component */\n\n\n到这里 san-loader 的第一次处理就结束了，下面我们来介绍为什么要生成这么多 import 语句以及路径中的?san&type=script&id=472cf1bd&lang=js 的作用是什么？\n\n\n# 第三阶段\n\nimport 语句匹配规则\n\n当第二阶段的结果返回给 webpack 时，webpack 会遍历当前模块的依赖，即每一条 import 语句，对于每一条import 语句再遍历 rules 进行规则匹配。\n\n比如当遇到 import script from \"/src/App.san?san&type=script&id=472cf1bd&lang=js\"; 这条语句时，在webpack 中的处理如下：\n\n/**\n  data: 语句信息\n    resource: \"/src/App.san\"\n    resourceQuery: \"?san&type=template&id=472cf1bd&lang=html\"\n\n  rule：遍历到的规则\n\n  result：存储 loader\n*/\n\n_run(data, rule, result) {\n  // test conditions\n  if (rule.resource && !data.resource) return false;\n  if (rule.resourceQuery && !data.resourceQuery) return false;\n  if (rule.resource && !rule.resource(data.resource)) return false;\n  if (\n    data.resourceQuery &&\n    rule.resourceQuery &&\n    !rule.resourceQuery(data.resourceQuery)\n  ) {\n    return false;\n  }\n\n  // 将 loader 添加到 result 中\n  if (rule.use) {\n    const process = use => {\n      if (typeof use === \"function\") {\n        process(use(data));\n      } else if (Array.isArray(use)) {\n        use.forEach(process);\n      } else {\n        result.push({\n          type: \"use\",\n          value: use,\n          enforce: rule.enforce\n        });\n      }\n    };\n    process(rule.use);\n  }\n\n  if (rule.rules) {\n    for (let i = 0; i < rule.rules.length; i++) {\n      this._run(data, rule.rules[i], result);\n    }\n  }\n\n  return true;\n}\n\n\n按照规则的先后顺序：\n\n * ?san&type=script&id=472cf1bd&lang=js 会被 cloneRules 识别，对应的 loader 是 babel-loader\n * /src/App.san 会被 /\\.san$/规则识别，对应的 loader 是 san-loader-next\n\nresult 逐个 push 进去后的结果为 ['babel-loader', 'san-loader-next']\n\n\n# 第四阶段\n\n提取代码块交给对应 loader 处理\n\n按照 loader 从后向前的顺序，首先会经过 san-loader 处理，然后再交给 babel-loader，这里也就是第二次进入san-loader，即根据 query.type 来提取对应的代码块：\n\nconst userOptions = getOptions(this);\nconst options: Options = { ...defaultOptions, ...userOptions };\n\nconst filename = this.resourcePath;\nconst sourceRoot = this.context || process.cwd();\nconst rawQuery = this.resourceQuery.slice(1);\nconst query = qs.parse(rawQuery);\n\nif (query && 'san' in query) {\n  const descriptor = getDescriptor(filename);\n  let result = { code: '', map: {} };\n\n  if (query.type === 'template') {\n    const hasScoped = descriptor!.styles.some((s) => s.scoped);\n    result = transformTemplate(\n      descriptor?.template!,\n      rawQuery,\n      filename,\n      options,\n      query,\n      hasScoped\n    );\n  } else if (query.type === 'style') {\n      result = transformStyle(\n        descriptor?.styles!,\n        rawQuery,\n        filename,\n        options,\n        query\n      );\n  } else {\n     result = {\n       code: descriptor?.script!.content!,\n       map: descriptor?.script?.map,\n     };\n  }\n  if (this.sourceMap) {\n     this.callback(null, result.code, result.map);\n  } else {\n     this.callback(null, result.code);\n  }\n}\n\n\n提取后的结果：\n\n// rawQuery 为 san&type=script&id=472cf1bd&lang=js\n{code: \"\\n\\n\\n\\n\\nexport default {\\n  initData() {\\n    return {\\n      name: 'San',\\n    };\\n  },\\n};\\n\", map: {…}}\n\n// rawQuery 为 san&type=template&id=472cf1bd&lang=html\n{code: '\\n  <div>Hello {{name}}!</div>\\n', map: {…}}\n\n// rawQuery 为 san&type=style&index=0&id=472cf1bd&lang=css\n{code: '\\ndiv {\\n  font-size: 40px;\\n}\\n', map: null}\n\n\n最后将提取后的代码块交给其他 loader 进行处理，到这里 san-loader 整体的工作流程就结束了。",normalizedContent:"# san-loader 原理\n\nsan-loader 是基于 webpack 的工具，允许开发者书写 san 单文件的方式来进行组件开发。如最基本的一个 san 单文件 app.san：\n\n<template>\n  <div>hello {{name}}!</div>\n</template>\n\n<script>\nexport default {\n  initdata() {\n    return {\n      name: 'san',\n    };\n  },\n};\n<\/script>\n\n<style>\ndiv {\n  font-size: 40px;\n}\n</style>\n\n\nsan-loader 的核心作用是将单文件中的 template、script、style 提取出来并交给其他 loader 进行处理。\n\n比如：\n\n * template交给html-loader处理\n * script交给babel-loader处理\n * style交给css-loader和style-loader处理\n\n那么 san-loader 是如何完成这一过程的呢？下面分为四个阶段来介绍：\n\n\n# 第一阶段\n\n**sanloaderplugin 在 webpack 正式构建之前修改原有的配置 rules。 **\n\n首先复习一下 compiler 钩子 和 webpack plugin 的工作原理，：\n\n 1. 读取配置的过程中会先执行 new sanloaderplugin(options) 初始化一个 sanloaderplugin 获得其实例。\n\n 2. 初始化 compiler 对象后调用 sanloaderplugin.apply(compiler) 给插件实例传入 compiler 对象。\n\n 3. 插件实例在获取到 compiler 对象后，就可以通过 compiler 对象去操作 webpack。\n\nclass sanloaderplugin {\n  static ns?: string;\n  apply(compiler) {\n\n    // 通过 compiler 获取原始配置的规则并处理\n    const rawrules = compiler.options.module.rules;\n    const { rules } = new ruleset(rawrules);\n\n    // 生成 clonedrules\n    const sanrule = rules[sanruleindex];\n    const clonedrules = rules.filter((r) => r !== sanrule).map(clonerule);\n\n    // 通过 compiler 对象更改 rules\n    compiler.options.module.rules = [...clonedrules, ...rules];\n  }\n}\n\n\nsanloaderplugin 主要做了以下几件事：\n\n 1. 通过 compiler 获取原始配置的规则并进行处理\n\n 2. 通过 rules 来生成 clonerules\n\n 3. 通过 compiler 对象修改了原有的规则，在 rules 前面加上了 clonerules（注意这里的顺序后面会讲到）\n\n假如这是项目中已经配置好的规则：\n\n[\n  {\n    test: /\\.san$/,\n    use: ['san-loader-next']\n  },\n  {\n    test: /\\.js$/i,\n    loader: 'babel-loader'\n  },\n  {\n    test: /\\.css$/,\n    use: ['style-loader', 'css-loader']\n  },\n  {\n    test: /\\.html$/i,\n    use: ['html-loader']\n  }\n]\n\n\n那么这就是处理后的规则：\n\n[\n  {use: ['babel-loader'], resource: ƒ, resourcequery: ƒ}\n  {use: ['style-loader', 'css-loader'], resource: ƒ,  resourcequery: ƒ}\n  {use: ['html-loader'], resource: ƒ,  resourcequery: ƒ}\n\n  {use: ['san-loader-next'], resource: ƒ}\n  {use: ['babel-loader'], resource: ƒ}\n  {use: ['style-loader', 'css-loader'], resource: ƒ}\n  {use: ['html-loader'], resource: ƒ}\n]\n\n\n其中后四条是原来的规则，只是在new ruleset阶段把 test 字段规范成了 resource 字段：\n\n{\n    use: ['babel-loader'],\n    test: /\\.js$/\n}\n\n// 等价于\n{\n    use: ['babel-loader'],\n    resource: {\n      test: /\\.js$/\n    }\n}\n\n\n前三条是新增的clonerules，那么为什么要添加这些规则呢？其实是因为我们的目的是让 san 单文件中的语言块也能被对应规则所识别然后交给对应的 loader 处理，比如 script 代码块需要被 babel-loader 来处理。所以需要把除了 .san 之外其他的规则复制一遍添加一些属性方法，让它们能够识别 san 文件中的代码块。\n\n这里需要注意另一个用来匹配资源查询（从问号开始）的字段： resourcequery\n\nrules: [\n  {\n    test: /\\.css$/,\n    resourcequery: /inline/,\n    use: 'url-loader',\n  },\n],\n  \n// 可以匹配\nimport foo from './foo.css?inline'\n\n\nresource 和 resourcequery 具体定义在 clonerule 方法中：\n\nfunction clonerule(rule) {\n  const { resource, resourcequery } = rule;\n  let currentresource;\n  const res = object.assign({}, rule, {\n    resource: {\n      test: (resource) => {\n        currentresource = resource;\n        return true;\n      },\n    },\n    resourcequery: (query) => {\n      // 首先，经过san-loader拆分之后的style、template、script会变成：\n      // xxx.san?san=&lang=js&type=script\n      // lang=js/css/less/html...，来自element的lang attribute\n      const parsed = qs.parse(query.slice(1));\n      // 跳过不是san=的，即不是san-loader拆分的文件\n      if (parsed.san == null) {\n        return false;\n      }\n      // 跳过san-loader拆分后，没有lang的，lang=js/css/less/html...\n      if (resource && parsed.lang == null) {\n        return false;\n      }\n      // 得到一个假的uri，用于判断之前的rule是否匹配\n      // /src/app.san.js\n      // /src/app.san.html\n      // /src/app.san.css\n      const fakeresourcepath = `${currentresource}.${parsed.lang}`;\n\n      // 复制之前的loader rule，规则匹配不上的，例如babel的test/\\.js$/，如果匹配不上，则跳过\n      // js文件，则xxx.js，resource(xxx.js) => true => false，则继续\n      if (resource && !resource(fakeresourcepath)) {\n        return false;\n      }\n      // 同上，匹配的是babel写了resourcequery的情况\n      if (resourcequery && !resourcequery(query)) {\n        return false;\n      }\n      if (parsed.type === 'style' && parsed.module !== undefined) {\n        const conf = findmatchedloader(\n          'css-loader',\n          rule,\n          currentresource,\n          resourcequery\n        );\n        // style 会经过很多规则，检查 css-loader 的那一个\n        if (conf && (!conf.options || !conf.options.modules)) {\n          throw new error(\n            `css-loader#module not set, required by ${currentresource}${query}`\n          );\n        }\n      }\n      // 经过过滤，则这个babel的rule，必须是query: san=&lang=js 才会过\n      // 同时跟babel的rule必须resource/resourcequery是匹配上的\n      // 这样可以避免给san-loader处理后的文件单独配置后续loader\n      // 实现共享项目的loader rule\n      return true;\n    },\n  });\n\n  if (rule.rules) {\n    res.rules = rule.rules.map(clonerule);\n  }\n\n  if (rule.oneof) {\n    res.oneof = rule.oneof.map(clonerule);\n  }\n\n  return res;\n}\n\n\n比如原本的.js规则可以识别 .js 结尾的文件，clone 后的规则加上了 resourcequery 就会识别 *.san?san&type=script&lang=js 这样的语句\n\n// 原有\n{ test: /\\.js$/i, loader: 'babel-loader'}\n\n// clone 后\n{use: ['babel-loader'], resource: ƒ, resourcequery: ƒ}\n\n\n到这里，webpack 正式构建之前的准备工作就做好了，我们通过插件修改了规则的配置。\n\n\n# 第二阶段\n\nsan-loader 第一次处理 san 单文件。\n\nwebpack 从入口文件出发，当遇到 app.san 文件时，会匹配到规则中的：\n\n{\n  test: /\\.san$/,\n  use: ['san-loader-next']\n}\n\n\n到这里我们第一次调用 san-loader 来处理 san 单文件，具体的处理流程为：\n\n源码地址：https://github.com/wanwu/san-loader/blob/next/src/loader.ts#l62\n\nconst shortfilepath = path\n  .relative(sourceroot, filename)\n  .replace(/^(\\.\\.[\\/\\\\])+/, '')\n  .replace(/\\\\/g, '/');\nconst scopeid = hash(shortfilepath);\n\n// 解析 sfc\nconst descriptor = parsesfc({\n  source,\n  filename,\n  sourceroot,\n  needmap: true,\n});\n\nsetdescriptor(filename, descriptor);\n\n// 生成入口文件\nconst templateimport = generatetemplateimport(descriptor, scopeid, options);\nconst stylesimport = generatestyleimport(descriptor, scopeid, options);\nconst scriptimport = generatescriptimport(descriptor, scopeid, options);\n\n// normalize.js 的绝对路径\nconst normalizepath = stringifyrequest(\n  this,\n  require.resolve('./normalize.js')\n);\n\nconst importstr = `import normalize from ${normalizepath};`\nconst exportstr = 'export default normalize(script, template, $style);'\n\nconst output = [\n  importstr,\n  scriptimport,\n  templateimport,\n  stylesimport,\n  exportstr,\n  '/* san-hmr component */',\n];\n\nthis.callback(null, output.join('\\n'));\n\n\n这里主要做了三件事：\n\n 1. 调用 san-sfc-compiler 库的 parsesfc 方法来解析文件内容\n\n 2. 生成 import 语句\n\n 3. 使用 this.callback 返回结果给 webpack\n\n处理后的结果如下：\n\nimport normalize from \"../../../dist/normalize.js\";\nimport script from \"/src/app.san?san&type=script&id=472cf1bd&lang=js\";\nexport * from \"/src/app.san?san&type=script&id=472cf1bd&lang=js\";\nimport template from \"src/app.san?san&type=template&id=472cf1bd&lang=html\";\n\nvar $style = [];\nimport \"/src/app.san?san&type=style&index=0&id=472cf1bd&lang=css\";$style = [];\n\nexport default normalize(script, template, $style);\n/* san-hmr component */\n\n\n到这里 san-loader 的第一次处理就结束了，下面我们来介绍为什么要生成这么多 import 语句以及路径中的?san&type=script&id=472cf1bd&lang=js 的作用是什么？\n\n\n# 第三阶段\n\nimport 语句匹配规则\n\n当第二阶段的结果返回给 webpack 时，webpack 会遍历当前模块的依赖，即每一条 import 语句，对于每一条import 语句再遍历 rules 进行规则匹配。\n\n比如当遇到 import script from \"/src/app.san?san&type=script&id=472cf1bd&lang=js\"; 这条语句时，在webpack 中的处理如下：\n\n/**\n  data: 语句信息\n    resource: \"/src/app.san\"\n    resourcequery: \"?san&type=template&id=472cf1bd&lang=html\"\n\n  rule：遍历到的规则\n\n  result：存储 loader\n*/\n\n_run(data, rule, result) {\n  // test conditions\n  if (rule.resource && !data.resource) return false;\n  if (rule.resourcequery && !data.resourcequery) return false;\n  if (rule.resource && !rule.resource(data.resource)) return false;\n  if (\n    data.resourcequery &&\n    rule.resourcequery &&\n    !rule.resourcequery(data.resourcequery)\n  ) {\n    return false;\n  }\n\n  // 将 loader 添加到 result 中\n  if (rule.use) {\n    const process = use => {\n      if (typeof use === \"function\") {\n        process(use(data));\n      } else if (array.isarray(use)) {\n        use.foreach(process);\n      } else {\n        result.push({\n          type: \"use\",\n          value: use,\n          enforce: rule.enforce\n        });\n      }\n    };\n    process(rule.use);\n  }\n\n  if (rule.rules) {\n    for (let i = 0; i < rule.rules.length; i++) {\n      this._run(data, rule.rules[i], result);\n    }\n  }\n\n  return true;\n}\n\n\n按照规则的先后顺序：\n\n * ?san&type=script&id=472cf1bd&lang=js 会被 clonerules 识别，对应的 loader 是 babel-loader\n * /src/app.san 会被 /\\.san$/规则识别，对应的 loader 是 san-loader-next\n\nresult 逐个 push 进去后的结果为 ['babel-loader', 'san-loader-next']\n\n\n# 第四阶段\n\n提取代码块交给对应 loader 处理\n\n按照 loader 从后向前的顺序，首先会经过 san-loader 处理，然后再交给 babel-loader，这里也就是第二次进入san-loader，即根据 query.type 来提取对应的代码块：\n\nconst useroptions = getoptions(this);\nconst options: options = { ...defaultoptions, ...useroptions };\n\nconst filename = this.resourcepath;\nconst sourceroot = this.context || process.cwd();\nconst rawquery = this.resourcequery.slice(1);\nconst query = qs.parse(rawquery);\n\nif (query && 'san' in query) {\n  const descriptor = getdescriptor(filename);\n  let result = { code: '', map: {} };\n\n  if (query.type === 'template') {\n    const hasscoped = descriptor!.styles.some((s) => s.scoped);\n    result = transformtemplate(\n      descriptor?.template!,\n      rawquery,\n      filename,\n      options,\n      query,\n      hasscoped\n    );\n  } else if (query.type === 'style') {\n      result = transformstyle(\n        descriptor?.styles!,\n        rawquery,\n        filename,\n        options,\n        query\n      );\n  } else {\n     result = {\n       code: descriptor?.script!.content!,\n       map: descriptor?.script?.map,\n     };\n  }\n  if (this.sourcemap) {\n     this.callback(null, result.code, result.map);\n  } else {\n     this.callback(null, result.code);\n  }\n}\n\n\n提取后的结果：\n\n// rawquery 为 san&type=script&id=472cf1bd&lang=js\n{code: \"\\n\\n\\n\\n\\nexport default {\\n  initdata() {\\n    return {\\n      name: 'san',\\n    };\\n  },\\n};\\n\", map: {…}}\n\n// rawquery 为 san&type=template&id=472cf1bd&lang=html\n{code: '\\n  <div>hello {{name}}!</div>\\n', map: {…}}\n\n// rawquery 为 san&type=style&index=0&id=472cf1bd&lang=css\n{code: '\\ndiv {\\n  font-size: 40px;\\n}\\n', map: null}\n\n\n最后将提取后的代码块交给其他 loader 进行处理，到这里 san-loader 整体的工作流程就结束了。",charsets:{cjk:!0}},{title:"san框架",frontmatter:{title:"san框架",date:"2021-07-13T11:27:54.000Z",categories:"San"},regularPath:"/san/san.html",relativePath:"san/san.md",key:"v-4dfcdb42",path:"/san/san.html",headers:[{level:2,title:"san-store",slug:"san-store",normalizedTitle:"san-store",charIndex:12},{level:3,title:"store",slug:"store",normalizedTitle:"store",charIndex:16},{level:3,title:"getState",slug:"getstate",normalizedTitle:"getstate",charIndex:976},{level:3,title:"Action",slug:"action",normalizedTitle:"action",charIndex:1055},{level:3,title:"dispath",slug:"dispath",normalizedTitle:"dispath",charIndex:478},{level:3,title:"connect",slug:"connect",normalizedTitle:"connect",charIndex:2050},{level:2,title:"san-update",slug:"san-update",normalizedTitle:"san-update",charIndex:25},{level:2,title:"React Native",slug:"react-native",normalizedTitle:"react native",charIndex:3064},{level:3,title:"几种跨平台框架的比较",slug:"几种跨平台框架的比较",normalizedTitle:"几种跨平台框架的比较",charIndex:3146},{level:3,title:"移动 App 的开发模式",slug:"移动-app-的开发模式",normalizedTitle:"移动 app 的开发模式",charIndex:3350},{level:3,title:"RN 的优势",slug:"rn-的优势",normalizedTitle:"rn 的优势",charIndex:3803},{level:3,title:"RN的不足",slug:"rn的不足",normalizedTitle:"rn的不足",charIndex:3978},{level:3,title:"运行原理",slug:"运行原理",normalizedTitle:"运行原理",charIndex:4118},{level:3,title:"san-native",slug:"san-native",normalizedTitle:"san-native",charIndex:39},{level:3,title:"为什么不用 rn 等其他方案",slug:"为什么不用-rn-等其他方案",normalizedTitle:"为什么不用 rn 等其他方案",charIndex:4722},{level:2,title:"san生命周期",slug:"san生命周期",normalizedTitle:"san生命周期",charIndex:53}],lastUpdated:"11/26/2021, 9:58:23 AM",lastUpdatedTimestamp:1637891903e3,headersStr:"san-store store getState Action dispath connect san-update React Native 几种跨平台框架的比较 移动 App 的开发模式 RN 的优势 RN的不足 运行原理 san-native 为什么不用 rn 等其他方案 san生命周期",content:"# san框架\n\n * san-store\n * san-update\n * san-native\n * san生命周期\n\n\n# san-store\n\nsan-store是san框架用于状态管理的工具，和vuex类似，但是还是有区别的，首先复习一下vue\n\n> vue中更改state的方式有且只有一个： mutation，用commit 来触发，限制是只能同步修改。\n> \n> 想要异步需要dispatch 一个 action，action中再触发commit修改state，action中可以做异步操作。\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n// 通过 dispathch 触发\nstore.dispatch('increment')\n\n\n\n\nSan-store中则不会有mutation和action之分，只存在action，通过dispatch来触发。\n\n\n\n\n# store\n\nstore的概念和vuex中一样，那么一个初始化的store是什么样的呢？（san-update库实现了一个更新对象的函数，同时随更新过程输出新旧对象的差异结构）\n\nimport {Store} from 'san-store';\nimport {builder} from 'san-update';\n\nlet myStore = new Store({\n    initData: {\n        user: {\n            name: 'your name'\n        }\n    },\n\n    actions: {\n        changeUserName(name) {\n            return builder().set('user.name', name);\n        }\n    }\n});\n\n\n\n# getState\n\nsan-store中用getState来获取state状态的值\n\nmyStore.getState('user.name');\n\n\n\n# Action\n\nAction是一个函数，可以直接定义在store中，也可以通过 addAction 方法可以为 Store 添加 Action。\n\n两个参数：\n\n * payload载荷\n * context对象：getState, dispatch\n\n返回值：\n\n * 返回一个 Promise 时，当前 Action 为异步\n * 返回一个 builder 或什么都不返回时，当前 Action 为同步\n\n使用builder构建更新函数\n\nfunction actionFun(payload, {getState, dispatch}) {\n\t// payload 载荷数据\n  // getState 获取state状态\n  // dispatch 触发其他action\n}\n\n// 同步 Action\nstore.addAction('setUserName', function (name) {\n    return builder().set('user.name', name);\n});\n\n// 异步 Action\nstore.addAction('login', function (payload, {getState, dispatch}) {\n    if (getState('user.name') === payload.name) {\n        return;\n    }\n\n    dispatch('logining', true);\n    return userService.validate(payload).then(() => {\n        dispatch('setUserName', payload.name);\n        dispatch('logining', false);\n    })\n});\n\n\n\n# dispath\n\n参数\n\n * {string} name action名称\n * {*} payload 给予的数据\n\n返回值\n\n * action 为同步时，返回 undefined\n * action 为异步时，返回 Promise\n\nstore.dispatch('login', {\n    name: 'errorrik',\n    password: 'xxxxx'\n});\n\n\n\n# connect\n\nconnect 用于将 store 实例与 san 组件连接，从而：\n\n * 当 store 数据变更时，连接的组件数据也进行相应的变更\n * 组件内部像调用方法一样 dispatch action，组件实现时无需关心对具体 store 的依赖\n\n两个参数：\n\n * mapStates\n * mapActions\n\nconnect.san 返回一个执行 connect 操作的函数，这个函数可以接受一个组件类作为参数\n\nexport default class UserComponent extends Component {\n  // 插值表达式直接访问 mapStates\n  static template = `\n\t\t<template>\n\t\t\t<div>{{ name }}</div>\n\t\t</template>\n\t`,\n  \n  changeName() {\n    // 通过 this.actions 访问 mapActions\n  \tthis.actions.change()\n  }\n}\n\nconnect.san(\n    {name: 'user.name'},\n    {change: 'changeUserName'}\n)(UserComponent);\n\n\n\n# san-update\n\nImmutable Data\n\nJavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值。\n\nImmutable Data是指一旦被创造后，就不可以被改变的数据。\n\n在javascript中我们可以通过deep clone来模拟Immutable Data，就是每次对数据进行操作，新对数据进行deep clone出一个新数据。但是深拷贝是用递归的方式实现的，十分消耗性能，所以诞生了Immutable Data\n\n可以理解为优化后的深拷贝。\n\n但是社区的库普遍存在一些问题，如：\n\n 1. 指令不够。除最基本的set、push、unshift、merge等功能外，其它功能难以方便地补充\n 2. 使用不便。当需要对一个对象的多个属性进行更新时，组装一个复杂的更新指令并不容易\n\nsan-update希望在社区经验的基础之上，通过提供更强大的功能和方便的使用方式（如链式调用）来简化基于不可变对象的系统开发\n\n具体使用可看：san-update官方文档\n\n\n# React Native\n\n * RN是 React 的一个原生扩展\n * 它允许我们通过 React 语法，来开发 ios 和 Android 原生应用\n\n\n# 几种跨平台框架的比较\n\n框架     RN（NA VIEW）   WEEX（NA VIEW）   FLUTTER（自绘制）\n所属公司   FB            ali             google\n编程语言   js（React）     js（Vue）         Dart\n引擎     JSCore        V8              Flutter engine\n\n\n# 移动 App 的开发模式\n\n原生开发：android / iOS\n\n混合开发：RN / weex / Flutter\n\nH5开发：html / css / js\n\n开发模式   原生开发               混合开发                 WEB开发\n运行环境   Android，iOS        Android，iOS          浏览器，webview\n编程语言   Java，Objective-C   JS，Dart(Flutter使用)   Html,css,js\n可移植性   差                  一般                   好\n开发速度   慢                  一般                   快\n性能     快                  较慢                   慢\n学习成本   高                  一般                   低\n\n\n# RN 的优势\n\n * 开发体验好\n   * 用统一的代码规范开发移动端程序，不用关注移动端的差异\n * 开发成本低\n   * 开发一次，可以生成 Android 和 iOS 两个系统上的 app\n   * Learn once，write anywhere\n * 学习成本低\n   * 只要掌握 JS 和 React，就可以进行移动端开发了\n\n\n# RN的不足\n\n * 不成熟\n   * 项目版本更新维护较频繁，学习成本高\n   * 试错成本高，有些问题较少解决方案，易耽误开发进度\n * 性能差\n   * 整体性能扔不如原生\n * 兼容性差\n   * 涉及底层的功能，需要针对 Android 和 ios 双端单独开发\n\n\n# 运行原理\n\n这里摘抄自React Native 原理与实践\n\nReact Native 需要一个 JS 的运行环境，因为 React Native 会把应用的 JS 代码编译成一个 JS 文件（x x.bundle），React Native 框架的目标就是解释运行这个 JS 脚本文件，如果是 Native 拓展的 API，则直接通过 bridge 调用 Native 方法，最基础的比如绘制 UI 界面，映射 Virtual DOM 到真实的 UI 组件中。\n\n\n\n绿色的是我们应用开发的部分，我们写的代码基本上都是在这一层。\n\n蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码。\n\n黄色代表平台相关的 bridge 代码，做定制化的时候会添加修改代码。\n\n红色代表系统平台的功能，另外红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了，红色部分是独立于 React Native 的。\n\n\n# san-native\n\nSanNative是一套动态NA视图框架，利用JS引擎驱动NA端渲染，使得web前端工程师可以十分方便的编写原生移动应用，一套代码二端运行。\n\n> 浏览器渲染：React / vue / angular / san => DOM api => 渲染\n> \n> San-native：san => Render Api => NA渲染\n\n\n# 为什么不用 rn 等其他方案\n\n移动端采用开源方案（Vue/React）也是可以考虑的，外部库的好处在于发展的非常快，经常会有些新的 feature。但这也将会是个很大的风险，开源库的快速迭代意味着随时有新的最佳实践取代旧的模式而频繁的破坏性更改，让早期采用者承担重构成本。\n\n\n# san生命周期\n\n生命周期       触发时机\ncompiled   组件视图模板编译完成，template编译生成ANODE\ninited     组件实例初始化完成，可以访问到 data\ncreated    组件元素创建完成，可以访问到路由信息\nattached   组件已被附加到页面中，此时可以访问到 DOM\ndetached   组件从页面中移除\ndisposed   组件卸载完成\n\n其中san组件中路由相关的route()函数会在inited后，created前执行。",normalizedContent:"# san框架\n\n * san-store\n * san-update\n * san-native\n * san生命周期\n\n\n# san-store\n\nsan-store是san框架用于状态管理的工具，和vuex类似，但是还是有区别的，首先复习一下vue\n\n> vue中更改state的方式有且只有一个： mutation，用commit 来触发，限制是只能同步修改。\n> \n> 想要异步需要dispatch 一个 action，action中再触发commit修改state，action中可以做异步操作。\n\nconst store = new vuex.store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n// 通过 dispathch 触发\nstore.dispatch('increment')\n\n\n\n\nsan-store中则不会有mutation和action之分，只存在action，通过dispatch来触发。\n\n\n\n\n# store\n\nstore的概念和vuex中一样，那么一个初始化的store是什么样的呢？（san-update库实现了一个更新对象的函数，同时随更新过程输出新旧对象的差异结构）\n\nimport {store} from 'san-store';\nimport {builder} from 'san-update';\n\nlet mystore = new store({\n    initdata: {\n        user: {\n            name: 'your name'\n        }\n    },\n\n    actions: {\n        changeusername(name) {\n            return builder().set('user.name', name);\n        }\n    }\n});\n\n\n\n# getstate\n\nsan-store中用getstate来获取state状态的值\n\nmystore.getstate('user.name');\n\n\n\n# action\n\naction是一个函数，可以直接定义在store中，也可以通过 addaction 方法可以为 store 添加 action。\n\n两个参数：\n\n * payload载荷\n * context对象：getstate, dispatch\n\n返回值：\n\n * 返回一个 promise 时，当前 action 为异步\n * 返回一个 builder 或什么都不返回时，当前 action 为同步\n\n使用builder构建更新函数\n\nfunction actionfun(payload, {getstate, dispatch}) {\n\t// payload 载荷数据\n  // getstate 获取state状态\n  // dispatch 触发其他action\n}\n\n// 同步 action\nstore.addaction('setusername', function (name) {\n    return builder().set('user.name', name);\n});\n\n// 异步 action\nstore.addaction('login', function (payload, {getstate, dispatch}) {\n    if (getstate('user.name') === payload.name) {\n        return;\n    }\n\n    dispatch('logining', true);\n    return userservice.validate(payload).then(() => {\n        dispatch('setusername', payload.name);\n        dispatch('logining', false);\n    })\n});\n\n\n\n# dispath\n\n参数\n\n * {string} name action名称\n * {*} payload 给予的数据\n\n返回值\n\n * action 为同步时，返回 undefined\n * action 为异步时，返回 promise\n\nstore.dispatch('login', {\n    name: 'errorrik',\n    password: 'xxxxx'\n});\n\n\n\n# connect\n\nconnect 用于将 store 实例与 san 组件连接，从而：\n\n * 当 store 数据变更时，连接的组件数据也进行相应的变更\n * 组件内部像调用方法一样 dispatch action，组件实现时无需关心对具体 store 的依赖\n\n两个参数：\n\n * mapstates\n * mapactions\n\nconnect.san 返回一个执行 connect 操作的函数，这个函数可以接受一个组件类作为参数\n\nexport default class usercomponent extends component {\n  // 插值表达式直接访问 mapstates\n  static template = `\n\t\t<template>\n\t\t\t<div>{{ name }}</div>\n\t\t</template>\n\t`,\n  \n  changename() {\n    // 通过 this.actions 访问 mapactions\n  \tthis.actions.change()\n  }\n}\n\nconnect.san(\n    {name: 'user.name'},\n    {change: 'changeusername'}\n)(usercomponent);\n\n\n\n# san-update\n\nimmutable data\n\njavascript 中的对象一般是可变的（mutable），因为使用了引用赋值。\n\nimmutable data是指一旦被创造后，就不可以被改变的数据。\n\n在javascript中我们可以通过deep clone来模拟immutable data，就是每次对数据进行操作，新对数据进行deep clone出一个新数据。但是深拷贝是用递归的方式实现的，十分消耗性能，所以诞生了immutable data\n\n可以理解为优化后的深拷贝。\n\n但是社区的库普遍存在一些问题，如：\n\n 1. 指令不够。除最基本的set、push、unshift、merge等功能外，其它功能难以方便地补充\n 2. 使用不便。当需要对一个对象的多个属性进行更新时，组装一个复杂的更新指令并不容易\n\nsan-update希望在社区经验的基础之上，通过提供更强大的功能和方便的使用方式（如链式调用）来简化基于不可变对象的系统开发\n\n具体使用可看：san-update官方文档\n\n\n# react native\n\n * rn是 react 的一个原生扩展\n * 它允许我们通过 react 语法，来开发 ios 和 android 原生应用\n\n\n# 几种跨平台框架的比较\n\n框架     rn（na view）   weex（na view）   flutter（自绘制）\n所属公司   fb            ali             google\n编程语言   js（react）     js（vue）         dart\n引擎     jscore        v8              flutter engine\n\n\n# 移动 app 的开发模式\n\n原生开发：android / ios\n\n混合开发：rn / weex / flutter\n\nh5开发：html / css / js\n\n开发模式   原生开发               混合开发                 web开发\n运行环境   android，ios        android，ios          浏览器，webview\n编程语言   java，objective-c   js，dart(flutter使用)   html,css,js\n可移植性   差                  一般                   好\n开发速度   慢                  一般                   快\n性能     快                  较慢                   慢\n学习成本   高                  一般                   低\n\n\n# rn 的优势\n\n * 开发体验好\n   * 用统一的代码规范开发移动端程序，不用关注移动端的差异\n * 开发成本低\n   * 开发一次，可以生成 android 和 ios 两个系统上的 app\n   * learn once，write anywhere\n * 学习成本低\n   * 只要掌握 js 和 react，就可以进行移动端开发了\n\n\n# rn的不足\n\n * 不成熟\n   * 项目版本更新维护较频繁，学习成本高\n   * 试错成本高，有些问题较少解决方案，易耽误开发进度\n * 性能差\n   * 整体性能扔不如原生\n * 兼容性差\n   * 涉及底层的功能，需要针对 android 和 ios 双端单独开发\n\n\n# 运行原理\n\n这里摘抄自react native 原理与实践\n\nreact native 需要一个 js 的运行环境，因为 react native 会把应用的 js 代码编译成一个 js 文件（x x.bundle），react native 框架的目标就是解释运行这个 js 脚本文件，如果是 native 拓展的 api，则直接通过 bridge 调用 native 方法，最基础的比如绘制 ui 界面，映射 virtual dom 到真实的 ui 组件中。\n\n\n\n绿色的是我们应用开发的部分，我们写的代码基本上都是在这一层。\n\n蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码。\n\n黄色代表平台相关的 bridge 代码，做定制化的时候会添加修改代码。\n\n红色代表系统平台的功能，另外红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了，红色部分是独立于 react native 的。\n\n\n# san-native\n\nsannative是一套动态na视图框架，利用js引擎驱动na端渲染，使得web前端工程师可以十分方便的编写原生移动应用，一套代码二端运行。\n\n> 浏览器渲染：react / vue / angular / san => dom api => 渲染\n> \n> san-native：san => render api => na渲染\n\n\n# 为什么不用 rn 等其他方案\n\n移动端采用开源方案（vue/react）也是可以考虑的，外部库的好处在于发展的非常快，经常会有些新的 feature。但这也将会是个很大的风险，开源库的快速迭代意味着随时有新的最佳实践取代旧的模式而频繁的破坏性更改，让早期采用者承担重构成本。\n\n\n# san生命周期\n\n生命周期       触发时机\ncompiled   组件视图模板编译完成，template编译生成anode\ninited     组件实例初始化完成，可以访问到 data\ncreated    组件元素创建完成，可以访问到路由信息\nattached   组件已被附加到页面中，此时可以访问到 dom\ndetached   组件从页面中移除\ndisposed   组件卸载完成\n\n其中san组件中路由相关的route()函数会在inited后，created前执行。",charsets:{cjk:!0}},{title:"乒乓球游戏",frontmatter:{},regularPath:"/three/three2.html",relativePath:"three/three2.md",key:"v-57f44261",path:"/three/three2.html",headers:[{level:3,title:"屏幕的位置",slug:"屏幕的位置",normalizedTitle:"屏幕的位置",charIndex:12},{level:2,title:"页面组成",slug:"页面组成",normalizedTitle:"页面组成",charIndex:114},{level:2,title:"HDR",slug:"hdr",normalizedTitle:"hdr",charIndex:232},{level:2,title:"如何设置背景图",slug:"如何设置背景图",normalizedTitle:"如何设置背景图",charIndex:924},{level:2,title:"纹理贴图",slug:"纹理贴图",normalizedTitle:"纹理贴图",charIndex:1079},{level:2,title:"单位与坐标",slug:"单位与坐标",normalizedTitle:"单位与坐标",charIndex:1596},{level:2,title:"透视关系",slug:"透视关系",normalizedTitle:"透视关系",charIndex:2159},{level:2,title:"抗锯齿",slug:"抗锯齿",normalizedTitle:"抗锯齿",charIndex:2477},{level:2,title:"运动轨迹",slug:"运动轨迹",normalizedTitle:"运动轨迹",charIndex:2864},{level:2,title:"用户交互",slug:"用户交互",normalizedTitle:"用户交互",charIndex:4207},{level:2,title:"raycast 算法",slug:"raycast-算法",normalizedTitle:"raycast 算法",charIndex:4318},{level:2,title:"相机视角移动",slug:"相机视角移动",normalizedTitle:"相机视角移动",charIndex:5223},{level:2,title:"碰撞检测",slug:"碰撞检测",normalizedTitle:"碰撞检测",charIndex:5664},{level:2,title:"AI策略",slug:"ai策略",normalizedTitle:"ai策略",charIndex:6278},{level:2,title:"帧率",slug:"帧率",normalizedTitle:"帧率",charIndex:6344},{level:2,title:"炫酷效果",slug:"炫酷效果",normalizedTitle:"炫酷效果",charIndex:6533},{level:2,title:"代码结构",slug:"代码结构",normalizedTitle:"代码结构",charIndex:6766},{level:2,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:7019},{level:2,title:"兼容性",slug:"兼容性",normalizedTitle:"兼容性",charIndex:7342}],lastUpdated:"9/2/2025, 11:24:35 AM",lastUpdatedTimestamp:1756783475e3,headersStr:"屏幕的位置 页面组成 HDR 如何设置背景图 纹理贴图 单位与坐标 透视关系 抗锯齿 运动轨迹 用户交互 raycast 算法 相机视角移动 碰撞检测 AI策略 帧率 炫酷效果 代码结构 性能优化 兼容性",content:"# 乒乓球游戏\n\n\n# 屏幕的位置\n\n近裁剪面和远裁剪面定义了相机的渲染范围。位于近裁剪面之前的物体和位于远裁剪面之后的物体都不会被渲染。为了提高渲染性能，通常应该尽量将近裁剪面和远裁剪面之间的距离设置得较小。\n\n\n\n\n\n\n# 页面组成\n\ngltf/glb 模型：\n\n\n\n\n\n直接使用模型虽然方便我们开发，但是还要考虑到性能和资源的影响，例如本次一个球拍的 glb模型大小就有接近800KB。开发时需要考虑有没有其他方式。\n\n> 如何给三维世界设置背景？\n\n\n# HDR\n\nHigh-Dynamic Range （HDR）image的缩写，简单说，HDRI是一种亮度范围非常广的图像，它比其它格式的图像有着更大亮度的数据贮存，而且它记录亮度的方式与传统的图片不同，不是用非线性的方式将亮度信息压缩到8bit或16bit的颜色空间内，而是用直接对应的方式记录亮度信息，它可以说记录了图片环境中的照明信息，因此我们可以使用这种图像来“照亮”场景。有很多HDRI文件是以全景图的形式提供的，我们也可以用它做环境背景来产生反射与折射。\n\n用最简单最直白易懂的话来总结说：HDRI就是会发光的图片。它的每一个像素，就相当于是一个小LED灯泡。最亮的部分就是太阳所在的部分。因为它是LED灯，所以它可以把光和色照射出来，影响到周围。\n\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader';\nconst rgbeLoader = new RGBELoader();\n\ufeff\nrgbeLoader.load('xxx.hdr', envMap => {\n    // hdr作为环境贴图生效，设置.mapping为EquirectangularReflectionMapping\n    envMap.mapping = THREE.EquirectangularReflectionMapping;\n    scene.environment = envMap; // 设置每个物体\n    scene.background = envMap; // 设置整体的天空背景\n})\n\n\n\n# 如何设置背景图\n\n\n\n\n\n// 可以给 render 设置透明，这样后面的背景图就会展示出来\nconst renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\nrenderer.setClearAlpha(0.0);\n\n\n\n# 纹理贴图\n\n对于场景中的某些地方的展示可以用纹理贴图\n\n\n\n\n\nconst geometry = new THREE.PlaneGeometry(1.1, 0.3); // 平面\nconst textureLoader = new THREE.TextureLoader();\ntextureLoader.load(TableFootPng, texture => {\n    const material = new THREE.MeshBasicMaterial({\n        map: texture,\n        transparent: true, // 防止图片背景透明部分为黑色\n    });\n    const mesh = new THREE.Mesh(geometry, material);//纹理贴图网格模型对象\n    mesh.position.set(0, -0.3, 1);\n    mesh.rotation.x = -Math.PI / 6;\n    scene.add(mesh);//网格模型添加到场景中\n});\n\n\nok，目前位置我们资源都准备好了，那么如何进行组装呢？\n\n\n# 单位与坐标\n\n在 three.js 中一般会默认一个单位对应一米，然后提前和视觉同学对齐，比如我们乒乓球中设置的各个物体的长宽如：\n\nconst TABLEWIDTH = 1.1; // 桌子宽度\nconst TABLEDEPTH = 2; // 桌子深度\nconst PADDLEWIDTH = 0.153; // 球拍模型宽度\nconst PADDLEHIGHT = 0.22; // 球拍模型高度\n\n\n然后我们需要约定好坐标原点，比如我们本次约定桌面中心为左边原点\n\n\n\n我们约定好上述条件后，视觉提供给我们的一般模型中会自带位置信息，我们只需要将其直接添加到场景中即可\n\n// GLTF 加载器\nimport {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader';\nconst loader = new GLTFLoader();\nconst TABLEGLB = 'https://feed-activity.cdn.bcebos.com/lego/duanju/nowuhuan-table.glb'; // 桌面\nloader.load(TABLEGLB, gltf => {\n    scene.add(gltf.scene);\n});\n\n\n\n# 透视关系\n\n摄影相关知识：\n\n * 超广角：20mm以下，常用于风光摄影\n * 广角：20mm-40mm，有拉伸空间的效果，比如房产中介拍摄房间视频。\n * 标准焦段：40mm-60mm，最接近人眼，用于拍摄人像\n * 长焦：60mm以上，有压缩空间的效果，拍摄远距离主体，如生态摄影及运动摄影\n\n\n\n在 three.js 中左图设置的相机焦距为 10mm，右图设置的为 35mm。\n\n由于要保证乒乓球桌的大小不变，10mm焦距的相机离物体较近，35mm焦距的相机离物体较远。\n\n离物体的距离会改变透视关系，所以两种焦距看到的乒乓球桌并不一样。\n\ncamera.setFocalLength(10); // 设置相机焦距\n\n\n\n\n\n# 抗锯齿\n\n通过Three.js开发应用程序的时候，场景渲染效果默认会有锯齿\n\n 1. 提高渲染器的抗锯齿质量，在创建渲染器时，可以设置抗锯齿属性来减少锯齿。\n 2. 使用更高分辨率的纹理来减少锯齿。\n 3. 使用多重采样抗锯齿（MASS）创建更平滑的边缘。\n 4. 使用平滑着色（Smooth Shading）来减少锯齿。\n 5. 使用后期处理（Post-Processing）来减少锯齿。\n\n效果越好的算法，渲染负担也越重，此处我们直接使用第一种即可。\n\nconst renderer = new THREE.WebGLRenderer({\n    antialias: true, // 抗锯齿\n});\n// 设置设备像素比，防止模糊输出 canvas\nrenderer.setPixelRatio(window.devicePixelRatio);\n\n\n\n\n\n\n\n# 运动轨迹\n\n三维空间，横向x轴，纵向y轴，垂直于屏幕z轴\n\n\n\n\n\n小球运动轨迹：x轴，z轴可以变化，y轴为抛物线（y随z变化）\n\n\n\n求经过（20，0）和（-10，0）且开口向下的抛物线方程，形如 y = - (z - a)^2/ b + c 或者 y = az^2 + bz + c，当然我们不希望每一次乒乓球的抛物线轨迹都相同，所以我们需要给出一些范围，随机产生轨迹的抛物线。\n\nconst calculateRanges = (\n    {\n        currentPos, // 当前位置坐标\n        zRange = [-0.8, -0.2], // 落点的z轴范围\n        bRange = [-2, 2], // 最高点的z轴范围\n        yRange = [0.12, 0.2], // z为0时的y轴范围\n    }\n) => {\n    const {y: yc, z: zc} = currentPos;\n    const [zMin, zMax] = zRange;\n    const [bMin, bMax] = bRange;\n    const [yMin, yMax] = yRange;\n    const results = [];\n    for (let z = zMin; z < zMax; z += 0.01) {\n        for (let b = bMin; b <= bMax; b += 0.01) {\n            if (Math.abs(zc - z) < 1e-6 || Math.abs(z + b) < 1e-6) {\n                continue;\n            } // 避免分母为0\n            const aNumerator = yc;\n            const aDenominator = (zc - z) * (zc + z + 2 * b);\n            const a = aNumerator / aDenominator;\n            if (isNaN(a) || !isFinite(a)) {\n                continue;\n            } // 检查a的有效性\n            const c = -a * (z + b) ** 2;\n            const inequalityLeft = a * b ** 2 + c;\n            if (inequalityLeft >= yMin && inequalityLeft <= yMax) {\n                results.push({a, b, c, z});\n            }\n        }\n    }\n    const random = Math.floor(Math.random() * results.length);\n    return results[random];\n};\n\n\n\n# 用户交互\n\n用户如何操作球拍？手指触摸在屏幕上其实是个二维平面，如何在二维平面上操作使得三维场景中的球拍移动？【此处demo演示下】\n\n * 球拍x坐标：根据mouseX变化\n * 球拍y坐标：固定即可\n * 球拍z坐标：raycast 算法求出真实的三维坐标\n\n\n# raycast 算法\n\n光线投射用于进行鼠标拾取（在三维空间中计算出鼠标移过了什么物体）\n\nhttps://threejs.org/docs/#api/zh/core/Raycaster\n\n\n\n\n\nconst raycaster = new THREE.Raycaster();\nconst pointer = new THREE.Vector2();\n\ufeff\nfunction onPointerMove( event ) {\n\t// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)\n\tpointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\tpointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n}\n\ufeff\nfunction render() {\n\t// 通过摄像机和鼠标位置更新射线\n    // coords —— 在标准化设备坐标中鼠标的二维坐标 —— X分量与Y分量应当在-1到1之间。\n    // camera —— 射线所来源的摄像机。\n\traycaster.setFromCamera( pointer, camera );\n\t// 计算物体和射线的焦点\n\tconst intersects = raycaster.intersectObjects( scene.children );\n\tfor ( let i = 0; i < intersects.length; i ++ ) {\n\t\tintersects[ i ].object.material.color.set( 0xff0000 );\n\t}\n\trenderer.render( scene, camera );\n}\n\ufeff\nwindow.addEventListener( 'pointermove', onPointerMove );\nwindow.requestAnimationFrame(render);\n\n\n\n# 相机视角移动\n\n使用户体验来回击打乒乓球拉扯的感觉，增添视觉冲击力。\n\n此处先演示下 demo，主要优化点为：\n\n 1. ai击中后相机跟随乒乓球进行一定程度的移动\n 2. 设定阈值防止视角拉的过远\n 3. 击中后视角回正\n\n> 为了实现相机移动后，用户球拍也跟随移动，需要将相机和用户球拍添加到一个 group 中\n\ninitCameraGroup() {\n    this.group = new THREE.Group();\n    // 将相机添加到组中\n    this.group.add(camera);\n    // 用户球拍添加到组中\n    this.group.add(user);\n    // 将组添加到scene中\n    scene.add(this.group);\n}\n\n\nTHREE.Group是一个组合对象，把零散的对象组合到一块便于操作，可以使用THREE.Group来操作一组对象，包括旋转，缩放，移动等，里面的子对象都会受到影响。\n\n\n# 碰撞检测\n\n完成对打过程的基础上，使用户体验发力打球的感觉，享受对战的真实感。\n\n计算球拍与小球三维坐标的关系来判断是否碰撞。\n\n 1. 方向\n 2. 速度\n\n\n\n\n\n // 2 * 1 / 60 = 0.1，记录击中球拍前 30ms 的位置\nconst nowPos = this.posArr[this.posArr.length - 1];\nconst prevPos = this.posArr[this.posArr.length - 3];\nif (nowPos && prevPos) {\n    // 偏移量\n    const offsetZ = prevPos.z - nowPos.z;\n    const offsetX = prevPos.x - nowPos.x;\n    // 判断方向\n    if (offsetX > 0) {\n        xDir = -1;\n    }\n    else if (offsetX < 0) {\n        xDir = 1;\n    }\n    // 根据offset算速度比例\n    this.xVelRatio = Math.min(2, 1 + Math.abs(offsetX) / 0.01);\n    this.zVelRatio = Math.min(2, 1 + Math.abs(offsetZ) / 0.1);\n}\n\n\n\n# AI策略\n\n 1. 如何让用户必赢\n 2. 如何让AI必赢\n\n思考：AI 能否接住球是靠什么控制的？答：x轴方向的移动速度\n\n\n# 帧率\n\n当前处理方式，每一帧球会移动一定的距离，在帧率不同的设备，移动相同的距离所花的时间不一样，这样就导致了不同设备上移动速度不一致的问题。不过时间是统一的，所有设备上 1s 就是 1s，因此由于之前动态计算抛物线的时候能获取到 z 的值，因此我们可以通过设置完成这个抛物线的时间，来控制球的速度，这样就不依赖帧率了。并且 y 和 z 的关系还是满足特定抛物线方程。\n\n\n# 炫酷效果\n\n 1. 拖尾：粒子系统实现，使用 ShaderMaterial 将球形纹理图片生成顶点着色器数据，再使用片元着色器为顶点描绘的形状片源着色。为了形成拖尾，需要复制顶点位置，当球速快的时候绘制的拖尾会不连续，因此增加插值让拖尾连续，也可以使用 tween.js 处理，但是会增加包体积。\n 2. 碰撞动效：二维击打动效，图片的切换\n 3. 落点提示：落在球台上的效果，使用光圈纹理，动画通过缩放实现\n 4. buff球光圈：buff 球同光圈纹理\n\n\n# 代码结构\n\n├── const.js # 常量\n├── index.js # 主体页面\n├── render #游戏相关\n│   ├── ai.js # ai球拍\n│   ├── ball.js # 乒乓球\n│   ├── collision.js # 碰撞特效\n│   ├── const.js # 常量\n│   ├── index.js # 渲染入口\n│   ├── user.js # 我方球拍\n│   └── utils.js # util方法\n└── styles.less # 样式\n\n\n\n# 性能优化\n\n 1. three.js自带性能监测工具\n 2. 纹理贴图替换模型：桌腿使用贴图，背景使用图片\n 3. pag对游戏的影响：多个 pag 可能会超过 canvas context 的限制，导致各个 pag 之间抢占 GPU 资源，游戏模型无法加载。\n 4. 音频加载优化：new Audio 是一个同步的操作，因此需要在空闲的时候初始化好，在使用的时候直接 play 即可，audio play 也是一个同步操作，会阻塞 js 执行\n 5. 游戏中应该暂停主框架多余的操作：主框架有一个拉新的轮询请求，在游戏中没有停止，一定程度上也占用系统资源。\n 6. 游戏中保证每一帧的处理函数尽可能少的同步逻辑，一些耗时操作使用异步。\n\n\n# 兼容性\n\nthreejs 兼容性问题\n\n 1. 0.160.0 以上不支持 webgl，只支持 webgl2，会导致部分手机白屏\n 2. 0.158.0 以上部分着色器语法不支持，导致对应效果无法渲染",normalizedContent:"# 乒乓球游戏\n\n\n# 屏幕的位置\n\n近裁剪面和远裁剪面定义了相机的渲染范围。位于近裁剪面之前的物体和位于远裁剪面之后的物体都不会被渲染。为了提高渲染性能，通常应该尽量将近裁剪面和远裁剪面之间的距离设置得较小。\n\n\n\n\n\n\n# 页面组成\n\ngltf/glb 模型：\n\n\n\n\n\n直接使用模型虽然方便我们开发，但是还要考虑到性能和资源的影响，例如本次一个球拍的 glb模型大小就有接近800kb。开发时需要考虑有没有其他方式。\n\n> 如何给三维世界设置背景？\n\n\n# hdr\n\nhigh-dynamic range （hdr）image的缩写，简单说，hdri是一种亮度范围非常广的图像，它比其它格式的图像有着更大亮度的数据贮存，而且它记录亮度的方式与传统的图片不同，不是用非线性的方式将亮度信息压缩到8bit或16bit的颜色空间内，而是用直接对应的方式记录亮度信息，它可以说记录了图片环境中的照明信息，因此我们可以使用这种图像来“照亮”场景。有很多hdri文件是以全景图的形式提供的，我们也可以用它做环境背景来产生反射与折射。\n\n用最简单最直白易懂的话来总结说：hdri就是会发光的图片。它的每一个像素，就相当于是一个小led灯泡。最亮的部分就是太阳所在的部分。因为它是led灯，所以它可以把光和色照射出来，影响到周围。\n\nimport {rgbeloader} from 'three/examples/jsm/loaders/rgbeloader';\nconst rgbeloader = new rgbeloader();\n\ufeff\nrgbeloader.load('xxx.hdr', envmap => {\n    // hdr作为环境贴图生效，设置.mapping为equirectangularreflectionmapping\n    envmap.mapping = three.equirectangularreflectionmapping;\n    scene.environment = envmap; // 设置每个物体\n    scene.background = envmap; // 设置整体的天空背景\n})\n\n\n\n# 如何设置背景图\n\n\n\n\n\n// 可以给 render 设置透明，这样后面的背景图就会展示出来\nconst renderer = new three.webglrenderer({antialias: true, alpha: true});\nrenderer.setclearalpha(0.0);\n\n\n\n# 纹理贴图\n\n对于场景中的某些地方的展示可以用纹理贴图\n\n\n\n\n\nconst geometry = new three.planegeometry(1.1, 0.3); // 平面\nconst textureloader = new three.textureloader();\ntextureloader.load(tablefootpng, texture => {\n    const material = new three.meshbasicmaterial({\n        map: texture,\n        transparent: true, // 防止图片背景透明部分为黑色\n    });\n    const mesh = new three.mesh(geometry, material);//纹理贴图网格模型对象\n    mesh.position.set(0, -0.3, 1);\n    mesh.rotation.x = -math.pi / 6;\n    scene.add(mesh);//网格模型添加到场景中\n});\n\n\nok，目前位置我们资源都准备好了，那么如何进行组装呢？\n\n\n# 单位与坐标\n\n在 three.js 中一般会默认一个单位对应一米，然后提前和视觉同学对齐，比如我们乒乓球中设置的各个物体的长宽如：\n\nconst tablewidth = 1.1; // 桌子宽度\nconst tabledepth = 2; // 桌子深度\nconst paddlewidth = 0.153; // 球拍模型宽度\nconst paddlehight = 0.22; // 球拍模型高度\n\n\n然后我们需要约定好坐标原点，比如我们本次约定桌面中心为左边原点\n\n\n\n我们约定好上述条件后，视觉提供给我们的一般模型中会自带位置信息，我们只需要将其直接添加到场景中即可\n\n// gltf 加载器\nimport {gltfloader} from 'three/examples/jsm/loaders/gltfloader';\nconst loader = new gltfloader();\nconst tableglb = 'https://feed-activity.cdn.bcebos.com/lego/duanju/nowuhuan-table.glb'; // 桌面\nloader.load(tableglb, gltf => {\n    scene.add(gltf.scene);\n});\n\n\n\n# 透视关系\n\n摄影相关知识：\n\n * 超广角：20mm以下，常用于风光摄影\n * 广角：20mm-40mm，有拉伸空间的效果，比如房产中介拍摄房间视频。\n * 标准焦段：40mm-60mm，最接近人眼，用于拍摄人像\n * 长焦：60mm以上，有压缩空间的效果，拍摄远距离主体，如生态摄影及运动摄影\n\n\n\n在 three.js 中左图设置的相机焦距为 10mm，右图设置的为 35mm。\n\n由于要保证乒乓球桌的大小不变，10mm焦距的相机离物体较近，35mm焦距的相机离物体较远。\n\n离物体的距离会改变透视关系，所以两种焦距看到的乒乓球桌并不一样。\n\ncamera.setfocallength(10); // 设置相机焦距\n\n\n\n\n\n# 抗锯齿\n\n通过three.js开发应用程序的时候，场景渲染效果默认会有锯齿\n\n 1. 提高渲染器的抗锯齿质量，在创建渲染器时，可以设置抗锯齿属性来减少锯齿。\n 2. 使用更高分辨率的纹理来减少锯齿。\n 3. 使用多重采样抗锯齿（mass）创建更平滑的边缘。\n 4. 使用平滑着色（smooth shading）来减少锯齿。\n 5. 使用后期处理（post-processing）来减少锯齿。\n\n效果越好的算法，渲染负担也越重，此处我们直接使用第一种即可。\n\nconst renderer = new three.webglrenderer({\n    antialias: true, // 抗锯齿\n});\n// 设置设备像素比，防止模糊输出 canvas\nrenderer.setpixelratio(window.devicepixelratio);\n\n\n\n\n\n\n\n# 运动轨迹\n\n三维空间，横向x轴，纵向y轴，垂直于屏幕z轴\n\n\n\n\n\n小球运动轨迹：x轴，z轴可以变化，y轴为抛物线（y随z变化）\n\n\n\n求经过（20，0）和（-10，0）且开口向下的抛物线方程，形如 y = - (z - a)^2/ b + c 或者 y = az^2 + bz + c，当然我们不希望每一次乒乓球的抛物线轨迹都相同，所以我们需要给出一些范围，随机产生轨迹的抛物线。\n\nconst calculateranges = (\n    {\n        currentpos, // 当前位置坐标\n        zrange = [-0.8, -0.2], // 落点的z轴范围\n        brange = [-2, 2], // 最高点的z轴范围\n        yrange = [0.12, 0.2], // z为0时的y轴范围\n    }\n) => {\n    const {y: yc, z: zc} = currentpos;\n    const [zmin, zmax] = zrange;\n    const [bmin, bmax] = brange;\n    const [ymin, ymax] = yrange;\n    const results = [];\n    for (let z = zmin; z < zmax; z += 0.01) {\n        for (let b = bmin; b <= bmax; b += 0.01) {\n            if (math.abs(zc - z) < 1e-6 || math.abs(z + b) < 1e-6) {\n                continue;\n            } // 避免分母为0\n            const anumerator = yc;\n            const adenominator = (zc - z) * (zc + z + 2 * b);\n            const a = anumerator / adenominator;\n            if (isnan(a) || !isfinite(a)) {\n                continue;\n            } // 检查a的有效性\n            const c = -a * (z + b) ** 2;\n            const inequalityleft = a * b ** 2 + c;\n            if (inequalityleft >= ymin && inequalityleft <= ymax) {\n                results.push({a, b, c, z});\n            }\n        }\n    }\n    const random = math.floor(math.random() * results.length);\n    return results[random];\n};\n\n\n\n# 用户交互\n\n用户如何操作球拍？手指触摸在屏幕上其实是个二维平面，如何在二维平面上操作使得三维场景中的球拍移动？【此处demo演示下】\n\n * 球拍x坐标：根据mousex变化\n * 球拍y坐标：固定即可\n * 球拍z坐标：raycast 算法求出真实的三维坐标\n\n\n# raycast 算法\n\n光线投射用于进行鼠标拾取（在三维空间中计算出鼠标移过了什么物体）\n\nhttps://threejs.org/docs/#api/zh/core/raycaster\n\n\n\n\n\nconst raycaster = new three.raycaster();\nconst pointer = new three.vector2();\n\ufeff\nfunction onpointermove( event ) {\n\t// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)\n\tpointer.x = ( event.clientx / window.innerwidth ) * 2 - 1;\n\tpointer.y = - ( event.clienty / window.innerheight ) * 2 + 1;\n}\n\ufeff\nfunction render() {\n\t// 通过摄像机和鼠标位置更新射线\n    // coords —— 在标准化设备坐标中鼠标的二维坐标 —— x分量与y分量应当在-1到1之间。\n    // camera —— 射线所来源的摄像机。\n\traycaster.setfromcamera( pointer, camera );\n\t// 计算物体和射线的焦点\n\tconst intersects = raycaster.intersectobjects( scene.children );\n\tfor ( let i = 0; i < intersects.length; i ++ ) {\n\t\tintersects[ i ].object.material.color.set( 0xff0000 );\n\t}\n\trenderer.render( scene, camera );\n}\n\ufeff\nwindow.addeventlistener( 'pointermove', onpointermove );\nwindow.requestanimationframe(render);\n\n\n\n# 相机视角移动\n\n使用户体验来回击打乒乓球拉扯的感觉，增添视觉冲击力。\n\n此处先演示下 demo，主要优化点为：\n\n 1. ai击中后相机跟随乒乓球进行一定程度的移动\n 2. 设定阈值防止视角拉的过远\n 3. 击中后视角回正\n\n> 为了实现相机移动后，用户球拍也跟随移动，需要将相机和用户球拍添加到一个 group 中\n\ninitcameragroup() {\n    this.group = new three.group();\n    // 将相机添加到组中\n    this.group.add(camera);\n    // 用户球拍添加到组中\n    this.group.add(user);\n    // 将组添加到scene中\n    scene.add(this.group);\n}\n\n\nthree.group是一个组合对象，把零散的对象组合到一块便于操作，可以使用three.group来操作一组对象，包括旋转，缩放，移动等，里面的子对象都会受到影响。\n\n\n# 碰撞检测\n\n完成对打过程的基础上，使用户体验发力打球的感觉，享受对战的真实感。\n\n计算球拍与小球三维坐标的关系来判断是否碰撞。\n\n 1. 方向\n 2. 速度\n\n\n\n\n\n // 2 * 1 / 60 = 0.1，记录击中球拍前 30ms 的位置\nconst nowpos = this.posarr[this.posarr.length - 1];\nconst prevpos = this.posarr[this.posarr.length - 3];\nif (nowpos && prevpos) {\n    // 偏移量\n    const offsetz = prevpos.z - nowpos.z;\n    const offsetx = prevpos.x - nowpos.x;\n    // 判断方向\n    if (offsetx > 0) {\n        xdir = -1;\n    }\n    else if (offsetx < 0) {\n        xdir = 1;\n    }\n    // 根据offset算速度比例\n    this.xvelratio = math.min(2, 1 + math.abs(offsetx) / 0.01);\n    this.zvelratio = math.min(2, 1 + math.abs(offsetz) / 0.1);\n}\n\n\n\n# ai策略\n\n 1. 如何让用户必赢\n 2. 如何让ai必赢\n\n思考：ai 能否接住球是靠什么控制的？答：x轴方向的移动速度\n\n\n# 帧率\n\n当前处理方式，每一帧球会移动一定的距离，在帧率不同的设备，移动相同的距离所花的时间不一样，这样就导致了不同设备上移动速度不一致的问题。不过时间是统一的，所有设备上 1s 就是 1s，因此由于之前动态计算抛物线的时候能获取到 z 的值，因此我们可以通过设置完成这个抛物线的时间，来控制球的速度，这样就不依赖帧率了。并且 y 和 z 的关系还是满足特定抛物线方程。\n\n\n# 炫酷效果\n\n 1. 拖尾：粒子系统实现，使用 shadermaterial 将球形纹理图片生成顶点着色器数据，再使用片元着色器为顶点描绘的形状片源着色。为了形成拖尾，需要复制顶点位置，当球速快的时候绘制的拖尾会不连续，因此增加插值让拖尾连续，也可以使用 tween.js 处理，但是会增加包体积。\n 2. 碰撞动效：二维击打动效，图片的切换\n 3. 落点提示：落在球台上的效果，使用光圈纹理，动画通过缩放实现\n 4. buff球光圈：buff 球同光圈纹理\n\n\n# 代码结构\n\n├── const.js # 常量\n├── index.js # 主体页面\n├── render #游戏相关\n│   ├── ai.js # ai球拍\n│   ├── ball.js # 乒乓球\n│   ├── collision.js # 碰撞特效\n│   ├── const.js # 常量\n│   ├── index.js # 渲染入口\n│   ├── user.js # 我方球拍\n│   └── utils.js # util方法\n└── styles.less # 样式\n\n\n\n# 性能优化\n\n 1. three.js自带性能监测工具\n 2. 纹理贴图替换模型：桌腿使用贴图，背景使用图片\n 3. pag对游戏的影响：多个 pag 可能会超过 canvas context 的限制，导致各个 pag 之间抢占 gpu 资源，游戏模型无法加载。\n 4. 音频加载优化：new audio 是一个同步的操作，因此需要在空闲的时候初始化好，在使用的时候直接 play 即可，audio play 也是一个同步操作，会阻塞 js 执行\n 5. 游戏中应该暂停主框架多余的操作：主框架有一个拉新的轮询请求，在游戏中没有停止，一定程度上也占用系统资源。\n 6. 游戏中保证每一帧的处理函数尽可能少的同步逻辑，一些耗时操作使用异步。\n\n\n# 兼容性\n\nthreejs 兼容性问题\n\n 1. 0.160.0 以上不支持 webgl，只支持 webgl2，会导致部分手机白屏\n 2. 0.158.0 以上部分着色器语法不支持，导致对应效果无法渲染",charsets:{cjk:!0}},{title:"2021年 9-12月",frontmatter:{},regularPath:"/time/2021.html",relativePath:"time/2021.md",key:"v-d382ca42",path:"/time/2021.html",lastUpdated:"7/8/2022, 6:03:34 PM",lastUpdatedTimestamp:1657274614e3,headersStr:null,content:"# 2021年 9-12月\n\n * React基础\n\n * Redux\n\n * React Hooks\n\n * TypeScript基础\n\n * TypeScript进阶\n\n * HMR原理",normalizedContent:"# 2021年 9-12月\n\n * react基础\n\n * redux\n\n * react hooks\n\n * typescript基础\n\n * typescript进阶\n\n * hmr原理",charsets:{cjk:!0}},{title:"2022年 1-6月",frontmatter:{},regularPath:"/time/2022a.html",relativePath:"time/2022a.md",key:"v-0913acae",path:"/time/2022a.html",lastUpdated:"7/8/2022, 6:03:34 PM",lastUpdatedTimestamp:1657274614e3,headersStr:null,content:"# 2022年 1-6月\n\n * ABtest\n\n * Nginx\n\n * devops介绍\n\n * 常见跨域方案\n\n * yaml简介\n\n * console.log 控制台 I/O 异步\n\n * 移动端h5开发\n\n * TypeScript中的装饰器\n\n * process.env全局变量\n\n * 跨平台与跨端技术简介\n\n * 《深入理解TypeScript》\n\n * 服务端渲染\n\n * san-loader 原理\n\n * express\n\n * 精读《深入浅出NodeJs》",normalizedContent:"# 2022年 1-6月\n\n * abtest\n\n * nginx\n\n * devops介绍\n\n * 常见跨域方案\n\n * yaml简介\n\n * console.log 控制台 i/o 异步\n\n * 移动端h5开发\n\n * typescript中的装饰器\n\n * process.env全局变量\n\n * 跨平台与跨端技术简介\n\n * 《深入理解typescript》\n\n * 服务端渲染\n\n * san-loader 原理\n\n * express\n\n * 精读《深入浅出nodejs》",charsets:{cjk:!0}},{title:"react three fiber",frontmatter:{},regularPath:"/three/three3.html",relativePath:"three/three3.md",key:"v-3fa254c2",path:"/three/three3.html",headers:[{level:2,title:"react three fiber",slug:"react-three-fiber",normalizedTitle:"react three fiber",charIndex:2},{level:3,title:"Mesh 网格",slug:"mesh-网格",normalizedTitle:"mesh 网格",charIndex:280},{level:3,title:"Material 材质",slug:"material-材质",normalizedTitle:"material 材质",charIndex:690},{level:3,title:"Texture 纹理",slug:"texture-纹理",normalizedTitle:"texture 纹理",charIndex:1027},{level:3,title:"useFrame",slug:"useframe",normalizedTitle:"useframe",charIndex:1433},{level:3,title:"useLoader",slug:"useloader",normalizedTitle:"useloader",charIndex:1167},{level:3,title:"useGLTF",slug:"usegltf",normalizedTitle:"usegltf",charIndex:2371},{level:3,title:"GLTF格式",slug:"gltf格式",normalizedTitle:"gltf格式",charIndex:2520},{level:3,title:"GLTF 动画",slug:"gltf-动画",normalizedTitle:"gltf 动画",charIndex:2866},{level:3,title:"THREE.Scene.traverse()",slug:"three-scene-traverse",normalizedTitle:"three.scene.traverse()",charIndex:4590},{level:3,title:"光源介绍",slug:"光源介绍",normalizedTitle:"光源介绍",charIndex:4750},{level:3,title:"阴影相机",slug:"阴影相机",normalizedTitle:"阴影相机",charIndex:5030},{level:3,title:"参数写法",slug:"参数写法",normalizedTitle:"参数写法",charIndex:5490},{level:3,title:"attach",slug:"attach",normalizedTitle:"attach",charIndex:6001},{level:3,title:"事件",slug:"事件",normalizedTitle:"事件",charIndex:6268},{level:3,title:"Shadows",slug:"shadows",normalizedTitle:"shadows",charIndex:7184},{level:2,title:"react three rapier 物理引擎",slug:"react-three-rapier-物理引擎",normalizedTitle:"react three rapier 物理引擎",charIndex:7903},{level:3,title:"Physics 组件",slug:"physics-组件",normalizedTitle:"physics 组件",charIndex:7977},{level:3,title:"RigidBody 刚体",slug:"rigidbody-刚体",normalizedTitle:"rigidbody 刚体",charIndex:8339},{level:3,title:"Automatic Colliders 自动碰撞体",slug:"automatic-colliders-自动碰撞体",normalizedTitle:"automatic colliders 自动碰撞体",charIndex:8686},{level:3,title:"Collision Events 碰撞事件",slug:"collision-events-碰撞事件",normalizedTitle:"collision events 碰撞事件",charIndex:10019},{level:3,title:"Configuring collision and solver groups 配置碰撞组",slug:"configuring-collision-and-solver-groups-配置碰撞组",normalizedTitle:"configuring collision and solver groups 配置碰撞组",charIndex:11014},{level:3,title:"Contact force events 碰撞力事件",slug:"contact-force-events-碰撞力事件",normalizedTitle:"contact force events 碰撞力事件",charIndex:11101},{level:3,title:"Sensor 传感器",slug:"sensor-传感器",normalizedTitle:"sensor 传感器",charIndex:11567},{level:3,title:"useRapier",slug:"userapier",normalizedTitle:"userapier",charIndex:11903},{level:3,title:"Ray-casting 光线投射",slug:"ray-casting-光线投射",normalizedTitle:"ray-casting 光线投射",charIndex:12079},{level:2,title:"小球弹跳案例",slug:"小球弹跳案例",normalizedTitle:"小球弹跳案例",charIndex:13022},{level:2,title:"React 相关",slug:"react-相关",normalizedTitle:"react 相关",charIndex:13883},{level:3,title:"createRoot",slug:"createroot",normalizedTitle:"createroot",charIndex:13896},{level:3,title:"Suspense",slug:"suspense",normalizedTitle:"suspense",charIndex:8173},{level:3,title:"Zustand",slug:"zustand",normalizedTitle:"zustand",charIndex:14041},{level:3,title:"将 JSX 作为子组件传递",slug:"将-jsx-作为子组件传递",normalizedTitle:"将 jsx 作为子组件传递",charIndex:15818}],lastUpdated:"9/2/2025, 11:24:35 AM",lastUpdatedTimestamp:1756783475e3,headersStr:"react three fiber Mesh 网格 Material 材质 Texture 纹理 useFrame useLoader useGLTF GLTF格式 GLTF 动画 THREE.Scene.traverse() 光源介绍 阴影相机 参数写法 attach 事件 Shadows react three rapier 物理引擎 Physics 组件 RigidBody 刚体 Automatic Colliders 自动碰撞体 Collision Events 碰撞事件 Configuring collision and solver groups 配置碰撞组 Contact force events 碰撞力事件 Sensor 传感器 useRapier Ray-casting 光线投射 小球弹跳案例 React 相关 createRoot Suspense Zustand 将 JSX 作为子组件传递",content:"# react three fiber\n\nReact-three-fiber 是一个基于 React 的3D 渲染库，它将three.js 的强大渲染能力与React 的声明式编程模型相结合。\n\nhttps://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\n# 创建项目\nnpm create vite 3d-app\n\n# 安装依赖\ncd 3d-app\nyarn\nyarn add three @react-three/fiber\n\n# Start\nnpm run dev\n\n\n\n# Mesh 网格\n\n在Three.js中，网格（Mesh）是由几何体（Geometry）和材质（Material）组成的对象。要缩放网格对象，您可以使用网格对象的scale属性。\n\n因此在定义一个物体时，我们需要依次指定一个物体的「形状」和「材质」，通过一种特殊的类「Mesh」，我将其称为「网格材料」，在 Three.js 中，Mesh 是表示三维物体的基础类，它将接收两个参数：\n\n * geometry：定义物体的形状；\n * material：定义物体的材质；\n\n现在，让我们创建一个简单的立方体：\n\nconst geometry = newTHREE.BoxGeometry()\nconst material = newTHREE.MeshBasicMaterial()\nconst mesh = newTHREE.Mesh(geometry, material)\nscene.add(mesh)\n\n\n\n\n\n# Material 材质\n\nhttps://threejs.org/docs/index.html?q=mater#api/zh/materials/Material\n\n材质是**几何体表面的材料，**用来定义物体外观的属性。它包含如何渲染物体的信息，如颜色，光照，反射等等。材质可以被赋予不同的属性，以便实现各种不同的外观效果。\n\n * MeshBasicMaterial 基础网格材质：一个以简单着色（平面或线框）方式来绘制几何体的材质，这种材质不受光照的影响。\n * MeshStandardMaterial 标准网格材质：一种基于物理的标准材质。\n\n更多材质可以看这篇文章：https://juejin.cn/post/7224112064461144123\n\n\n# Texture 纹理\n\nTexture 用于创建一个纹理贴图，将其应用到一个表面，或者作为反射/折射贴图。就类似将一个商标图片粘贴到一个商品上。\n\n// 通过TextureLoader 加载贴图，并生成纹理对象，交给材质的map属性。\n  const ballTexture = useLoader(\n    THREE.TextureLoader,\n    \"./textures/beach_ball_texture.png\"\n  );\n  \n  <mesh castShadow receiveShadow>\n    <sphereGeometry args={[0.3, 128, 128]} />\n    <meshStandardMaterial map={ballTexture} flatShading />\n  </mesh>\n\n\n这张贴图会按照等距圆柱投影的原理映射到球体上\n\n\n\n\n\n\n# useFrame\n\n此hook允许在页面每一帧渲染的时候运行代码，比如更新渲染效果、控件等，与Three.js中调用requestAnimationFrame实行重绘动画效果是一样的。你将接收到状*态值state和时钟增量delta。回调函数将在渲染帧之前被调用，当组件卸载时，它会自动从渲染循环中注销。\n\n * delta：若设备的屏幕刷新频率问 60Hz，即每秒钟屏幕刷新60次，每次刷新为 1/60 = 0.016s，这里的 delta 值即为 0.016\n\nuseFrame((state, delta, xrFrame)=>{// 此函数在共享渲染循环内以本机刷新率运行});\n\n\n\n# useLoader\n\nhttps://docs.pmnd.rs/react-three-fiber/tutorials/loading-models\n\n如果你想在 Three.js Fiber 应用程序中加载模型，可以使用 Three.js 的useLoader钩子来实现。这个钩子允许你在 React 组件中异步加载 Three.js 中的资源，包括模型、纹理和其他文件。然后，你可以在组件中使用 useLoader 钩子来异步加载 glTF 模型。在加载完成后，钩子将返回一个包含加载的模型的 THREE.Group 实例。你可以将这个实例添加到场景中，或者在组件的 JSX 中使用它：\n\nimport { useLoader } from '@react-three/fiber';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\n\nfunction Model() {\n  const gltf = useLoader(GLTFLoader, '/path/to/model.gltf');\n  return <primitive object={gltf.scene} />;\n}\n\n// <primitive object={...} /> can mount any existing, foreign threejs object into the scene.\n\n\n\n# useGLTF\n\n// 加载模型可以使用 useGLTF\nimport { useGLTF } from '@react-three/drei'\nconst gltf = useGLTF('/test.glb')\n\nuseGLTF.preload('/test.glb') // 预加载\n\n\n\n# GLTF格式\n\nGLTF 文档\n\n代码中打印引入的 GLTF 是如下格式：\n\n\n\n * scenes：一个GLTF 可能包含多个场景\n * scene：scene属性指示这些场景中的哪一个应该是加载资产时显示的默认场景，它通过引用node来定义场景图。\n * nodes：每个场景都对应一个 nodes 数组\n * node：场景图中的一个结点。它可以包含一个变换(比如旋转或平移)，引用更多的子结点。它可以引用 mesh 和 camera。\n * animation：animation 可以用来描述节点的translation、rotation或scale属性如何随时间变化。\n * materials：包含定义材质及其属性的元素，这里是 MeshBasicMaterial\n\n\n\n\n# GLTF 动画\n\nThree.js的最基础的动画系统，由以下几部分组成：\n\n * KeyFrameTrack\n * AnimationClip\n * AnimitionMixer\n * AnimationAction\n\n# AnimationClip\n\n在建模软件制作好动画之后，可以导出模型文件；通过Loader将模型文件加载之后，建模软件制作的动画就会被保存在animations中。这个animations就是一个AnimationClip的数组。\n\n例如，常见的对人进行建模时，通常会包含一些动作动画：走路、跑步、挥手等。导出模型后，被Loader载入之后，每一个动作都会变成一个AnimationClip对象。\n\n下面这个例子里只有一个 AnimationClip 对象，说明只有一个动画。如果有多个动画时，可能需要用户做某些操作来播放不同的动画。\n\n\n\n# KeyFrameTrack\n\n对于每个AnimationClip（可以理解为每个动作），都包含了很多对象属性的变化。例如，跑步这个动作包含：左胳膊、右胳膊、左腿、右腿等对象的属性变化。对于每一个属性，可以通过关键帧（KeyFrameTrack）来描述它的变化。如这个 AnimationClip 中包含了许多 KeyFrameTrack：\n\n\n\n# AnimationMixer\n\nhttps://threejs.org/docs/#api/zh/animation/AnimationMixer\n\n * 描述：动画混合器是用于场景中特定对象的动画的播放器。当场景中的多个对象独立动画时，每个对象都可以使用同一个动画混合器。可以理解成一个总控制台，它的作用，就是用来控制“时刻” 。可以形象的理解为是一个动画播放的进度条。\n * 参数：rootObject 混合器播放的动画所属的对象。就是包含动画模型的场景对象。\n * 常用属性：\n   * .time 全局的混合器时间。\n   * .clipAction(AnimationClip) 返回所传入的剪辑参数的AnimationAction对象。\n   * .getRoot() 返回混合器的根对象。\n   * .update() 推进混合器时间并更新动画。在渲染函数中调用更新动画。\n\n# AnimationAction\n\nhttps://threejs.org/docs/#api/zh/animation/AnimationAction\n\nAnimationActions 用来调度存储在AnimationClips中的动画。通过AnimationMixer.clipAction()进行创建。这个动作可以理解为把AnimationClip放进控制台进行播放。AnimationAction提供了一系列的API来控制对应的AnimationClip的播放。\n\n// 引入 gltf\nconst meta = useGLTF('./models/dazhaohu.glb');\n// 获取 场景和动画\nconst { scene, animations } = meta;\n// 创建动画混合器\nconst mixer = new THREE.AnimationMixer(scene);\n// 遍历动画\nanimations.forEach((clip) => {\n    // animationMixer.clipAction 来生成 animationAction ，然后进行 play\n    mixer.clipAction(clip).play();\n});\n\nconst clock = new THREE.Clock();\nfunction animate() {\n    requestAnimationFrame(animate);\n    const delta = clock.getDelta();\n    if (mixer !== undefined) {\n        // 推进混合器时间并更新动画\n        mixer.update(delta);\n    }\n}\n\n\n\n# THREE.Scene.traverse()\n\n我们可以将一个方法作为参数传递给 traverse() 方法，这个传递来的方法将会在每一个子对象上执行。由于THREE.Scene对象存储的是对象树，所以如果子对象本身还有子对象，traverse()方法会在所有的子对象上执行，直到遍历完场景树中的所有对象为止。\n\n\n# 光源介绍\n\nhttps://hicc.pro/p/three.js/threejs-lighting#threepointlight%E7%82%B9%E5%85%89%E6%BA%90\n\n * Ambient Light：环境光可以照亮三维场景中的所有物体，没有阴影；只有两个属性，color和intensity\n * DirectionalLight：方向是从一个平行光的位置 position 到 target 的位置\n   * target：灯光从它的位置（position）指向目标位置。默认的目标位置 target 为(0, 0, 0)。\n\n\n# 阴影相机\n\n为了在three.js中使用阴影，您需要创建一个阴影相机。\n\n阴影相机（Shadow Camera）是一个用于生成阴影图像的虚拟相机。它不会在屏幕上渲染图像，而是在后台计算阴影贴图。阴影相机类似于场景中的主相机，但是需要一些不同的设置和参数。\n\n\n\nconst light = useRef();\n<directionalLight\n    ref={light}\n    castShadow\n    position={[4, 4, 1]}\n    intensity={1.5}\n    shadow-mapSize={[512, 512]}\n    shadow-camera-near={1}\n    shadow-camera-far={10}\n    shadow-camera-top={10}\n    shadow-camera-right={10}\n    shadow-camera-bottom={-10}\n    shadow-camera-left={-10}\n />\n\n\n\n# 参数写法\n\nnew THREE.SphereGeometry(1, 32)\n// 在 React Three Fiber 中，构造函数参数始终通过 args 作为数组传递\n\n// 球体几何体，参数为：半径，水平分段数，垂直分段数，详见 https://threejs.org/docs/#api/zh/geometries/SphereGeometry\n<sphereGeometry args={[1, 32, 32]} />\n\n// 类似地 <meshStandardMaterial color={new THREE.Color('hotpink')} /> 可以直接写成\n<meshStandardMaterial color=\"hotpink\" />\n\n// 缩放 mesh 的 scale 参数可以写成 <mesh scale={[1, 1, 1]} />\n<mesh scale={1} />\n\n// 嵌套属性 mesh.rotation.x 用破折号\n<mesh rotation-x={1} material-uniforms-resolution-value={[512, 512]} />\n\n\n\n# attach\n\nhttps://docs.pmnd.rs/react-three-fiber/api/objects#attach\n\n<mesh>\n  <meshNormalMaterial attach=\"material\" />\n  <boxGeometry attach=\"geometry\" />\n</mesh>\n\n// equal to\n\nmesh.material = new THREE.MeshNormalMaterial()\nmesh.geometry = new THREE.BoxGeometry()\n\n\n\n# 事件\n\n和浏览器事件类似：https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_events#%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86\n\n<mesh\n  onClick={(e) => console.log('click')}\n  onContextMenu={(e) => console.log('context menu')}\n  onDoubleClick={(e) => console.log('double click')}\n  onWheel={(e) => console.log('wheel spins 滚轮')}\n  onPointerUp={(e) => console.log('up')}\n  onPointerDown={(e) => console.log('down')}\n  onPointerOver={(e) => console.log('over')}\n  onPointerOut={(e) => console.log('out')}\n  onPointerEnter={(e) => console.log('enter')}\n  onPointerLeave={(e) => console.log('leave')}\n  onPointerMove={(e) => console.log('move')}\n  onPointerMissed={() => console.log('missed')} // fires on clicks that haven't hit any meshes.\n  onUpdate={(self) => console.log('props have been updated')} // that is called every time the object gets fresh props,\n/>\n\n\n\n# Shadows\n\n// shadows 属性代表全局允许添加阴影\n<Canvas shadows />\n\n// castShadow 代表允许投射阴影\n<mesh castShadow />\n\n// receiveShadow 代表允许接收阴影\n<mesh receiveShadow />\n\n\n一个例子\n\n<Canvas shadows camera={{ position: [0, 3, 3] }}>\n  // 物体投射阴影\n  <mesh rotation-y={Math.PI / 4} castShadow>\n    <boxGeometry />\n    <meshStandardMaterial color=\"white\" />\n  </mesh>\n    \n  // 平面接收阴影\n  <mesh rotation-x={-Math.PI / 2} position-y={-0.5} receiveShadow>\n    <planeGeometry args={[5, 5]} />\n    <meshStandardMaterial color=\"white\" />\n  </mesh>\n  \n  // 除此之外，还有添加灯光 castShadow，不然不会展示阴影\n  <directionalLight position={[5, 5, 5]} intensity={0.5} castShadow />\n  <directionalLight position={[-5, 5, 5]} intensity={0.5} color=\"red\" castShadow />\n</Canvas>\n\n\n\n\n\n# react three rapier 物理引擎\n\nhttps://github.com/pmndrs/react-three-rapier\n\n\n# Physics 组件\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#the-physics-component\n\n * gravity 重力：默认为 [0, -9.81, 0]，用来模拟真实物理世界\n\nconst Scene = () => {\n  return (\n    <Canvas>\n      <Suspense>\n        <Physics gravity={[0, 1, 0]} interpolation={false} colliders={false}>\n          ...\n        </Physics>\n      </Suspense>\n    </Canvas>\n  );\n};\n\n\n\n# RigidBody 刚体\n\n * restitution={0.2}：弹性系数 ，衡量两个物体在碰撞后的反弹程度\n * friction={1}：摩擦力，摩擦力是对抗碰撞体接触的两个刚体之间相对切向运动的力\n * linearDamping={0.5}：线性阻尼，用于减小刚体的线性速率，值越大物体移动越慢\n * angulularDamping={0.5}：角阻尼，用于减小刚体的旋转速率，值越大刚体旋转越慢\n\n刚体组件常用于在 physics 中添加一个 mesh ，基于 mesh 的形状会默认生成一个 Colliders。\n\nconst RigidBodyMesh = () => (\n  <RigidBody>\n    <mesh />\n  </RigidBody>\n);\n\n\n\n# Automatic Colliders 自动碰撞体\n\n默认情况下，RigidBody 会为其包含的所有网格体生成自动碰撞体。您可以通过在 上设置 colliders 属性来控制碰撞体，或者通过在 上设置 colliders 来全局更改它。设置 Colliders={false} 会禁止自动生成。\n\nconst Scene = () => (\n  <Physics colliders=\"hull\">\n    <RigidBody>\n      <Box />\n    </RigidBody>\n    <RigidBody position={[0, 10, 0]}>\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n\n// 关闭 physics 设置全局碰撞体，在每个 RigidBody 上设置\nconst Scene = () => (\n  <Physics colliders={false}>\n    {/* Use an automatic CuboidCollider for all meshes inside this RigidBody */}\n    <RigidBody colliders=\"cuboid\">\n      <Box />\n    </RigidBody>\n\n    {/* Use an automatic BallCollider for all meshes inside this RigidBody */}\n    <RigidBody position={[0, 10, 0]} colliders=\"ball\">\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n\n\n碰撞体包括几种类型：cuboid（长方体）、ball（球体）、trimesh、hull\n\n一个直观的例子：https://codesandbox.io/p/sandbox/react-three-rapier-auto-colliders-b4coz1?file=%2Fsrc%2FApp.tsx%3A35%2C29-35%2C36\n\n\n\n当然我们也可以在 RigidBody 中手动创建 colliders\n\nconst Scene = () => (<>\n  {/* 创建自定义的碰撞体 */}\n  <RigidBody position={[0, 10, 0]}>\n    <BallCollider args={[0.5]} /> // 球体，参数为半径\n    \n    <CuboidCollider args={[0.5, 0.5, 0.5]} /> // 长方体，参数为长宽高\n    \n    <MeshCollider type=\"trimesh\">\n      <mesh ... />\n    </MeshCollider>\n\n    <MeshCollider type=\"hull\">\n      <mesh ... />\n    </MeshCollider>\n  </RigidBody>\n<>)\n\n\n\n# Collision Events 碰撞事件\n\n * onCollisionEnter：开始碰撞\n   * target：触发碰撞的物体\n   * other：被碰撞的物体\n   * manifold：碰撞产生的接触流形（contact manifold）\n * onCollisionExit：碰撞结束\n\nconst RigidBottle = () => {\n  const [isAsleep, setIsAsleep] = useState(false);\n\n  return (\n    <RigidBody\n      colliders=\"hull\"\n      onSleep={() => setIsAsleep(true)}\n      onWake={() => setIsAsleep(false)}\n      name=\"Bally McBallFace\"\n      onCollisionEnter={({ manifold, target, other }) => {\n        console.log(\n          \"Collision at world position \",\n          manifold.solverContactPoint(0)\n        );\n\n        if (other.rigidBodyObject) {\n          console.log(\n            // this rigid body's Object3D\n            target.rigidBodyObject.name,\n            \" collided with \",\n            // the other rigid body's Object3D\n            other.rigidBodyObject.name\n          );\n        }\n      }}\n    >\n      <Sphere>\n        <meshPhysicalMaterial color={isAsleep ? \"white\" : \"blue\"} />\n      </Sphere>\n    </RigidBody>\n  );\n};\n\n\n\n# Configuring collision and solver groups 配置碰撞组\n\n最有效防止碰撞体直接相互碰撞的方法就是给出碰撞体所属的碰撞组。详见文档\n\n\n# Contact force events 碰撞力事件\n\n在碰撞体发生碰撞时会触发碰撞力事件\n\n<RigidBody\n  colliders=\"ball\"\n  onContactForce={(payload) => {\n    console.log(`The total force generated was: ${payload.totalForce}`);\n  }}\n>\n  <Sphere>\n    <meshPhysicalMaterial color={\"grey\"} />\n  </Sphere>\n</RigidBody>\n\n\n * payload：\n   * target：触发碰撞的物体\n   * other：被碰撞的物体\n   * totalForce：两个碰撞体之间所有力的总和\n   * totalForceMagnitude：两个碰撞体之间所有力大小总和\n   * maxForceDirection：接触点处最大力的方向\n   * maxForceMagnitude：接触点处最大力的大小\n\n\n\n\n# Sensor 传感器\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#sensors\n\n碰撞体可以设置传感器，它可以用于监测一个碰撞体进入或者离开另一个碰撞体，在此过程中不会经历碰撞。\n\n * onIntersectionEnter\n * onIntersectionExit\n\n<RigidBody>\n  <GoalPosts />\n\n  <CuboidCollider\n    args={[5, 5, 1]}\n    sensor\n    onIntersectionEnter={() => console.log(\"Goal!\")}\n  />\n</RigidBody>\n\n\n\n# useRapier\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#advanced-hooks-usage\n\n如果想要对物理世界更加精细的控制，可能需要用到 useRapier\n\nconst { rapier, world } = useRapier();\n\n\n\n# Ray-casting 光线投射\n\nhttps://rapier.rs/docs/user_guides/javascript/scene_queries/#ray-casting\n\n光线投射可查找与光线相交的一个或多个碰撞体。光线投射是一种极其常见的操作，涵盖了多种用例：发射子弹、角色控制器、渲染。\n\n射线：https://threejs.org/docs/#api/zh/math/Ray\n\n * origin - 射线的原点，默认值是一个位于(0, 0, 0)的Vector3。\n * direction - 射线的方向。该向量必须经过标准化使向量长度为1（使用Vector3.normalize），这样才能使方法正常运行。 默认值是一个位于(0, 0, -1)的Vector3。\n\n// 光线由 origin [1, 2, 3] 和 direction [0, 1, 0] 定义：\nlet ray = new RAPIER.Ray({ x: 1.0, y: 2.0, z: 3.0 }, { x: 0.0, y: 1.0, z: 0.0 });\nlet maxToi = 4.0;\nlet solid = true;\n\n// maxToi: max time of impact\n// solid: considers everything as solid (如果光线起点在一个固体内，那么光线则无法继续传播，toi 为 0， 若设置为false那么会继续传播直到触碰到固体边界)\nlet hit = world.castRay(ray, maxToi, solid);\n\n// 如果光线发生碰撞\nif (hit != null) {\n    // 光线传播的距离 = ray.dir * toi\n    // 撞击点 = ray.origin + ray.dir * toi\n    let hitPoint = ray.pointAt(hit.toi); // hit.toi 即为发生碰撞所经历的时间\n    console.log(\"Collider\", hit.colliderHandle, \"hit at point\", hitPoint);\n}\n\n\n\n\n# 小球弹跳案例\n\n\n\n需要实现点击【跳】小球弹起，已知：\n\n 1. 底部反弹平面所处位置为 y = -0.1，高度为 0.1，所以若小球静止在平面上小球底部则正好处于 y = 0\n 2. 小球在空中不能弹跳，只能处在平面上时进行跳跃\n\n思路：利用光线投射计算小球与底部平面的距离，在底部平面或者离底部平台很近时则进行弹跳。\n\nconst jump = () => {\n    // 设 orgin 为小球的球心坐标，为射线 ray 的起点\n    const origin = body.current.translation();\n    // origin 坐标向下移动 0.31，小球半径为 0.3，若初始位置小球就在平面上，那么 orgin 则在底部反弹面的内部，此时若进行光线投射则会直接碰撞，toi 为 0\n    origin.y -= 0.31;\n    // direction 设为 y 轴负方向的单位向量，即射线 ray 的方向\n    const direction = { x: 0, y: -1, z: 0 };\n    // 射线 rag 从 orgin 出发，方向为正下方\n    const ray = new rapier.Ray(origin, direction);\n    // 射线与物体碰撞，则返回碰撞结果\n    const hit = world.castRay(ray, 10, true); \n\n    // 进行弹跳操作\n    // toi = 0 代表小球正处于平面上\n    // 0 < toi < 0.15 代表小球即将落到平面上也可以进行弹跳\n    // toi > 0.15 代表小球仍在空中比较高的地方，不能弹跳\n    if (hit.toi < 0.15) {\n      // 施加一个向上的冲量\n      body.current.applyImpulse({ x: 0, y: 0.75, z: 0 });\n    }\n };\n\n\n\n# React 相关\n\n\n# createRoot\n\nhttps://zh-hans.react.dev/reference/react-dom/client/createRoot\n\n\n# Suspense\n\nhttps://zh-hans.react.dev/reference/react/Suspense\n\n\n# Zustand\n\nZustand 状态库：轻便、简洁、强大的 React 状态管理工具\n\nhttps://awesomedevin.github.io/zustand-vue/\n\nimport { create } from 'zustand'\n\n// Store 初始化\nconst useBearStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}))\n\n// Store 绑定组件\nfunction BearCounter() {\n  const bears = useBearStore((state) => state.bears)\n  return <h1>{bears} around here ...</h1>\n}\n\n// 更新目标状态\nfunction Controls() {\n  const increasePopulation = useBearStore((state) => state.increasePopulation)\n  return <button onClick={increasePopulation}>one up</button>\n}\n\n\n监听 store 状态：https://awesomedevin.github.io/zustand-vue/docs/advanced/read-set-state-outside-of-component\n\nconst useDogStore = create(() => ({ paw: true, snout: true, fur: true }))\n\n// 获取非反应性最新状态\nconst paw = useDogStore.getState().paw\n// 监听所有更改，对每个更改同步触发\nconst unsub1 = useDogStore.subscribe(console.log)\n// 更新状态，将触发监听器\nuseDogStore.setState({ paw: false })\n// 取消监听\nunsub1()\n\n// 当然，你可以像往常一样使用钩子\nconst Component = () => {\n  const paw = useDogStore((state) => state.paw)\n  ...\n\n\nsubscribeWithSelector\n\nimport { subscribeWithSelector } from 'zustand/middleware'\nconst useDogStore = create(\n  subscribeWithSelector(() => ({ paw: true, snout: true, fur: true }))\n)\n\n// 仅限 `paw` 修改时，触发监听\nconst unsub2 = useDogStore.subscribe((state) => state.paw, console.log)\n// subscribe 还可以监听到旧值\nconst unsub3 = useDogStore.subscribe(\n  (state) => state.paw,\n  (paw, previousPaw) => console.log(paw, previousPaw)\n)\n// subscribe 也支持自定义相等函数\nconst unsub4 = useDogStore.subscribe(\n  (state) => [state.paw, state.fur],\n  console.log,\n  { equalityFn: shallow }\n)\n// 立即订阅并触发\nconst unsub5 = useDogStore.subscribe((state) => state.paw, console.log, {\n  fireImmediately: true,\n})\n\n\n\n# 将 JSX 作为子组件传递\n\nhttps://zh-hans.react.dev/learn/passing-props-to-a-component#passing-jsx-as-children\n\n\n\nimport Avatar from './Avatar.js';\n\nfunction Card({ children }) {\n  return (\n    <div className=\"card\">\n      {children}\n    </div>\n  );\n}\n\nexport default function Profile() {\n  return (\n    <Card>\n      <Avatar\n        size={100}\n        person={{ \n          name: 'Katsuko Saruhashi',\n          imageId: 'YfeOqp2'\n        }}\n      />\n    </Card>\n  );\n}\n",normalizedContent:"# react three fiber\n\nreact-three-fiber 是一个基于 react 的3d 渲染库，它将three.js 的强大渲染能力与react 的声明式编程模型相结合。\n\nhttps://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\n# 创建项目\nnpm create vite 3d-app\n\n# 安装依赖\ncd 3d-app\nyarn\nyarn add three @react-three/fiber\n\n# start\nnpm run dev\n\n\n\n# mesh 网格\n\n在three.js中，网格（mesh）是由几何体（geometry）和材质（material）组成的对象。要缩放网格对象，您可以使用网格对象的scale属性。\n\n因此在定义一个物体时，我们需要依次指定一个物体的「形状」和「材质」，通过一种特殊的类「mesh」，我将其称为「网格材料」，在 three.js 中，mesh 是表示三维物体的基础类，它将接收两个参数：\n\n * geometry：定义物体的形状；\n * material：定义物体的材质；\n\n现在，让我们创建一个简单的立方体：\n\nconst geometry = newthree.boxgeometry()\nconst material = newthree.meshbasicmaterial()\nconst mesh = newthree.mesh(geometry, material)\nscene.add(mesh)\n\n\n\n\n\n# material 材质\n\nhttps://threejs.org/docs/index.html?q=mater#api/zh/materials/material\n\n材质是**几何体表面的材料，**用来定义物体外观的属性。它包含如何渲染物体的信息，如颜色，光照，反射等等。材质可以被赋予不同的属性，以便实现各种不同的外观效果。\n\n * meshbasicmaterial 基础网格材质：一个以简单着色（平面或线框）方式来绘制几何体的材质，这种材质不受光照的影响。\n * meshstandardmaterial 标准网格材质：一种基于物理的标准材质。\n\n更多材质可以看这篇文章：https://juejin.cn/post/7224112064461144123\n\n\n# texture 纹理\n\ntexture 用于创建一个纹理贴图，将其应用到一个表面，或者作为反射/折射贴图。就类似将一个商标图片粘贴到一个商品上。\n\n// 通过textureloader 加载贴图，并生成纹理对象，交给材质的map属性。\n  const balltexture = useloader(\n    three.textureloader,\n    \"./textures/beach_ball_texture.png\"\n  );\n  \n  <mesh castshadow receiveshadow>\n    <spheregeometry args={[0.3, 128, 128]} />\n    <meshstandardmaterial map={balltexture} flatshading />\n  </mesh>\n\n\n这张贴图会按照等距圆柱投影的原理映射到球体上\n\n\n\n\n\n\n# useframe\n\n此hook允许在页面每一帧渲染的时候运行代码，比如更新渲染效果、控件等，与three.js中调用requestanimationframe实行重绘动画效果是一样的。你将接收到状*态值state和时钟增量delta。回调函数将在渲染帧之前被调用，当组件卸载时，它会自动从渲染循环中注销。\n\n * delta：若设备的屏幕刷新频率问 60hz，即每秒钟屏幕刷新60次，每次刷新为 1/60 = 0.016s，这里的 delta 值即为 0.016\n\nuseframe((state, delta, xrframe)=>{// 此函数在共享渲染循环内以本机刷新率运行});\n\n\n\n# useloader\n\nhttps://docs.pmnd.rs/react-three-fiber/tutorials/loading-models\n\n如果你想在 three.js fiber 应用程序中加载模型，可以使用 three.js 的useloader钩子来实现。这个钩子允许你在 react 组件中异步加载 three.js 中的资源，包括模型、纹理和其他文件。然后，你可以在组件中使用 useloader 钩子来异步加载 gltf 模型。在加载完成后，钩子将返回一个包含加载的模型的 three.group 实例。你可以将这个实例添加到场景中，或者在组件的 jsx 中使用它：\n\nimport { useloader } from '@react-three/fiber';\nimport { gltfloader } from 'three/examples/jsm/loaders/gltfloader';\n\nfunction model() {\n  const gltf = useloader(gltfloader, '/path/to/model.gltf');\n  return <primitive object={gltf.scene} />;\n}\n\n// <primitive object={...} /> can mount any existing, foreign threejs object into the scene.\n\n\n\n# usegltf\n\n// 加载模型可以使用 usegltf\nimport { usegltf } from '@react-three/drei'\nconst gltf = usegltf('/test.glb')\n\nusegltf.preload('/test.glb') // 预加载\n\n\n\n# gltf格式\n\ngltf 文档\n\n代码中打印引入的 gltf 是如下格式：\n\n\n\n * scenes：一个gltf 可能包含多个场景\n * scene：scene属性指示这些场景中的哪一个应该是加载资产时显示的默认场景，它通过引用node来定义场景图。\n * nodes：每个场景都对应一个 nodes 数组\n * node：场景图中的一个结点。它可以包含一个变换(比如旋转或平移)，引用更多的子结点。它可以引用 mesh 和 camera。\n * animation：animation 可以用来描述节点的translation、rotation或scale属性如何随时间变化。\n * materials：包含定义材质及其属性的元素，这里是 meshbasicmaterial\n\n\n\n\n# gltf 动画\n\nthree.js的最基础的动画系统，由以下几部分组成：\n\n * keyframetrack\n * animationclip\n * animitionmixer\n * animationaction\n\n# animationclip\n\n在建模软件制作好动画之后，可以导出模型文件；通过loader将模型文件加载之后，建模软件制作的动画就会被保存在animations中。这个animations就是一个animationclip的数组。\n\n例如，常见的对人进行建模时，通常会包含一些动作动画：走路、跑步、挥手等。导出模型后，被loader载入之后，每一个动作都会变成一个animationclip对象。\n\n下面这个例子里只有一个 animationclip 对象，说明只有一个动画。如果有多个动画时，可能需要用户做某些操作来播放不同的动画。\n\n\n\n# keyframetrack\n\n对于每个animationclip（可以理解为每个动作），都包含了很多对象属性的变化。例如，跑步这个动作包含：左胳膊、右胳膊、左腿、右腿等对象的属性变化。对于每一个属性，可以通过关键帧（keyframetrack）来描述它的变化。如这个 animationclip 中包含了许多 keyframetrack：\n\n\n\n# animationmixer\n\nhttps://threejs.org/docs/#api/zh/animation/animationmixer\n\n * 描述：动画混合器是用于场景中特定对象的动画的播放器。当场景中的多个对象独立动画时，每个对象都可以使用同一个动画混合器。可以理解成一个总控制台，它的作用，就是用来控制“时刻” 。可以形象的理解为是一个动画播放的进度条。\n * 参数：rootobject 混合器播放的动画所属的对象。就是包含动画模型的场景对象。\n * 常用属性：\n   * .time 全局的混合器时间。\n   * .clipaction(animationclip) 返回所传入的剪辑参数的animationaction对象。\n   * .getroot() 返回混合器的根对象。\n   * .update() 推进混合器时间并更新动画。在渲染函数中调用更新动画。\n\n# animationaction\n\nhttps://threejs.org/docs/#api/zh/animation/animationaction\n\nanimationactions 用来调度存储在animationclips中的动画。通过animationmixer.clipaction()进行创建。这个动作可以理解为把animationclip放进控制台进行播放。animationaction提供了一系列的api来控制对应的animationclip的播放。\n\n// 引入 gltf\nconst meta = usegltf('./models/dazhaohu.glb');\n// 获取 场景和动画\nconst { scene, animations } = meta;\n// 创建动画混合器\nconst mixer = new three.animationmixer(scene);\n// 遍历动画\nanimations.foreach((clip) => {\n    // animationmixer.clipaction 来生成 animationaction ，然后进行 play\n    mixer.clipaction(clip).play();\n});\n\nconst clock = new three.clock();\nfunction animate() {\n    requestanimationframe(animate);\n    const delta = clock.getdelta();\n    if (mixer !== undefined) {\n        // 推进混合器时间并更新动画\n        mixer.update(delta);\n    }\n}\n\n\n\n# three.scene.traverse()\n\n我们可以将一个方法作为参数传递给 traverse() 方法，这个传递来的方法将会在每一个子对象上执行。由于three.scene对象存储的是对象树，所以如果子对象本身还有子对象，traverse()方法会在所有的子对象上执行，直到遍历完场景树中的所有对象为止。\n\n\n# 光源介绍\n\nhttps://hicc.pro/p/three.js/threejs-lighting#threepointlight%e7%82%b9%e5%85%89%e6%ba%90\n\n * ambient light：环境光可以照亮三维场景中的所有物体，没有阴影；只有两个属性，color和intensity\n * directionallight：方向是从一个平行光的位置 position 到 target 的位置\n   * target：灯光从它的位置（position）指向目标位置。默认的目标位置 target 为(0, 0, 0)。\n\n\n# 阴影相机\n\n为了在three.js中使用阴影，您需要创建一个阴影相机。\n\n阴影相机（shadow camera）是一个用于生成阴影图像的虚拟相机。它不会在屏幕上渲染图像，而是在后台计算阴影贴图。阴影相机类似于场景中的主相机，但是需要一些不同的设置和参数。\n\n\n\nconst light = useref();\n<directionallight\n    ref={light}\n    castshadow\n    position={[4, 4, 1]}\n    intensity={1.5}\n    shadow-mapsize={[512, 512]}\n    shadow-camera-near={1}\n    shadow-camera-far={10}\n    shadow-camera-top={10}\n    shadow-camera-right={10}\n    shadow-camera-bottom={-10}\n    shadow-camera-left={-10}\n />\n\n\n\n# 参数写法\n\nnew three.spheregeometry(1, 32)\n// 在 react three fiber 中，构造函数参数始终通过 args 作为数组传递\n\n// 球体几何体，参数为：半径，水平分段数，垂直分段数，详见 https://threejs.org/docs/#api/zh/geometries/spheregeometry\n<spheregeometry args={[1, 32, 32]} />\n\n// 类似地 <meshstandardmaterial color={new three.color('hotpink')} /> 可以直接写成\n<meshstandardmaterial color=\"hotpink\" />\n\n// 缩放 mesh 的 scale 参数可以写成 <mesh scale={[1, 1, 1]} />\n<mesh scale={1} />\n\n// 嵌套属性 mesh.rotation.x 用破折号\n<mesh rotation-x={1} material-uniforms-resolution-value={[512, 512]} />\n\n\n\n# attach\n\nhttps://docs.pmnd.rs/react-three-fiber/api/objects#attach\n\n<mesh>\n  <meshnormalmaterial attach=\"material\" />\n  <boxgeometry attach=\"geometry\" />\n</mesh>\n\n// equal to\n\nmesh.material = new three.meshnormalmaterial()\nmesh.geometry = new three.boxgeometry()\n\n\n\n# 事件\n\n和浏览器事件类似：https://developer.mozilla.org/zh-cn/docs/web/api/pointer_events#%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%85%a8%e5%b1%80%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86\n\n<mesh\n  onclick={(e) => console.log('click')}\n  oncontextmenu={(e) => console.log('context menu')}\n  ondoubleclick={(e) => console.log('double click')}\n  onwheel={(e) => console.log('wheel spins 滚轮')}\n  onpointerup={(e) => console.log('up')}\n  onpointerdown={(e) => console.log('down')}\n  onpointerover={(e) => console.log('over')}\n  onpointerout={(e) => console.log('out')}\n  onpointerenter={(e) => console.log('enter')}\n  onpointerleave={(e) => console.log('leave')}\n  onpointermove={(e) => console.log('move')}\n  onpointermissed={() => console.log('missed')} // fires on clicks that haven't hit any meshes.\n  onupdate={(self) => console.log('props have been updated')} // that is called every time the object gets fresh props,\n/>\n\n\n\n# shadows\n\n// shadows 属性代表全局允许添加阴影\n<canvas shadows />\n\n// castshadow 代表允许投射阴影\n<mesh castshadow />\n\n// receiveshadow 代表允许接收阴影\n<mesh receiveshadow />\n\n\n一个例子\n\n<canvas shadows camera={{ position: [0, 3, 3] }}>\n  // 物体投射阴影\n  <mesh rotation-y={math.pi / 4} castshadow>\n    <boxgeometry />\n    <meshstandardmaterial color=\"white\" />\n  </mesh>\n    \n  // 平面接收阴影\n  <mesh rotation-x={-math.pi / 2} position-y={-0.5} receiveshadow>\n    <planegeometry args={[5, 5]} />\n    <meshstandardmaterial color=\"white\" />\n  </mesh>\n  \n  // 除此之外，还有添加灯光 castshadow，不然不会展示阴影\n  <directionallight position={[5, 5, 5]} intensity={0.5} castshadow />\n  <directionallight position={[-5, 5, 5]} intensity={0.5} color=\"red\" castshadow />\n</canvas>\n\n\n\n\n\n# react three rapier 物理引擎\n\nhttps://github.com/pmndrs/react-three-rapier\n\n\n# physics 组件\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#the-physics-component\n\n * gravity 重力：默认为 [0, -9.81, 0]，用来模拟真实物理世界\n\nconst scene = () => {\n  return (\n    <canvas>\n      <suspense>\n        <physics gravity={[0, 1, 0]} interpolation={false} colliders={false}>\n          ...\n        </physics>\n      </suspense>\n    </canvas>\n  );\n};\n\n\n\n# rigidbody 刚体\n\n * restitution={0.2}：弹性系数 ，衡量两个物体在碰撞后的反弹程度\n * friction={1}：摩擦力，摩擦力是对抗碰撞体接触的两个刚体之间相对切向运动的力\n * lineardamping={0.5}：线性阻尼，用于减小刚体的线性速率，值越大物体移动越慢\n * angululardamping={0.5}：角阻尼，用于减小刚体的旋转速率，值越大刚体旋转越慢\n\n刚体组件常用于在 physics 中添加一个 mesh ，基于 mesh 的形状会默认生成一个 colliders。\n\nconst rigidbodymesh = () => (\n  <rigidbody>\n    <mesh />\n  </rigidbody>\n);\n\n\n\n# automatic colliders 自动碰撞体\n\n默认情况下，rigidbody 会为其包含的所有网格体生成自动碰撞体。您可以通过在 上设置 colliders 属性来控制碰撞体，或者通过在 上设置 colliders 来全局更改它。设置 colliders={false} 会禁止自动生成。\n\nconst scene = () => (\n  <physics colliders=\"hull\">\n    <rigidbody>\n      <box />\n    </rigidbody>\n    <rigidbody position={[0, 10, 0]}>\n      <sphere />\n    </rigidbody>\n  </physics>\n);\n\n// 关闭 physics 设置全局碰撞体，在每个 rigidbody 上设置\nconst scene = () => (\n  <physics colliders={false}>\n    {/* use an automatic cuboidcollider for all meshes inside this rigidbody */}\n    <rigidbody colliders=\"cuboid\">\n      <box />\n    </rigidbody>\n\n    {/* use an automatic ballcollider for all meshes inside this rigidbody */}\n    <rigidbody position={[0, 10, 0]} colliders=\"ball\">\n      <sphere />\n    </rigidbody>\n  </physics>\n);\n\n\n碰撞体包括几种类型：cuboid（长方体）、ball（球体）、trimesh、hull\n\n一个直观的例子：https://codesandbox.io/p/sandbox/react-three-rapier-auto-colliders-b4coz1?file=%2fsrc%2fapp.tsx%3a35%2c29-35%2c36\n\n\n\n当然我们也可以在 rigidbody 中手动创建 colliders\n\nconst scene = () => (<>\n  {/* 创建自定义的碰撞体 */}\n  <rigidbody position={[0, 10, 0]}>\n    <ballcollider args={[0.5]} /> // 球体，参数为半径\n    \n    <cuboidcollider args={[0.5, 0.5, 0.5]} /> // 长方体，参数为长宽高\n    \n    <meshcollider type=\"trimesh\">\n      <mesh ... />\n    </meshcollider>\n\n    <meshcollider type=\"hull\">\n      <mesh ... />\n    </meshcollider>\n  </rigidbody>\n<>)\n\n\n\n# collision events 碰撞事件\n\n * oncollisionenter：开始碰撞\n   * target：触发碰撞的物体\n   * other：被碰撞的物体\n   * manifold：碰撞产生的接触流形（contact manifold）\n * oncollisionexit：碰撞结束\n\nconst rigidbottle = () => {\n  const [isasleep, setisasleep] = usestate(false);\n\n  return (\n    <rigidbody\n      colliders=\"hull\"\n      onsleep={() => setisasleep(true)}\n      onwake={() => setisasleep(false)}\n      name=\"bally mcballface\"\n      oncollisionenter={({ manifold, target, other }) => {\n        console.log(\n          \"collision at world position \",\n          manifold.solvercontactpoint(0)\n        );\n\n        if (other.rigidbodyobject) {\n          console.log(\n            // this rigid body's object3d\n            target.rigidbodyobject.name,\n            \" collided with \",\n            // the other rigid body's object3d\n            other.rigidbodyobject.name\n          );\n        }\n      }}\n    >\n      <sphere>\n        <meshphysicalmaterial color={isasleep ? \"white\" : \"blue\"} />\n      </sphere>\n    </rigidbody>\n  );\n};\n\n\n\n# configuring collision and solver groups 配置碰撞组\n\n最有效防止碰撞体直接相互碰撞的方法就是给出碰撞体所属的碰撞组。详见文档\n\n\n# contact force events 碰撞力事件\n\n在碰撞体发生碰撞时会触发碰撞力事件\n\n<rigidbody\n  colliders=\"ball\"\n  oncontactforce={(payload) => {\n    console.log(`the total force generated was: ${payload.totalforce}`);\n  }}\n>\n  <sphere>\n    <meshphysicalmaterial color={\"grey\"} />\n  </sphere>\n</rigidbody>\n\n\n * payload：\n   * target：触发碰撞的物体\n   * other：被碰撞的物体\n   * totalforce：两个碰撞体之间所有力的总和\n   * totalforcemagnitude：两个碰撞体之间所有力大小总和\n   * maxforcedirection：接触点处最大力的方向\n   * maxforcemagnitude：接触点处最大力的大小\n\n\n\n\n# sensor 传感器\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#sensors\n\n碰撞体可以设置传感器，它可以用于监测一个碰撞体进入或者离开另一个碰撞体，在此过程中不会经历碰撞。\n\n * onintersectionenter\n * onintersectionexit\n\n<rigidbody>\n  <goalposts />\n\n  <cuboidcollider\n    args={[5, 5, 1]}\n    sensor\n    onintersectionenter={() => console.log(\"goal!\")}\n  />\n</rigidbody>\n\n\n\n# userapier\n\nhttps://github.com/pmndrs/react-three-rapier?tab=readme-ov-file#advanced-hooks-usage\n\n如果想要对物理世界更加精细的控制，可能需要用到 userapier\n\nconst { rapier, world } = userapier();\n\n\n\n# ray-casting 光线投射\n\nhttps://rapier.rs/docs/user_guides/javascript/scene_queries/#ray-casting\n\n光线投射可查找与光线相交的一个或多个碰撞体。光线投射是一种极其常见的操作，涵盖了多种用例：发射子弹、角色控制器、渲染。\n\n射线：https://threejs.org/docs/#api/zh/math/ray\n\n * origin - 射线的原点，默认值是一个位于(0, 0, 0)的vector3。\n * direction - 射线的方向。该向量必须经过标准化使向量长度为1（使用vector3.normalize），这样才能使方法正常运行。 默认值是一个位于(0, 0, -1)的vector3。\n\n// 光线由 origin [1, 2, 3] 和 direction [0, 1, 0] 定义：\nlet ray = new rapier.ray({ x: 1.0, y: 2.0, z: 3.0 }, { x: 0.0, y: 1.0, z: 0.0 });\nlet maxtoi = 4.0;\nlet solid = true;\n\n// maxtoi: max time of impact\n// solid: considers everything as solid (如果光线起点在一个固体内，那么光线则无法继续传播，toi 为 0， 若设置为false那么会继续传播直到触碰到固体边界)\nlet hit = world.castray(ray, maxtoi, solid);\n\n// 如果光线发生碰撞\nif (hit != null) {\n    // 光线传播的距离 = ray.dir * toi\n    // 撞击点 = ray.origin + ray.dir * toi\n    let hitpoint = ray.pointat(hit.toi); // hit.toi 即为发生碰撞所经历的时间\n    console.log(\"collider\", hit.colliderhandle, \"hit at point\", hitpoint);\n}\n\n\n\n\n# 小球弹跳案例\n\n\n\n需要实现点击【跳】小球弹起，已知：\n\n 1. 底部反弹平面所处位置为 y = -0.1，高度为 0.1，所以若小球静止在平面上小球底部则正好处于 y = 0\n 2. 小球在空中不能弹跳，只能处在平面上时进行跳跃\n\n思路：利用光线投射计算小球与底部平面的距离，在底部平面或者离底部平台很近时则进行弹跳。\n\nconst jump = () => {\n    // 设 orgin 为小球的球心坐标，为射线 ray 的起点\n    const origin = body.current.translation();\n    // origin 坐标向下移动 0.31，小球半径为 0.3，若初始位置小球就在平面上，那么 orgin 则在底部反弹面的内部，此时若进行光线投射则会直接碰撞，toi 为 0\n    origin.y -= 0.31;\n    // direction 设为 y 轴负方向的单位向量，即射线 ray 的方向\n    const direction = { x: 0, y: -1, z: 0 };\n    // 射线 rag 从 orgin 出发，方向为正下方\n    const ray = new rapier.ray(origin, direction);\n    // 射线与物体碰撞，则返回碰撞结果\n    const hit = world.castray(ray, 10, true); \n\n    // 进行弹跳操作\n    // toi = 0 代表小球正处于平面上\n    // 0 < toi < 0.15 代表小球即将落到平面上也可以进行弹跳\n    // toi > 0.15 代表小球仍在空中比较高的地方，不能弹跳\n    if (hit.toi < 0.15) {\n      // 施加一个向上的冲量\n      body.current.applyimpulse({ x: 0, y: 0.75, z: 0 });\n    }\n };\n\n\n\n# react 相关\n\n\n# createroot\n\nhttps://zh-hans.react.dev/reference/react-dom/client/createroot\n\n\n# suspense\n\nhttps://zh-hans.react.dev/reference/react/suspense\n\n\n# zustand\n\nzustand 状态库：轻便、简洁、强大的 react 状态管理工具\n\nhttps://awesomedevin.github.io/zustand-vue/\n\nimport { create } from 'zustand'\n\n// store 初始化\nconst usebearstore = create((set) => ({\n  bears: 0,\n  increasepopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeallbears: () => set({ bears: 0 }),\n}))\n\n// store 绑定组件\nfunction bearcounter() {\n  const bears = usebearstore((state) => state.bears)\n  return <h1>{bears} around here ...</h1>\n}\n\n// 更新目标状态\nfunction controls() {\n  const increasepopulation = usebearstore((state) => state.increasepopulation)\n  return <button onclick={increasepopulation}>one up</button>\n}\n\n\n监听 store 状态：https://awesomedevin.github.io/zustand-vue/docs/advanced/read-set-state-outside-of-component\n\nconst usedogstore = create(() => ({ paw: true, snout: true, fur: true }))\n\n// 获取非反应性最新状态\nconst paw = usedogstore.getstate().paw\n// 监听所有更改，对每个更改同步触发\nconst unsub1 = usedogstore.subscribe(console.log)\n// 更新状态，将触发监听器\nusedogstore.setstate({ paw: false })\n// 取消监听\nunsub1()\n\n// 当然，你可以像往常一样使用钩子\nconst component = () => {\n  const paw = usedogstore((state) => state.paw)\n  ...\n\n\nsubscribewithselector\n\nimport { subscribewithselector } from 'zustand/middleware'\nconst usedogstore = create(\n  subscribewithselector(() => ({ paw: true, snout: true, fur: true }))\n)\n\n// 仅限 `paw` 修改时，触发监听\nconst unsub2 = usedogstore.subscribe((state) => state.paw, console.log)\n// subscribe 还可以监听到旧值\nconst unsub3 = usedogstore.subscribe(\n  (state) => state.paw,\n  (paw, previouspaw) => console.log(paw, previouspaw)\n)\n// subscribe 也支持自定义相等函数\nconst unsub4 = usedogstore.subscribe(\n  (state) => [state.paw, state.fur],\n  console.log,\n  { equalityfn: shallow }\n)\n// 立即订阅并触发\nconst unsub5 = usedogstore.subscribe((state) => state.paw, console.log, {\n  fireimmediately: true,\n})\n\n\n\n# 将 jsx 作为子组件传递\n\nhttps://zh-hans.react.dev/learn/passing-props-to-a-component#passing-jsx-as-children\n\n\n\nimport avatar from './avatar.js';\n\nfunction card({ children }) {\n  return (\n    <div classname=\"card\">\n      {children}\n    </div>\n  );\n}\n\nexport default function profile() {\n  return (\n    <card>\n      <avatar\n        size={100}\n        person={{ \n          name: 'katsuko saruhashi',\n          imageid: 'yfeoqp2'\n        }}\n      />\n    </card>\n  );\n}\n",charsets:{cjk:!0}},{title:"Three.js",frontmatter:{},regularPath:"/three/three1.html",relativePath:"three/three1.md",key:"v-608ca1ba",path:"/three/three1.html",headers:[{level:2,title:"计算机图形学",slug:"计算机图形学",normalizedTitle:"计算机图形学",charIndex:43},{level:3,title:"1. 电影特效",slug:"_1-电影特效",normalizedTitle:"1. 电影特效",charIndex:212},{level:3,title:"2. 游戏开发",slug:"_2-游戏开发",normalizedTitle:"2. 游戏开发",charIndex:338},{level:3,title:"3. 虚拟现实",slug:"_3-虚拟现实",normalizedTitle:"3. 虚拟现实",charIndex:445},{level:3,title:"4. 工程设计",slug:"_4-工程设计",normalizedTitle:"4. 工程设计",charIndex:569},{level:2,title:"计算机图形学、OpenGL、webGL、three.js 关系",slug:"计算机图形学、opengl、webgl、three-js-关系",normalizedTitle:"计算机图形学、opengl、webgl、three.js 关系",charIndex:667},{level:2,title:"Canvas",slug:"canvas",normalizedTitle:"canvas",charIndex:1337},{level:2,title:"three.js",slug:"three-js-2",normalizedTitle:"three.js",charIndex:15},{level:3,title:"基础元素",slug:"基础元素",normalizedTitle:"基础元素",charIndex:1764},{level:2,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:294},{level:2,title:"相机",slug:"相机",normalizedTitle:"相机",charIndex:1748},{level:2,title:"物体",slug:"物体",normalizedTitle:"物体",charIndex:1620},{level:2,title:"光源",slug:"光源",normalizedTitle:"光源",charIndex:1855},{level:3,title:"渲染器",slug:"渲染器",normalizedTitle:"渲染器",charIndex:1945},{level:2,title:"三维坐标系",slug:"三维坐标系",normalizedTitle:"三维坐标系",charIndex:4206},{level:2,title:"three.js 中的数学",slug:"three-js-中的数学",normalizedTitle:"three.js 中的数学",charIndex:4559},{level:3,title:"向量",slug:"向量",normalizedTitle:"向量",charIndex:4577},{level:2,title:"点乘",slug:"点乘",normalizedTitle:"点乘",charIndex:4772},{level:2,title:"叉乘",slug:"叉乘",normalizedTitle:"叉乘",charIndex:4858},{level:2,title:"欧拉角",slug:"欧拉角",normalizedTitle:"欧拉角",charIndex:5015},{level:2,title:"四元数",slug:"四元数",normalizedTitle:"四元数",charIndex:5400},{level:2,title:"加载 .GLTF/.GLB 文件",slug:"加载-gltf-glb-文件",normalizedTitle:"加载 .gltf/.glb 文件",charIndex:6152}],lastUpdated:"9/2/2025, 11:26:21 AM",lastUpdatedTimestamp:1756783581e3,headersStr:"计算机图形学 1. 电影特效 2. 游戏开发 3. 虚拟现实 4. 工程设计 计算机图形学、OpenGL、webGL、three.js 关系 Canvas three.js 基础元素 场景 相机 物体 光源 渲染器 三维坐标系 three.js 中的数学 向量 点乘 叉乘 欧拉角 四元数 加载 .GLTF/.GLB 文件",content:"# Three.js\n\n介绍 three.js 之前先需要介绍一下一门计算机基础学科：计算机图形学\n\n\n# 计算机图形学\n\n计算机图形学是一门研究通过计算机将数据转换成图形，并在专门显示设备上显示的原理方法和技术的学科。它是建立在传统的图学理论、应用数学及计算机科学基础上的一门边缘学科。\n\n总而言之计算机图形学是研究怎样利用计算机来显示、生成和处理图形的原理、方法和技术的一门学科，这里的图形是指三维图形的处理。\n\n\n# 1. 电影特效\n\n计算机图形学在电影特效中有着广泛的应用。通过计算机生成的图形，电影制作人员可以创造出各种想象力丰富的特效，例如逼真的爆炸、怪物与外星人、超凡脱俗的场景等。这些特效大大提升了电影的视觉效果，并为故事情节增添了动态和吸引力。\n\n\n\n\n# 2. 游戏开发\n\n计算机图形学在游戏开发中也扮演着重要角色。游戏开发人员使用计算机图形学的技术来设计游戏中的场景、角色和动画效果。通过逼真的渲染和交互性能，计算机图形学为玩家提供了身临其境的游戏体验。\n\n\n\n\n# 3. 虚拟现实\n\n虚拟现实是计算机图形学的一个重要应用领域。借助于计算机图形学的技术，虚拟现实可以模拟出现实世界或虚构世界的场景，并通过头戴式设备等交互工具让用户身临其境地体验。虚拟现实技术已经在游戏、教育、医疗等领域得到了广泛应用。\n\n\n\n\n# 4. 工程设计\n\n计算机图形学在工程设计中也起到了重要的作用。通过使用三维建模和渲染技术，工程师可以设计和模拟出各种产品和建筑的外观和功能，从而实现对设计方案的可视化评估和改善。\n\n\n\n\n\n\n# 计算机图形学、OpenGL、webGL、three.js 关系\n\n计算机图形学：计算机图形学是一门学科，范畴非常大，被广泛应用于特效、捕捉、动画、设计、模拟与仿真当中。\n\nOpenGL：是一种C语言标准的库，将各种计算机图形学的成果封装入库，其它开发人员可以非常方便的调用，不需要进行繁复的底层构建工作，便可以实现相关应用的开发。它提供了一组函数和接口，是一种底层的API。\n\nWebGL：WebGL是基于JavaScript的Web图形库，它将OpenGL ES 2.0的功能暴露给了Web浏览器。WebGL允许在Web页面上使用GPU加速的2D和3D图形渲染。它是一种用于在Web浏览器中创建交互式图形应用程序的技术，无需插件。通过WebGL，开发者可以在网页上创建高性能的图形和游戏。\n\nThree.js：Three.js是一个用于在Web上创建3D图形应用程序的JavaScript库。它建立在WebGL之上，简化了3D图形编程的复杂性。Three.js提供了高级的抽象和工具，使开发者能够更容易地创建各种3D场景、对象和特效，而无需深入了解WebGL的底层细节。它广泛用于Web上的3D游戏、可视化、虚拟现实等应用的开发。\n\n\n\n简而言之，OpenGL是底层的图形渲染API，WebGL是将OpenGL引入到Web浏览器中的技术，而Three.js是一个建立在WebGL之上的高级JavaScript库，用于简化Web上的3D图形编程。使用Three.js可以更容易地创建具有吸引力和互动性的Web上的3D图形应用程序。\n\n\n# Canvas\n\n看到这里可能会有疑问，那平时我们用过的 canvas 是什么呢？\n\nCanvas 是一个HTML5标准的2D绘图API，它使用JavaScript API来绘制图形。Canvas提供了一组简单的绘图函数，可以用于绘制图形、文本和图像。Canvas通常用于创建简单的2D图形，比如图表、游戏和用户界面。因此，WebGL主要用于创建复杂的3D场景，而Canvas则用于创建简单的2D图形。当需要处理复杂的3D场景时，使用WebGL会更加适合。当只需要创建简单的2D图形时，使用Canvas会更加便捷。\n\n\n# three.js\n\n\n\n计算机是如何显示3d物体的? 显示器是二维的, 三维的物体要变成二维的, 一定是经过了某种变换.\n\n这个过程跟照相是很相似的, 照相也是将真实世界(三维的)变成一张照片(二维的), 想象一下是如何照相的:\n\n 1. 找一个好地点, 被照相的人摆好姿势\n 2. 找个好的角度放置相机\n 3. 按下快门\n\n\n# 基础元素\n\n**场景（scene）**相当于一个舞台，我们需要将展示的东西放在这个舞台上。\n\n**照相机（camera）**相当于人的眼睛，我们想要看到物体，就需要眼睛去看。\n\n**光源（light）**物体需要光照才能看见，不然就是漆黑一片（但是在某些情况下展示物体不需要光源）。\n\n**物体（object）**我们想要表现的内容，会有形状和材质属性。\n\n**渲染器（render）**我们可以把渲染器想想成为一个画布，我们需要在这个画布上去画出我们需要展示的东西。\n\n\n\n\n# 场景\n\n场景是一个三维空间，是存放所有物品的容器，可以把场景想象成一个空房间，房间里面可以放置要呈现的物体、相机、光源等。\n\n\n\n场景允许在什么地方、摆放什么东西来交给 three.js 来进行渲染，场景也就是放置物体、灯光和相机的地方。\n\n创建场景：要构件一个场景很简单，只需要new一个场景对象出来即可：\n\nconst scene = new THREE.Scene()\n\n\n\n# 相机\n\n在场景中需要添加一个相机，相机用来确定观察位置、方向、角度，相机看到的内容，就是我们最终在屏幕上看到的内容。在程序运行过程中，可以调整相机的位置、方向、角度。\n\n想象一下，在房间里放了一个摄像机，你不在房间里面，但可以远程控制相机移动，摄像机传给远程电脑上展示出来的画面，就是 three.js 在屏幕上呈现的画面。\n\n相机分为两种 透视投影相机（perspectiveCamera）和正交投影相机（OrthographicCamera ）\n\n透视投影相机（perspectiveCamera）特点透视相机的效果是模拟人眼看到的效果，跟人眼看到的世界是一样的，近大远小。\n\n正交投影相机（OrthographicCamera ）特点正交投影则远近都是一样的大小，三维空间中平行的线，投影到二维空间也一定是平行的。\n\n\n\n创建透视投影相机：\n\nconst camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n// 设置相机位置：\ncamera.position.set(5, 10, 10);\n\n\n参数       介绍\nfov      视野：表示摄像机能看到的视野。推荐默认值50\naspect   指定渲染结果水平方向和竖直方向长度的比值，推荐默认值为窗口的宽高比，即window.innerWidth/window.innerHeight，如果比例设置的不对，会发现渲染出来的画面有拉伸或者压缩的感觉。\nnear     近端渲染距离：指定从距离摄像机多近的位置开始渲染，推荐默认值0.1\nfar      远端距离：指定摄像机从它所在的位置最远能看到多远，太小场景中的远处不会被渲染，太大会浪费资源影响性能，推荐默认值1000。\n\n\n# 物体\n\n在 Three.js 中为我们预设了一些二维和三维几何体模型：\n\nPlaneGeometry（平面几何体）\n\nCircleGeometry（圆形几何体）\n\nRingGeometry（圆环几何体）\n\nBoxGeometry（立方几何体）\n\nSphereGeometry（球几何体）\n\nCylinderGeometry（圆柱几何体）\n\nTorusGeometry（圆环几何体）\n\n// 创建一个长、宽、高均为1个单位的立方体\nconst geometry = new THREE.BoxGeometry(1, 1, 1); \n\n\n\n# 光源\n\n在 Three.js 中可以创建出很多不同类型的光源：\n\n**环境光（AmbientLight）：**环境光是一种基本光源，它会均匀的照亮场景中的所有物体，环境光没有特定的来源方向，且不会产生阴影。\n\n**聚光灯（SpotLight）：**聚光灯（类似手电筒、舞台聚光灯）是从一个方向上的一个点发出，沿着一个圆锥体，它离光越远，它的尺寸就越大。这种光源会产生阴影。\n\n**平行光（DirectionalLight）：**平行光是沿着特定方向发射的光。这种光的表现像是无限远,从它发出的光线都是平行的。常常用平行光来模拟太阳光 的效果; 太阳足够远，因此我们可以认为太阳的位置是无限远，所以我们认为从太阳发出的光线也都是平行的。这种光源会产生阴影。\n\n// 创建光源\nconst spotLight = new THREE.SpotLight(0xffffff);\n// 设置光源位置\nspotLight.position.set(0, 20, 20);\n// 设置光源照射的强度\nspotLight.intensity = 5;\n// 将光源添加到场景中\nscene.add(spotLight);\n\n\n\n# 渲染器\n\n渲染器的作用就是将相机拍摄出的画面在浏览器中呈现出来。渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。\n\nThree.js中有很多种类的渲染器，例如webGLRenderer、canvasRenderer、SVGRenderer，通常使用的是WebGLRenderer渲染器。\n\n// 创建WebGLRenderer渲染器\nconst renderer = new THREE.WebGLRenderer();\n // 通过调用 setSize() 方法设置渲染的长宽（设置渲染器为全屏）\nrenderer.setSize(window.innerWidth, window.innerHeight);\n // 将渲染结果展示到页面上\ndocument.body.appendChild(renderer.domElement);\n// 创建完渲染器后，需要调用render方法将之前创建好的场景和相机相结合从而渲染出来\nrenderer.render(scene, camera);\n\n\n\n# 三维坐标系\n\n为了方便观察3D图像，添加三维坐标系对象\n\n// 为了方便观察3D图像，添加三维坐标系对象\nconst axes = new THREE.AxisHelper(4); // 坐标系轴长设置为 4\n// 把三维坐标系 添加到场景中\nscene.add(axes);\n\n\n\n\n综上使用 Three.js，在屏幕上展示 3D 图形的大概步骤：\n\n 1. 创建一个三维空间场景（ Scene ）；\n 2. 创建一个相机（ Camera ），确定一个观察点，并设置相机的观察方向和角度；\n 3. 创建渲染器，设置渲染器的长宽，将渲染结果展示到页面上；\n 4. 创建物体（几何体、材质、网格）、光源（同时设置光源位置），并添加到场景中去；\n 5. 最后通过渲染器，把场景、相机渲染到页面上。\n\n\n\n\n# three.js 中的数学\n\n\n# 向量\n\n在数学中，向量（也称为矢量），指具有大小（magnitude）和方向的量。它可以形象化地表示为带箭头的线段。\n\n\n\n// 已知两个点的坐标\nconst A = Vector3(1, 2, 0)\nconst B = Vector3(-2, 1, 2)\n// 求 AB 向量\nconst AB = B.clone().sub(A) // Vector3(-3, -1, 2)\n\n\n\n# 点乘\n\n已知两个向量，如何求向量的夹角？\n\n\n\nconst CosineValue = A.dot(B) / (A.length() * B.length())\n\n\n\n# 叉乘\n\n\n\n几何意义：如果以向量a和b为边构成一个平行四边形，那么这两个向量外积的模长与这个平行四边形的面积相等。\n\n// 声明一个向量对象，用来保存.crossVectors()方法结果\n  const C = new THREE.Vector3();\n  C.crossVectors(A, B);\n\n\n\n# 欧拉角\n\n3D游戏或者3D电影中，比如黑客帝国中酷炫的旋转是怎么实现的？旋转的算法有很多，这里主要介绍其中一种：欧拉角。\n\n\n\n欧拉角是飞控系统中用于描述飞行器姿态的方式，使用三个角度来表示，分别是yaw偏航角、pitch俯仰角、roll 滚转角。\n\n * yaw：偏航角，是指飞行器偏离原来航线的角度。\n * pitch：俯仰角，是指飞行器机头抬起的角度。\n * roll：滚转角，是指飞行器绕着自身头尾轴线翻滚的角度。\n\n\n\nconst a = new THREE.Euler( 0, 1, 1.57, 'XYZ'); // 创建一个欧拉对象，'XYZ'表示旋转顺序的字符串，默认为大写\nconst b = new THREE.Vector3( 1, 0, 1 ); // 创建一个变量\nb.applyEuler(a); // 将欧拉变换应用到这一向量上\n\n\n\n# 四元数\n\n形如a+bi（a、b均为实数）的数为复数，其中，a被称为实部，b被称为虚部，i为虚数单位，i^2 = -1。\n\n\n\n\n\n四元数的发现者是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的。他花了一生中大部分时间寻找『三维复数』，据说每天早上他儿子都会问他，找没找到三维复数，但他总是说还没有。但是在 1843年10月16日，走过都柏林的布鲁姆桥的时候，他灵光一闪，他需要给复数加上的不是一个维度，而是额外两个假想的维度，即一共三个虚维度来描述空间，而实数在第四个维度，垂直于全部三个虚数轴，他就在桥上刻下了描述这三个虚数单位的等式。\n\n在发现四元数后，他努力地推广四元数，并作为教学生描述三维空间时的第一语言。但当时的反派数学家也没闲着，批判晦涩难懂的四元数是邪恶的，甚至四元数乘法不满足交换律。知道一个世纪之后，四元数在计算机工业界起死回生，程序员把它应用到图像，机器人，以及涉及到3维空间旋转的领域。二十世纪四元数还被应用于另一个重要的领域：量子力学。\n\n\n\n\n\nthree.js 对四元数的数学细节和算法进行了封装。\n\n// 创建一个四元数对象\nconst quaternion = new THREE.Quaternion();\n// 给定旋转轴和旋转角度生成旋转四元数，物体绕z轴旋转90度\nquaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1).normalize(), Math.PI / 2);\n// 创建向量\nconst vector = new THREE.Vector3( 1, 0, 0 );\n// 将四元数变换应用在此向量上\nvector.applyQuaternion( quaternion );\n\n\n\n# 加载 .GLTF/.GLB 文件\n\n * glTF 即是 GL Transmission Format 的缩写。\n * glTF 是一种3D内容的格式标准，由Khronos Group管理，（Khronos Group还管理着OpenGL系列、OpenCL等重要的行业标准）。\n * glTF 的设计是面向实时渲染应用的，尽量提供可以直接传输给图形API的数据形式，不再需要二次转换。\n * glTF 对OpenGL ES、WebGL非常友好。\n * glTF 的目标是：3D领域的JPEG。\n * 作为一个标准，自2015年10月发布（glTF 1.0）以来，已经得到了业界广泛的认可，你可以相信它的水平。\n * glTF目前最新版本为2.0已于2017年6月正式发布。\n\nGLTF格式是三维模型格式（json），你可以把GLTF格式的三维模型理解为.jpg、.png格式的图片一样。Web 开发图片会是常用格式，而对于 Web3D 开发，GLTF必然成为一个重要的标准格式。\n\n.glTF是文本格式文件，而 .glb 是 .glTF 的二进制格式。\n\nSketchfab 上可以下载 GLTF 模型\n\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n// 创建场景\nconst scene = new THREE.Scene();\n// 创建相机\nconst camera = new THREE.PerspectiveCamera(\n    50, \n    window.innerWidth / window.innerHeight, \n    0.1, \n    1000 \n);\ncamera.position.set(0, 0, 5);\n// 创建渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n// 添加光源\nconst spotLight = new THREE.SpotLight(0xffffff);\nspotLight.position.set(0, 20, 20);\nspotLight.intensity = 5;\nscene.add(spotLight);\n// 加载模型\nconst loader = new GLTFLoader().setPath('models/shiba/');\nloader.load('scene.gltf', function (gltf) {\n    scene.add(gltf.scene);\n    render();\n})\n// 创建控件对象, 可以使得相机围绕目标进行轨道运动。\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.addEventListener('change', render);\ncontrols.minDistance = 2; // 能够将相机向内移动多少\ncontrols.maxDistance = 10; // 能够将相机向外移动多少\ncontrols.target.set(0, 0, 0); // 控制器的焦点，轨道围绕它运行\ncontrols.update(); // 更新控制器\n\nfunction render() {\n    renderer.render(scene, camera);\n};\n",normalizedContent:"# three.js\n\n介绍 three.js 之前先需要介绍一下一门计算机基础学科：计算机图形学\n\n\n# 计算机图形学\n\n计算机图形学是一门研究通过计算机将数据转换成图形，并在专门显示设备上显示的原理方法和技术的学科。它是建立在传统的图学理论、应用数学及计算机科学基础上的一门边缘学科。\n\n总而言之计算机图形学是研究怎样利用计算机来显示、生成和处理图形的原理、方法和技术的一门学科，这里的图形是指三维图形的处理。\n\n\n# 1. 电影特效\n\n计算机图形学在电影特效中有着广泛的应用。通过计算机生成的图形，电影制作人员可以创造出各种想象力丰富的特效，例如逼真的爆炸、怪物与外星人、超凡脱俗的场景等。这些特效大大提升了电影的视觉效果，并为故事情节增添了动态和吸引力。\n\n\n\n\n# 2. 游戏开发\n\n计算机图形学在游戏开发中也扮演着重要角色。游戏开发人员使用计算机图形学的技术来设计游戏中的场景、角色和动画效果。通过逼真的渲染和交互性能，计算机图形学为玩家提供了身临其境的游戏体验。\n\n\n\n\n# 3. 虚拟现实\n\n虚拟现实是计算机图形学的一个重要应用领域。借助于计算机图形学的技术，虚拟现实可以模拟出现实世界或虚构世界的场景，并通过头戴式设备等交互工具让用户身临其境地体验。虚拟现实技术已经在游戏、教育、医疗等领域得到了广泛应用。\n\n\n\n\n# 4. 工程设计\n\n计算机图形学在工程设计中也起到了重要的作用。通过使用三维建模和渲染技术，工程师可以设计和模拟出各种产品和建筑的外观和功能，从而实现对设计方案的可视化评估和改善。\n\n\n\n\n\n\n# 计算机图形学、opengl、webgl、three.js 关系\n\n计算机图形学：计算机图形学是一门学科，范畴非常大，被广泛应用于特效、捕捉、动画、设计、模拟与仿真当中。\n\nopengl：是一种c语言标准的库，将各种计算机图形学的成果封装入库，其它开发人员可以非常方便的调用，不需要进行繁复的底层构建工作，便可以实现相关应用的开发。它提供了一组函数和接口，是一种底层的api。\n\nwebgl：webgl是基于javascript的web图形库，它将opengl es 2.0的功能暴露给了web浏览器。webgl允许在web页面上使用gpu加速的2d和3d图形渲染。它是一种用于在web浏览器中创建交互式图形应用程序的技术，无需插件。通过webgl，开发者可以在网页上创建高性能的图形和游戏。\n\nthree.js：three.js是一个用于在web上创建3d图形应用程序的javascript库。它建立在webgl之上，简化了3d图形编程的复杂性。three.js提供了高级的抽象和工具，使开发者能够更容易地创建各种3d场景、对象和特效，而无需深入了解webgl的底层细节。它广泛用于web上的3d游戏、可视化、虚拟现实等应用的开发。\n\n\n\n简而言之，opengl是底层的图形渲染api，webgl是将opengl引入到web浏览器中的技术，而three.js是一个建立在webgl之上的高级javascript库，用于简化web上的3d图形编程。使用three.js可以更容易地创建具有吸引力和互动性的web上的3d图形应用程序。\n\n\n# canvas\n\n看到这里可能会有疑问，那平时我们用过的 canvas 是什么呢？\n\ncanvas 是一个html5标准的2d绘图api，它使用javascript api来绘制图形。canvas提供了一组简单的绘图函数，可以用于绘制图形、文本和图像。canvas通常用于创建简单的2d图形，比如图表、游戏和用户界面。因此，webgl主要用于创建复杂的3d场景，而canvas则用于创建简单的2d图形。当需要处理复杂的3d场景时，使用webgl会更加适合。当只需要创建简单的2d图形时，使用canvas会更加便捷。\n\n\n# three.js\n\n\n\n计算机是如何显示3d物体的? 显示器是二维的, 三维的物体要变成二维的, 一定是经过了某种变换.\n\n这个过程跟照相是很相似的, 照相也是将真实世界(三维的)变成一张照片(二维的), 想象一下是如何照相的:\n\n 1. 找一个好地点, 被照相的人摆好姿势\n 2. 找个好的角度放置相机\n 3. 按下快门\n\n\n# 基础元素\n\n**场景（scene）**相当于一个舞台，我们需要将展示的东西放在这个舞台上。\n\n**照相机（camera）**相当于人的眼睛，我们想要看到物体，就需要眼睛去看。\n\n**光源（light）**物体需要光照才能看见，不然就是漆黑一片（但是在某些情况下展示物体不需要光源）。\n\n**物体（object）**我们想要表现的内容，会有形状和材质属性。\n\n**渲染器（render）**我们可以把渲染器想想成为一个画布，我们需要在这个画布上去画出我们需要展示的东西。\n\n\n\n\n# 场景\n\n场景是一个三维空间，是存放所有物品的容器，可以把场景想象成一个空房间，房间里面可以放置要呈现的物体、相机、光源等。\n\n\n\n场景允许在什么地方、摆放什么东西来交给 three.js 来进行渲染，场景也就是放置物体、灯光和相机的地方。\n\n创建场景：要构件一个场景很简单，只需要new一个场景对象出来即可：\n\nconst scene = new three.scene()\n\n\n\n# 相机\n\n在场景中需要添加一个相机，相机用来确定观察位置、方向、角度，相机看到的内容，就是我们最终在屏幕上看到的内容。在程序运行过程中，可以调整相机的位置、方向、角度。\n\n想象一下，在房间里放了一个摄像机，你不在房间里面，但可以远程控制相机移动，摄像机传给远程电脑上展示出来的画面，就是 three.js 在屏幕上呈现的画面。\n\n相机分为两种 透视投影相机（perspectivecamera）和正交投影相机（orthographiccamera ）\n\n透视投影相机（perspectivecamera）特点透视相机的效果是模拟人眼看到的效果，跟人眼看到的世界是一样的，近大远小。\n\n正交投影相机（orthographiccamera ）特点正交投影则远近都是一样的大小，三维空间中平行的线，投影到二维空间也一定是平行的。\n\n\n\n创建透视投影相机：\n\nconst camera = new three.perspectivecamera(fov, aspect, near, far);\n// 设置相机位置：\ncamera.position.set(5, 10, 10);\n\n\n参数       介绍\nfov      视野：表示摄像机能看到的视野。推荐默认值50\naspect   指定渲染结果水平方向和竖直方向长度的比值，推荐默认值为窗口的宽高比，即window.innerwidth/window.innerheight，如果比例设置的不对，会发现渲染出来的画面有拉伸或者压缩的感觉。\nnear     近端渲染距离：指定从距离摄像机多近的位置开始渲染，推荐默认值0.1\nfar      远端距离：指定摄像机从它所在的位置最远能看到多远，太小场景中的远处不会被渲染，太大会浪费资源影响性能，推荐默认值1000。\n\n\n# 物体\n\n在 three.js 中为我们预设了一些二维和三维几何体模型：\n\nplanegeometry（平面几何体）\n\ncirclegeometry（圆形几何体）\n\nringgeometry（圆环几何体）\n\nboxgeometry（立方几何体）\n\nspheregeometry（球几何体）\n\ncylindergeometry（圆柱几何体）\n\ntorusgeometry（圆环几何体）\n\n// 创建一个长、宽、高均为1个单位的立方体\nconst geometry = new three.boxgeometry(1, 1, 1); \n\n\n\n# 光源\n\n在 three.js 中可以创建出很多不同类型的光源：\n\n**环境光（ambientlight）：**环境光是一种基本光源，它会均匀的照亮场景中的所有物体，环境光没有特定的来源方向，且不会产生阴影。\n\n**聚光灯（spotlight）：**聚光灯（类似手电筒、舞台聚光灯）是从一个方向上的一个点发出，沿着一个圆锥体，它离光越远，它的尺寸就越大。这种光源会产生阴影。\n\n**平行光（directionallight）：**平行光是沿着特定方向发射的光。这种光的表现像是无限远,从它发出的光线都是平行的。常常用平行光来模拟太阳光 的效果; 太阳足够远，因此我们可以认为太阳的位置是无限远，所以我们认为从太阳发出的光线也都是平行的。这种光源会产生阴影。\n\n// 创建光源\nconst spotlight = new three.spotlight(0xffffff);\n// 设置光源位置\nspotlight.position.set(0, 20, 20);\n// 设置光源照射的强度\nspotlight.intensity = 5;\n// 将光源添加到场景中\nscene.add(spotlight);\n\n\n\n# 渲染器\n\n渲染器的作用就是将相机拍摄出的画面在浏览器中呈现出来。渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。\n\nthree.js中有很多种类的渲染器，例如webglrenderer、canvasrenderer、svgrenderer，通常使用的是webglrenderer渲染器。\n\n// 创建webglrenderer渲染器\nconst renderer = new three.webglrenderer();\n // 通过调用 setsize() 方法设置渲染的长宽（设置渲染器为全屏）\nrenderer.setsize(window.innerwidth, window.innerheight);\n // 将渲染结果展示到页面上\ndocument.body.appendchild(renderer.domelement);\n// 创建完渲染器后，需要调用render方法将之前创建好的场景和相机相结合从而渲染出来\nrenderer.render(scene, camera);\n\n\n\n# 三维坐标系\n\n为了方便观察3d图像，添加三维坐标系对象\n\n// 为了方便观察3d图像，添加三维坐标系对象\nconst axes = new three.axishelper(4); // 坐标系轴长设置为 4\n// 把三维坐标系 添加到场景中\nscene.add(axes);\n\n\n\n\n综上使用 three.js，在屏幕上展示 3d 图形的大概步骤：\n\n 1. 创建一个三维空间场景（ scene ）；\n 2. 创建一个相机（ camera ），确定一个观察点，并设置相机的观察方向和角度；\n 3. 创建渲染器，设置渲染器的长宽，将渲染结果展示到页面上；\n 4. 创建物体（几何体、材质、网格）、光源（同时设置光源位置），并添加到场景中去；\n 5. 最后通过渲染器，把场景、相机渲染到页面上。\n\n\n\n\n# three.js 中的数学\n\n\n# 向量\n\n在数学中，向量（也称为矢量），指具有大小（magnitude）和方向的量。它可以形象化地表示为带箭头的线段。\n\n\n\n// 已知两个点的坐标\nconst a = vector3(1, 2, 0)\nconst b = vector3(-2, 1, 2)\n// 求 ab 向量\nconst ab = b.clone().sub(a) // vector3(-3, -1, 2)\n\n\n\n# 点乘\n\n已知两个向量，如何求向量的夹角？\n\n\n\nconst cosinevalue = a.dot(b) / (a.length() * b.length())\n\n\n\n# 叉乘\n\n\n\n几何意义：如果以向量a和b为边构成一个平行四边形，那么这两个向量外积的模长与这个平行四边形的面积相等。\n\n// 声明一个向量对象，用来保存.crossvectors()方法结果\n  const c = new three.vector3();\n  c.crossvectors(a, b);\n\n\n\n# 欧拉角\n\n3d游戏或者3d电影中，比如黑客帝国中酷炫的旋转是怎么实现的？旋转的算法有很多，这里主要介绍其中一种：欧拉角。\n\n\n\n欧拉角是飞控系统中用于描述飞行器姿态的方式，使用三个角度来表示，分别是yaw偏航角、pitch俯仰角、roll 滚转角。\n\n * yaw：偏航角，是指飞行器偏离原来航线的角度。\n * pitch：俯仰角，是指飞行器机头抬起的角度。\n * roll：滚转角，是指飞行器绕着自身头尾轴线翻滚的角度。\n\n\n\nconst a = new three.euler( 0, 1, 1.57, 'xyz'); // 创建一个欧拉对象，'xyz'表示旋转顺序的字符串，默认为大写\nconst b = new three.vector3( 1, 0, 1 ); // 创建一个变量\nb.applyeuler(a); // 将欧拉变换应用到这一向量上\n\n\n\n# 四元数\n\n形如a+bi（a、b均为实数）的数为复数，其中，a被称为实部，b被称为虚部，i为虚数单位，i^2 = -1。\n\n\n\n\n\n四元数的发现者是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的。他花了一生中大部分时间寻找『三维复数』，据说每天早上他儿子都会问他，找没找到三维复数，但他总是说还没有。但是在 1843年10月16日，走过都柏林的布鲁姆桥的时候，他灵光一闪，他需要给复数加上的不是一个维度，而是额外两个假想的维度，即一共三个虚维度来描述空间，而实数在第四个维度，垂直于全部三个虚数轴，他就在桥上刻下了描述这三个虚数单位的等式。\n\n在发现四元数后，他努力地推广四元数，并作为教学生描述三维空间时的第一语言。但当时的反派数学家也没闲着，批判晦涩难懂的四元数是邪恶的，甚至四元数乘法不满足交换律。知道一个世纪之后，四元数在计算机工业界起死回生，程序员把它应用到图像，机器人，以及涉及到3维空间旋转的领域。二十世纪四元数还被应用于另一个重要的领域：量子力学。\n\n\n\n\n\nthree.js 对四元数的数学细节和算法进行了封装。\n\n// 创建一个四元数对象\nconst quaternion = new three.quaternion();\n// 给定旋转轴和旋转角度生成旋转四元数，物体绕z轴旋转90度\nquaternion.setfromaxisangle(new three.vector3(0, 0, 1).normalize(), math.pi / 2);\n// 创建向量\nconst vector = new three.vector3( 1, 0, 0 );\n// 将四元数变换应用在此向量上\nvector.applyquaternion( quaternion );\n\n\n\n# 加载 .gltf/.glb 文件\n\n * gltf 即是 gl transmission format 的缩写。\n * gltf 是一种3d内容的格式标准，由khronos group管理，（khronos group还管理着opengl系列、opencl等重要的行业标准）。\n * gltf 的设计是面向实时渲染应用的，尽量提供可以直接传输给图形api的数据形式，不再需要二次转换。\n * gltf 对opengl es、webgl非常友好。\n * gltf 的目标是：3d领域的jpeg。\n * 作为一个标准，自2015年10月发布（gltf 1.0）以来，已经得到了业界广泛的认可，你可以相信它的水平。\n * gltf目前最新版本为2.0已于2017年6月正式发布。\n\ngltf格式是三维模型格式（json），你可以把gltf格式的三维模型理解为.jpg、.png格式的图片一样。web 开发图片会是常用格式，而对于 web3d 开发，gltf必然成为一个重要的标准格式。\n\n.gltf是文本格式文件，而 .glb 是 .gltf 的二进制格式。\n\nsketchfab 上可以下载 gltf 模型\n\nimport * as three from 'three';\nimport { gltfloader } from 'three/examples/jsm/loaders/gltfloader.js';\nimport { orbitcontrols } from 'three/examples/jsm/controls/orbitcontrols.js';\n// 创建场景\nconst scene = new three.scene();\n// 创建相机\nconst camera = new three.perspectivecamera(\n    50, \n    window.innerwidth / window.innerheight, \n    0.1, \n    1000 \n);\ncamera.position.set(0, 0, 5);\n// 创建渲染器\nconst renderer = new three.webglrenderer();\nrenderer.setsize(window.innerwidth, window.innerheight);\ndocument.body.appendchild(renderer.domelement);\n// 添加光源\nconst spotlight = new three.spotlight(0xffffff);\nspotlight.position.set(0, 20, 20);\nspotlight.intensity = 5;\nscene.add(spotlight);\n// 加载模型\nconst loader = new gltfloader().setpath('models/shiba/');\nloader.load('scene.gltf', function (gltf) {\n    scene.add(gltf.scene);\n    render();\n})\n// 创建控件对象, 可以使得相机围绕目标进行轨道运动。\nconst controls = new orbitcontrols(camera, renderer.domelement);\ncontrols.addeventlistener('change', render);\ncontrols.mindistance = 2; // 能够将相机向内移动多少\ncontrols.maxdistance = 10; // 能够将相机向外移动多少\ncontrols.target.set(0, 0, 0); // 控制器的焦点，轨道围绕它运行\ncontrols.update(); // 更新控制器\n\nfunction render() {\n    renderer.render(scene, camera);\n};\n",charsets:{cjk:!0}},{title:"2022年 7-12月",frontmatter:{},regularPath:"/time/2022b.html",relativePath:"time/2022b.md",key:"v-36664eb2",path:"/time/2022b.html",lastUpdated:"12/8/2022, 7:39:09 PM",lastUpdatedTimestamp:1670499549e3,headersStr:null,content:"# 2022年 7-12月\n\n * ES2016 - ES2022\n\n * 预检请求与重定向\n\n * 当 async/await 遇到 forEach\n\n * React Fiber\n\n * Docker\n\n * JSON.stringify的三个参数\n\n * 单元测试\n\n * Http状态码整理(新增103)\n\n * npm、cnpm、nvm、nrm、yarn、tyarn、npx、pnpm\n\n * 利用 husky 和 lint-staged 构建工作流\n\n * Http协议介绍\n\n * Shell命令",normalizedContent:"# 2022年 7-12月\n\n * es2016 - es2022\n\n * 预检请求与重定向\n\n * 当 async/await 遇到 foreach\n\n * react fiber\n\n * docker\n\n * json.stringify的三个参数\n\n * 单元测试\n\n * http状态码整理(新增103)\n\n * npm、cnpm、nvm、nrm、yarn、tyarn、npx、pnpm\n\n * 利用 husky 和 lint-staged 构建工作流\n\n * http协议介绍\n\n * shell命令",charsets:{cjk:!0}},{title:"2023年 1-6月",frontmatter:{},regularPath:"/time/2023a.html",relativePath:"time/2023a.md",key:"v-3cf55a6b",path:"/time/2023a.html",lastUpdated:"5/18/2023, 3:43:33 PM",lastUpdatedTimestamp:1684395813e3,headersStr:null,content:"# 2023年 1-6月\n\n * 正则捕获组与非捕获组\n\n * chrome 和 vscode 调试工具\n\n * Charles 抓包\n\n * git reset 和 git revert 区别\n\n * Chrome性能分析&性能监视器\n\n * 区块链学习",normalizedContent:"# 2023年 1-6月\n\n * 正则捕获组与非捕获组\n\n * chrome 和 vscode 调试工具\n\n * charles 抓包\n\n * git reset 和 git revert 区别\n\n * chrome性能分析&性能监视器\n\n * 区块链学习",charsets:{cjk:!0}},{title:"贴图",frontmatter:{},regularPath:"/three/three4.html",relativePath:"three/three4.md",key:"v-686968dd",path:"/three/three4.html",headers:[{level:2,title:"自发光",slug:"自发光",normalizedTitle:"自发光",charIndex:765},{level:2,title:"材质的 color 和 emissive",slug:"材质的-color-和-emissive",normalizedTitle:"材质的 color 和 emissive",charIndex:908},{level:2,title:"监听动画 finish 和 loop",slug:"监听动画-finish-和-loop",normalizedTitle:"监听动画 finish 和 loop",charIndex:1251},{level:2,title:"玻璃材质",slug:"玻璃材质",normalizedTitle:"玻璃材质",charIndex:1538},{level:3,title:"EXT_meshopt_compression 简介",slug:"ext-meshopt-compression-简介",normalizedTitle:"ext_meshopt_compression 简介",charIndex:2123},{level:2,title:"压缩模型步骤（以 glTF-Transform 为例）",slug:"压缩模型步骤-以-gltf-transform-为例",normalizedTitle:"压缩模型步骤（以 gltf-transform 为例）",charIndex:2393},{level:3,title:"安装工具",slug:"安装工具",normalizedTitle:"安装工具",charIndex:2425},{level:3,title:"压缩模型",slug:"压缩模型",normalizedTitle:"压缩模型",charIndex:2393},{level:3,title:"3. 在 Three.js 中加载压缩模型",slug:"_3-在-three-js-中加载压缩模型",normalizedTitle:"3. 在 three.js 中加载压缩模型",charIndex:2737},{level:2,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:3046},{level:3,title:"1. 压缩的核心价值：减少传输和存储成本",slug:"_1-压缩的核心价值-减少传输和存储成本",normalizedTitle:"1. 压缩的核心价值：减少传输和存储成本",charIndex:3190},{level:3,title:"2. 解压开销可控，总体收益为正",slug:"_2-解压开销可控-总体收益为正",normalizedTitle:"2. 解压开销可控，总体收益为正",charIndex:3438},{level:3,title:"3. 压缩的附加优化",slug:"_3-压缩的附加优化",normalizedTitle:"3. 压缩的附加优化",charIndex:3634},{level:3,title:"4. 适用场景权衡",slug:"_4-适用场景权衡",normalizedTitle:"4. 适用场景权衡",charIndex:3801},{level:2,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:4008},{level:2,title:"什么是 shader",slug:"什么是-shader",normalizedTitle:"什么是 shader",charIndex:4152},{level:2,title:"为什么 shader 运行特别快",slug:"为什么-shader-运行特别快",normalizedTitle:"为什么 shader 运行特别快",charIndex:4405},{level:2,title:"GLSL是什么？",slug:"glsl是什么",normalizedTitle:"glsl是什么？",charIndex:5142},{level:2,title:"为什么 Shaders 不好学？",slug:"为什么-shaders-不好学",normalizedTitle:"为什么 shaders 不好学？",charIndex:5224},{level:2,title:"顶点着色器和片段着色器",slug:"顶点着色器和片段着色器",normalizedTitle:"顶点着色器和片段着色器",charIndex:5644},{level:2,title:"在 three.js 中实现一个水墨风的 shader",slug:"在-three-js-中实现一个水墨风的-shader",normalizedTitle:"在 three.js 中实现一个水墨风的 shader",charIndex:5824}],lastUpdated:"9/2/2025, 11:24:35 AM",lastUpdatedTimestamp:1756783475e3,headersStr:"自发光 材质的 color 和 emissive 监听动画 finish 和 loop 玻璃材质 EXT_meshopt_compression 简介 压缩模型步骤（以 glTF-Transform 为例） 安装工具 压缩模型 3. 在 Three.js 中加载压缩模型 收益 1. 压缩的核心价值：减少传输和存储成本 2. 解压开销可控，总体收益为正 3. 压缩的附加优化 4. 适用场景权衡 结论 什么是 shader 为什么 shader 运行特别快 GLSL是什么？ 为什么 Shaders 不好学？ 顶点着色器和片段着色器 在 three.js 中实现一个水墨风的 shader",content:"# 贴图\n\n【threeJs笔记】3. Three.js贴图Texture_three js obj 贴纸-CSDN博客\n\nhttps://juejin.cn/post/7311219067118026762\n\n给路面添加纹理贴图（颜色贴图）\n\n\n\n\n\n// 2.1 创建材质，并加载路面颜色贴图\nconst texture = new THREE.TextureLoader().load(TRACK_WATER_TEXTURE);\ntexture.wrapS = THREE.RepeatWrapping;\ntexture.wrapT = THREE.RepeatWrapping;\ntexture.repeat.set(20, 20); // 设置重复次数，数值越大重复次数越多\nconst material = new THREE.MeshStandardMaterial({\n    // color: 0x4193ea,\n    map: texture,\n    // emissive: 0x0426cd,\n    // metalness: 0.5,\n    // roughness: 0.3,\n    // transparent: true,\n    // opacity: 0.9,\n    // fog: this.scene.fog !== undefined,\n});\nmaterial._my_is_water = true; // _my_ 标记为水面材质\nthis.trackWaterModel.traverse(object => {\n    if (object.isMesh) {\n        object.material = material;\n    }\n});\n\n\n\n# 自发光\n\n一开始每个室内场景都需要添加许多光源，导致渲染卡顿。后面替换成了自发光的模型，glb里面自带发光信息，然后把代码中光照删除。\n\nthree.js 如何添加自发光：Three.js自发光贴图 .emissiveMap_threejs 材质通过贴图实现发光-CSDN博客\n\n\n# 材质的 color 和 emissive\n\nhttp://www.webgl3d.cn/pages/57f348/\n\nconst material = new THREE.MeshStandardMaterial({\n    color: 0xfbefb1,\n    alphaMap: this.animationTextures[this.currentFrame],\n    emissive: 0xfbefb1,\n    metalness: 0.3,\n    roughness: 0.3,\n    transparent: true,\n    blending: THREE.AdditiveBlending,\n    depthTest: false,\n});\n\n\n\n# 监听动画 finish 和 loop\n\n小人默认是跑步动作，在小人动作做衔接的时候可能需要等当前跑步动作循环完成后再触发别的动作，所以需要监听动作循环结束。\n\nthis.mixer.addEventListener('finished', e => {\n    console.log(e.action._clip.name);\n    // 动作结束\n});\n\nthis.mixer.addEventListener('loop', e => {\n    console.log(e.action._clip.name);\n    // 动作每次循环后\n});\n\n\n\n# 玻璃材质\n\n场景中有许多国宝陈列在玻璃中，需要给对应的 mesh 增加玻璃材质。\n\n\n\nboliScene.traverse(object => {\n    // 和视觉统一好需要添加 mesh 的 name，找到对应的 mesh 添加玻璃材质\n    if (object.name === '玻璃') {\n        const material = new THREE.MeshPhongMaterial({\n            // color: 0xffffff,\n            // emissive: 0xffffff,\n            // reflectivity: 0.5,\n            // refractionRatio: 0.5,\n            transparent: true,\n            opacity: 0.2,\n        });\n        // 为透明的网格禁用深度写入：这样可以避免玻璃内部的物体在某个角度不见了\n        material.depthWrite = false; \n        object.material = material;\n    }\n});\n\n\n\n# ext_meshopt_compression 模型压缩\n\n\n# EXT_meshopt_compression 简介\n\n * 目标：高效压缩 glTF/GLB 模型的顶点、索引等几何数据，通常可减少**30%~50%**体积。\n * 特点：\n   * 基于无损压缩算法，数据解压后与原始数据完全一致。\n   * 解压速度极快，适合实时应用（如 Web 或游戏）。\n * 支持工具：\n   * glTF-Transform（推荐）\n   * Blender（需插件支持）\n   * Three.js（运行时解码）\n\n----------------------------------------\n\n\n# 压缩模型步骤（以 glTF-Transform 为例）\n\n\n# 安装工具\n\n通过 Node.js 安装命令行工具：\n\nnpm install --global @gltf-transform/cli\n\n\n\n# 压缩模型\n\n使用meshopt压缩命令处理 glTF/GLB 文件：\n\ngltf-transform meshopt input.glb output.glb\n\n\n可选参数：\n\n * --level：压缩级别（0=最快，1=平衡，2=最高压缩率，默认为1）。\n * --keep-points：保留顶点数据不压缩（默认压缩所有属性）。 示例（最高压缩率）：\n\ngltf-transform meshopt input.glb output.glb --level 2\n\n\n\n# 3. 在 Three.js 中加载压缩模型\n\n确保 Three.js 版本 ≥r137，并在初始化时注册扩展，使用GLTFLoader加载压缩后的模型：\n\nimport {MeshoptDecoder} from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\nconst loader = new GLTFLoader();\nloader.setMeshoptDecoder(MeshoptDecoder);\n\n\n\n# 收益\n\n压缩阶段：优化后两个模型分别从 6.4M -> 4.1M 和 7.2M -> 4.2 M，整体减少了 39%\n\n解压阶段：加载模型阶段事件变化基本无新增，（解压速度通常在 1ms 内完成）\n\n整体模型的 loading时间从 2s -> 1.5s，整体减少了 25%\n\n\n\n\n# 1. 压缩的核心价值：减少传输和存储成本\n\n * 压缩阶段：模型在导出或传输前被压缩，文件体积显著减小（通常可减少 50%-80%）。\n * 解压阶段：运行时通过 GPU 或 CPU 快速解压，恢复为原始网格数据供渲染使用。\n * 实际效果：\n   * 加载时间缩短：用户下载/加载模型的时间减少（尤其对 Web 场景关键）。\n   * 带宽成本降低：传输小体积文件节省流量（对移动端或弱网环境友好）。\n\n----------------------------------------\n\n\n# 2. 解压开销可控，总体收益为正\n\n * 解压效率：meshopt算法针对运行时优化，解压速度极快（通常在 1ms 内完成）。\n * CPU vs. 传输时间：解压消耗的 CPU 时间远小于未压缩时等待网络传输的时间。\n * 内存占用：解压后的数据可能通过优化布局（如量化、顶点重排）减少内存占用。\n\n----------------------------------------\n\n\n# 3. 压缩的附加优化\n\n * 顶点/索引优化：meshopt不仅压缩，还会优化顶点顺序、索引缓冲区，可能提升渲染性能。\n * 兼容性：解压过程通常由引擎内置工具（如 Three.js 的MeshoptDecoder）自动处理，无需手动干预。\n\n----------------------------------------\n\n\n# 4. 适用场景权衡\n\n * 推荐使用：\n   * 大型场景（如 3D 地图、游戏关卡）。\n   * 网络传输场景（如 Web 应用、多人在线游戏）。\n   * 资源受限平台（如移动端、VR/AR 设备）。\n * 谨慎使用：\n   * 模型本身已极简（压缩收益有限）。\n   * 运行时解压可能成为瓶颈（需测试解压时间）。\n\n----------------------------------------\n\n\n# 结论\n\n压缩后的模型在运行时解压是合理的权衡：用可控的 CPU 开销换取更快的加载速度和更低的传输成本。对于大多数 3D 应用（尤其是 Web 和移动端），这是性能优化的关键步骤。\n\n\n# shader\n\nhttps://thebookofshaders.com/?lan=ch\n\n\n# 什么是 shader\n\n如果你曾经有用计算机绘图的经验，你就知道在这个过程中你需要画一个圆，然后一个长方形，一条线，一些三角形……直到画出你想要的图像。这个过程很像用手写一封信或一本书 —— 都是一系列的指令，需要你一件一件完成。\n\nShaders 也是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。也就是说，你的代码必须根据像素在屏幕上的不同位置执行不同的操作。就像活字印刷，你的程序就像一个 function（函数），输入位置信息，输出颜色信息，当它编译完之后会以相当快的速度运行。\n\n\n# 为什么 shader 运行特别快\n\n为了回答这个问题，不得不给大家介绍****并行处理****（parallel processing）的神奇之处。\n\n想象你的 CPU 是一个大的工业管道，然后每一个任务都是通过这个管道的某些东西，这些任务需要串行，每个管道通常被称为****线程****。\n\n视频游戏和其他图形应用比起别的程序来说，需要高得多的处理能力。因为它们的图形内容需要操作无数像素。想想看，屏幕上的每一个像素都需要计算，而在 3D 游戏中几何和透视也都需要计算。\n\n让我们回到开始那个关于管道和任务的比喻。屏幕上的每个像素都代表一个最简单的任务。单独来看完成任何一个像素的任务对 CPU 来说都很容易，那么问题来了，屏幕上的每一个像素都需要解决这样的小任务！也就是说，哪怕是对于一个老式的屏幕（分辨率 800x600）来说，都需要每帧处理480000个像素，每秒就需要处理14400000个像素。\n\n这个时候，并行处理就是最好的解决方案。比起用三五个强大的微处理器（或者说“管道”）来处理这些信息，用一大堆小的微处理器来并行计算，就要好得多。这就是图形处理器（GPU : Graphic Processor Unit)的来由。\n\n设想一堆小型微处理器排成一个平面的画面，14400000个像素可以在一秒内阻塞几乎任何管道。但是一面800x600的管道墙，每秒接收30波480000个像素的信息就可以流畅完成。这在更高的分辨率下也是成立的 —— 并行的处理器越多，可以处理的数据流就越大。\n\n另一个 GPU 的魔法是特殊数学函数可通过硬件加速。非常复杂的数学操作可以直接被微芯片解决，而无须通过软件。这就表示可以有更快的三角和矩阵运算 —— 和电流一样快。\n\n\n# GLSL是什么？\n\nGLSL 代表 openGL Shading Language，openGL 着色语言，在 three.js 中也可以编写 GLSL。\n\n\n# 为什么 Shaders 不好学？\n\nGPU 的强大的架构设计也有其限制与不足。\n\n为了能使许多管线并行运行，每一个线程必须与其他的相独立。我们称这些线程对于其他线程在进行的运算是“盲视”的。这个限制就会使得所有数据必须以相同的方向流动。所以就不可能检查其他线程的输出结果，修改输入的数据，或者把一个线程的输出结果输入给另一个线程。允许数据在线程之间线程流动会使数据的整体性面临威胁。\n\n并且 GPU 会让所有并行的微处理器（管道们）一直处在忙碌状态；只要它们一有空闲就会接到新的信息。一个线程不可能知道它前一刻在做什么。它可能是在画操作系统界面上的一个按钮，然后渲染了游戏中的一部分天空，然后显示了一封 email 中的一些文字。每个线程不仅是“盲视”的，而且还是“无记忆”的。同时，它要求编写一个通用的规则，依据像素的不同位置依次输出不同的结果。这种抽象性，和盲视、无记忆的限制使得 shaders 在程序员新手中不是很受欢迎。\n\n\n# 顶点着色器和片段着色器\n\nshader 有两种，在最简配置下，至少都得有两个着色器：一个叫顶点着色器（vertex shader），另一个叫片段着色器（fragment shader）。\n\n顶点着色器负责处理每个顶点的位置，可能还有法线、颜色等信息。每个顶点都会执行一次。\n\n片元着色器则是处理每个像素的颜色和其他属性。每个像素片元都会执行一次代码。\n\n\n# 在 three.js 中实现一个水墨风的 shader\n\n在 three.js 有许多内置的材质，有些时候这些材质不能满足我们的需求，比如下面给一个用 shader 实现的水墨风材质。\n\n// 着色器代码\nconst shaderMaterial = new THREE.ShaderMaterial({\n    vertexShader: `\n        varying vec2 vUv;        // 将 UV 坐标传给片元着色器\n        varying vec3 vNormal;    // 传递法线方向\n        varying vec3 vPosition;  // 传递顶点位置\n        void main() {\n            vUv = uv;                        // 保存 UV 坐标\n            vNormal = normal;                // 保存法线\n            vPosition = position;            // 保存顶点位置\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); // 计算屏幕坐标\n        }\n    `,\n    fragmentShader: `\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        // 简单噪声函数\n        float rand(vec2 n) { \n            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n        }\n        void main() {\n            // 边缘检测（简易版）\n            float edge = length(fwidth(vNormal)) * 2.0; // 计算法线变化的剧烈程度（边缘区域变化大）\n            edge = 1.0 - smoothstep(0.0, 1.5, edge); // 将边缘值转为 0-1 的强度（1代表边缘）\n            // 生成水墨噪声\n            float noise = rand(vUv * 100.0) * 0.2; // 通过 UV 坐标生成噪点（*100 控制噪点密度）\n            // 颜色量化（3个色阶）\n            float color = length(vPosition) * 0.3 + noise; // 混合位置信息和噪点\n            color = floor(color * 3.0) / 3.0; // 将颜色分为 3 个色阶（0, 0.33, 0.66, 1.0）\n            // 组合效果\n            float final = max(color * 0.8, edge * 0.9); // 合并颜色和边缘（深色优先）\n            // 添加纸质纹理\n            float paper = rand(vUv * 50.0) * 0.1; // 生成更细腻的纸质纹理\n            final = clamp(final + paper, 0.0, 1.0); // 叠加纸质噪点并限制范围\n            // 最终颜色（带少许青色）\n            gl_FragColor = vec4(vec3(final * 0.9, final * 1.0, final * 0.95), 1.0); // 通过 RGB 系数调整颜色偏向青灰色（0.9, 1.0, 0.95 加强绿色和蓝色）。\n        }\n    `,\n    side: THREE.DoubleSide, // 双面渲染（防止背面透明）\n});\n\ufeff\n// 创建测试物体\nconst geom = new THREE.TorusKnotGeometry(2, 0.8, 64, 16);\nconst mesh = new THREE.Mesh(geom, shaderMaterial);\nscene.add(mesh);\n\n\n * projectionMatrix 表示的是摄像机的投影矩阵，modelViewMatrix 表示的是场景中物体的位置到真实世界的映射，这两个共同来决定将物体渲染到屏幕的哪个位置。\n * fwidth：是一个GLSL内置函数，用于计算函数在屏幕空间（或者其他坐标系）中x和y方向的变化率，也就是函数沿着x和y方向的梯度。\n * length：用于计算向量的长度（模长）\n * smoothstep：是一个平滑阶梯插值函数，它在两个阈值之间产生平滑的过渡。小于起点时为0，大于终点时为1，在这之间则平滑过渡。\n * clamp：clamp(x,a,b) // 当x<a时返回a,当x>b时返回b,否则返回本身\n\n\n# composer 描边\n\nimport {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';\nimport {OutlinePass} from 'three/addons/postprocessing/OutlinePass.js';\nimport {OutputPass} from 'three/addons/postprocessing/OutputPass.js';\nimport {RenderPass} from 'three/addons/postprocessing/RenderPass.js';\n\nconst composer = new EffectComposer(renderer); // 创建后处理对象EffectComposer，WebGL渲染器作为参数\ncomposer.setPixelRatio(window.devicePixelRatio); // 关键：适配高DPI屏幕\ncomposer.setSize(window.innerWidth, window.innerHeight);\nconst renderPass = new RenderPass(scene, camera); // 创建一个渲染器通道，场景和相机作为参数\ncomposer.addPass(renderPass); // 设置renderPass通道\nconst outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);\noutlinePass.visibleEdgeColor.set('#FFFF00'); // 发光颜色\noutlinePass.hiddenEdgeColor.set('gray'); // 被其它物体挡住部分的颜色\noutlinePass.edgeGlow = 0.0; // 边缘辉光大小\noutlinePass.usePatternTexture = false; // 默认是flase，改成true后仅显示边框\noutlinePass.edgeThickness = 3.0; // 发光厚度\noutlinePass.edgeStrength = 6.0; // 发光强度\noutlinePass.downSampleRatio = 2; // 能改变光的宽度，建议默认不动\noutlinePass.pulsePeriod = 0; // 边缘闪烁，默认为0无闪烁，数值越小，闪的越快\ncomposer.addPass(outlinePass);\nconst outputPass = new OutputPass();\ncomposer.addPass(outputPass);\noutlinePass.selectedObjects = [];\n\n// 给具体的模型添加\nthis.fragmentModel.traverse(obj => {\n    if (obj.type === 'Mesh') {\n        outlinePass.selectedObjects = [obj];\n    }\n});\n\n\n前后效果对比\n\n\n\n注意：若给物体添加了环境光（如hdr）可能会影响描边。\n\n\n# 内存问题\n\n由于重复游戏可能会因为模型卸载不干净或者引用没清除导致内存泄露，建议使用 chrome 自带的内存分析，多次游戏进行前后的内存对比，来查找原因",normalizedContent:"# 贴图\n\n【threejs笔记】3. three.js贴图texture_three js obj 贴纸-csdn博客\n\nhttps://juejin.cn/post/7311219067118026762\n\n给路面添加纹理贴图（颜色贴图）\n\n\n\n\n\n// 2.1 创建材质，并加载路面颜色贴图\nconst texture = new three.textureloader().load(track_water_texture);\ntexture.wraps = three.repeatwrapping;\ntexture.wrapt = three.repeatwrapping;\ntexture.repeat.set(20, 20); // 设置重复次数，数值越大重复次数越多\nconst material = new three.meshstandardmaterial({\n    // color: 0x4193ea,\n    map: texture,\n    // emissive: 0x0426cd,\n    // metalness: 0.5,\n    // roughness: 0.3,\n    // transparent: true,\n    // opacity: 0.9,\n    // fog: this.scene.fog !== undefined,\n});\nmaterial._my_is_water = true; // _my_ 标记为水面材质\nthis.trackwatermodel.traverse(object => {\n    if (object.ismesh) {\n        object.material = material;\n    }\n});\n\n\n\n# 自发光\n\n一开始每个室内场景都需要添加许多光源，导致渲染卡顿。后面替换成了自发光的模型，glb里面自带发光信息，然后把代码中光照删除。\n\nthree.js 如何添加自发光：three.js自发光贴图 .emissivemap_threejs 材质通过贴图实现发光-csdn博客\n\n\n# 材质的 color 和 emissive\n\nhttp://www.webgl3d.cn/pages/57f348/\n\nconst material = new three.meshstandardmaterial({\n    color: 0xfbefb1,\n    alphamap: this.animationtextures[this.currentframe],\n    emissive: 0xfbefb1,\n    metalness: 0.3,\n    roughness: 0.3,\n    transparent: true,\n    blending: three.additiveblending,\n    depthtest: false,\n});\n\n\n\n# 监听动画 finish 和 loop\n\n小人默认是跑步动作，在小人动作做衔接的时候可能需要等当前跑步动作循环完成后再触发别的动作，所以需要监听动作循环结束。\n\nthis.mixer.addeventlistener('finished', e => {\n    console.log(e.action._clip.name);\n    // 动作结束\n});\n\nthis.mixer.addeventlistener('loop', e => {\n    console.log(e.action._clip.name);\n    // 动作每次循环后\n});\n\n\n\n# 玻璃材质\n\n场景中有许多国宝陈列在玻璃中，需要给对应的 mesh 增加玻璃材质。\n\n\n\nboliscene.traverse(object => {\n    // 和视觉统一好需要添加 mesh 的 name，找到对应的 mesh 添加玻璃材质\n    if (object.name === '玻璃') {\n        const material = new three.meshphongmaterial({\n            // color: 0xffffff,\n            // emissive: 0xffffff,\n            // reflectivity: 0.5,\n            // refractionratio: 0.5,\n            transparent: true,\n            opacity: 0.2,\n        });\n        // 为透明的网格禁用深度写入：这样可以避免玻璃内部的物体在某个角度不见了\n        material.depthwrite = false; \n        object.material = material;\n    }\n});\n\n\n\n# ext_meshopt_compression 模型压缩\n\n\n# ext_meshopt_compression 简介\n\n * 目标：高效压缩 gltf/glb 模型的顶点、索引等几何数据，通常可减少**30%~50%**体积。\n * 特点：\n   * 基于无损压缩算法，数据解压后与原始数据完全一致。\n   * 解压速度极快，适合实时应用（如 web 或游戏）。\n * 支持工具：\n   * gltf-transform（推荐）\n   * blender（需插件支持）\n   * three.js（运行时解码）\n\n----------------------------------------\n\n\n# 压缩模型步骤（以 gltf-transform 为例）\n\n\n# 安装工具\n\n通过 node.js 安装命令行工具：\n\nnpm install --global @gltf-transform/cli\n\n\n\n# 压缩模型\n\n使用meshopt压缩命令处理 gltf/glb 文件：\n\ngltf-transform meshopt input.glb output.glb\n\n\n可选参数：\n\n * --level：压缩级别（0=最快，1=平衡，2=最高压缩率，默认为1）。\n * --keep-points：保留顶点数据不压缩（默认压缩所有属性）。 示例（最高压缩率）：\n\ngltf-transform meshopt input.glb output.glb --level 2\n\n\n\n# 3. 在 three.js 中加载压缩模型\n\n确保 three.js 版本 ≥r137，并在初始化时注册扩展，使用gltfloader加载压缩后的模型：\n\nimport {meshoptdecoder} from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport {gltfloader} from 'three/examples/jsm/loaders/gltfloader.js';\nconst loader = new gltfloader();\nloader.setmeshoptdecoder(meshoptdecoder);\n\n\n\n# 收益\n\n压缩阶段：优化后两个模型分别从 6.4m -> 4.1m 和 7.2m -> 4.2 m，整体减少了 39%\n\n解压阶段：加载模型阶段事件变化基本无新增，（解压速度通常在 1ms 内完成）\n\n整体模型的 loading时间从 2s -> 1.5s，整体减少了 25%\n\n\n\n\n# 1. 压缩的核心价值：减少传输和存储成本\n\n * 压缩阶段：模型在导出或传输前被压缩，文件体积显著减小（通常可减少 50%-80%）。\n * 解压阶段：运行时通过 gpu 或 cpu 快速解压，恢复为原始网格数据供渲染使用。\n * 实际效果：\n   * 加载时间缩短：用户下载/加载模型的时间减少（尤其对 web 场景关键）。\n   * 带宽成本降低：传输小体积文件节省流量（对移动端或弱网环境友好）。\n\n----------------------------------------\n\n\n# 2. 解压开销可控，总体收益为正\n\n * 解压效率：meshopt算法针对运行时优化，解压速度极快（通常在 1ms 内完成）。\n * cpu vs. 传输时间：解压消耗的 cpu 时间远小于未压缩时等待网络传输的时间。\n * 内存占用：解压后的数据可能通过优化布局（如量化、顶点重排）减少内存占用。\n\n----------------------------------------\n\n\n# 3. 压缩的附加优化\n\n * 顶点/索引优化：meshopt不仅压缩，还会优化顶点顺序、索引缓冲区，可能提升渲染性能。\n * 兼容性：解压过程通常由引擎内置工具（如 three.js 的meshoptdecoder）自动处理，无需手动干预。\n\n----------------------------------------\n\n\n# 4. 适用场景权衡\n\n * 推荐使用：\n   * 大型场景（如 3d 地图、游戏关卡）。\n   * 网络传输场景（如 web 应用、多人在线游戏）。\n   * 资源受限平台（如移动端、vr/ar 设备）。\n * 谨慎使用：\n   * 模型本身已极简（压缩收益有限）。\n   * 运行时解压可能成为瓶颈（需测试解压时间）。\n\n----------------------------------------\n\n\n# 结论\n\n压缩后的模型在运行时解压是合理的权衡：用可控的 cpu 开销换取更快的加载速度和更低的传输成本。对于大多数 3d 应用（尤其是 web 和移动端），这是性能优化的关键步骤。\n\n\n# shader\n\nhttps://thebookofshaders.com/?lan=ch\n\n\n# 什么是 shader\n\n如果你曾经有用计算机绘图的经验，你就知道在这个过程中你需要画一个圆，然后一个长方形，一条线，一些三角形……直到画出你想要的图像。这个过程很像用手写一封信或一本书 —— 都是一系列的指令，需要你一件一件完成。\n\nshaders 也是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。也就是说，你的代码必须根据像素在屏幕上的不同位置执行不同的操作。就像活字印刷，你的程序就像一个 function（函数），输入位置信息，输出颜色信息，当它编译完之后会以相当快的速度运行。\n\n\n# 为什么 shader 运行特别快\n\n为了回答这个问题，不得不给大家介绍****并行处理****（parallel processing）的神奇之处。\n\n想象你的 cpu 是一个大的工业管道，然后每一个任务都是通过这个管道的某些东西，这些任务需要串行，每个管道通常被称为****线程****。\n\n视频游戏和其他图形应用比起别的程序来说，需要高得多的处理能力。因为它们的图形内容需要操作无数像素。想想看，屏幕上的每一个像素都需要计算，而在 3d 游戏中几何和透视也都需要计算。\n\n让我们回到开始那个关于管道和任务的比喻。屏幕上的每个像素都代表一个最简单的任务。单独来看完成任何一个像素的任务对 cpu 来说都很容易，那么问题来了，屏幕上的每一个像素都需要解决这样的小任务！也就是说，哪怕是对于一个老式的屏幕（分辨率 800x600）来说，都需要每帧处理480000个像素，每秒就需要处理14400000个像素。\n\n这个时候，并行处理就是最好的解决方案。比起用三五个强大的微处理器（或者说“管道”）来处理这些信息，用一大堆小的微处理器来并行计算，就要好得多。这就是图形处理器（gpu : graphic processor unit)的来由。\n\n设想一堆小型微处理器排成一个平面的画面，14400000个像素可以在一秒内阻塞几乎任何管道。但是一面800x600的管道墙，每秒接收30波480000个像素的信息就可以流畅完成。这在更高的分辨率下也是成立的 —— 并行的处理器越多，可以处理的数据流就越大。\n\n另一个 gpu 的魔法是特殊数学函数可通过硬件加速。非常复杂的数学操作可以直接被微芯片解决，而无须通过软件。这就表示可以有更快的三角和矩阵运算 —— 和电流一样快。\n\n\n# glsl是什么？\n\nglsl 代表 opengl shading language，opengl 着色语言，在 three.js 中也可以编写 glsl。\n\n\n# 为什么 shaders 不好学？\n\ngpu 的强大的架构设计也有其限制与不足。\n\n为了能使许多管线并行运行，每一个线程必须与其他的相独立。我们称这些线程对于其他线程在进行的运算是“盲视”的。这个限制就会使得所有数据必须以相同的方向流动。所以就不可能检查其他线程的输出结果，修改输入的数据，或者把一个线程的输出结果输入给另一个线程。允许数据在线程之间线程流动会使数据的整体性面临威胁。\n\n并且 gpu 会让所有并行的微处理器（管道们）一直处在忙碌状态；只要它们一有空闲就会接到新的信息。一个线程不可能知道它前一刻在做什么。它可能是在画操作系统界面上的一个按钮，然后渲染了游戏中的一部分天空，然后显示了一封 email 中的一些文字。每个线程不仅是“盲视”的，而且还是“无记忆”的。同时，它要求编写一个通用的规则，依据像素的不同位置依次输出不同的结果。这种抽象性，和盲视、无记忆的限制使得 shaders 在程序员新手中不是很受欢迎。\n\n\n# 顶点着色器和片段着色器\n\nshader 有两种，在最简配置下，至少都得有两个着色器：一个叫顶点着色器（vertex shader），另一个叫片段着色器（fragment shader）。\n\n顶点着色器负责处理每个顶点的位置，可能还有法线、颜色等信息。每个顶点都会执行一次。\n\n片元着色器则是处理每个像素的颜色和其他属性。每个像素片元都会执行一次代码。\n\n\n# 在 three.js 中实现一个水墨风的 shader\n\n在 three.js 有许多内置的材质，有些时候这些材质不能满足我们的需求，比如下面给一个用 shader 实现的水墨风材质。\n\n// 着色器代码\nconst shadermaterial = new three.shadermaterial({\n    vertexshader: `\n        varying vec2 vuv;        // 将 uv 坐标传给片元着色器\n        varying vec3 vnormal;    // 传递法线方向\n        varying vec3 vposition;  // 传递顶点位置\n        void main() {\n            vuv = uv;                        // 保存 uv 坐标\n            vnormal = normal;                // 保存法线\n            vposition = position;            // 保存顶点位置\n            gl_position = projectionmatrix * modelviewmatrix * vec4(position, 1.0); // 计算屏幕坐标\n        }\n    `,\n    fragmentshader: `\n        varying vec2 vuv;\n        varying vec3 vnormal;\n        varying vec3 vposition;\n        // 简单噪声函数\n        float rand(vec2 n) { \n            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n        }\n        void main() {\n            // 边缘检测（简易版）\n            float edge = length(fwidth(vnormal)) * 2.0; // 计算法线变化的剧烈程度（边缘区域变化大）\n            edge = 1.0 - smoothstep(0.0, 1.5, edge); // 将边缘值转为 0-1 的强度（1代表边缘）\n            // 生成水墨噪声\n            float noise = rand(vuv * 100.0) * 0.2; // 通过 uv 坐标生成噪点（*100 控制噪点密度）\n            // 颜色量化（3个色阶）\n            float color = length(vposition) * 0.3 + noise; // 混合位置信息和噪点\n            color = floor(color * 3.0) / 3.0; // 将颜色分为 3 个色阶（0, 0.33, 0.66, 1.0）\n            // 组合效果\n            float final = max(color * 0.8, edge * 0.9); // 合并颜色和边缘（深色优先）\n            // 添加纸质纹理\n            float paper = rand(vuv * 50.0) * 0.1; // 生成更细腻的纸质纹理\n            final = clamp(final + paper, 0.0, 1.0); // 叠加纸质噪点并限制范围\n            // 最终颜色（带少许青色）\n            gl_fragcolor = vec4(vec3(final * 0.9, final * 1.0, final * 0.95), 1.0); // 通过 rgb 系数调整颜色偏向青灰色（0.9, 1.0, 0.95 加强绿色和蓝色）。\n        }\n    `,\n    side: three.doubleside, // 双面渲染（防止背面透明）\n});\n\ufeff\n// 创建测试物体\nconst geom = new three.torusknotgeometry(2, 0.8, 64, 16);\nconst mesh = new three.mesh(geom, shadermaterial);\nscene.add(mesh);\n\n\n * projectionmatrix 表示的是摄像机的投影矩阵，modelviewmatrix 表示的是场景中物体的位置到真实世界的映射，这两个共同来决定将物体渲染到屏幕的哪个位置。\n * fwidth：是一个glsl内置函数，用于计算函数在屏幕空间（或者其他坐标系）中x和y方向的变化率，也就是函数沿着x和y方向的梯度。\n * length：用于计算向量的长度（模长）\n * smoothstep：是一个平滑阶梯插值函数，它在两个阈值之间产生平滑的过渡。小于起点时为0，大于终点时为1，在这之间则平滑过渡。\n * clamp：clamp(x,a,b) // 当x<a时返回a,当x>b时返回b,否则返回本身\n\n\n# composer 描边\n\nimport {effectcomposer} from 'three/addons/postprocessing/effectcomposer.js';\nimport {outlinepass} from 'three/addons/postprocessing/outlinepass.js';\nimport {outputpass} from 'three/addons/postprocessing/outputpass.js';\nimport {renderpass} from 'three/addons/postprocessing/renderpass.js';\n\nconst composer = new effectcomposer(renderer); // 创建后处理对象effectcomposer，webgl渲染器作为参数\ncomposer.setpixelratio(window.devicepixelratio); // 关键：适配高dpi屏幕\ncomposer.setsize(window.innerwidth, window.innerheight);\nconst renderpass = new renderpass(scene, camera); // 创建一个渲染器通道，场景和相机作为参数\ncomposer.addpass(renderpass); // 设置renderpass通道\nconst outlinepass = new outlinepass(new three.vector2(window.innerwidth, window.innerheight), scene, camera);\noutlinepass.visibleedgecolor.set('#ffff00'); // 发光颜色\noutlinepass.hiddenedgecolor.set('gray'); // 被其它物体挡住部分的颜色\noutlinepass.edgeglow = 0.0; // 边缘辉光大小\noutlinepass.usepatterntexture = false; // 默认是flase，改成true后仅显示边框\noutlinepass.edgethickness = 3.0; // 发光厚度\noutlinepass.edgestrength = 6.0; // 发光强度\noutlinepass.downsampleratio = 2; // 能改变光的宽度，建议默认不动\noutlinepass.pulseperiod = 0; // 边缘闪烁，默认为0无闪烁，数值越小，闪的越快\ncomposer.addpass(outlinepass);\nconst outputpass = new outputpass();\ncomposer.addpass(outputpass);\noutlinepass.selectedobjects = [];\n\n// 给具体的模型添加\nthis.fragmentmodel.traverse(obj => {\n    if (obj.type === 'mesh') {\n        outlinepass.selectedobjects = [obj];\n    }\n});\n\n\n前后效果对比\n\n\n\n注意：若给物体添加了环境光（如hdr）可能会影响描边。\n\n\n# 内存问题\n\n由于重复游戏可能会因为模型卸载不干净或者引用没清除导致内存泄露，建议使用 chrome 自带的内存分析，多次游戏进行前后的内存对比，来查找原因",charsets:{cjk:!0}},{title:"babel",frontmatter:{},regularPath:"/tool/babel.html",relativePath:"tool/babel.md",key:"v-31f17df6",path:"/tool/babel.html",headers:[{level:2,title:"安装与使用",slug:"安装与使用",normalizedTitle:"安装与使用",charIndex:185},{level:2,title:"@babel/preset-env",slug:"babel-preset-env",normalizedTitle:"@babel/preset-env",charIndex:539},{level:2,title:"@babel/polyfill",slug:"babel-polyfill",normalizedTitle:"@babel/polyfill",charIndex:2005},{level:2,title:"@babel/runtime",slug:"babel-runtime",normalizedTitle:"@babel/runtime",charIndex:2676},{level:2,title:"@babel/plugin-transform-runtime",slug:"babel-plugin-transform-runtime",normalizedTitle:"@babel/plugin-transform-runtime",charIndex:2693},{level:2,title:"@babel/register",slug:"babel-register",normalizedTitle:"@babel/register",charIndex:3451}],lastUpdated:"3/1/2022, 3:30:47 PM",lastUpdatedTimestamp:1646119847e3,headersStr:"安装与使用 @babel/preset-env @babel/polyfill @babel/runtime @babel/plugin-transform-runtime @babel/register",content:'# babel\n\n本文部分转载于Babel教程\n\nThe compiler for writing next generation JavaScript\n\n简单翻译下就是“用于编写下一代JavaScript的编译器”。Babel是一个工具集，主要用于将ES6版本的JavaScript代码转为ES5等向后兼容的JS代码，从而可以运行在低版本浏览器或其它环境中。\n\n\n# 安装与使用\n\nBabel依赖Node.js，没有安装的话，去官网下载安装最新稳定版本的Node.js。\n\n在本地新建一个文件夹，在该文件夹下新建一个js文件，文件命名为babel.config.js。该文件是 Babel配置文件 ，我们在该文件里输入如下内容：\n\nmodule.exports = {\n  presets: ["@babel/env"],\n  plugins: []\n}\n\n\n然后在该文件夹下新建一个js文件main.js，该js里的代码是我们需要转译的，我们写入代码\n\nvar fn = (num) => num + 2;\n\n\n然后执行下面的命令安装三个npm包，这些npm包是Babel官方包\n\nnpm install --save-dev @babel/cli @babel/core @babel/preset-env\n\n\n安装完成后，执行下面的命令进行转码，该命令含义是把 main.js 转码生成 compiled.js 文件\n\nnpx babel main.js -o compiled.js\n\n\n此时文件夹下会生成compiled.js，该文件是转换后的代码：\n\n"use strict";\nvar fn = function fn(num) {\n  return num + 2;\n};\n\n\n这就是一个最简单的Babel使用过程，我们把用ES6编写main.js转换成了ES5的compiled.js。\n\n * @babel/cli是Babel命令行转码工具，如果我们使用命令行进行Babel转码就需要安装它。\n * @babel/cli依赖@babel/core，因此也需要安装@babel/core这个Babel核心npm包。\n * @babel/preset-env这个npm包提供了ES6转换ES5的语法转换规则，我们在Babel配置文件里指定使用它。如果不使用的话，也可以完成转码，但转码后的代码仍然是ES6的，相当于没有转码。\n\n\n# @babel/preset-env\n\nBabel插件的数量非常多，处理ES2015的有\n\n * @babel/plugin-transform-arrow-functions\n * @babel/plugin-transform-block-scoped-functions\n * @babel/plugin-transform-block-scoping ......\n\nBabel插件实在太多，假如只配置插件数组，那我们前端工程要把ES2015,ES2016,ES2017...下的所有插件都写到配置项里，我们的Babel配置文件会非常臃肿。\n\npreset预设就是帮我们解决这个问题的。预设是一组Babel插件的集合：\n\n * @babel/preset-env\n * @babel/preset-react\n * @babel/preset-typescript\n * babel-preset-es2015\n\n2017年Babel 的官网上在9月宣布 ES2015 / ES2016/ ES2017 等等 ES20xx 时代的 presets 通通被废弃（deprecated），取而代之的是 babel-preset-env，并且承诺它将成为“未来不会过时的（future-proof）”解决方案。在Babel7之后，babel-preset-env 的名字是 @babel/preset-env。\n\n也就是说： babel preset 将基于你的实际浏览器及运行环境，自动的确定babel插件及polyfills，转译ES2015及此版本以上的语言。\n\n在没有配置项的情况下，@babel/preset-env 表现的同 babel-preset-latest 一样(或者可以说同 babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017 结合到一起，表现的一致。所以那么多的 preset 预设，现在只需一个 @babel/preset-env 就可以了。\n\n{\n  "presets": [\n    ["@babel/preset-env"]\n  ]\n}\n\n\nBabel教程7：Babel配置文件\n\nBabel教程10：@babel/preset-env\n\n\n# @babel/polyfill\n\nvar fn = (num) => num + 2;\nvar promise = Promise.resolve(\'ok\')\n\n\n执行命令：\n\nnpx babel main.js -o compiled.js\n\n\n生成 compiled.js 如下：\n\n"use strict";\nvar fn = function fn(num) {\n  return num + 2;\n};\nvar promise = Promise.resolve(\'ok\');\n\n\n我们发现Babel并没有对ES6的Promise进行转换 ，在比较老的浏览器（ 例如火狐27 ）里打开引入后控制台会报错：Promise is not defined。\n\n> 为何 Babel没有对ES6的Promise进行转换 ？\n> \n> 因为Babel默认只转换新的JavaScript语法（syntax），而不转换新的 API。\n> \n> 新的API分类两类，一类是Promise、Map、Symbol、Proxy、Iterator等全局对象及其对象自身的方法，例如Object.assign，Promise.resolve；另一类是新的实例方法，例如数组实例方法[1, 4, -5, 10].find((item) => item < 0)\n\n缺点：babel-polyfill比较简单粗暴，在引入的同时，也污染了全局对象，导致无效增加了很多用不到的polyfill，也可能会污染子模块的变量引用，可能导致不必要的冲突。我们目前一般会使用 @babel/runtime 和 @babel/plugin-transform-runtime\n\n\n# @babel/runtime\n\nbabel-runtime 和 babel-polyfill有点类似，都是去兼容新API的“垫片”，它和 babel-polyfill 最大的不同就是可以做到按需引用，哪里需要什么就用什么，比如我需要Promise。一般在生成环境，首先安装依赖，然后引入：\n\n// npm install --save babel-runtime\nimport Promise from \'babel-runtime/core-js/promise\';\n\n\n\n# @babel/plugin-transform-runtime\n\n如果用 @babel/runtime，如果我10个文件要引用Promise，难道每个文件都得写个 @babel/runtime的Promise引入么，显然很麻烦。那么 @babel/plugin-transform-runtime就是用来解决这个问题的，无论你多少个文件引入了相关新的API，它只会存在一份，@babel/plugin-transform-runtime 本质上依赖于 babel-runtime 的 core-js，在编译的时候会帮你自动处理，在开发环境安装依赖：\n\nnpm install --save-dev @babel/plugin-transform-runtime\n\n\n你只需要配置：\n\n{\n  "plugins": [\n    "@babel/plugin-transform-runtime"\n  ]\n}\n\n\n> 综上，我们最常用的预设是 @babel/preset-env，最常用的插件是 @babel/plugin-transform-runtime\n\n\n# @babel/register\n\nbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。\n\nnpm install --save-dev @babel/register\n\n\n使用时，必须首先加载babel-register。\n\nrequire("babel-register");\nrequire("./index.js");\n\n\n然后，就不需要手动对index.js转码了。\n\n需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n默认忽略 node_modules\n\n注意： 默认情况下，所有对 node_modules 目录下的文件的 require 请求都将被忽略。你可以通过以下方式传递一个用于匹配被忽略文件的正则表达式来修改默认行为：\n\nrequire("@babel/register")({\n  // When a file path matches this regex then it is not compiled\n  ignore: [],\n  \n  // It will not be compiled if `true` is returned.\n  function(filepath) {\n      return filepath !== "/path/to/es6-file.js";\n  }\n});\n',normalizedContent:'# babel\n\n本文部分转载于babel教程\n\nthe compiler for writing next generation javascript\n\n简单翻译下就是“用于编写下一代javascript的编译器”。babel是一个工具集，主要用于将es6版本的javascript代码转为es5等向后兼容的js代码，从而可以运行在低版本浏览器或其它环境中。\n\n\n# 安装与使用\n\nbabel依赖node.js，没有安装的话，去官网下载安装最新稳定版本的node.js。\n\n在本地新建一个文件夹，在该文件夹下新建一个js文件，文件命名为babel.config.js。该文件是 babel配置文件 ，我们在该文件里输入如下内容：\n\nmodule.exports = {\n  presets: ["@babel/env"],\n  plugins: []\n}\n\n\n然后在该文件夹下新建一个js文件main.js，该js里的代码是我们需要转译的，我们写入代码\n\nvar fn = (num) => num + 2;\n\n\n然后执行下面的命令安装三个npm包，这些npm包是babel官方包\n\nnpm install --save-dev @babel/cli @babel/core @babel/preset-env\n\n\n安装完成后，执行下面的命令进行转码，该命令含义是把 main.js 转码生成 compiled.js 文件\n\nnpx babel main.js -o compiled.js\n\n\n此时文件夹下会生成compiled.js，该文件是转换后的代码：\n\n"use strict";\nvar fn = function fn(num) {\n  return num + 2;\n};\n\n\n这就是一个最简单的babel使用过程，我们把用es6编写main.js转换成了es5的compiled.js。\n\n * @babel/cli是babel命令行转码工具，如果我们使用命令行进行babel转码就需要安装它。\n * @babel/cli依赖@babel/core，因此也需要安装@babel/core这个babel核心npm包。\n * @babel/preset-env这个npm包提供了es6转换es5的语法转换规则，我们在babel配置文件里指定使用它。如果不使用的话，也可以完成转码，但转码后的代码仍然是es6的，相当于没有转码。\n\n\n# @babel/preset-env\n\nbabel插件的数量非常多，处理es2015的有\n\n * @babel/plugin-transform-arrow-functions\n * @babel/plugin-transform-block-scoped-functions\n * @babel/plugin-transform-block-scoping ......\n\nbabel插件实在太多，假如只配置插件数组，那我们前端工程要把es2015,es2016,es2017...下的所有插件都写到配置项里，我们的babel配置文件会非常臃肿。\n\npreset预设就是帮我们解决这个问题的。预设是一组babel插件的集合：\n\n * @babel/preset-env\n * @babel/preset-react\n * @babel/preset-typescript\n * babel-preset-es2015\n\n2017年babel 的官网上在9月宣布 es2015 / es2016/ es2017 等等 es20xx 时代的 presets 通通被废弃（deprecated），取而代之的是 babel-preset-env，并且承诺它将成为“未来不会过时的（future-proof）”解决方案。在babel7之后，babel-preset-env 的名字是 @babel/preset-env。\n\n也就是说： babel preset 将基于你的实际浏览器及运行环境，自动的确定babel插件及polyfills，转译es2015及此版本以上的语言。\n\n在没有配置项的情况下，@babel/preset-env 表现的同 babel-preset-latest 一样(或者可以说同 babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017 结合到一起，表现的一致。所以那么多的 preset 预设，现在只需一个 @babel/preset-env 就可以了。\n\n{\n  "presets": [\n    ["@babel/preset-env"]\n  ]\n}\n\n\nbabel教程7：babel配置文件\n\nbabel教程10：@babel/preset-env\n\n\n# @babel/polyfill\n\nvar fn = (num) => num + 2;\nvar promise = promise.resolve(\'ok\')\n\n\n执行命令：\n\nnpx babel main.js -o compiled.js\n\n\n生成 compiled.js 如下：\n\n"use strict";\nvar fn = function fn(num) {\n  return num + 2;\n};\nvar promise = promise.resolve(\'ok\');\n\n\n我们发现babel并没有对es6的promise进行转换 ，在比较老的浏览器（ 例如火狐27 ）里打开引入后控制台会报错：promise is not defined。\n\n> 为何 babel没有对es6的promise进行转换 ？\n> \n> 因为babel默认只转换新的javascript语法（syntax），而不转换新的 api。\n> \n> 新的api分类两类，一类是promise、map、symbol、proxy、iterator等全局对象及其对象自身的方法，例如object.assign，promise.resolve；另一类是新的实例方法，例如数组实例方法[1, 4, -5, 10].find((item) => item < 0)\n\n缺点：babel-polyfill比较简单粗暴，在引入的同时，也污染了全局对象，导致无效增加了很多用不到的polyfill，也可能会污染子模块的变量引用，可能导致不必要的冲突。我们目前一般会使用 @babel/runtime 和 @babel/plugin-transform-runtime\n\n\n# @babel/runtime\n\nbabel-runtime 和 babel-polyfill有点类似，都是去兼容新api的“垫片”，它和 babel-polyfill 最大的不同就是可以做到按需引用，哪里需要什么就用什么，比如我需要promise。一般在生成环境，首先安装依赖，然后引入：\n\n// npm install --save babel-runtime\nimport promise from \'babel-runtime/core-js/promise\';\n\n\n\n# @babel/plugin-transform-runtime\n\n如果用 @babel/runtime，如果我10个文件要引用promise，难道每个文件都得写个 @babel/runtime的promise引入么，显然很麻烦。那么 @babel/plugin-transform-runtime就是用来解决这个问题的，无论你多少个文件引入了相关新的api，它只会存在一份，@babel/plugin-transform-runtime 本质上依赖于 babel-runtime 的 core-js，在编译的时候会帮你自动处理，在开发环境安装依赖：\n\nnpm install --save-dev @babel/plugin-transform-runtime\n\n\n你只需要配置：\n\n{\n  "plugins": [\n    "@babel/plugin-transform-runtime"\n  ]\n}\n\n\n> 综上，我们最常用的预设是 @babel/preset-env，最常用的插件是 @babel/plugin-transform-runtime\n\n\n# @babel/register\n\nbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用babel进行转码。\n\nnpm install --save-dev @babel/register\n\n\n使用时，必须首先加载babel-register。\n\nrequire("babel-register");\nrequire("./index.js");\n\n\n然后，就不需要手动对index.js转码了。\n\n需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n默认忽略 node_modules\n\n注意： 默认情况下，所有对 node_modules 目录下的文件的 require 请求都将被忽略。你可以通过以下方式传递一个用于匹配被忽略文件的正则表达式来修改默认行为：\n\nrequire("@babel/register")({\n  // when a file path matches this regex then it is not compiled\n  ignore: [],\n  \n  // it will not be compiled if `true` is returned.\n  function(filepath) {\n      return filepath !== "/path/to/es6-file.js";\n  }\n});\n',charsets:{cjk:!0}},{title:"单反和微单",frontmatter:{},regularPath:"/tool/camera.html",relativePath:"tool/camera.md",key:"v-4871443f",path:"/tool/camera.html",headers:[{level:2,title:"单反和微单",slug:"单反和微单",normalizedTitle:"单反和微单",charIndex:2},{level:2,title:"曝光三要素",slug:"曝光三要素",normalizedTitle:"曝光三要素",charIndex:366},{level:3,title:"光圈",slug:"光圈",normalizedTitle:"光圈",charIndex:373},{level:3,title:"快门",slug:"快门",normalizedTitle:"快门",charIndex:66},{level:3,title:"感光度",slug:"感光度",normalizedTitle:"感光度",charIndex:379},{level:2,title:"焦距（焦段）",slug:"焦距-焦段",normalizedTitle:"焦距（焦段）",charIndex:1041},{level:2,title:"白平衡",slug:"白平衡",normalizedTitle:"白平衡",charIndex:1593},{level:2,title:"测光",slug:"测光",normalizedTitle:"测光",charIndex:2259},{level:2,title:"人像参数",slug:"人像参数",normalizedTitle:"人像参数",charIndex:2758},{level:2,title:"逆光怎么拍",slug:"逆光怎么拍",normalizedTitle:"逆光怎么拍",charIndex:2986}],lastUpdated:"5/29/2024, 1:12:54 PM",lastUpdatedTimestamp:1716959574e3,headersStr:"单反和微单 曝光三要素 光圈 快门 感光度 焦距（焦段） 白平衡 测光 人像参数 逆光怎么拍",content:"# 单反和微单\n\n单反：单镜头反光照相机\n\n * 画面进入镜头，经过反光板反射五棱镜折射，从光学取景器中就可以看到成像。\n * 按下快门，反光板抬起，画面进入 CMOS，成为了照片。\n\n\n\n\n\n微单：无反相机\n\n * 没有反光板，光线透过镜头直接落在传感器上，再通过光电信号的转化，显示在电子取景器里。\n\n\n\n对比：\n\n * 重量：同样像素，微单更轻。\n * 对焦：单反的取景和对焦是两个系统，在反光板的旁边还有一个小的反光板，将光线反射进对焦模块上（本质也是个传感器），对焦模块有多大，对焦的范围就有多大。而微单直接将对焦集成到 CMOS 上，兼顾了对焦和成像，使得对焦点可以完全铺满整个 CMOS，可以全屏对焦追焦\n\n\n\n> 总结：微单更轻更小更强，只是因为单反硕大的外观，繁多的按键，先入为主的定位看起来更专业而已。\n\n\n# 曝光三要素\n\n光圈、快门、感光度（ISO）\n\n\n# 光圈\n\n用来控制相机进光量多少的装置，它通常存在镜头内，由一组可开合的叶片组成。在相机上用 F 表示。\n\nF = 镜头焦距 / 通光孔直径\n\n根据公式就解释了，为什么 光圈值 F 越大，实际光圈越小。\n\n * 光圈 F 值越大，光圈越小，通光量变小，画面变暗，景深越深\n * 光圈 F 值越小，光圈越大，通光量变大，画面变亮，景深越浅\n\n> 景深指的是焦点范围相对清晰的这一区间。所以光圈另一个重要的应用就是实现背景模糊。\n> \n> 光圈越小，景深越深，物体越清晰；光圈越大，景深越浅，更容易实现背景模糊的效果。\n> \n> 类似于近视眼的人，眯起眼睛相当于光圈变小，会看的更清晰。\n\n * 大光圈更适合拍摄人像，希望主体从杂乱的背景中突出\n * 小光圈更适合拍摄风景，希望全局清晰的大场景\n\n在设计光圈的时候，相邻两档的透光亮要相差一倍，也就是面积要相差一倍，直径则相差 1.2 倍，所以整数档光圈会呈现 1.4 倍的倍数关系\n\n> F1.4 => F2.0 => F2.8 => F4.0 => F5.6 => F8.0 ....\n\n\n# 快门\n\n控制光线进入相机时间长短的装置，单位是 s，时间越长，接收到的光线也就越多。\n\n * 高速快门：适用于抓拍运动物体，会更加清晰。\n * 慢速快门：能拍到运动轨迹，适用于拍车的轨迹，细水长流的感觉\n\n\n# 感光度\n\n对光线的敏感度，适用于在光圈和快门调整后仍然很暗，或者阴天的环境下提高亮度。\n\n正因为提高了光线敏感度所以也可能会出现噪点。\n\n\n# 焦距（焦段）\n\n焦距：凸透镜的光学中心到焦点的距离，当然相机不止一个镜片，只需要理解即可。焦距是一个固定的值，如 16mm 焦距，24mm焦距，如果达到 3000mm 就属于望远镜了\n\n焦段：一般指焦距的范围，比如 16-35mm，24-70mm\n\n> 焦距越短，视角越广；焦距越长，视角越窄\n\n * 超广角：20mm以下\n * 广角：20mm-40mm\n * 标准焦段：40mm-60mm\n * 长焦：60mm以上\n\n> 其中 40mm-60mm 标准焦段最接近人的眼睛，50mm小痰盂是一个比较火的镜头\n\n * 数字变焦：放大裁剪图片达到类似于增加焦距的效果。\n * 光学变焦：通过光学镜头结构来实现变焦，比数字变焦会更清晰。\n * 长焦镜头：有压缩空间的效果\n * 广角镜头：有拉伸空间的效果，比如房产中间拍摄房间视频。\n\n> 希区柯克变焦：是电影制作中的流行元素，镜头中的主体大小不变，而背景大小改变。会有一种背景不断涌动的感觉。\n\n焦距并不能改变透视关系（近大远小），只有距离才能。这就相当于你拿一个长焦镜头拍的画面和拿一个广角镜头拍的画面再经过裁切得到的透视关系是相同的，只是长焦镜头的会更清晰一些。\n\n所以想改变透视关系形成空间压缩的感觉就需要远离被拍物体，然后使用长焦镜头拍摄。\n\n\n# 白平衡\n\n色温：环境中客观存在的光源颜色，随温度越高，颜色呈现 红（1000K） => 白（5500K） => 蓝（8000K）\n\n> 一个物体的温度越高，则它辐射的电磁波波长越短，其中可见光里，红橙黄绿蓝靛紫，红光光波最长，紫光光波最短，所以暖色调的物体温度比冷色调的物体温度低。\n\n * 日出日落：2000K - 3000K\n * 晴天正午：5000K - 6000K\n * 阴天色温：6000K - 7000K\n\n白平衡：人为控制相机设置用来平衡环境的色温，还原现实中物体原本的颜色（让白色的物体恢复白色），即把白平衡的K值和色温的K值调整为相同即可。K值越低画面越冷，K值越高画面越暖，与色温正好相反。\n\n> 色温 > 白平衡：画面偏冷\n> \n> 色温 < 白平衡：画面偏暖\n> \n> 色温 = 白平衡：物体本色\n\n * 如果想画面温馨，白平衡设置为 6000K - 7000K\n * 如果想冷清孤独：白平衡设置为 3000K - 4000K\n\n如果画面偏绿了怎么办？可以用白平衡偏移：在白平衡的基础上进行额外的偏色。\n\n可以在相机的色彩偏移界面向绿色的对角线方向移动即可。\n\n\n\n其实这里我们可以用色彩偏移来制造氛围感，A：红色，B：蓝色，G：绿色，M：洋红色\n\n风格按一二三四象限：\n\n * 红绿色：港风\n * 蓝绿色：小清新风格\n * 蓝粉色：法式风格\n * 红粉色：复古风格\n\n> 调整白平衡的统一标准一般是让任务肤色保持在一个健康写实的范围。\n> \n> 黄种人的皮肤可以在还原白色的情况下再往冷色调调一些\n\n\n# 测光\n\n测光：相机根据检测到的光线明暗情况来设置机内参数，让我们可以拍出明暗合适的照片。\n\n我们之所以能看到五彩斑斓的世界是因为物体会吸收和反射出一定的光，而当我们去掉颜色时照片使用灰度表示亮度的，从暗到亮分别为，黑（反射率3%），灰（反射率18%），白（反射率90%），其中灰色为亮度正常的部分，也就是常说的18度灰，这就是相机认为的正常曝光，所以调节测光模式就是你想把那个地方拍成正常亮度。\n\n测光物体在白雪上时，因为白色本来反射率就具有很高亮度就很亮，把其调整为中等亮度那么画面整体会特别暗，此时我们就可以增加一点曝光补偿。反之测光物体在黑色物体上时，我们可以减一点曝光补偿。这就是俗称的【白加黑减】\n\n> 哎？那么既然可以调节曝光补偿还要曝光三要素干嘛？其实单独调节曝光也是通过调节曝光三要素来改变的\n\n相机一般有以下几种测光模式：\n\n * 评价测光：整体画面取平均值，适用于风景，街拍\n * 中央重点测光：只对中心区域进行测光，适用于人像，特写\n * 点测光：对更小的区域进行测光。适用于逆光，剪影，夜景\n * 局部测光：类似于点测光，但测光区域稍微大一些。适用于逆光或突出主体\n\n\n# 人像参数\n\n * 锐度：锐度控制人物皮肤细节，适当降低，会起到一定的磨皮效果。（高锐度适合人文扫街）\n * 反差：控制面部的明暗对比度，适当降低 ，可以让脸上的明暗关系变得更为柔和。\n * 饱和度：控制着面部的色彩浓度，适当降低，会令肤色看起来略显冷清。（高饱和度适合风光旅拍）\n * 色调：控制画面偏色，调高色条画面会向绿色偏移。降低色调，画面会向红色偏移。\n\n> 降低饱和度，提高色调：日系小清新风格\n> \n> 提高饱和度，降低色调：复古港风\n\n\n# 逆光怎么拍\n\n1.身体挡住太阳，或者让太阳漏出来一点\n\n2.不要以天空为背景，寻找亮度较低的深色背景。或者使用反光板对脸部补光\n\n3.使用点测光对人物面部进行测光，就能拍出面部明亮的逆光照。如果将测光点对准天空就能拍出氛围感剪影照片。\n\n4.选择日落前，光线柔和，橙黄色调",normalizedContent:"# 单反和微单\n\n单反：单镜头反光照相机\n\n * 画面进入镜头，经过反光板反射五棱镜折射，从光学取景器中就可以看到成像。\n * 按下快门，反光板抬起，画面进入 cmos，成为了照片。\n\n\n\n\n\n微单：无反相机\n\n * 没有反光板，光线透过镜头直接落在传感器上，再通过光电信号的转化，显示在电子取景器里。\n\n\n\n对比：\n\n * 重量：同样像素，微单更轻。\n * 对焦：单反的取景和对焦是两个系统，在反光板的旁边还有一个小的反光板，将光线反射进对焦模块上（本质也是个传感器），对焦模块有多大，对焦的范围就有多大。而微单直接将对焦集成到 cmos 上，兼顾了对焦和成像，使得对焦点可以完全铺满整个 cmos，可以全屏对焦追焦\n\n\n\n> 总结：微单更轻更小更强，只是因为单反硕大的外观，繁多的按键，先入为主的定位看起来更专业而已。\n\n\n# 曝光三要素\n\n光圈、快门、感光度（iso）\n\n\n# 光圈\n\n用来控制相机进光量多少的装置，它通常存在镜头内，由一组可开合的叶片组成。在相机上用 f 表示。\n\nf = 镜头焦距 / 通光孔直径\n\n根据公式就解释了，为什么 光圈值 f 越大，实际光圈越小。\n\n * 光圈 f 值越大，光圈越小，通光量变小，画面变暗，景深越深\n * 光圈 f 值越小，光圈越大，通光量变大，画面变亮，景深越浅\n\n> 景深指的是焦点范围相对清晰的这一区间。所以光圈另一个重要的应用就是实现背景模糊。\n> \n> 光圈越小，景深越深，物体越清晰；光圈越大，景深越浅，更容易实现背景模糊的效果。\n> \n> 类似于近视眼的人，眯起眼睛相当于光圈变小，会看的更清晰。\n\n * 大光圈更适合拍摄人像，希望主体从杂乱的背景中突出\n * 小光圈更适合拍摄风景，希望全局清晰的大场景\n\n在设计光圈的时候，相邻两档的透光亮要相差一倍，也就是面积要相差一倍，直径则相差 1.2 倍，所以整数档光圈会呈现 1.4 倍的倍数关系\n\n> f1.4 => f2.0 => f2.8 => f4.0 => f5.6 => f8.0 ....\n\n\n# 快门\n\n控制光线进入相机时间长短的装置，单位是 s，时间越长，接收到的光线也就越多。\n\n * 高速快门：适用于抓拍运动物体，会更加清晰。\n * 慢速快门：能拍到运动轨迹，适用于拍车的轨迹，细水长流的感觉\n\n\n# 感光度\n\n对光线的敏感度，适用于在光圈和快门调整后仍然很暗，或者阴天的环境下提高亮度。\n\n正因为提高了光线敏感度所以也可能会出现噪点。\n\n\n# 焦距（焦段）\n\n焦距：凸透镜的光学中心到焦点的距离，当然相机不止一个镜片，只需要理解即可。焦距是一个固定的值，如 16mm 焦距，24mm焦距，如果达到 3000mm 就属于望远镜了\n\n焦段：一般指焦距的范围，比如 16-35mm，24-70mm\n\n> 焦距越短，视角越广；焦距越长，视角越窄\n\n * 超广角：20mm以下\n * 广角：20mm-40mm\n * 标准焦段：40mm-60mm\n * 长焦：60mm以上\n\n> 其中 40mm-60mm 标准焦段最接近人的眼睛，50mm小痰盂是一个比较火的镜头\n\n * 数字变焦：放大裁剪图片达到类似于增加焦距的效果。\n * 光学变焦：通过光学镜头结构来实现变焦，比数字变焦会更清晰。\n * 长焦镜头：有压缩空间的效果\n * 广角镜头：有拉伸空间的效果，比如房产中间拍摄房间视频。\n\n> 希区柯克变焦：是电影制作中的流行元素，镜头中的主体大小不变，而背景大小改变。会有一种背景不断涌动的感觉。\n\n焦距并不能改变透视关系（近大远小），只有距离才能。这就相当于你拿一个长焦镜头拍的画面和拿一个广角镜头拍的画面再经过裁切得到的透视关系是相同的，只是长焦镜头的会更清晰一些。\n\n所以想改变透视关系形成空间压缩的感觉就需要远离被拍物体，然后使用长焦镜头拍摄。\n\n\n# 白平衡\n\n色温：环境中客观存在的光源颜色，随温度越高，颜色呈现 红（1000k） => 白（5500k） => 蓝（8000k）\n\n> 一个物体的温度越高，则它辐射的电磁波波长越短，其中可见光里，红橙黄绿蓝靛紫，红光光波最长，紫光光波最短，所以暖色调的物体温度比冷色调的物体温度低。\n\n * 日出日落：2000k - 3000k\n * 晴天正午：5000k - 6000k\n * 阴天色温：6000k - 7000k\n\n白平衡：人为控制相机设置用来平衡环境的色温，还原现实中物体原本的颜色（让白色的物体恢复白色），即把白平衡的k值和色温的k值调整为相同即可。k值越低画面越冷，k值越高画面越暖，与色温正好相反。\n\n> 色温 > 白平衡：画面偏冷\n> \n> 色温 < 白平衡：画面偏暖\n> \n> 色温 = 白平衡：物体本色\n\n * 如果想画面温馨，白平衡设置为 6000k - 7000k\n * 如果想冷清孤独：白平衡设置为 3000k - 4000k\n\n如果画面偏绿了怎么办？可以用白平衡偏移：在白平衡的基础上进行额外的偏色。\n\n可以在相机的色彩偏移界面向绿色的对角线方向移动即可。\n\n\n\n其实这里我们可以用色彩偏移来制造氛围感，a：红色，b：蓝色，g：绿色，m：洋红色\n\n风格按一二三四象限：\n\n * 红绿色：港风\n * 蓝绿色：小清新风格\n * 蓝粉色：法式风格\n * 红粉色：复古风格\n\n> 调整白平衡的统一标准一般是让任务肤色保持在一个健康写实的范围。\n> \n> 黄种人的皮肤可以在还原白色的情况下再往冷色调调一些\n\n\n# 测光\n\n测光：相机根据检测到的光线明暗情况来设置机内参数，让我们可以拍出明暗合适的照片。\n\n我们之所以能看到五彩斑斓的世界是因为物体会吸收和反射出一定的光，而当我们去掉颜色时照片使用灰度表示亮度的，从暗到亮分别为，黑（反射率3%），灰（反射率18%），白（反射率90%），其中灰色为亮度正常的部分，也就是常说的18度灰，这就是相机认为的正常曝光，所以调节测光模式就是你想把那个地方拍成正常亮度。\n\n测光物体在白雪上时，因为白色本来反射率就具有很高亮度就很亮，把其调整为中等亮度那么画面整体会特别暗，此时我们就可以增加一点曝光补偿。反之测光物体在黑色物体上时，我们可以减一点曝光补偿。这就是俗称的【白加黑减】\n\n> 哎？那么既然可以调节曝光补偿还要曝光三要素干嘛？其实单独调节曝光也是通过调节曝光三要素来改变的\n\n相机一般有以下几种测光模式：\n\n * 评价测光：整体画面取平均值，适用于风景，街拍\n * 中央重点测光：只对中心区域进行测光，适用于人像，特写\n * 点测光：对更小的区域进行测光。适用于逆光，剪影，夜景\n * 局部测光：类似于点测光，但测光区域稍微大一些。适用于逆光或突出主体\n\n\n# 人像参数\n\n * 锐度：锐度控制人物皮肤细节，适当降低，会起到一定的磨皮效果。（高锐度适合人文扫街）\n * 反差：控制面部的明暗对比度，适当降低 ，可以让脸上的明暗关系变得更为柔和。\n * 饱和度：控制着面部的色彩浓度，适当降低，会令肤色看起来略显冷清。（高饱和度适合风光旅拍）\n * 色调：控制画面偏色，调高色条画面会向绿色偏移。降低色调，画面会向红色偏移。\n\n> 降低饱和度，提高色调：日系小清新风格\n> \n> 提高饱和度，降低色调：复古港风\n\n\n# 逆光怎么拍\n\n1.身体挡住太阳，或者让太阳漏出来一点\n\n2.不要以天空为背景，寻找亮度较低的深色背景。或者使用反光板对脸部补光\n\n3.使用点测光对人物面部进行测光，就能拍出面部明亮的逆光照。如果将测光点对准天空就能拍出氛围感剪影照片。\n\n4.选择日落前，光线柔和，橙黄色调",charsets:{cjk:!0}},{title:"chrome 和 vscode 调试工具",frontmatter:{},regularPath:"/tool/debugger.html",relativePath:"tool/debugger.md",key:"v-56cbc582",path:"/tool/debugger.html",headers:[{level:2,title:"chrome 调试 web 项目",slug:"chrome-调试-web-项目",normalizedTitle:"chrome 调试 web 项目",charIndex:230},{level:2,title:"vscode 调试 web 项目",slug:"vscode-调试-web-项目",normalizedTitle:"vscode 调试 web 项目",charIndex:681},{level:2,title:"chrome 调试 node 项目",slug:"chrome-调试-node-项目",normalizedTitle:"chrome 调试 node 项目",charIndex:1593},{level:2,title:"vscode 调试 node 项目",slug:"vscode-调试-node-项目",normalizedTitle:"vscode 调试 node 项目",charIndex:1876},{level:2,title:"条件断点",slug:"条件断点",normalizedTitle:"条件断点",charIndex:2494}],lastUpdated:"1/6/2023, 2:27:26 PM",lastUpdatedTimestamp:1672986446e3,headersStr:"chrome 调试 web 项目 vscode 调试 web 项目 chrome 调试 node 项目 vscode 调试 node 项目 条件断点",content:'# chrome 和 vscode 调试工具\n\n在开发过程中，我们最常用的是 console.log 调试，但是这样会有很多问题，比如console.log 打印出来的数据不一定准确。\n\n再比如调试 node 程序打印时，你会发现对象的值也是对象的时候不会展开，而是打印一个 [Object] [Array] 这种字符串，更致命的是打印的太长会超过缓冲区的大小，终端里会显示不全，所以这时候就需要使用 chrome 调试工具和 vscode调试工具。\n\n\n# chrome 调试 web 项目\n\n在调试的时候，我们直接在想要调试的代码位置加上 debugger 即可，此时运行项目即可在 chrome 控制台看到：\n\n\n\n其中红框内的调试按钮，从左到右含义分别为：\n\n * resume/pause script execution：恢复/暂停脚本执行。\n * step over next function call：跨过函数，不遇到函数时，执行下一步。遇到函数时，不进入函数。\n * step into next function call：进入函数，不遇到函数时，执行下一步。遇到函数时，进入函数执行上下文。\n * step out of current function：跳出当前函数。\n * step：执行下一步。\n * deactivate breakpoints：使所有断点暂时失效。\n * pause on exceptions：出现异常暂停。\n\n假如选择了 pause on exceptions ，那么程序在遇到错误时也会暂停：\n\n\n\n\n# vscode 调试 web 项目\n\n我们拿一个 vue 项目来操作，用 vscode 打开项目之后，切换到左侧的调试区域并点击创建 launch.json,然后选择 Web App (Chrome)\n\n\n\n// .vscode/launch.json\n{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "chrome",\n            "request": "launch",\n            "name": "Launch Chrome against localhost",\n            "url": "http://localhost:8080", // 填项目本地运行地址\n            "webRoot": "${workspaceFolder}"\n        }\n    ]\n}\n\n\n本地npm run dev运行项目之后，然后就可以在代码上打上断点，然后点击 Launch 按钮（或者 F5）进行调试，点击后会自动启动一个 chrome 窗口打开项目，此时断点就已经生效了。\n\n\n\n同样的，此时 vscode 中有和 chrome 类似的调试按钮，把 Caught Exceptions 勾上，这样在代码报错的地方，就会自动中断执行。\n\n\n\n断点生效后，vscode 中会有一个调试控制台 debug console，在这里可以打印想要看到的变量，例如这里我打印了this：\n\n\n\n如果想打印出某个变量，也可以使用 log point 功能，右键选择Add Logpint，然后使用{}包裹想要打印的变量，这样也会在调试控制台输出。\n\n\n\n> 这种方式的优点是没有污染代码，如果用 console.log 的话调试完之后这个 console 还需要删掉。\n\n左侧还可以查看调用栈call stack，例如这里执行路线为：created() => test()\n\n\n\n而且点击每个调用栈，在 variables 中还可以看到当前调用栈中的变量：\n\n\n\n\n# chrome 调试 node 项目\n\n// index.js\nconst greeting = \'hello nodejs debugger\';\ndebugger;\nconsole.log(greeting);\n\n\n终端中输入：node --inspect-brk index.js，然后打开 chrome://inspect/#devices\n\n\n\n> --inspect-brk 表示运行这个 js 文件的同时，在文件的第一行打上断点。\n\n点击 inspect 此时 chrome 会打开一个 nodejs 专用的调试窗口，并且代码在第一行中断了。\n\n\n\n\n# vscode 调试 node 项目\n\n同样地，和 vscode 调试 web 项目一样，在项目中创建 launch.json:\n\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "node",\n            "request": "launch",\n            "name": "Launch Program",\n            "skipFiles": [\n                "<node_internals>/**"\n            ],\n            "program": "${workspaceFolder}/index.js"\n        }\n    ]\n}\n\n\n然后就可以在 vscode 中进行调试了，和上面介绍过的没有差别：\n\n\n\n\n# 条件断点\n\n在某些情况下，我们不希望打上的每个断点都发挥作用，而是在执行到断点那行，且满足某个条件再中断代码执行。这就是条件断点。\n\nfor (let i = 0; i < 10; i++) {\n  console.log(\'i\', i);\n}\n\n\n比如上面的代码，假设我们在第二行 console.log 打了断点，那么这个断点总计会中断十次。这往往是我们不希望看到的，可能我们需要的仅仅是其中某一次循环而非所有。这时候可以右键点击并选择 Add Conditional Breakpoint。\n\n\n\n可以看到调试控制台前几次 i 均打印出来，直到 i === 5 时才中断执行。',normalizedContent:'# chrome 和 vscode 调试工具\n\n在开发过程中，我们最常用的是 console.log 调试，但是这样会有很多问题，比如console.log 打印出来的数据不一定准确。\n\n再比如调试 node 程序打印时，你会发现对象的值也是对象的时候不会展开，而是打印一个 [object] [array] 这种字符串，更致命的是打印的太长会超过缓冲区的大小，终端里会显示不全，所以这时候就需要使用 chrome 调试工具和 vscode调试工具。\n\n\n# chrome 调试 web 项目\n\n在调试的时候，我们直接在想要调试的代码位置加上 debugger 即可，此时运行项目即可在 chrome 控制台看到：\n\n\n\n其中红框内的调试按钮，从左到右含义分别为：\n\n * resume/pause script execution：恢复/暂停脚本执行。\n * step over next function call：跨过函数，不遇到函数时，执行下一步。遇到函数时，不进入函数。\n * step into next function call：进入函数，不遇到函数时，执行下一步。遇到函数时，进入函数执行上下文。\n * step out of current function：跳出当前函数。\n * step：执行下一步。\n * deactivate breakpoints：使所有断点暂时失效。\n * pause on exceptions：出现异常暂停。\n\n假如选择了 pause on exceptions ，那么程序在遇到错误时也会暂停：\n\n\n\n\n# vscode 调试 web 项目\n\n我们拿一个 vue 项目来操作，用 vscode 打开项目之后，切换到左侧的调试区域并点击创建 launch.json,然后选择 web app (chrome)\n\n\n\n// .vscode/launch.json\n{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "chrome",\n            "request": "launch",\n            "name": "launch chrome against localhost",\n            "url": "http://localhost:8080", // 填项目本地运行地址\n            "webroot": "${workspacefolder}"\n        }\n    ]\n}\n\n\n本地npm run dev运行项目之后，然后就可以在代码上打上断点，然后点击 launch 按钮（或者 f5）进行调试，点击后会自动启动一个 chrome 窗口打开项目，此时断点就已经生效了。\n\n\n\n同样的，此时 vscode 中有和 chrome 类似的调试按钮，把 caught exceptions 勾上，这样在代码报错的地方，就会自动中断执行。\n\n\n\n断点生效后，vscode 中会有一个调试控制台 debug console，在这里可以打印想要看到的变量，例如这里我打印了this：\n\n\n\n如果想打印出某个变量，也可以使用 log point 功能，右键选择add logpint，然后使用{}包裹想要打印的变量，这样也会在调试控制台输出。\n\n\n\n> 这种方式的优点是没有污染代码，如果用 console.log 的话调试完之后这个 console 还需要删掉。\n\n左侧还可以查看调用栈call stack，例如这里执行路线为：created() => test()\n\n\n\n而且点击每个调用栈，在 variables 中还可以看到当前调用栈中的变量：\n\n\n\n\n# chrome 调试 node 项目\n\n// index.js\nconst greeting = \'hello nodejs debugger\';\ndebugger;\nconsole.log(greeting);\n\n\n终端中输入：node --inspect-brk index.js，然后打开 chrome://inspect/#devices\n\n\n\n> --inspect-brk 表示运行这个 js 文件的同时，在文件的第一行打上断点。\n\n点击 inspect 此时 chrome 会打开一个 nodejs 专用的调试窗口，并且代码在第一行中断了。\n\n\n\n\n# vscode 调试 node 项目\n\n同样地，和 vscode 调试 web 项目一样，在项目中创建 launch.json:\n\n{\n    // use intellisense to learn about possible attributes.\n    // hover to view descriptions of existing attributes.\n    // for more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "node",\n            "request": "launch",\n            "name": "launch program",\n            "skipfiles": [\n                "<node_internals>/**"\n            ],\n            "program": "${workspacefolder}/index.js"\n        }\n    ]\n}\n\n\n然后就可以在 vscode 中进行调试了，和上面介绍过的没有差别：\n\n\n\n\n# 条件断点\n\n在某些情况下，我们不希望打上的每个断点都发挥作用，而是在执行到断点那行，且满足某个条件再中断代码执行。这就是条件断点。\n\nfor (let i = 0; i < 10; i++) {\n  console.log(\'i\', i);\n}\n\n\n比如上面的代码，假设我们在第二行 console.log 打了断点，那么这个断点总计会中断十次。这往往是我们不希望看到的，可能我们需要的仅仅是其中某一次循环而非所有。这时候可以右键点击并选择 add conditional breakpoint。\n\n\n\n可以看到调试控制台前几次 i 均打印出来，直到 i === 5 时才中断执行。',charsets:{cjk:!0}},{title:"htmlparser2",frontmatter:{},regularPath:"/tool/htmlparser2.html",relativePath:"tool/htmlparser2.md",key:"v-b22ada6e",path:"/tool/htmlparser2.html",lastUpdated:"3/3/2022, 10:50:26 AM",lastUpdatedTimestamp:1646275826e3,headersStr:null,content:'# htmlparser2\n\nhtmlparser2 是一个 HTML/XML 解析器。\n\nconst htmlparser2 = require("htmlparser2");\nconst parser = new htmlparser2.Parser({\n    // 当遇到标签时调用\n    onopentag(name, attributes) {\n        if (name === "script" && attributes.type === "text/javascript") {\n            console.log("JS! Hooray!");\n        }\n    },\n    // 当遇到文本时调用\n    ontext(text) {\n        console.log("--\x3e", text);\n    },\n    // 当标签结束时调用\n    onclosetag(tagname) {\n        if (tagname === "script") {\n            console.log("That\'s it?!");\n        }\n    },\n});\nparser.write(\n    "Xyz <script type=\'text/javascript\'>const foo = \'<<bar>>\';</ script>"\n);\nparser.end();\n\n/**\n--\x3e Xyz\nJS! Hooray!\n--\x3e const foo = \'<<bar>>\';\nThat\'s it?!\n*/\n\n\n解析成 DOM tree\n\nconst htmlparser2 = require("htmlparser2");\n\nconst htmlString = \n`<!DOCTYPE html>\n<html>\n\n<body>\n    <h1>My First Heading</h1>\n    <p>My first paragraph.</p>\n</body>\n\n</html>\n`\n\nconst dom = htmlparser2.parseDocument(htmlString);\nconsole.log(dom)\n\n\n\n\n解析结果也可以到 astexplorer.net 中查看。',normalizedContent:'# htmlparser2\n\nhtmlparser2 是一个 html/xml 解析器。\n\nconst htmlparser2 = require("htmlparser2");\nconst parser = new htmlparser2.parser({\n    // 当遇到标签时调用\n    onopentag(name, attributes) {\n        if (name === "script" && attributes.type === "text/javascript") {\n            console.log("js! hooray!");\n        }\n    },\n    // 当遇到文本时调用\n    ontext(text) {\n        console.log("--\x3e", text);\n    },\n    // 当标签结束时调用\n    onclosetag(tagname) {\n        if (tagname === "script") {\n            console.log("that\'s it?!");\n        }\n    },\n});\nparser.write(\n    "xyz <script type=\'text/javascript\'>const foo = \'<<bar>>\';</ script>"\n);\nparser.end();\n\n/**\n--\x3e xyz\njs! hooray!\n--\x3e const foo = \'<<bar>>\';\nthat\'s it?!\n*/\n\n\n解析成 dom tree\n\nconst htmlparser2 = require("htmlparser2");\n\nconst htmlstring = \n`<!doctype html>\n<html>\n\n<body>\n    <h1>my first heading</h1>\n    <p>my first paragraph.</p>\n</body>\n\n</html>\n`\n\nconst dom = htmlparser2.parsedocument(htmlstring);\nconsole.log(dom)\n\n\n\n\n解析结果也可以到 astexplorer.net 中查看。',charsets:{cjk:!0}},{title:"npm、cnpm、nvm、nrm、yarn、tyarn、npx、pnpm",frontmatter:{},regularPath:"/tool/npm.html",relativePath:"tool/npm.md",key:"v-52235c03",path:"/tool/npm.html",headers:[{level:2,title:"npm && cnpm",slug:"npm-cnpm",normalizedTitle:"npm &amp;&amp; cnpm",charIndex:null},{level:2,title:"nrm",slug:"nrm",normalizedTitle:"nrm",charIndex:15},{level:2,title:"nvm",slug:"nvm",normalizedTitle:"nvm",charIndex:11},{level:2,title:"yarn && tyarn",slug:"yarn-tyarn",normalizedTitle:"yarn &amp;&amp; tyarn",charIndex:null},{level:2,title:"npx",slug:"npx",normalizedTitle:"npx",charIndex:30},{level:2,title:"pnpm",slug:"pnpm",normalizedTitle:"pnpm",charIndex:34}],lastUpdated:"7/7/2022, 6:20:47 PM",lastUpdatedTimestamp:1657189247e3,headersStr:"npm && cnpm nrm nvm yarn && tyarn npx pnpm",content:'# npm、cnpm、nvm、nrm、yarn、tyarn、npx、pnpm\n\n这么多工具还分不清楚，看这篇文章就够了。\n\n\n# npm && cnpm\n\n下载完 node 就自动有了 npm，但是 npm 源访问可能比较慢，这就有了 cnpm\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n这样就全局创建了命令 cnpm，使用淘宝镜像源，当然也可以直接这样使用：\n\nnpm install xxx --registry=https://registry.npm.taobao.org\n\n\n\n# nrm\n\nnpm包有很多的镜像源，有的源有的时候访问失败，有的源可能没有最新的包,有的要使用公司内部的源，所以有时需要切换npm的源，nrm包就是解决快速切换问题的。\n\nnrm ls # 列出可选择的源\nnrm use <registry> # 切换使用的源\nnrm add <registry> <url> # 添加一个源\nnrm del <registry> # 删除一个源\nnrm test npm # 测试源速度\n\n\n其实这种方式相当于\n\nnpm install xxx --registry=<url>\n\n\n\n# nvm\n\nnvm 是管理 node 版本的工具，类似的还有 n\n\n\n# yarn && tyarn\n\nyarn 是 FaceBook 开源的一个新的包管理器， 和npm的作用是一样的。它和npm最大区别是，yarn是并行下载的，所以下载速度很快\n\ntyarn 即是对应的淘宝镜像源\n\nnpm i yarn tyarn -g\n\n\n\n# npx\n\nnpx 会自动查找当前目录依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装。\n\nnpx create-react-app my-app\n# 这条命令会临时安装 create-react-app 包，命令完成后会删掉。\n\n\n * npx --no-install：不尝试下载，这时 npx 的作用就是首先会在当前目录寻找命令，不存在则去全局中去找。\n * npx --ignore-existing：必须下载，无论本地是否存在都去下载。\n\n\n# pnpm\n\nperformant npm ，意味"高性能的 npm"。pnpm由npm/yarn衍生而来，解决了npm/yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”，pnpm比传统方案(yarn, npm)安装包的速度快了两倍：\n\nnpm install -g pnpm\npnpm add package\npnpm remove package\n\n\n> 当使用npm或者yarn时，如果你有100个项目使用了某个依赖，就会有100份依赖的副本保存在磁盘上，对于pnpm，依赖项将存储在一个内容可寻址的仓库中。\n> \n> 所有文件都会在存储在硬盘上的同一个位置，当多个包被安装时，所有文件都会从同一位置创建硬链接，不会占用额外的磁盘空间，允许跨项目共享同一版本依赖。\n\n为什么推荐使用pnpm',normalizedContent:'# npm、cnpm、nvm、nrm、yarn、tyarn、npx、pnpm\n\n这么多工具还分不清楚，看这篇文章就够了。\n\n\n# npm && cnpm\n\n下载完 node 就自动有了 npm，但是 npm 源访问可能比较慢，这就有了 cnpm\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n这样就全局创建了命令 cnpm，使用淘宝镜像源，当然也可以直接这样使用：\n\nnpm install xxx --registry=https://registry.npm.taobao.org\n\n\n\n# nrm\n\nnpm包有很多的镜像源，有的源有的时候访问失败，有的源可能没有最新的包,有的要使用公司内部的源，所以有时需要切换npm的源，nrm包就是解决快速切换问题的。\n\nnrm ls # 列出可选择的源\nnrm use <registry> # 切换使用的源\nnrm add <registry> <url> # 添加一个源\nnrm del <registry> # 删除一个源\nnrm test npm # 测试源速度\n\n\n其实这种方式相当于\n\nnpm install xxx --registry=<url>\n\n\n\n# nvm\n\nnvm 是管理 node 版本的工具，类似的还有 n\n\n\n# yarn && tyarn\n\nyarn 是 facebook 开源的一个新的包管理器， 和npm的作用是一样的。它和npm最大区别是，yarn是并行下载的，所以下载速度很快\n\ntyarn 即是对应的淘宝镜像源\n\nnpm i yarn tyarn -g\n\n\n\n# npx\n\nnpx 会自动查找当前目录依赖包中的可执行文件，如果找不到，就会去 path 里找。如果依然找不到，就会帮你安装。\n\nnpx create-react-app my-app\n# 这条命令会临时安装 create-react-app 包，命令完成后会删掉。\n\n\n * npx --no-install：不尝试下载，这时 npx 的作用就是首先会在当前目录寻找命令，不存在则去全局中去找。\n * npx --ignore-existing：必须下载，无论本地是否存在都去下载。\n\n\n# pnpm\n\nperformant npm ，意味"高性能的 npm"。pnpm由npm/yarn衍生而来，解决了npm/yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”，pnpm比传统方案(yarn, npm)安装包的速度快了两倍：\n\nnpm install -g pnpm\npnpm add package\npnpm remove package\n\n\n> 当使用npm或者yarn时，如果你有100个项目使用了某个依赖，就会有100份依赖的副本保存在磁盘上，对于pnpm，依赖项将存储在一个内容可寻址的仓库中。\n> \n> 所有文件都会在存储在硬盘上的同一个位置，当多个包被安装时，所有文件都会从同一位置创建硬链接，不会占用额外的磁盘空间，允许跨项目共享同一版本依赖。\n\n为什么推荐使用pnpm',charsets:{cjk:!0}},{title:"postcss",frontmatter:{},regularPath:"/tool/postcss.html",relativePath:"tool/postcss.md",key:"v-979acdda",path:"/tool/postcss.html",headers:[{level:2,title:"与预处理器的区别",slug:"与预处理器的区别",normalizedTitle:"与预处理器的区别",charIndex:272},{level:2,title:"接入 webpack",slug:"接入-webpack",normalizedTitle:"接入 webpack",charIndex:527},{level:2,title:"常用插件",slug:"常用插件",normalizedTitle:"常用插件",charIndex:861},{level:2,title:"API 使用",slug:"api-使用",normalizedTitle:"api 使用",charIndex:1014},{level:3,title:"Result.root",slug:"result-root",normalizedTitle:"result.root",charIndex:1319},{level:3,title:"LazyResult",slug:"lazyresult",normalizedTitle:"lazyresult",charIndex:1371}],lastUpdated:"4/6/2023, 7:10:18 PM",lastUpdatedTimestamp:1680779418e3,headersStr:"与预处理器的区别 接入 webpack 常用插件 API 使用 Result.root LazyResult",content:"# postcss\n\n 1. 官方文档\n\n 2. github地址\n\n 3. PostCSS 入门教程\n\n 4. Postcss了解一下\n\nPostCSS 是一个用 JavaScript 工具和插件转换 CSS 代码的工具，常见的功能如：\n\n * 使用下一代css语法\n * 自动补全浏览器前缀\n * 自动把px代为转换成rem\n * css 代码压缩等等\n\nPostCSS 可以称为一个平台，提供了一个解析器，能够将 CSS 解析成 AST，还需要配合插件使用。\n\n大多数构建工具内置了 PostCSS，例如 vite，可以直接配置\n\n\n# 与预处理器的区别\n\n * Less / Sass / Stylus，这类工具都属于 CSS 预处理工具。预处理指的是通过特殊的规则，将非 css 文本格式最终生成 css 文件。\n * postcss 则是对 CSS 进行处理，最终生成的还是 CSS。\n * 从其名字 postcss 可以看出早期是被当做后处理器的。也就是处理less/sass 编译后的 css。最常用的插件就是 autoprefixer，根据浏览器版本添加兼容前缀。（post：在...之后的，例如后序遍历 postorder）\n\n\n# 接入 webpack\n\n目前一般还是 postcss 和 less/sass 结合使用，在 webpack 配置中，postcss-loader 要写在 sass-loader/less-loader 前面。\n\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.(css|less)$/i,\n                use: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'],\n            },\n        ]\n    }\n}\n\n\n\n# 常用插件\n\n * Autoprefixer：前缀补全\n * postcss-pxtorem：把 px 转换成 rem\n\n:fullscreen {\n}\n\n/* 处理后 */\n:-webkit-full-screen {\n}\n:-ms-fullscreen {\n}\n:fullscreen {\n}\n\n\n\n# API 使用\n\nPostcss 除了插件的使用方式还提供了 api：\n\nlet postcss = require('postcss');\nlet autoprefixer = require('autoprefixer');\n\nlet css = `:fullscreen {}`\n\npostcss([autoprefixer]).process(css).then(result => {\n  console.log(result.css)\n})\n\n// 输出\n// :-webkit-full-screen {}\n// :-ms-fullscreen {}\n// :fullscreen {}\n\n\n\n# Result.root\n\n除了 Result.css 还有 Result.root 等属性\n\n\n\n\n# LazyResult\n\nPost CSS 转换结果的 Promise 代理\n\nconst lazy = postcss([autoprefixer]).process(css)\n\n\n * LazyResult.root\n\n通过同步插件处理输入 CSS 并返回 Result.root，也就是说两个 API 返回结果相同。\n\n注意：此属性仅适用于同步插件。 如果处理器包含任何异步插件，它将引发错误。\n\nlet postcss = require('postcss');\nconst autoprefixer = require('autoprefixer');\n\nlet css = `:fullscreen {}`\n\nconst lazy = postcss([autoprefixer]).process(css)\nconsole.log(lazy.root)\n",normalizedContent:"# postcss\n\n 1. 官方文档\n\n 2. github地址\n\n 3. postcss 入门教程\n\n 4. postcss了解一下\n\npostcss 是一个用 javascript 工具和插件转换 css 代码的工具，常见的功能如：\n\n * 使用下一代css语法\n * 自动补全浏览器前缀\n * 自动把px代为转换成rem\n * css 代码压缩等等\n\npostcss 可以称为一个平台，提供了一个解析器，能够将 css 解析成 ast，还需要配合插件使用。\n\n大多数构建工具内置了 postcss，例如 vite，可以直接配置\n\n\n# 与预处理器的区别\n\n * less / sass / stylus，这类工具都属于 css 预处理工具。预处理指的是通过特殊的规则，将非 css 文本格式最终生成 css 文件。\n * postcss 则是对 css 进行处理，最终生成的还是 css。\n * 从其名字 postcss 可以看出早期是被当做后处理器的。也就是处理less/sass 编译后的 css。最常用的插件就是 autoprefixer，根据浏览器版本添加兼容前缀。（post：在...之后的，例如后序遍历 postorder）\n\n\n# 接入 webpack\n\n目前一般还是 postcss 和 less/sass 结合使用，在 webpack 配置中，postcss-loader 要写在 sass-loader/less-loader 前面。\n\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.(css|less)$/i,\n                use: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'],\n            },\n        ]\n    }\n}\n\n\n\n# 常用插件\n\n * autoprefixer：前缀补全\n * postcss-pxtorem：把 px 转换成 rem\n\n:fullscreen {\n}\n\n/* 处理后 */\n:-webkit-full-screen {\n}\n:-ms-fullscreen {\n}\n:fullscreen {\n}\n\n\n\n# api 使用\n\npostcss 除了插件的使用方式还提供了 api：\n\nlet postcss = require('postcss');\nlet autoprefixer = require('autoprefixer');\n\nlet css = `:fullscreen {}`\n\npostcss([autoprefixer]).process(css).then(result => {\n  console.log(result.css)\n})\n\n// 输出\n// :-webkit-full-screen {}\n// :-ms-fullscreen {}\n// :fullscreen {}\n\n\n\n# result.root\n\n除了 result.css 还有 result.root 等属性\n\n\n\n\n# lazyresult\n\npost css 转换结果的 promise 代理\n\nconst lazy = postcss([autoprefixer]).process(css)\n\n\n * lazyresult.root\n\n通过同步插件处理输入 css 并返回 result.root，也就是说两个 api 返回结果相同。\n\n注意：此属性仅适用于同步插件。 如果处理器包含任何异步插件，它将引发错误。\n\nlet postcss = require('postcss');\nconst autoprefixer = require('autoprefixer');\n\nlet css = `:fullscreen {}`\n\nconst lazy = postcss([autoprefixer]).process(css)\nconsole.log(lazy.root)\n",charsets:{cjk:!0}},{title:"yaml",frontmatter:{},regularPath:"/tool/yaml.html",relativePath:"tool/yaml.md",key:"v-5e39087f",path:"/tool/yaml.html",lastUpdated:"5/19/2022, 8:46:54 PM",lastUpdatedTimestamp:1652964414e3,headersStr:null,content:'# yaml\n\nYAML 是一个可读性高，用来表达资料序列化的格式。常用于存储一些配置文件，如：\n\nreceipt:     Oz-Ware Purchase Invoice\ndate:        2012-08-06\ncustomer:\n    given:   Dorothy\n    family:  Gale\n   \nitems:\n    - part_no:   A4786\n      descrip:   Water Bucket (Filled)\n      price:     1.47\n      quantity:  4\n\n    - part_no:   E1628\n      descrip:   High Heeled "Ruby" Slippers\n      size:      8\n      price:     133.7\n      quantity:  1\n\n\nYaml 和 json 可以互相转换（在线转换工具），其实可以把 yaml 看成 json 文件的变形，其中短横线看做为数组，其他看作为对象。上面的 yaml 可以转换成如下 json：\n\n{\n    "receipt": "Oz-Ware Purchase Invoice",\n    "date": "2012-08-06T00:00:00.000Z",\n    "customer": {\n        "given": "Dorothy",\n        "family": "Gale"\n    },\n    "items": [\n        {\n            "part_no": "A4786",\n            "descrip": "Water Bucket (Filled)",\n            "price": 1.47,\n            "quantity": 4\n        },\n        {\n            "part_no": "E1628",\n            "descrip": "High Heeled \\"Ruby\\" Slippers",\n            "size": 8,\n            "price": 133.7,\n            "quantity": 1\n        }\n    ]\n}\n\n\nnpm 包 yaml 也可实现该功能：\n\nimport fs from \'fs\'\nimport YAML from \'yaml\'\n\nconst file = fs.readFileSync(\'./file.yml\', \'utf8\')\nYAML.parse(file)\n\n\n举一个场景，后端提供了一份 yaml 文件的 url，前端如何将其下载并读取内容呢？\n\n// 根据获取 yaml 配置文件并转 json\nfunction getYaml(url) {\n  let that = this;\n  let fileUrl = url;\n  let xhr = new XMLHttpRequest();\n  xhr.open(\'get\', fileUrl, true);\n  xhr.responseType = \'blob\';\n  xhr.onload = function () {\n    if (this.status === 200) {\n      const reader = new FileReader();\n      reader.readAsText(this.response);\n      reader.onload = function () {\n        that.json = yaml.parse(reader.result);\n        that.parseJson(that.json);\n      };\n    }\n  };\n  xhr.send();\n}\n\n\n使用 axios 封装一下：\n\n> 这里有两层异步操作，第一步是 axios.get，第二步是文件读取 reader\n> \n> 第二层利用 Promise 封装，使用 async / await 来得到 最终结果。\n\nfunction downloadYaml(url) {\n  return axios.get(url, {\n      responseType: \'blob\',\n    })\n    .then(res => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.readAsText(res.data);\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n      });\n    })\n});\n\nasync function getYaml(url){\n  const res = await downloadYaml(url);\n  this.json = yaml.parse(res);\n  this.parseJson(this.json);\n}\n\ngetYaml(url);\n\n// 简化后相当于\nfunction a() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(111)\n        }, 1000)\n    }).then(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve(222)\n            }, 1000)\n        })\n    })\n}\n\nasync function b() {\n    const x = await a();\n    console.log(x) // 222\n}\n\nb();\n\n\n请求的时候我们可以看到，请求文件的响应类型为 application/octet-stream，是二进制数据流的文件。\n\n\n\n * Blob对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。\n\n * XMLHttpRequest 属性 responseType 是一个枚举字符串值，用于指定响应中包含的数据类型。\n   \n   它还允许作者更改响应类型。XMLHttpRequest.responseType = blob 代表 response 是一个包含二进制数据的 Blob 对象。\n\n * FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。\n\n * FileReader.readAsText 方法可以将 Blob 或者 File 对象转根据特殊的编码格式转化为内容(字符串形式)',normalizedContent:'# yaml\n\nyaml 是一个可读性高，用来表达资料序列化的格式。常用于存储一些配置文件，如：\n\nreceipt:     oz-ware purchase invoice\ndate:        2012-08-06\ncustomer:\n    given:   dorothy\n    family:  gale\n   \nitems:\n    - part_no:   a4786\n      descrip:   water bucket (filled)\n      price:     1.47\n      quantity:  4\n\n    - part_no:   e1628\n      descrip:   high heeled "ruby" slippers\n      size:      8\n      price:     133.7\n      quantity:  1\n\n\nyaml 和 json 可以互相转换（在线转换工具），其实可以把 yaml 看成 json 文件的变形，其中短横线看做为数组，其他看作为对象。上面的 yaml 可以转换成如下 json：\n\n{\n    "receipt": "oz-ware purchase invoice",\n    "date": "2012-08-06t00:00:00.000z",\n    "customer": {\n        "given": "dorothy",\n        "family": "gale"\n    },\n    "items": [\n        {\n            "part_no": "a4786",\n            "descrip": "water bucket (filled)",\n            "price": 1.47,\n            "quantity": 4\n        },\n        {\n            "part_no": "e1628",\n            "descrip": "high heeled \\"ruby\\" slippers",\n            "size": 8,\n            "price": 133.7,\n            "quantity": 1\n        }\n    ]\n}\n\n\nnpm 包 yaml 也可实现该功能：\n\nimport fs from \'fs\'\nimport yaml from \'yaml\'\n\nconst file = fs.readfilesync(\'./file.yml\', \'utf8\')\nyaml.parse(file)\n\n\n举一个场景，后端提供了一份 yaml 文件的 url，前端如何将其下载并读取内容呢？\n\n// 根据获取 yaml 配置文件并转 json\nfunction getyaml(url) {\n  let that = this;\n  let fileurl = url;\n  let xhr = new xmlhttprequest();\n  xhr.open(\'get\', fileurl, true);\n  xhr.responsetype = \'blob\';\n  xhr.onload = function () {\n    if (this.status === 200) {\n      const reader = new filereader();\n      reader.readastext(this.response);\n      reader.onload = function () {\n        that.json = yaml.parse(reader.result);\n        that.parsejson(that.json);\n      };\n    }\n  };\n  xhr.send();\n}\n\n\n使用 axios 封装一下：\n\n> 这里有两层异步操作，第一步是 axios.get，第二步是文件读取 reader\n> \n> 第二层利用 promise 封装，使用 async / await 来得到 最终结果。\n\nfunction downloadyaml(url) {\n  return axios.get(url, {\n      responsetype: \'blob\',\n    })\n    .then(res => {\n      return new promise((resolve, reject) => {\n        const reader = new filereader();\n        reader.readastext(res.data);\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n      });\n    })\n});\n\nasync function getyaml(url){\n  const res = await downloadyaml(url);\n  this.json = yaml.parse(res);\n  this.parsejson(this.json);\n}\n\ngetyaml(url);\n\n// 简化后相当于\nfunction a() {\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            resolve(111)\n        }, 1000)\n    }).then(() => {\n        return new promise((resolve, reject) => {\n            settimeout(() => {\n                resolve(222)\n            }, 1000)\n        })\n    })\n}\n\nasync function b() {\n    const x = await a();\n    console.log(x) // 222\n}\n\nb();\n\n\n请求的时候我们可以看到，请求文件的响应类型为 application/octet-stream，是二进制数据流的文件。\n\n\n\n * blob对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 readablestream 来用于数据操作。\n\n * xmlhttprequest 属性 responsetype 是一个枚举字符串值，用于指定响应中包含的数据类型。\n   \n   它还允许作者更改响应类型。xmlhttprequest.responsetype = blob 代表 response 是一个包含二进制数据的 blob 对象。\n\n * filereader 对象允许web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 file 或 blob 对象指定要读取的文件或数据。\n\n * filereader.readastext 方法可以将 blob 或者 file 对象转根据特殊的编码格式转化为内容(字符串形式)',charsets:{cjk:!0}},{title:"面试准备",frontmatter:{},regularPath:"/time/code.html",relativePath:"time/code.md",key:"v-12ea54df",path:"/time/code.html",lastUpdated:"6/12/2025, 7:16:20 PM",lastUpdatedTimestamp:174972698e4,headersStr:null,content:"# 面试准备\n\n * part1\n   * 最长递增子序列：leetcode300\n   * 最长公共子序列(LCS)：leetcode1143\n   * 编辑距离：leetcode72\n   * 最大子序列和：leetcode53\n   * 打家劫舍：leetcode198\n   * 最小路径和：leetcode64\n   * 前序遍历：leetcode144\n   * 中序遍历：leetcode94\n   * 后序遍历：leetcode145\n * part2\n   * 实现 map、reduce、'abcd'.f() 返回 'd-c-b-a'\n   * this 指向\n   * new 实现\n   * 什么是原型\n   * 说出常见的数组方法\n   * 防抖、节流（时间戳版和定时器版并说出区别）\n   * osi七层协议，TCP/IP五层协议，arp/rarp协议\n   * BFC 概念\n   * 跨平台与跨端技术\n * part3\n   * 闭包：概念、优缺点、应用(Vue diff 算法、nodeOps)\n   * 函数式编程：纯函数、递归与尾递归、记忆函数、高阶函数、柯里化与偏函数、函数组合\n   * 垃圾回收机制（GC算法、内存泄露、内存溢出、V8引擎的内存分配与垃圾回收）\n   * 手写：并发请求控制、数组去重（4种）、数组扁平化（2种）、判断数组方法（5种）、instanceof\n   * Promise（手写、方法）、深拷贝、WeakMap、WeakSet\n   * fetch、ajax、axios、XHR 区别(ajax异步技术包括新的fetch和传统的XHR, axios是对XHR的封装)\n   * 合并有序数组：leetcode88\n   * 合并区间：leetcode56\n   * 前端缓存（浏览器缓存、HTTP缓存）cache-control、last-modified(3个缺点)、etag\n   * 事件循环(宏任务、微任务)、nextTick原理\n   * 二分查找：二分查找\n   * LRU：leetcode146\n   * 只出现过一次的数字：leetcode136\n   * 旋转矩阵：旋转矩阵\n   * diff 算法（createPatchFunction、patch、patchVnode、updateChildren、vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快、O(n^3) 和 O(n) 如何计算）\n   * 浏览器多进程架构、页面渲染解析过程、回流与重绘、CSS硬件加速、js/css 阻塞 dom 解析/渲染？、script 标签 defer、async\n   * 路径总和：leetcode112、求根到叶子节点数字之和：leetcode129\n   * 岛屿数量：leetcode200、岛屿最大面积：leetcode695\n   * 7层模型、UDP/TCP(超时重传、滑动窗口、流量控制、拥塞控制)、http（0.9 ~ 3、长连接/管道化、多路复用/二进制分帧/首部压缩）、队头阻塞（TCP和HTTP）、https\n   * 最近公共祖先：leetcode236、翻转二叉树：leetcode226、相同的树：leetcode100\n   * XSS（反射、存储、Dom）：httponly、转义、csp、x-xss-protected；CSRF：同源检测、samesite、验证码、token；点击劫持：禁止内嵌；中间人攻击；控制台注入；钓鱼；第三方依赖安全；\n   * 发布订阅模式、观察者模式、Object.create(null) 和 {} 区别\n   * 二叉树的层次遍历：leetcode102、二叉树的最大宽度：leetcode662、二叉树的右视图：leetcode199\n   * Vue 响应式原理、proxy（Reflect、receiver）\n   * 二叉树的最大深度：leetcode104、二叉树的最小深度：leetcode111、N叉树的最大深度：leetcode559\n   * vuex（state、mutation、action）、redux（state、reducer、action）、react-redux 区别\n   * 最长有效括号：leetcode32\n   * 前端路由：hash（hashchange）、history（pushState、replaceState、popState）\n   * 回溯算法、全排列：Leetcode46、括号生成：leetcode22、电话号码的数字组合：leetcode17、子集：Leetcode78\n   * 继承（ES5、ES6）、Object.create、call/apply/bind 实现\n   * 路径总和：leetcode112、路径总和II：leetcode112\n   * 组合总和：leetcode39、组合总和II：leetcode40\n   * http 状态码、cookie 和 session 区别、小程序原理\n * part4\n   * 面试题整理\n   * 前序中序构造二叉树：leetcode105\n   * 扁平数据结构转Tree、根据边构造二叉树\n   * 两个栈实现队列\n   * background-size: 100%、cover、contain 的区别\n     * 100%: 按容器比例撑满，图片变形；\n     * cover: 图片宽高比不变，把背景图片放大到适合元素容器的尺寸，但是超出容器的部分可能会裁掉。\n     * contain: 图片宽高比不变，缩放至整个图片自身能完全显示出来，所以容器会有留白区域。\n   * 最大宽度坡: leetcode962、表现良好的最长时间段: leetcode1124\n   * 最小栈: leetcode155\n   * 单调栈相关题目：\n     * 每日温度: leetcode739\n     * 下一个更大元素: leetcode496\n     * 接雨水: leetcode42\n     * 柱状图中的最大矩形: leetcode84\n     * 最大矩形: leetcode85\n     * 移掉 k 位数字: leetcode402\n   * 动态规划：\n     * 最大子序列和（连续）: leetcode53\n     * 最长递增子序列: leetcode300\n     * 最长公共子序列(LCS): leetcode1143\n     * 最长非重复子串: 剑指offer48\n     * 编辑距离(SES): leetcode72\n     * 买卖股票的最佳时机: leetcode121\n     * 最小路径和: leetcode64\n     * 三角形的最小路径和: leetcode120\n   * 顺时针打印矩阵: leetcode54\n   * 岛屿数量: leetcode200\n   * 岛屿最大面积: leetcode695\n   * 求根到叶子节点数字之和: leetcode129\n   * 路径总和: leetcode112\n   * 环形链表: leetcode141\n   * 环形链表2: leetcode142\n   * 树相关：\n     * 相同的树: leetcode100\n     * 判断二叉树是否对称: leetcode101\n     * 合并二叉树: leetcode617\n     * 求二叉树的深度(最大): leetcode104\n     * 求二叉树的深度(最小): leetcode111\n     * 翻转二叉树: leetcode226\n     * 验证二叉搜索树: leetcode98\n   * 数组第k大元素: leetcode215\n     * 堆排序、快排、冒泡、选择排序\n   * 合并两个有序链表: leetcode21\n   * 滑动窗口最大值: leetcode239\n * part5\n   * 什么是 promise?promise.all/allsettled/race/any\n   * 宏任务/微任务/事件循环，UI渲染在事件循环的哪个阶段？\n   * 虚拟DOM 的作用是什么？与真实DOM的区别？虚拟DOM的性能一定优于真实DOM吗？\n   * 如何优化 React 组件性能？虚拟列表，懒加载，批量状态更新，css代替js动画\n   * useEffect是用来干什么的， 有几个参数，依赖数组（deps）有什么作用？ 执行时机\n   * 介绍下 useMemo， useCallback，React.memo\n   * React组件渲染的两个阶段？\n   * 什么是 React Fiber？解决了什么问题？什么是双缓存fiber tree\n   * 为什么没有 Vue Fiber？vue 和 react 的渲染流程有什么区别？\n * part6\n   * 介绍下你理解的区块链（铸币，牺牲隐私，大型账本，不被篡改，哈希算法，哈希指针）\n   * 什么是共识机制，pos和pow\n   * 硬分叉(ETH和ETC)和软分叉(coinbase)\n   * Ghost 协议(以太坊出块时间较短)\n   * 什么是智能合约，什么是汽油费（图灵完备，停机问题，以太坊交易原子性，一旦错误汽油费不会退回）\n   * NFT Defi DAPP DAO 这些都是什么\n   * metamask 和 bianace/okx/bitget 这些交易所的区别\n   * 介绍下 ERC20 和 ERC721",normalizedContent:"# 面试准备\n\n * part1\n   * 最长递增子序列：leetcode300\n   * 最长公共子序列(lcs)：leetcode1143\n   * 编辑距离：leetcode72\n   * 最大子序列和：leetcode53\n   * 打家劫舍：leetcode198\n   * 最小路径和：leetcode64\n   * 前序遍历：leetcode144\n   * 中序遍历：leetcode94\n   * 后序遍历：leetcode145\n * part2\n   * 实现 map、reduce、'abcd'.f() 返回 'd-c-b-a'\n   * this 指向\n   * new 实现\n   * 什么是原型\n   * 说出常见的数组方法\n   * 防抖、节流（时间戳版和定时器版并说出区别）\n   * osi七层协议，tcp/ip五层协议，arp/rarp协议\n   * bfc 概念\n   * 跨平台与跨端技术\n * part3\n   * 闭包：概念、优缺点、应用(vue diff 算法、nodeops)\n   * 函数式编程：纯函数、递归与尾递归、记忆函数、高阶函数、柯里化与偏函数、函数组合\n   * 垃圾回收机制（gc算法、内存泄露、内存溢出、v8引擎的内存分配与垃圾回收）\n   * 手写：并发请求控制、数组去重（4种）、数组扁平化（2种）、判断数组方法（5种）、instanceof\n   * promise（手写、方法）、深拷贝、weakmap、weakset\n   * fetch、ajax、axios、xhr 区别(ajax异步技术包括新的fetch和传统的xhr, axios是对xhr的封装)\n   * 合并有序数组：leetcode88\n   * 合并区间：leetcode56\n   * 前端缓存（浏览器缓存、http缓存）cache-control、last-modified(3个缺点)、etag\n   * 事件循环(宏任务、微任务)、nexttick原理\n   * 二分查找：二分查找\n   * lru：leetcode146\n   * 只出现过一次的数字：leetcode136\n   * 旋转矩阵：旋转矩阵\n   * diff 算法（createpatchfunction、patch、patchvnode、updatechildren、vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快、o(n^3) 和 o(n) 如何计算）\n   * 浏览器多进程架构、页面渲染解析过程、回流与重绘、css硬件加速、js/css 阻塞 dom 解析/渲染？、script 标签 defer、async\n   * 路径总和：leetcode112、求根到叶子节点数字之和：leetcode129\n   * 岛屿数量：leetcode200、岛屿最大面积：leetcode695\n   * 7层模型、udp/tcp(超时重传、滑动窗口、流量控制、拥塞控制)、http（0.9 ~ 3、长连接/管道化、多路复用/二进制分帧/首部压缩）、队头阻塞（tcp和http）、https\n   * 最近公共祖先：leetcode236、翻转二叉树：leetcode226、相同的树：leetcode100\n   * xss（反射、存储、dom）：httponly、转义、csp、x-xss-protected；csrf：同源检测、samesite、验证码、token；点击劫持：禁止内嵌；中间人攻击；控制台注入；钓鱼；第三方依赖安全；\n   * 发布订阅模式、观察者模式、object.create(null) 和 {} 区别\n   * 二叉树的层次遍历：leetcode102、二叉树的最大宽度：leetcode662、二叉树的右视图：leetcode199\n   * vue 响应式原理、proxy（reflect、receiver）\n   * 二叉树的最大深度：leetcode104、二叉树的最小深度：leetcode111、n叉树的最大深度：leetcode559\n   * vuex（state、mutation、action）、redux（state、reducer、action）、react-redux 区别\n   * 最长有效括号：leetcode32\n   * 前端路由：hash（hashchange）、history（pushstate、replacestate、popstate）\n   * 回溯算法、全排列：leetcode46、括号生成：leetcode22、电话号码的数字组合：leetcode17、子集：leetcode78\n   * 继承（es5、es6）、object.create、call/apply/bind 实现\n   * 路径总和：leetcode112、路径总和ii：leetcode112\n   * 组合总和：leetcode39、组合总和ii：leetcode40\n   * http 状态码、cookie 和 session 区别、小程序原理\n * part4\n   * 面试题整理\n   * 前序中序构造二叉树：leetcode105\n   * 扁平数据结构转tree、根据边构造二叉树\n   * 两个栈实现队列\n   * background-size: 100%、cover、contain 的区别\n     * 100%: 按容器比例撑满，图片变形；\n     * cover: 图片宽高比不变，把背景图片放大到适合元素容器的尺寸，但是超出容器的部分可能会裁掉。\n     * contain: 图片宽高比不变，缩放至整个图片自身能完全显示出来，所以容器会有留白区域。\n   * 最大宽度坡: leetcode962、表现良好的最长时间段: leetcode1124\n   * 最小栈: leetcode155\n   * 单调栈相关题目：\n     * 每日温度: leetcode739\n     * 下一个更大元素: leetcode496\n     * 接雨水: leetcode42\n     * 柱状图中的最大矩形: leetcode84\n     * 最大矩形: leetcode85\n     * 移掉 k 位数字: leetcode402\n   * 动态规划：\n     * 最大子序列和（连续）: leetcode53\n     * 最长递增子序列: leetcode300\n     * 最长公共子序列(lcs): leetcode1143\n     * 最长非重复子串: 剑指offer48\n     * 编辑距离(ses): leetcode72\n     * 买卖股票的最佳时机: leetcode121\n     * 最小路径和: leetcode64\n     * 三角形的最小路径和: leetcode120\n   * 顺时针打印矩阵: leetcode54\n   * 岛屿数量: leetcode200\n   * 岛屿最大面积: leetcode695\n   * 求根到叶子节点数字之和: leetcode129\n   * 路径总和: leetcode112\n   * 环形链表: leetcode141\n   * 环形链表2: leetcode142\n   * 树相关：\n     * 相同的树: leetcode100\n     * 判断二叉树是否对称: leetcode101\n     * 合并二叉树: leetcode617\n     * 求二叉树的深度(最大): leetcode104\n     * 求二叉树的深度(最小): leetcode111\n     * 翻转二叉树: leetcode226\n     * 验证二叉搜索树: leetcode98\n   * 数组第k大元素: leetcode215\n     * 堆排序、快排、冒泡、选择排序\n   * 合并两个有序链表: leetcode21\n   * 滑动窗口最大值: leetcode239\n * part5\n   * 什么是 promise?promise.all/allsettled/race/any\n   * 宏任务/微任务/事件循环，ui渲染在事件循环的哪个阶段？\n   * 虚拟dom 的作用是什么？与真实dom的区别？虚拟dom的性能一定优于真实dom吗？\n   * 如何优化 react 组件性能？虚拟列表，懒加载，批量状态更新，css代替js动画\n   * useeffect是用来干什么的， 有几个参数，依赖数组（deps）有什么作用？ 执行时机\n   * 介绍下 usememo， usecallback，react.memo\n   * react组件渲染的两个阶段？\n   * 什么是 react fiber？解决了什么问题？什么是双缓存fiber tree\n   * 为什么没有 vue fiber？vue 和 react 的渲染流程有什么区别？\n * part6\n   * 介绍下你理解的区块链（铸币，牺牲隐私，大型账本，不被篡改，哈希算法，哈希指针）\n   * 什么是共识机制，pos和pow\n   * 硬分叉(eth和etc)和软分叉(coinbase)\n   * ghost 协议(以太坊出块时间较短)\n   * 什么是智能合约，什么是汽油费（图灵完备，停机问题，以太坊交易原子性，一旦错误汽油费不会退回）\n   * nft defi dapp dao 这些都是什么\n   * metamask 和 bianace/okx/bitget 这些交易所的区别\n   * 介绍下 erc20 和 erc721",charsets:{cjk:!0}},{title:"《深入理解 TypeScript》",frontmatter:{},regularPath:"/ts/book.html",relativePath:"ts/book.md",key:"v-66d04f5f",path:"/ts/book.html",headers:[{level:2,title:"第一章 为什么要使用 TypeScript",slug:"第一章-为什么要使用-typescript",normalizedTitle:"第一章 为什么要使用 typescript",charIndex:24},{level:2,title:"第二章 JavaScript 常见语法",slug:"第二章-javascript-常见语法",normalizedTitle:"第二章 javascript 常见语法",charIndex:121},{level:3,title:"相等",slug:"相等",normalizedTitle:"相等",charIndex:407},{level:3,title:"null 和 undefined",slug:"null-和-undefined",normalizedTitle:"null 和 undefined",charIndex:619},{level:3,title:"数字",slug:"数字",normalizedTitle:"数字",charIndex:1342},{level:2,title:"第三章 JavaScript新语法特性",slug:"第三章-javascript新语法特性",normalizedTitle:"第三章 javascript新语法特性",charIndex:2240},{level:3,title:"3.1 类",slug:"_3-1-类",normalizedTitle:"3.1 类",charIndex:2264},{level:3,title:"3.2 箭头函数",slug:"_3-2-箭头函数",normalizedTitle:"3.2 箭头函数",charIndex:3124},{level:3,title:"3.3 let",slug:"_3-3-let",normalizedTitle:"3.3 let",charIndex:3948},{level:3,title:"3.4 rest",slug:"_3-4-rest",normalizedTitle:"3.4 rest",charIndex:4370},{level:3,title:"3.5 扩展运算符",slug:"_3-5-扩展运算符",normalizedTitle:"3.5 扩展运算符",charIndex:4515}],lastUpdated:"4/8/2022, 3:26:25 PM",lastUpdatedTimestamp:1649402785e3,headersStr:"第一章 为什么要使用 TypeScript 第二章 JavaScript 常见语法 相等 null 和 undefined 数字 第三章 JavaScript新语法特性 3.1 类 3.2 箭头函数 3.3 let 3.4 rest 3.5 扩展运算符",content:'# 《深入理解 TypeScript》\n\n\n# 第一章 为什么要使用 TypeScript\n\n * 为 JavaScript 提供可选的类型系统\n * 兼容当前及未来的 JavaScript 的特性，是 JavaScript 的超集\n\n\n# 第二章 JavaScript 常见语法\n\nTypeScript 将试图保护你免受无意义的 JavaScript 代码的影响，关于 JavaScript 的知识仍然需要学习。\n\n[] + []; // JavaScript 返回 \'\'，TypeScript 会报错\n{} + []; // JavaScript 返回 0，TypeScript 会报错\n[] + {}; // JavaScript 返回 [object Object]，TypeScript 会报错\n\'hello\' - 1; // JavaScript 返回 NaN，TypeScript 会报错\n\n\n\n# 相等\n\n在 JavaScript 中：\n\n5 == \'5\' // true\n5 === \'5\' // false\n"" == "0" // false\n"" == 0 // true\n\n\n而在 TypeScript 中在编写代码时就会报错，避免了隐式类型转换：\n\n5 == \'5\' // false\n5 === \'5\' // false\n"" == "0" // false\n"" == 0 // false\n\n\n\n\n\n# null 和 undefined\n\n * undefined：变量没有初始化\n * null：变量不可用\n\n无论在 JavaScript 还是在 TypeScript 中：\n\nnull == undefined // true\n0 == undefined // false\n"" == undefined // false \nfalse == undefined // false\n\n\n推荐使用 == null 来检查 undefined 和 null，因为你通常不希望区分它们。\n\nfunction foo (arg: string | null | undefined) {\n  if (arg != null) {\n    // arg 是字符串的情况，因为 != 排除了 null 和 undefined\n  }\n}\n\n\n限制显示地使用 undefined\n\nfunction foo() {\n  // if ...\n  return { a: 1, b: 2 }\n  // else ...\n  return { a: 1, b: undefined }\n}\n\n// 应该使用一个返回值的类型注解\nfunction foo(): {a: number, b?: number} {\n  // if ...\n  return { a: 1, b: 2 }\n  // else ...\n  return { a: 1}\n}\n\n\nJson 和序列化\n\n// JSON 标准支持编码 null，但是不支持 undefined\nJSON.stringify({a: null, b: undefined}) // {a: null}\n\n\n\n# 数字\n\n内置数字类型表示的整数限制是\n\nconsole.log({max: Number.MAX_SAFE_INTEGER, min: Number.MIN_SAFE_INTEGER})\n// {max: 9007199254740991, min: -9007199254740991}\n\n// 不安全的值会存在误差\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2) // true\n\n\n为了检查是否安全可以使用Number.isSafeInteger\n\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n\n\n无穷\n\n数字的边界值可以用 Number.MAX_VALUE 和 -Number.MAX_VALUE 的值来表示\n\nconsole.log(Number.MAX_VALUE) // 1.7976931348623157e+308\nconsole.log(-Number.MAX_VALUE) // -1.7976931348623157e+308\n\n\n超出边界但是精读没有改变的值都被限制在此范围内，但是超出边界且精度已经改变的值，用 Infinity 表示\n\nconsole.log(Number.MAX_VALUE + 10**1000); // Infinity\n\n\n最小非 0 值可以用 Number.MIN_VALUE 来表示\n\nconsole.log(Number.MIN_VALUE); // 5e-324\n\n// 小于 MIN_VALUE 的值会被转换为 0\nconsole.log(Number.MIN_VALUE / 10); // 0\n\n\n> 就像大于 Number.MAX_VALUE 的值会被限制为 Infinity，小于 Number.MIN_VALUE 的值会被限制为 0\n\n\n# 第三章 JavaScript新语法特性\n\n\n# 3.1 类\n\n1. 继承：支持使用 extends 关键字实现单继承\n\n2. 静态：静态属性会被所有的实例共享\n\nclass Something {\n  static instances = 0;\n  constructor() {\n\t\tSomething.instances++;\n  }\n}\n\nvar s1 = new Something();\nvar s2 = new Something();\nconsole.log(Something.instances); // 2\n\n\n3. 访问修饰符：public、private、protected\n\n可访问   PUBLIC   PROTECTED   PRIVATE\n类     是        是           是\n子类    是        是           否\n实例    是        否           否\n\n在运行时（在编译后的 JavaScipt 代码中），这些没有任何意义，但是如果你没有正确地使用它们的话，在编译时会抛出错误。\n\n4. 抽象：拥有一个 abstract 修饰符意味着该函数不能直接被调用，并且子类必须实现这个功能\n\n * abstract 类不能直接被实例化，用户必须创建一个类来继承 abstract 类\n * abstract 成员不能直接被访问，子类必须实现这个功能\n\n5. 构造器：构造器是可选的，类不是必须要有一个构造器，示例如下：\n\nclass Foo {}\nvar foo = new Foo();\n\n\n可以使用构造器来定义成员变量\n\nclass Foo {\n  x: number;\n  constructor(x: number) {\n    this.x = x;\n  }\n}\n\n// TS 为这种方式提供了一个缩写，x 加一个修饰符前缀，它会在类上自动声明，并且从构造器中复制过去\nclass Foo {\n  constructor(public x: number)\n}\n\n\n\n# 3.2 箭头函数\n\nthis 一直是 JavaScript 的一个痛点，箭头函数通过使用捕获上下文的 this 的意义的方式，修复了此问题。\n\nfunction Person(age) {\n  this.age = age;\n  this.growOld = function() {\n    this.age++;\n  }\n}\n\nvar person = new Person(1);\nsetTimeout(person.growOld, 1000);\nsetTimeout(function() {\n  console.log(person.age); // 1\n}, 2000)\n\n\n如果在浏览器中运行，函数中的 this 将会指向 window，利用箭头函数改写\n\nfunction Person(age) {\n  this.age = age;\n  this.growOld = () => {\n    this.age++;\n  }\n}\n\n// 相当于捕获了 this\nfunction Person(age) {\n  this.age = age;\n  var _this = this;\n  this.growOld = function() {\n    _this.age++;\n  }\n}\n\nvar person = new Person(1);\nsetTimeout(person.growOld, 1000);\nsetTimeout(function() {\n  console.log(person.age); // 1\n}, 2000)\n\n\n快速返回对象\n\n// 错误\nvar foo = () => {\n  bar: 123\n}\n\n// 正确\nvar foo = () => {\n  return { bar: 123 }\n}\n\n// 正确\nvar foo = () => ({\n  bar: 123\n})\n\n\n\n# 3.3 let\n\nlet 声明了块级作用域，let 关键字，创建块级作用域的条件是必须有一个 { } 包裹：\n\nvar foo = 123;\nif (true) {\n    var foo = 456;\n}\nconsole.log(foo); // 456\n\n// test.ts\nlet foo = 123;\nif (true) {\n    let foo = 456;\n}\nconsole.log(foo); // 123\n\n// 以上代码经过 ts 转换后会创建一个新的变量名\nvar foo = 123;\nif (true) {\n    var foo_1 = 456;\n}\nconsole.log(foo);\n\n\n除 let 外，函数也可以创建一个新的作用域\n\nvar foo = 123\nfunction test() {\n  var foo = 456\n}\ntest()\nconsole.log(foo) // 123\n\n\n\n# 3.4 rest\n\n使用 rest 可以删除成员\n\nconst point3D = { x: 1, y: 2, z: 3 };\n\nconst { z, ...point2D } = point3D;\nconsole.log(point2D); // { x: 1, y: 2 }\n\n\n\n# 3.5 扩展运算符\n\n对于对象来说，扩展的顺序很重要，后面的属性可以覆盖前面的属性。\n\nconst point2D = { x: 1, y: 2 };\nconst point3D = { x: 5, z: 4, ...point2D }; // { x: 1, y: 2, z: 4}\n',normalizedContent:'# 《深入理解 typescript》\n\n\n# 第一章 为什么要使用 typescript\n\n * 为 javascript 提供可选的类型系统\n * 兼容当前及未来的 javascript 的特性，是 javascript 的超集\n\n\n# 第二章 javascript 常见语法\n\ntypescript 将试图保护你免受无意义的 javascript 代码的影响，关于 javascript 的知识仍然需要学习。\n\n[] + []; // javascript 返回 \'\'，typescript 会报错\n{} + []; // javascript 返回 0，typescript 会报错\n[] + {}; // javascript 返回 [object object]，typescript 会报错\n\'hello\' - 1; // javascript 返回 nan，typescript 会报错\n\n\n\n# 相等\n\n在 javascript 中：\n\n5 == \'5\' // true\n5 === \'5\' // false\n"" == "0" // false\n"" == 0 // true\n\n\n而在 typescript 中在编写代码时就会报错，避免了隐式类型转换：\n\n5 == \'5\' // false\n5 === \'5\' // false\n"" == "0" // false\n"" == 0 // false\n\n\n\n\n\n# null 和 undefined\n\n * undefined：变量没有初始化\n * null：变量不可用\n\n无论在 javascript 还是在 typescript 中：\n\nnull == undefined // true\n0 == undefined // false\n"" == undefined // false \nfalse == undefined // false\n\n\n推荐使用 == null 来检查 undefined 和 null，因为你通常不希望区分它们。\n\nfunction foo (arg: string | null | undefined) {\n  if (arg != null) {\n    // arg 是字符串的情况，因为 != 排除了 null 和 undefined\n  }\n}\n\n\n限制显示地使用 undefined\n\nfunction foo() {\n  // if ...\n  return { a: 1, b: 2 }\n  // else ...\n  return { a: 1, b: undefined }\n}\n\n// 应该使用一个返回值的类型注解\nfunction foo(): {a: number, b?: number} {\n  // if ...\n  return { a: 1, b: 2 }\n  // else ...\n  return { a: 1}\n}\n\n\njson 和序列化\n\n// json 标准支持编码 null，但是不支持 undefined\njson.stringify({a: null, b: undefined}) // {a: null}\n\n\n\n# 数字\n\n内置数字类型表示的整数限制是\n\nconsole.log({max: number.max_safe_integer, min: number.min_safe_integer})\n// {max: 9007199254740991, min: -9007199254740991}\n\n// 不安全的值会存在误差\nconsole.log(number.max_safe_integer + 1 === number.max_safe_integer + 2) // true\n\n\n为了检查是否安全可以使用number.issafeinteger\n\nnumber.issafeinteger(number.max_safe_integer) // true\nnumber.issafeinteger(number.max_safe_integer + 1) // false\n\n\n无穷\n\n数字的边界值可以用 number.max_value 和 -number.max_value 的值来表示\n\nconsole.log(number.max_value) // 1.7976931348623157e+308\nconsole.log(-number.max_value) // -1.7976931348623157e+308\n\n\n超出边界但是精读没有改变的值都被限制在此范围内，但是超出边界且精度已经改变的值，用 infinity 表示\n\nconsole.log(number.max_value + 10**1000); // infinity\n\n\n最小非 0 值可以用 number.min_value 来表示\n\nconsole.log(number.min_value); // 5e-324\n\n// 小于 min_value 的值会被转换为 0\nconsole.log(number.min_value / 10); // 0\n\n\n> 就像大于 number.max_value 的值会被限制为 infinity，小于 number.min_value 的值会被限制为 0\n\n\n# 第三章 javascript新语法特性\n\n\n# 3.1 类\n\n1. 继承：支持使用 extends 关键字实现单继承\n\n2. 静态：静态属性会被所有的实例共享\n\nclass something {\n  static instances = 0;\n  constructor() {\n\t\tsomething.instances++;\n  }\n}\n\nvar s1 = new something();\nvar s2 = new something();\nconsole.log(something.instances); // 2\n\n\n3. 访问修饰符：public、private、protected\n\n可访问   public   protected   private\n类     是        是           是\n子类    是        是           否\n实例    是        否           否\n\n在运行时（在编译后的 javascipt 代码中），这些没有任何意义，但是如果你没有正确地使用它们的话，在编译时会抛出错误。\n\n4. 抽象：拥有一个 abstract 修饰符意味着该函数不能直接被调用，并且子类必须实现这个功能\n\n * abstract 类不能直接被实例化，用户必须创建一个类来继承 abstract 类\n * abstract 成员不能直接被访问，子类必须实现这个功能\n\n5. 构造器：构造器是可选的，类不是必须要有一个构造器，示例如下：\n\nclass foo {}\nvar foo = new foo();\n\n\n可以使用构造器来定义成员变量\n\nclass foo {\n  x: number;\n  constructor(x: number) {\n    this.x = x;\n  }\n}\n\n// ts 为这种方式提供了一个缩写，x 加一个修饰符前缀，它会在类上自动声明，并且从构造器中复制过去\nclass foo {\n  constructor(public x: number)\n}\n\n\n\n# 3.2 箭头函数\n\nthis 一直是 javascript 的一个痛点，箭头函数通过使用捕获上下文的 this 的意义的方式，修复了此问题。\n\nfunction person(age) {\n  this.age = age;\n  this.growold = function() {\n    this.age++;\n  }\n}\n\nvar person = new person(1);\nsettimeout(person.growold, 1000);\nsettimeout(function() {\n  console.log(person.age); // 1\n}, 2000)\n\n\n如果在浏览器中运行，函数中的 this 将会指向 window，利用箭头函数改写\n\nfunction person(age) {\n  this.age = age;\n  this.growold = () => {\n    this.age++;\n  }\n}\n\n// 相当于捕获了 this\nfunction person(age) {\n  this.age = age;\n  var _this = this;\n  this.growold = function() {\n    _this.age++;\n  }\n}\n\nvar person = new person(1);\nsettimeout(person.growold, 1000);\nsettimeout(function() {\n  console.log(person.age); // 1\n}, 2000)\n\n\n快速返回对象\n\n// 错误\nvar foo = () => {\n  bar: 123\n}\n\n// 正确\nvar foo = () => {\n  return { bar: 123 }\n}\n\n// 正确\nvar foo = () => ({\n  bar: 123\n})\n\n\n\n# 3.3 let\n\nlet 声明了块级作用域，let 关键字，创建块级作用域的条件是必须有一个 { } 包裹：\n\nvar foo = 123;\nif (true) {\n    var foo = 456;\n}\nconsole.log(foo); // 456\n\n// test.ts\nlet foo = 123;\nif (true) {\n    let foo = 456;\n}\nconsole.log(foo); // 123\n\n// 以上代码经过 ts 转换后会创建一个新的变量名\nvar foo = 123;\nif (true) {\n    var foo_1 = 456;\n}\nconsole.log(foo);\n\n\n除 let 外，函数也可以创建一个新的作用域\n\nvar foo = 123\nfunction test() {\n  var foo = 456\n}\ntest()\nconsole.log(foo) // 123\n\n\n\n# 3.4 rest\n\n使用 rest 可以删除成员\n\nconst point3d = { x: 1, y: 2, z: 3 };\n\nconst { z, ...point2d } = point3d;\nconsole.log(point2d); // { x: 1, y: 2 }\n\n\n\n# 3.5 扩展运算符\n\n对于对象来说，扩展的顺序很重要，后面的属性可以覆盖前面的属性。\n\nconst point2d = { x: 1, y: 2 };\nconst point3d = { x: 5, z: 4, ...point2d }; // { x: 1, y: 2, z: 4}\n',charsets:{cjk:!0}},{title:"Performance",frontmatter:{},regularPath:"/tool/performance.html",relativePath:"tool/performance.md",key:"v-1397f439",path:"/tool/performance.html",headers:[{level:2,title:"一、核心功能",slug:"一、核心功能",normalizedTitle:"一、核心功能",charIndex:191},{level:2,title:"二、关键接口与使用方法",slug:"二、关键接口与使用方法",normalizedTitle:"二、关键接口与使用方法",charIndex:436},{level:3,title:"1. Performance Timing（性能时间线）",slug:"_1-performance-timing-性能时间线",normalizedTitle:"1. performance timing（性能时间线）",charIndex:452},{level:3,title:"2. Resource Timing API",slug:"_2-resource-timing-api",normalizedTitle:"2. resource timing api",charIndex:1525},{level:3,title:"3. User Timing API",slug:"_3-user-timing-api",normalizedTitle:"3. user timing api",charIndex:2078},{level:3,title:"4. Performance Observer API",slug:"_4-performance-observer-api",normalizedTitle:"4. performance observer api",charIndex:2465},{level:3,title:"5. High Resolution Time API",slug:"_5-high-resolution-time-api",normalizedTitle:"5. high resolution time api",charIndex:2972},{level:2,title:"三、核心性能指标（Web Vitals）",slug:"三、核心性能指标-web-vitals",normalizedTitle:"三、核心性能指标（web vitals）",charIndex:3241},{level:2,title:"四、实际应用案例",slug:"四、实际应用案例",normalizedTitle:"四、实际应用案例",charIndex:3753},{level:3,title:"1. 性能监控与上报",slug:"_1-性能监控与上报",normalizedTitle:"1. 性能监控与上报",charIndex:3766},{level:3,title:"2. 优化资源加载策略",slug:"_2-优化资源加载策略",normalizedTitle:"2. 优化资源加载策略",charIndex:4394},{level:3,title:"3. 检测卡顿（长任务）",slug:"_3-检测卡顿-长任务",normalizedTitle:"3. 检测卡顿（长任务）",charIndex:4631},{level:2,title:"五、浏览器兼容性",slug:"五、浏览器兼容性",normalizedTitle:"五、浏览器兼容性",charIndex:4920},{level:2,title:"六、总结",slug:"六、总结",normalizedTitle:"六、总结",charIndex:5205}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"一、核心功能 二、关键接口与使用方法 1. Performance Timing（性能时间线） 2. Resource Timing API 3. User Timing API 4. Performance Observer API 5. High Resolution Time API 三、核心性能指标（Web Vitals） 四、实际应用案例 1. 性能监控与上报 2. 优化资源加载策略 3. 检测卡顿（长任务） 五、浏览器兼容性 六、总结",content:"# Performance\n\nPerformance API 是 Web 平台提供的一组 JavaScript 接口，用于精确测量和分析网页或应用的性能指标（如加载时间、渲染耗时、资源加载效率等）。它通过 window.performance 对象暴露，开发者可以利用这些数据优化用户体验、定位性能瓶颈，并监控应用运行状态。以下是其核心功能、关键接口及使用场景的详细介绍：\n\n\n# 一、核心功能\n\nPerformance API 主要解决以下问题：\n\n 1. 精确计时：提供高精度时间戳（毫秒级，部分浏览器支持微秒级），避免 Date.now() 的精度限制。\n 2. 性能指标采集：记录页面生命周期各阶段（如导航、渲染、资源加载）的耗时。\n 3. 资源监控：跟踪图片、脚本、样式等资源的加载时间和状态。\n 4. 用户行为分析：测量交互事件（如点击、滚动）的响应延迟。\n 5. 长期性能监控：结合 PerformanceObserver 实现实时数据收集和上报。\n\n\n# 二、关键接口与使用方法\n\n\n# 1. Performance Timing（性能时间线）\n\n# （1）Navigation Timing API\n\n记录页面导航（从用户发起请求到页面完全加载）的各个阶段耗时，通过 performance.timing 或 performance.getEntriesByType('navigation')[0] 获取。\n\n示例字段：\n\nconst timing = performance.getEntriesByType('navigation')[0];\nconsole.log({\n  // 用户发起请求的时间戳（相对于页面加载起点）\n  navigationStart: timing.navigationStart,\n  // DNS查询耗时\n  domainLookupEnd - timing.domainLookupStart,\n  // TCP连接耗时\n  connectEnd - timing.connectStart,\n  // 请求到响应开始（TTFB）\n  responseStart - timing.requestStart,\n  // 响应数据接收耗时\n  responseEnd - timing.responseStart,\n  // DOM解析耗时\n  domComplete - timing.domInteractive,\n  // 页面完全加载耗时\n  loadEventEnd - timing.navigationStart,\n});\n\n\n可视化工具： Chrome DevTools 的 Performance 面板会自动解析这些数据，生成瀑布图（Waterfall Chart）。\n\n# （2）Paint Timing API\n\n记录页面首次渲染（First Paint, FP）和首次内容渲染（First Contentful Paint, FCP）的时间点。\n\nconst paintEntries = performance.getEntriesByType('paint');\nconsole.log({\n  'First Paint': paintEntries.find(e => e.name === 'first-paint')?.startTime,\n  'First Contentful Paint': paintEntries.find(e => e.name === 'first-contentful-paint')?.startTime,\n});\n\n\n\n# 2. Resource Timing API\n\n监控所有资源（脚本、样式、图片、XHR/Fetch请求等）的加载性能，通过 performance.getEntriesByType('resource') 获取。\n\n示例字段：\n\nconst resources = performance.getEntriesByType('resource');\nresources.forEach(resource => {\n  console.log({\n    name: resource.name, // 资源URL\n    duration: resource.duration, // 总耗时\n    initiatorType: resource.initiatorType, // 资源类型（script/img/css等）\n    transferSize: resource.transferSize, // 传输大小（含头部）\n    encodedBodySize: resource.encodedBodySize, // 压缩后大小\n  });\n});\n\n\n应用场景：\n\n * 识别慢加载资源（如大图片、未压缩的JS文件）。\n * 分析第三方脚本（如广告、分析工具）对性能的影响。\n\n\n# 3. User Timing API\n\n标记自定义代码段的执行时间，用于测量关键业务逻辑的耗时。\n\n示例：\n\n// 标记开始\nperformance.mark('API_Request_Start');\n \n// 模拟异步请求\nsetTimeout(() => {\n  performance.mark('API_Request_End');\n \n  // 计算区间耗时\n  const measure = performance.measure('API_Request_Duration', 'API_Request_Start', 'API_Request_End');\n  console.log(measure.duration); // 耗时（毫秒）\n}, 1000);\n\n\n优势： 比手动记录 Date.now() 更精确，且可与浏览器性能工具集成。\n\n\n# 4. Performance Observer API\n\n实时监听性能事件（如资源加载、长任务等），避免轮询查询性能数据。\n\n示例：\n\nconst observer = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach(entry => {\n    if (entry.entryType === 'longtask') {\n      console.warn('Long task detected:', entry.duration); // 检测长任务（>50ms）\n    }\n  });\n});\n \n// 监听长任务和资源加载\nobserver.observe({ entryTypes: ['longtask', 'resource'] });\n\n\n常见监听类型：\n\n * paint：首次渲染事件。\n * resource：资源加载事件。\n * longtask：主线程被阻塞超过50ms的任务（可能导致卡顿）。\n * navigation：页面导航事件。\n\n\n# 5. High Resolution Time API\n\n提供高精度时间戳（performance.now()），相对于页面加载起点（performance.timeOrigin），精度可达微秒级（受浏览器限制）。\n\n对比 Date.now()：\n\nconsole.log(Date.now()); // 系统时间，可能被调整（如用户修改时钟）\nconsole.log(performance.now()); // 相对于页面加载的稳定时间，不受系统时间影响\n\n\n应用场景： 精确测量代码执行时间（如动画帧间隔、游戏逻辑耗时）。\n\n\n# 三、核心性能指标（Web Vitals）\n\nGoogle 提出的 Web Vitals 是一组关键性能指标，可通过 Performance API 计算：\n\n 1. LCP（Largest Contentful Paint）\n    \n    ：最大内容元素渲染时间（衡量页面主要内容加载速度）。\n    \n    const lcp = performance.getEntriesByType('largest-contentful-paint')[0];\n    console.log('LCP:', lcp.startTime);\n    \n\n 2. FID（First Input Delay）：首次输入延迟（衡量交互响应速度）。 需通过 Event Timing API 或真实用户监控（RUM）获取。\n\n 3. CLS（Cumulative Layout Shift）：累计布局偏移（衡量页面稳定性）。 需通过 Layout Instability API 计算。\n\n 4. TTI（Time to Interactive）：可交互时间（衡量页面完全可用的时间）。 需结合长任务和资源加载状态计算。\n\n\n# 四、实际应用案例\n\n\n# 1. 性能监控与上报\n\nfunction reportPerformance() {\n  const data = {\n    navigation: performance.getEntriesByType('navigation')[0],\n    resources: performance.getEntriesByType('resource').map(r => ({\n      url: r.name,\n      duration: r.duration,\n    })),\n    timings: {\n      FCP: performance.getEntriesByName('first-contentful-paint')[0]?.startTime,\n      LCP: performance.getEntriesByType('largest-contentful-paint')[0]?.startTime,\n    },\n  };\n \n  // 上报到分析平台（如Google Analytics、Sentry）\n  navigator.sendBeacon('/api/performance', JSON.stringify(data));\n}\n \n// 在页面卸载时触发上报\nwindow.addEventListener('beforeunload', reportPerformance);\n\n\n\n# 2. 优化资源加载策略\n\n// 识别慢加载资源并优化\nconst slowResources = performance.getEntriesByType('resource')\n  .filter(r => r.duration > 1000) // 过滤耗时>1s的资源\n  .map(r => r.name);\n \nconsole.warn('Slow resources:', slowResources);\n// 解决方案：预加载、CDN加速、代码分割\n\n\n\n# 3. 检测卡顿（长任务）\n\nconst observer = new PerformanceObserver((list) => {\n  list.getEntries().forEach(entry => {\n    if (entry.duration > 50) {\n      console.error('Long task detected:', entry);\n      // 解决方案：拆分任务、使用Web Worker\n    }\n  });\n});\nobserver.observe({ entryTypes: ['longtask'] });\n\n\n\n# 五、浏览器兼容性\n\n * 主流支持：现代浏览器（Chrome、Firefox、Edge、Safari）均支持 Performance API 的核心功能。\n\n * 部分差异\n   \n   * performance.getEntriesByType('largest-contentful-paint') 在旧版浏览器中可能缺失。\n   * PerformanceObserver 的 entryTypes 支持程度不同（如 longtask 在部分移动端浏览器中不可用）。\n\n * 降级方案：使用 polyfill（如 web-vitals 库）或特征检测。\n\n\n# 六、总结\n\nAPI 分类          核心接口                                       典型应用场景\nTiming API      performance.timing                         分析页面加载生命周期\nResource API    performance.getEntriesByType('resource')   监控资源加载性能\nUser Timing     performance.mark() / measure()             测量自定义代码段耗时\nObserver API    PerformanceObserver                        实时监听性能事件（如长任务）\nHigh Res Time   performance.now()                          高精度计时（动画、游戏）\n\nPerformance API 是前端性能优化的“瑞士军刀”，结合 Chrome DevTools 和自动化监控工具（如 Lighthouse、Sentry），可构建完整的性能分析体系。对于微前端、SPA 等复杂应用，它能帮助开发者精准定位子应用加载、路由切换等场景的性能问题。",normalizedContent:"# performance\n\nperformance api 是 web 平台提供的一组 javascript 接口，用于精确测量和分析网页或应用的性能指标（如加载时间、渲染耗时、资源加载效率等）。它通过 window.performance 对象暴露，开发者可以利用这些数据优化用户体验、定位性能瓶颈，并监控应用运行状态。以下是其核心功能、关键接口及使用场景的详细介绍：\n\n\n# 一、核心功能\n\nperformance api 主要解决以下问题：\n\n 1. 精确计时：提供高精度时间戳（毫秒级，部分浏览器支持微秒级），避免 date.now() 的精度限制。\n 2. 性能指标采集：记录页面生命周期各阶段（如导航、渲染、资源加载）的耗时。\n 3. 资源监控：跟踪图片、脚本、样式等资源的加载时间和状态。\n 4. 用户行为分析：测量交互事件（如点击、滚动）的响应延迟。\n 5. 长期性能监控：结合 performanceobserver 实现实时数据收集和上报。\n\n\n# 二、关键接口与使用方法\n\n\n# 1. performance timing（性能时间线）\n\n# （1）navigation timing api\n\n记录页面导航（从用户发起请求到页面完全加载）的各个阶段耗时，通过 performance.timing 或 performance.getentriesbytype('navigation')[0] 获取。\n\n示例字段：\n\nconst timing = performance.getentriesbytype('navigation')[0];\nconsole.log({\n  // 用户发起请求的时间戳（相对于页面加载起点）\n  navigationstart: timing.navigationstart,\n  // dns查询耗时\n  domainlookupend - timing.domainlookupstart,\n  // tcp连接耗时\n  connectend - timing.connectstart,\n  // 请求到响应开始（ttfb）\n  responsestart - timing.requeststart,\n  // 响应数据接收耗时\n  responseend - timing.responsestart,\n  // dom解析耗时\n  domcomplete - timing.dominteractive,\n  // 页面完全加载耗时\n  loadeventend - timing.navigationstart,\n});\n\n\n可视化工具： chrome devtools 的 performance 面板会自动解析这些数据，生成瀑布图（waterfall chart）。\n\n# （2）paint timing api\n\n记录页面首次渲染（first paint, fp）和首次内容渲染（first contentful paint, fcp）的时间点。\n\nconst paintentries = performance.getentriesbytype('paint');\nconsole.log({\n  'first paint': paintentries.find(e => e.name === 'first-paint')?.starttime,\n  'first contentful paint': paintentries.find(e => e.name === 'first-contentful-paint')?.starttime,\n});\n\n\n\n# 2. resource timing api\n\n监控所有资源（脚本、样式、图片、xhr/fetch请求等）的加载性能，通过 performance.getentriesbytype('resource') 获取。\n\n示例字段：\n\nconst resources = performance.getentriesbytype('resource');\nresources.foreach(resource => {\n  console.log({\n    name: resource.name, // 资源url\n    duration: resource.duration, // 总耗时\n    initiatortype: resource.initiatortype, // 资源类型（script/img/css等）\n    transfersize: resource.transfersize, // 传输大小（含头部）\n    encodedbodysize: resource.encodedbodysize, // 压缩后大小\n  });\n});\n\n\n应用场景：\n\n * 识别慢加载资源（如大图片、未压缩的js文件）。\n * 分析第三方脚本（如广告、分析工具）对性能的影响。\n\n\n# 3. user timing api\n\n标记自定义代码段的执行时间，用于测量关键业务逻辑的耗时。\n\n示例：\n\n// 标记开始\nperformance.mark('api_request_start');\n \n// 模拟异步请求\nsettimeout(() => {\n  performance.mark('api_request_end');\n \n  // 计算区间耗时\n  const measure = performance.measure('api_request_duration', 'api_request_start', 'api_request_end');\n  console.log(measure.duration); // 耗时（毫秒）\n}, 1000);\n\n\n优势： 比手动记录 date.now() 更精确，且可与浏览器性能工具集成。\n\n\n# 4. performance observer api\n\n实时监听性能事件（如资源加载、长任务等），避免轮询查询性能数据。\n\n示例：\n\nconst observer = new performanceobserver((list) => {\n  const entries = list.getentries();\n  entries.foreach(entry => {\n    if (entry.entrytype === 'longtask') {\n      console.warn('long task detected:', entry.duration); // 检测长任务（>50ms）\n    }\n  });\n});\n \n// 监听长任务和资源加载\nobserver.observe({ entrytypes: ['longtask', 'resource'] });\n\n\n常见监听类型：\n\n * paint：首次渲染事件。\n * resource：资源加载事件。\n * longtask：主线程被阻塞超过50ms的任务（可能导致卡顿）。\n * navigation：页面导航事件。\n\n\n# 5. high resolution time api\n\n提供高精度时间戳（performance.now()），相对于页面加载起点（performance.timeorigin），精度可达微秒级（受浏览器限制）。\n\n对比 date.now()：\n\nconsole.log(date.now()); // 系统时间，可能被调整（如用户修改时钟）\nconsole.log(performance.now()); // 相对于页面加载的稳定时间，不受系统时间影响\n\n\n应用场景： 精确测量代码执行时间（如动画帧间隔、游戏逻辑耗时）。\n\n\n# 三、核心性能指标（web vitals）\n\ngoogle 提出的 web vitals 是一组关键性能指标，可通过 performance api 计算：\n\n 1. lcp（largest contentful paint）\n    \n    ：最大内容元素渲染时间（衡量页面主要内容加载速度）。\n    \n    const lcp = performance.getentriesbytype('largest-contentful-paint')[0];\n    console.log('lcp:', lcp.starttime);\n    \n\n 2. fid（first input delay）：首次输入延迟（衡量交互响应速度）。 需通过 event timing api 或真实用户监控（rum）获取。\n\n 3. cls（cumulative layout shift）：累计布局偏移（衡量页面稳定性）。 需通过 layout instability api 计算。\n\n 4. tti（time to interactive）：可交互时间（衡量页面完全可用的时间）。 需结合长任务和资源加载状态计算。\n\n\n# 四、实际应用案例\n\n\n# 1. 性能监控与上报\n\nfunction reportperformance() {\n  const data = {\n    navigation: performance.getentriesbytype('navigation')[0],\n    resources: performance.getentriesbytype('resource').map(r => ({\n      url: r.name,\n      duration: r.duration,\n    })),\n    timings: {\n      fcp: performance.getentriesbyname('first-contentful-paint')[0]?.starttime,\n      lcp: performance.getentriesbytype('largest-contentful-paint')[0]?.starttime,\n    },\n  };\n \n  // 上报到分析平台（如google analytics、sentry）\n  navigator.sendbeacon('/api/performance', json.stringify(data));\n}\n \n// 在页面卸载时触发上报\nwindow.addeventlistener('beforeunload', reportperformance);\n\n\n\n# 2. 优化资源加载策略\n\n// 识别慢加载资源并优化\nconst slowresources = performance.getentriesbytype('resource')\n  .filter(r => r.duration > 1000) // 过滤耗时>1s的资源\n  .map(r => r.name);\n \nconsole.warn('slow resources:', slowresources);\n// 解决方案：预加载、cdn加速、代码分割\n\n\n\n# 3. 检测卡顿（长任务）\n\nconst observer = new performanceobserver((list) => {\n  list.getentries().foreach(entry => {\n    if (entry.duration > 50) {\n      console.error('long task detected:', entry);\n      // 解决方案：拆分任务、使用web worker\n    }\n  });\n});\nobserver.observe({ entrytypes: ['longtask'] });\n\n\n\n# 五、浏览器兼容性\n\n * 主流支持：现代浏览器（chrome、firefox、edge、safari）均支持 performance api 的核心功能。\n\n * 部分差异\n   \n   * performance.getentriesbytype('largest-contentful-paint') 在旧版浏览器中可能缺失。\n   * performanceobserver 的 entrytypes 支持程度不同（如 longtask 在部分移动端浏览器中不可用）。\n\n * 降级方案：使用 polyfill（如 web-vitals 库）或特征检测。\n\n\n# 六、总结\n\napi 分类          核心接口                                       典型应用场景\ntiming api      performance.timing                         分析页面加载生命周期\nresource api    performance.getentriesbytype('resource')   监控资源加载性能\nuser timing     performance.mark() / measure()             测量自定义代码段耗时\nobserver api    performanceobserver                        实时监听性能事件（如长任务）\nhigh res time   performance.now()                          高精度计时（动画、游戏）\n\nperformance api 是前端性能优化的“瑞士军刀”，结合 chrome devtools 和自动化监控工具（如 lighthouse、sentry），可构建完整的性能分析体系。对于微前端、spa 等复杂应用，它能帮助开发者精准定位子应用加载、路由切换等场景的性能问题。",charsets:{cjk:!0}},{title:"常用工具和插件",frontmatter:{},regularPath:"/tool/tool.html",relativePath:"tool/tool.md",key:"v-70043cdf",path:"/tool/tool.html",headers:[{level:2,title:"VSCode 常用插件",slug:"vscode-常用插件",normalizedTitle:"vscode 常用插件",charIndex:14},{level:2,title:"vue-dev-tools",slug:"vue-dev-tools",normalizedTitle:"vue-dev-tools",charIndex:705},{level:2,title:"Jsonview",slug:"jsonview",normalizedTitle:"jsonview",charIndex:739},{level:2,title:"Iterm2 + oh my zsh",slug:"iterm2-oh-my-zsh",normalizedTitle:"iterm2 + oh my zsh",charIndex:807},{level:2,title:"nvm和n",slug:"nvm和n",normalizedTitle:"nvm和n",charIndex:967},{level:2,title:"homebrew",slug:"homebrew",normalizedTitle:"homebrew",charIndex:1030},{level:2,title:"tree",slug:"tree",normalizedTitle:"tree",charIndex:1127},{level:2,title:"npm, cnpm, yarn,tyarn",slug:"npm-cnpm-yarn-tyarn",normalizedTitle:"npm, cnpm, yarn,tyarn",charIndex:1170},{level:2,title:"同时配置github和gitlab",slug:"同时配置github和gitlab",normalizedTitle:"同时配置github和gitlab",charIndex:1298},{level:2,title:"github访问慢",slug:"github访问慢",normalizedTitle:"github访问慢",charIndex:864},{level:2,title:"carbon",slug:"carbon",normalizedTitle:"carbon",charIndex:2998},{level:2,title:"github部署",slug:"github部署",normalizedTitle:"github部署",charIndex:3033},{level:2,title:"tmux",slug:"tmux",normalizedTitle:"tmux",charIndex:3431},{level:2,title:"绘图工具",slug:"绘图工具",normalizedTitle:"绘图工具",charIndex:3497},{level:2,title:"charles",slug:"charles",normalizedTitle:"charles",charIndex:3531},{level:3,title:"如何使用 charles 抓包（APP）",slug:"如何使用-charles-抓包-app",normalizedTitle:"如何使用 charles 抓包（app）",charIndex:3867},{level:2,title:"nodemon",slug:"nodemon",normalizedTitle:"nodemon",charIndex:4371},{level:2,title:"helm",slug:"helm",normalizedTitle:"helm",charIndex:4467},{level:2,title:"ipic",slug:"ipic",normalizedTitle:"ipic",charIndex:4527},{level:2,title:"Mac 软件",slug:"mac-软件",normalizedTitle:"mac 软件",charIndex:4557},{level:2,title:"github cli",slug:"github-cli",normalizedTitle:"github cli",charIndex:4592},{level:2,title:"JSDoc",slug:"jsdoc",normalizedTitle:"jsdoc",charIndex:4914},{level:2,title:"HomeBrew 清华镜像",slug:"homebrew-清华镜像",normalizedTitle:"homebrew 清华镜像",charIndex:4958},{level:2,title:"python",slug:"python",normalizedTitle:"python",charIndex:5213},{level:3,title:"查看可安装 Python 版本",slug:"查看可安装-python-版本",normalizedTitle:"查看可安装 python 版本",charIndex:5941}],lastUpdated:"11/7/2023, 7:15:29 PM",lastUpdatedTimestamp:1699355729e3,headersStr:"VSCode 常用插件 vue-dev-tools Jsonview Iterm2 + oh my zsh nvm和n homebrew tree npm, cnpm, yarn,tyarn 同时配置github和gitlab github访问慢 carbon github部署 tmux 绘图工具 charles 如何使用 charles 抓包（APP） nodemon helm ipic Mac 软件 github cli JSDoc HomeBrew 清华镜像 python 查看可安装 Python 版本",content:'# 常用工具和插件\n\n\n# VSCode 常用插件\n\n * Git History： 查看 git 历史\n * Leetcode：刷题必备\n * Bracket Pair Colorizer：括号匹配\n * GitLens：在 vscode 上使用 git 功能\n * Chinese (Simplified) Language Pack for Visual Studio Code：中文设置\n\n> 安装后，在 locale.json 中添加 "locale": "zh-cn"，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 "config" 筛选可用命令列表，最后选择配置语言命令。\n\n * Babel JavaScript：JavaScript 语法高亮显示\n * ESLint\n * Live Server\n * open in browser\n * Minapp：微信小程序标签、属性的智能补全\n * wechat-snippet：微信小程序代码辅助\n * wxml：微信小程序 wxml 格式化以及高亮组件\n * Vetur: 支持vue文件的语法高亮显示，除了支持template模板以外，还支持大多数主流的前端开发脚本和插件，比如Sass和TypeScript\n * vscode-icons\n * vue-helper插件：代码提示，函数跳转\n * Codelf：右键变量命名\n * any-rule：正则大全\n * es6-string-html：模板字符串高亮\n * 模板字符串闭合\n * 自动补全\n\n\n# vue-dev-tools\n\n> 控制台调试 vue，安装\n\n\n# Jsonview\n\nhttps://github.com/gildas-lormeau/JSONView-for-Chrome\n\n\n# Iterm2 + oh my zsh\n\niTerm2 + Oh My Zsh 打造舒适终端体验\n\n其中字体包等资源github访问慢可以去gitee上找\n\noh my zsh命令提示功能 ,提示颜色在 perference / profiles / color / ANSI Colors / Bright设置\n\n\n# nvm和n\n\n安装node：brew install node\n\n管理node版本工具：nvm或者n，我比较喜欢用n\n\n\n# homebrew\n\nHomebrew是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程。对于Appstore中没有的软件，推荐使用此方法安装管理第三方软件。\n\n\n# tree\n\n安装：brew install tree\n\n使用：tree -a\n\n\n# npm, cnpm, yarn,tyarn\n\n下载完 node 就自动有了 npm\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\ncnpm i -g yarn\n\n\n\n# 同时配置github和gitlab\n\n生成公钥：ssh-keygen -t rsa -C 915397405@qq.com -f ~/.ssh/id_rsa_github\n\n进入 ssh 配置目录：cd ~/.ssh\n\n配置文件生效：sudo source config\n\ngit配置github与gitlab同时使用\n\n# gitlab\nHost icode\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa\n\n# github\nHost github\n  HostName github.com\n  User 915397405@qq.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_github\n\n\n如果出现了 git@github.com: Permission denied (publickey).\n\n可以进入ssh目录运行下ssh-add id_rsa_github试试\n\n----------------------------------------\n\n如果出现以下错误：Bad owner or permissions on .ssh/config\n\n这个时候，只需要在.ssh目录，执行以下命令行：sudo chmod 600 config\n\n----------------------------------------\n\nkex_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n\n则配置下 hosts 中的 github ip 地址即可\n\n----------------------------------------\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\n\n// 删除下 know_hosts 重新 push\nssh-keygen -R github.com\n\n\n----------------------------------------\n\nUnable to negotiate with xx.xx.xx.xx port xxxx: no matching host key type found. Their offer: ssh-rsa\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n// config 中增加配置\nHost *\nHostkeyAlgorithms +ssh-rsa\nPubkeyAcceptedKeyTypes +ssh-rsa\n\n\n\n# github访问慢\n\n解决GitHub下载速度太慢问题\n\n\n# carbon\n\nhttps://carbon.now.sh/\n\n\n# github部署\n\n项目中新建脚本 scripts/deploy-gh.sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd dist\n\n# git 命令\ngit init\ngit add .\ngit commit -m \'deploy\'\n\n# 发布: git push -f git@github.com:<USERNAME>/<REPO>.git master:gh-pages\ngit push -f git@github.com:jinjingxuan/san-admin.git master:gh-pages\n\n# 返回上一次的工作目录\ncd -\n\n\npackage.json中：\n\n"scripts": {\n  "deploy-gh": "bash scripts/deploy-gh.sh"\n}\n\n\n\n# tmux\n\n开发机常用\n\nhttp://www.ruanyifeng.com/blog/2019/10/tmux.html\n\n\n# 绘图工具\n\nhttps://excalidraw.com/\n\n\n# charles\n\n\n\ncharles 相当于插在服务器和客户端之间的过滤器，当客户端向服务器发起请求的时候，先到 charles 进行过滤，然后 charles 在把最终的数据发送给服务器。服务器接收请求后的返回数据，也会先到 charles，经过 charles 过滤后再发给客户端。charles 发给服务器的数据，不一定是客户端请求的数据，charles 在接到客户端的请求时可以自由的修改数据。同理：客户端接收的数据，不一定就是服务器返回的数据，而是 charles 给的数据。(类似中间人攻击)\n\n官网：https://www.charlesproxy.com/\n\n破解：https://www.zzzmode.com/mytools/charles/\n\n\n# 如何使用 charles 抓包（APP）\n\n 1. 点击顶部菜单栏【Help】--\x3e选择【SSL Proxying】，点击【install Charles Root Certificate】在 mac 上安装 Charles 根证书即可； 点击安装【Install Charles Root Certificate On a Mobile Device or Remote Browser】在移动设备上或远程浏览器安装证书；\n\n\n\n 2. 保证手机和 mac 在同一局域网内，wifi 配置手动代理（按 charles 给出的 ip 和 端口号），然后访问 chls.pro/ssl 下载证书，然后通用 -> 关于本机 -> 证书信任设置中选中 Charles 的证书\n\n\n\n 3. 检查下 charles proxy setting\n\n\n\n 4. 接下来就可以抓包了，如果出现红叉以下情况，可能是证书过期了。【Help】--\x3e【SSL Proxying】--\x3e 【Reset Charles Root Certificate】重置证书，手机上也把之前下载好的证书卸载掉，按照以上步骤重新安装。\n\n\n\n\n# nodemon\n\nnodemon是一种工具，可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序。\n\nnpm install -g nodemon\n\n\n\n# helm\n\nMac 上修改 host 文件的工具，Appstore中就能下载。可以建多份配置文件来回切换。\n\n\n\n\n# ipic\n\n图床工具，Appstore中就能下载。\n\n\n# Mac 软件\n\nhttps://www.macwk.com/\n\n\n# github cli\n\n当我们将本地代码提交到 GitHub 后，就可以在 GitHub 网站上查看到各种的交互信息了，例如其它开发者提的 Issue，或者提交的代码合并请求等。但是，如果我们能在命令行上直接查看、处理这些信息，那么就有了 github cli\n\n官网：https://cli.github.com/\n\n安装：brew install gh\n\n更新：brew update && brew upgrade gh\n\n授权登录：gh auth login（通过命令行交互会调起浏览器 github 进行授权）\n\n查看 issue 列表：gh issue list\n\n切换到 pr 分支：gh pr checkout 111\n\n\n# JSDoc\n\njs注释工具：https://www.jsdoc.com.cn/\n\n\n# HomeBrew 清华镜像\n\nhttps://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\n\nbrew 安装 php：https://stackoverflow.com/questions/70417377/error-php7-3-has-been-disabled-because-it-is-a-versioned-formula、https://github.com/shivammathur/homebrew-php/discussions/743\n\n\n# python\n\n在跑项目时报了这个错：\n\n> "Can\'t find Python executable "python", you can set the PYTHON env variable."\n\n问题是找不到 python 命令，然而我的电脑中装了 python3，输入 python3 ok 但是输入 python 时确实没有。于是按照stackoverflow解决了下。\n\npyenv 是Python 版本管理工具。 pyenv 可以改变全局的Python 版本，在系统中安装多个版本的Python\n\n> npm ERR! gyp info it worked if it ends with ok npm ERR! gyp info using node-gyp@3.8.0 npm ERR! gyp info using node@16.0.0 | darwin | x64 npm ERR! gyp ERR! configure error npm ERR! gyp ERR! stack Error: Command failed: /Users/jinjingxuan/.pyenv/shims/python -c import sys; print "%s.%s.%s" % sys.version_info[:3]; npm ERR! gyp ERR! stack File "", line 1 npm ERR! gyp ERR! stack import sys; print "%s.%s.%s" % sys.version_info[:3];\n\n原因一般是本机安装了python3，但依赖的脚本有python2的\n\n\n# 查看可安装 Python 版本\n\n使用如下命令查看可安装版本\n\n$ pyenv install -l\n$ pyenv install 2.7.3   # 安装 python\n$ pyenv uninstall 2.7.3 # 卸载 python\n$ pyenv global 2.7.3  # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。\n$ pyenv local 2.7.3 # 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。\n\n\n还遇到了这个问题\n\n> BUILD FAILED (OS X 13.4 using python-build 20180424)\n\n# 最后这样安装成功了\nbrew intall gcc \nCC=/usr/bin/gcc pyenv install 2.7.18\n',normalizedContent:'# 常用工具和插件\n\n\n# vscode 常用插件\n\n * git history： 查看 git 历史\n * leetcode：刷题必备\n * bracket pair colorizer：括号匹配\n * gitlens：在 vscode 上使用 git 功能\n * chinese (simplified) language pack for visual studio code：中文设置\n\n> 安装后，在 locale.json 中添加 "locale": "zh-cn"，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 ctrl+shift+p 打开命令面板，之后输入 "config" 筛选可用命令列表，最后选择配置语言命令。\n\n * babel javascript：javascript 语法高亮显示\n * eslint\n * live server\n * open in browser\n * minapp：微信小程序标签、属性的智能补全\n * wechat-snippet：微信小程序代码辅助\n * wxml：微信小程序 wxml 格式化以及高亮组件\n * vetur: 支持vue文件的语法高亮显示，除了支持template模板以外，还支持大多数主流的前端开发脚本和插件，比如sass和typescript\n * vscode-icons\n * vue-helper插件：代码提示，函数跳转\n * codelf：右键变量命名\n * any-rule：正则大全\n * es6-string-html：模板字符串高亮\n * 模板字符串闭合\n * 自动补全\n\n\n# vue-dev-tools\n\n> 控制台调试 vue，安装\n\n\n# jsonview\n\nhttps://github.com/gildas-lormeau/jsonview-for-chrome\n\n\n# iterm2 + oh my zsh\n\niterm2 + oh my zsh 打造舒适终端体验\n\n其中字体包等资源github访问慢可以去gitee上找\n\noh my zsh命令提示功能 ,提示颜色在 perference / profiles / color / ansi colors / bright设置\n\n\n# nvm和n\n\n安装node：brew install node\n\n管理node版本工具：nvm或者n，我比较喜欢用n\n\n\n# homebrew\n\nhomebrew是一款自由及开放源代码的软件包管理系统，用以简化macos系统上的软件安装过程。对于appstore中没有的软件，推荐使用此方法安装管理第三方软件。\n\n\n# tree\n\n安装：brew install tree\n\n使用：tree -a\n\n\n# npm, cnpm, yarn,tyarn\n\n下载完 node 就自动有了 npm\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\ncnpm i -g yarn\n\n\n\n# 同时配置github和gitlab\n\n生成公钥：ssh-keygen -t rsa -c 915397405@qq.com -f ~/.ssh/id_rsa_github\n\n进入 ssh 配置目录：cd ~/.ssh\n\n配置文件生效：sudo source config\n\ngit配置github与gitlab同时使用\n\n# gitlab\nhost icode\n  hostname gitlab.com\n  preferredauthentications publickey\n  identityfile ~/.ssh/id_rsa\n\n# github\nhost github\n  hostname github.com\n  user 915397405@qq.com\n  preferredauthentications publickey\n  identityfile ~/.ssh/id_rsa_github\n\n\n如果出现了 git@github.com: permission denied (publickey).\n\n可以进入ssh目录运行下ssh-add id_rsa_github试试\n\n----------------------------------------\n\n如果出现以下错误：bad owner or permissions on .ssh/config\n\n这个时候，只需要在.ssh目录，执行以下命令行：sudo chmod 600 config\n\n----------------------------------------\n\nkex_exchange_identification: connection closed by remote host\nfatal: could not read from remote repository.\n\nplease make sure you have the correct access rights\nand the repository exists.\n\n\n则配置下 hosts 中的 github ip 地址即可\n\n----------------------------------------\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    warning: remote host identification has changed!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nit is possible that someone is doing something nasty!\nsomeone could be eavesdropping on you right now (man-in-the-middle attack)!\n\n// 删除下 know_hosts 重新 push\nssh-keygen -r github.com\n\n\n----------------------------------------\n\nunable to negotiate with xx.xx.xx.xx port xxxx: no matching host key type found. their offer: ssh-rsa\nfatal: could not read from remote repository.\n\nplease make sure you have the correct access rights\nand the repository exists.\n\n// config 中增加配置\nhost *\nhostkeyalgorithms +ssh-rsa\npubkeyacceptedkeytypes +ssh-rsa\n\n\n\n# github访问慢\n\n解决github下载速度太慢问题\n\n\n# carbon\n\nhttps://carbon.now.sh/\n\n\n# github部署\n\n项目中新建脚本 scripts/deploy-gh.sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd dist\n\n# git 命令\ngit init\ngit add .\ngit commit -m \'deploy\'\n\n# 发布: git push -f git@github.com:<username>/<repo>.git master:gh-pages\ngit push -f git@github.com:jinjingxuan/san-admin.git master:gh-pages\n\n# 返回上一次的工作目录\ncd -\n\n\npackage.json中：\n\n"scripts": {\n  "deploy-gh": "bash scripts/deploy-gh.sh"\n}\n\n\n\n# tmux\n\n开发机常用\n\nhttp://www.ruanyifeng.com/blog/2019/10/tmux.html\n\n\n# 绘图工具\n\nhttps://excalidraw.com/\n\n\n# charles\n\n\n\ncharles 相当于插在服务器和客户端之间的过滤器，当客户端向服务器发起请求的时候，先到 charles 进行过滤，然后 charles 在把最终的数据发送给服务器。服务器接收请求后的返回数据，也会先到 charles，经过 charles 过滤后再发给客户端。charles 发给服务器的数据，不一定是客户端请求的数据，charles 在接到客户端的请求时可以自由的修改数据。同理：客户端接收的数据，不一定就是服务器返回的数据，而是 charles 给的数据。(类似中间人攻击)\n\n官网：https://www.charlesproxy.com/\n\n破解：https://www.zzzmode.com/mytools/charles/\n\n\n# 如何使用 charles 抓包（app）\n\n 1. 点击顶部菜单栏【help】--\x3e选择【ssl proxying】，点击【install charles root certificate】在 mac 上安装 charles 根证书即可； 点击安装【install charles root certificate on a mobile device or remote browser】在移动设备上或远程浏览器安装证书；\n\n\n\n 2. 保证手机和 mac 在同一局域网内，wifi 配置手动代理（按 charles 给出的 ip 和 端口号），然后访问 chls.pro/ssl 下载证书，然后通用 -> 关于本机 -> 证书信任设置中选中 charles 的证书\n\n\n\n 3. 检查下 charles proxy setting\n\n\n\n 4. 接下来就可以抓包了，如果出现红叉以下情况，可能是证书过期了。【help】--\x3e【ssl proxying】--\x3e 【reset charles root certificate】重置证书，手机上也把之前下载好的证书卸载掉，按照以上步骤重新安装。\n\n\n\n\n# nodemon\n\nnodemon是一种工具，可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序。\n\nnpm install -g nodemon\n\n\n\n# helm\n\nmac 上修改 host 文件的工具，appstore中就能下载。可以建多份配置文件来回切换。\n\n\n\n\n# ipic\n\n图床工具，appstore中就能下载。\n\n\n# mac 软件\n\nhttps://www.macwk.com/\n\n\n# github cli\n\n当我们将本地代码提交到 github 后，就可以在 github 网站上查看到各种的交互信息了，例如其它开发者提的 issue，或者提交的代码合并请求等。但是，如果我们能在命令行上直接查看、处理这些信息，那么就有了 github cli\n\n官网：https://cli.github.com/\n\n安装：brew install gh\n\n更新：brew update && brew upgrade gh\n\n授权登录：gh auth login（通过命令行交互会调起浏览器 github 进行授权）\n\n查看 issue 列表：gh issue list\n\n切换到 pr 分支：gh pr checkout 111\n\n\n# jsdoc\n\njs注释工具：https://www.jsdoc.com.cn/\n\n\n# homebrew 清华镜像\n\nhttps://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\n\nbrew 安装 php：https://stackoverflow.com/questions/70417377/error-php7-3-has-been-disabled-because-it-is-a-versioned-formula、https://github.com/shivammathur/homebrew-php/discussions/743\n\n\n# python\n\n在跑项目时报了这个错：\n\n> "can\'t find python executable "python", you can set the python env variable."\n\n问题是找不到 python 命令，然而我的电脑中装了 python3，输入 python3 ok 但是输入 python 时确实没有。于是按照stackoverflow解决了下。\n\npyenv 是python 版本管理工具。 pyenv 可以改变全局的python 版本，在系统中安装多个版本的python\n\n> npm err! gyp info it worked if it ends with ok npm err! gyp info using node-gyp@3.8.0 npm err! gyp info using node@16.0.0 | darwin | x64 npm err! gyp err! configure error npm err! gyp err! stack error: command failed: /users/jinjingxuan/.pyenv/shims/python -c import sys; print "%s.%s.%s" % sys.version_info[:3]; npm err! gyp err! stack file "", line 1 npm err! gyp err! stack import sys; print "%s.%s.%s" % sys.version_info[:3];\n\n原因一般是本机安装了python3，但依赖的脚本有python2的\n\n\n# 查看可安装 python 版本\n\n使用如下命令查看可安装版本\n\n$ pyenv install -l\n$ pyenv install 2.7.3   # 安装 python\n$ pyenv uninstall 2.7.3 # 卸载 python\n$ pyenv global 2.7.3  # 设置全局的 python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。\n$ pyenv local 2.7.3 # 设置 python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 python 版本优先级较 global 高。\n\n\n还遇到了这个问题\n\n> build failed (os x 13.4 using python-build 20180424)\n\n# 最后这样安装成功了\nbrew intall gcc \ncc=/usr/bin/gcc pyenv install 2.7.18\n',charsets:{cjk:!0}},{title:"TypeScript 进阶",frontmatter:{},regularPath:"/ts/ts-advance.html",relativePath:"ts/ts-advance.md",key:"v-d9099882",path:"/ts/ts-advance.html",headers:[{level:2,title:"类型断言",slug:"类型断言",normalizedTitle:"类型断言",charIndex:20},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:91},{level:3,title:"类型断言与类型转换",slug:"类型断言与类型转换",normalizedTitle:"类型断言与类型转换",charIndex:585},{level:3,title:"类型断言可能是有害的",slug:"类型断言可能是有害的",normalizedTitle:"类型断言可能是有害的",charIndex:679},{level:3,title:"双重断言",slug:"双重断言",normalizedTitle:"双重断言",charIndex:808},{level:2,title:"类型保护",slug:"类型保护",normalizedTitle:"类型保护",charIndex:28},{level:3,title:"typeof",slug:"typeof",normalizedTitle:"typeof",charIndex:1325},{level:3,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:1312},{level:3,title:"in",slug:"in",normalizedTitle:"in",charIndex:474},{level:3,title:"自定义类型保护",slug:"自定义类型保护",normalizedTitle:"自定义类型保护",charIndex:2761},{level:2,title:"类型推断",slug:"类型推断",normalizedTitle:"类型推断",charIndex:36},{level:3,title:"定义变量",slug:"定义变量",normalizedTitle:"定义变量",charIndex:3315},{level:3,title:"函数返回值",slug:"函数返回值",normalizedTitle:"函数返回值",charIndex:3444},{level:3,title:"赋值",slug:"赋值",normalizedTitle:"赋值",charIndex:1121},{level:3,title:"结构化",slug:"结构化",normalizedTitle:"结构化",charIndex:3778}],lastUpdated:"9/30/2021, 3:27:11 PM",lastUpdatedTimestamp:1632986831e3,headersStr:"类型断言 语法 类型断言与类型转换 类型断言可能是有害的 双重断言 类型保护 typeof instanceof in 自定义类型保护 类型推断 定义变量 函数返回值 赋值 结构化",content:"# TypeScript 进阶\n\n * 类型断言\n * 类型保护\n * 类型推断\n\n\n# 类型断言\n\n类型断言（Type Assertion）可以用来手动指定一个值的类型。\n\n\n# 语法\n\n// 两种写法，在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n值 as 类型\n\n<类型>值\n\n\nTypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。TypeScript 类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误。\n\nconst foo = {};\nfoo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'\n\n\n这里的代码发出了错误警告，因为 foo 的类型推断为 {}，即没有属性的对象。因此，你不能在它的属性上添加 bar 或 bas，你可以通过类型断言来避免此问题：你可以通过类型断言来避免此问题：\n\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n\n\n\n# 类型断言与类型转换\n\n它之所以不被称为「类型转换」，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。\n\n\n# 类型断言可能是有害的\n\n如果你没有按约定添加属性，TypeScript 编译器并不会对此发出错误警告\n\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\n\n\n\n# 双重断言\n\n类型断言，尽管我们已经证明了它并不是那么安全，但它也还是有用武之地。如下一个非常实用的例子所示，当使用者了解传入参数更具体的类型时，类型断言能按预期工作：\n\nfunction handler(event: Event) {\n  const mouseEvent = event as MouseEvent;\n}\n\n\n然而，如下例子中的代码将会报错，尽管使用者已经使用了类型断言：\n\nfunction handler(event: Event) {\n  const element = event as HTMLElement; // Error: 'Event' 和 'HTMLElement' 中的任何一个都不能赋值给另外一个\n}\n\n\n如果你仍然想使用那个类型，你可以使用双重断言。首先断言成兼容所有类型的 any，编译器将不会报错：\n\nfunction handler(event: Event) {\n  const element = (event as any) as HTMLElement; // ok\n}\n\n\n\n# 类型保护\n\nTypeScript 熟知 JavaScript 中 instanceof 和 typeof 运算符的用法。如果你在一个条件块中使用这些，TypeScript 将会推导出在条件块中的的变量类型。如下例所示，TypeScript 将会辨别 string 上是否存在特定的函数，以及是否发生了拼写错误：\n\n\n# typeof\n\nfunction doSome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上, 拼写错误\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\n}\n\n\n\n# instanceof\n\nclass Foo {\n  foo = 123;\n  common = '123';\n}\n\nclass Bar {\n  bar = 123;\n  common = '123';\n}\n\nfunction doStuff(arg: Foo | Bar) {\n  if (arg instanceof Foo) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // Error\n  }\n  if (arg instanceof Bar) {\n    console.log(arg.foo); // Error\n    console.log(arg.bar); // ok\n  }\n}\n\ndoStuff(new Foo());\ndoStuff(new Bar());\n\n\nTypeScript 甚至能够理解 else。当你使用 if 来缩小类型时，TypeScript 知道在其他块中的类型并不是 if 中的类型：\n\nclass Foo {\n  foo = 123;\n}\n\nclass Bar {\n  bar = 123;\n}\n\nfunction doStuff(arg: Foo | Bar) {\n  if (arg instanceof Foo) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // Error\n  } else {\n    // 这个块中，一定是 'Bar'\n    console.log(arg.foo); // Error\n    console.log(arg.bar); // ok\n  }\n}\n\ndoStuff(new Foo());\ndoStuff(new Bar());\n\n\n\n# in\n\nin 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用：\n\ninterface A {\n  x: number;\n}\n\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  } else {\n    // q: B\n    q.x = 1 // Error: 类型 B 上不存在属性 x\n  }\n}\n\n\n\n# 自定义类型保护\n\n// 仅仅是一个 interface\ninterface Foo {\n  foo: number;\n  common: string;\n}\n\ninterface Bar {\n  bar: number;\n  common: string;\n}\n\n// 用户自己定义的类型保护！\nfunction isFoo(arg: Foo | Bar): arg is Foo {\n  return (arg as Foo).foo !== undefined;\n}\n\n// 用户自己定义的类型保护使用用例：\nfunction doStuff(arg: Foo | Bar) {\n  if (isFoo(arg)) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // Error\n  } else {\n    console.log(arg.foo); // Error\n    console.log(arg.bar); // ok\n  }\n}\n\ndoStuff({ foo: 123, common: '123' });\ndoStuff({ bar: 123, common: '123' });\n\n\n\n# 类型推断\n\n\n# 定义变量\n\nlet foo = 123; // foo 是 'number'\nlet bar = 'hello'; // bar 是 'string'\n\nfoo = bar; // Error: 不能将 'string' 赋值给 `number`\n\n\n\n# 函数返回值\n\n返回类型能被 return 语句推断，如下所示，推断函数返回为一个数字：\n\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\n\n\n# 赋值\n\n函数参数类型/返回值也能通过赋值来推断。如下所示，foo 的类型是 Adder，他能让 foo 的参数 a、b 是 number 类型。\n\ntype Adder = (a: number, b: number) => number;\nlet foo: Adder = (a, b) => {\n  a = 'hello'; // Error：不能把 'string' 类型赋值给 'number' 类型\n  return a + b;\n};\n\n\n\n# 结构化\n\n这些简单的规则也适用于结构化的存在（对象字面量），例如在下面这种情况下 foo 的类型被推断为 { a: number, b: number }：\n\nconst foo = {\n  a: 123,\n  b: 456\n};\n\nfoo.a = 'hello'; // Error：不能把 'string' 类型赋值给 'number' 类型\n",normalizedContent:"# typescript 进阶\n\n * 类型断言\n * 类型保护\n * 类型推断\n\n\n# 类型断言\n\n类型断言（type assertion）可以用来手动指定一个值的类型。\n\n\n# 语法\n\n// 两种写法，在 tsx 语法（react 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n值 as 类型\n\n<类型>值\n\n\ntypescript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。typescript 类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误。\n\nconst foo = {};\nfoo.bar = 123; // error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // error: 'bas' 属性不存在于 '{}'\n\n\n这里的代码发出了错误警告，因为 foo 的类型推断为 {}，即没有属性的对象。因此，你不能在它的属性上添加 bar 或 bas，你可以通过类型断言来避免此问题：你可以通过类型断言来避免此问题：\n\ninterface foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n\n\n\n# 类型断言与类型转换\n\n它之所以不被称为「类型转换」，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。\n\n\n# 类型断言可能是有害的\n\n如果你没有按约定添加属性，typescript 编译器并不会对此发出错误警告\n\ninterface foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as foo;\n\n\n\n# 双重断言\n\n类型断言，尽管我们已经证明了它并不是那么安全，但它也还是有用武之地。如下一个非常实用的例子所示，当使用者了解传入参数更具体的类型时，类型断言能按预期工作：\n\nfunction handler(event: event) {\n  const mouseevent = event as mouseevent;\n}\n\n\n然而，如下例子中的代码将会报错，尽管使用者已经使用了类型断言：\n\nfunction handler(event: event) {\n  const element = event as htmlelement; // error: 'event' 和 'htmlelement' 中的任何一个都不能赋值给另外一个\n}\n\n\n如果你仍然想使用那个类型，你可以使用双重断言。首先断言成兼容所有类型的 any，编译器将不会报错：\n\nfunction handler(event: event) {\n  const element = (event as any) as htmlelement; // ok\n}\n\n\n\n# 类型保护\n\ntypescript 熟知 javascript 中 instanceof 和 typeof 运算符的用法。如果你在一个条件块中使用这些，typescript 将会推导出在条件块中的的变量类型。如下例所示，typescript 将会辨别 string 上是否存在特定的函数，以及是否发生了拼写错误：\n\n\n# typeof\n\nfunction dosome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，typescript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // error: 'subtr' 方法并没有存在于 `string` 上, 拼写错误\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // error: 无法保证 `x` 是 `string` 类型\n}\n\n\n\n# instanceof\n\nclass foo {\n  foo = 123;\n  common = '123';\n}\n\nclass bar {\n  bar = 123;\n  common = '123';\n}\n\nfunction dostuff(arg: foo | bar) {\n  if (arg instanceof foo) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // error\n  }\n  if (arg instanceof bar) {\n    console.log(arg.foo); // error\n    console.log(arg.bar); // ok\n  }\n}\n\ndostuff(new foo());\ndostuff(new bar());\n\n\ntypescript 甚至能够理解 else。当你使用 if 来缩小类型时，typescript 知道在其他块中的类型并不是 if 中的类型：\n\nclass foo {\n  foo = 123;\n}\n\nclass bar {\n  bar = 123;\n}\n\nfunction dostuff(arg: foo | bar) {\n  if (arg instanceof foo) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // error\n  } else {\n    // 这个块中，一定是 'bar'\n    console.log(arg.foo); // error\n    console.log(arg.bar); // ok\n  }\n}\n\ndostuff(new foo());\ndostuff(new bar());\n\n\n\n# in\n\nin 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用：\n\ninterface a {\n  x: number;\n}\n\ninterface b {\n  y: string;\n}\n\nfunction dostuff(q: a | b) {\n  if ('x' in q) {\n    // q: a\n  } else {\n    // q: b\n    q.x = 1 // error: 类型 b 上不存在属性 x\n  }\n}\n\n\n\n# 自定义类型保护\n\n// 仅仅是一个 interface\ninterface foo {\n  foo: number;\n  common: string;\n}\n\ninterface bar {\n  bar: number;\n  common: string;\n}\n\n// 用户自己定义的类型保护！\nfunction isfoo(arg: foo | bar): arg is foo {\n  return (arg as foo).foo !== undefined;\n}\n\n// 用户自己定义的类型保护使用用例：\nfunction dostuff(arg: foo | bar) {\n  if (isfoo(arg)) {\n    console.log(arg.foo); // ok\n    console.log(arg.bar); // error\n  } else {\n    console.log(arg.foo); // error\n    console.log(arg.bar); // ok\n  }\n}\n\ndostuff({ foo: 123, common: '123' });\ndostuff({ bar: 123, common: '123' });\n\n\n\n# 类型推断\n\n\n# 定义变量\n\nlet foo = 123; // foo 是 'number'\nlet bar = 'hello'; // bar 是 'string'\n\nfoo = bar; // error: 不能将 'string' 赋值给 `number`\n\n\n\n# 函数返回值\n\n返回类型能被 return 语句推断，如下所示，推断函数返回为一个数字：\n\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\n\n\n# 赋值\n\n函数参数类型/返回值也能通过赋值来推断。如下所示，foo 的类型是 adder，他能让 foo 的参数 a、b 是 number 类型。\n\ntype adder = (a: number, b: number) => number;\nlet foo: adder = (a, b) => {\n  a = 'hello'; // error：不能把 'string' 类型赋值给 'number' 类型\n  return a + b;\n};\n\n\n\n# 结构化\n\n这些简单的规则也适用于结构化的存在（对象字面量），例如在下面这种情况下 foo 的类型被推断为 { a: number, b: number }：\n\nconst foo = {\n  a: 123,\n  b: 456\n};\n\nfoo.a = 'hello'; // error：不能把 'string' 类型赋值给 'number' 类型\n",charsets:{cjk:!0}},{title:"TypeScirpt类型声明文件",frontmatter:{},regularPath:"/ts/ts-type.html",relativePath:"ts/ts-type.md",key:"v-5f89be0a",path:"/ts/ts-type.html",headers:[{level:2,title:".d.ts",slug:"d-ts",normalizedTitle:".d.ts",charIndex:72},{level:2,title:"全局声明",slug:"全局声明",normalizedTitle:"全局声明",charIndex:980},{level:2,title:"编写声明文件",slug:"编写声明文件",normalizedTitle:"编写声明文件",charIndex:1278}],lastUpdated:"3/1/2022, 3:30:47 PM",lastUpdatedTimestamp:1646119847e3,headersStr:".d.ts 全局声明 编写声明文件",content:"# TypeScirpt类型声明文件\n\n类型声明（Type Declaration）或者 类型定义（Type Definition）文件是一个以.d.ts作为文件后缀名的TypeScript文件。\n\n类型声明文件用来帮助开发者在 typescript 中使用已有的 JavaScript 工具包。\n\n\n# .d.ts\n\n类型声明文件的后缀名为.d.ts，文件中只包含与类型相关的代码，不包含逻辑代码，它们的作用旨在为开发者提供类型信息，所以它们只在开发阶段起作用。\n\n> 我们知道第三方库一般会使用 ts 代码编写，ts 代码会编译成 js 代码，发布后供他人使用。这个时候类型信息就丢失了。当我们在 IDE 中引入第三方库时，如果该库没有提供类型声明，TypeScript 则不知道该库是什么类型，有什么东西，进而 IDE 会进行报错。\n\n比如我们在项目中使用jQuery，直接在全局使用变量$或jQuery：\n\n$('#foo');\n// 找不到名称 \"$\"。是否需要安装 jQuery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`。ts(2581)\n\n\nDefinitelyTyped 社区为我们提供了很多第三方 npm 声明文件包，例如@types/lodash和@types/node等等。你可以使用npm安装@types下的声明包。\n\nnpm install -D @types/jquery\n\n\n这些包会被下载到 node_modules/@types文件夹下。\n\n声明文件有两种使用方法：\n\n * 将声明文件和源码放在一起\n * 将声明文件发布到 @types 下\n\n我们一般不需要手动去写声明文件，如果我们的文件本身是用 TS 编写的，在编译的时候让 TS 自动生成声明文件，并在发布的时候将 .d.ts 文件一起发布即可。\n\n如果是手动写的声明文件，那么需要满足以下任一一项条件，才能被正确的识别：\n\n * 给 package.json 中的 types 或 typings 字段指定类型声明文件的路径。\n * 声明文件放在项目根目录下，命名为 index.d.ts\n * 与入口文件（package.json 中的 main 字段指定的入口文件）一起，编写一个同名 .d.ts 文件\n\n\n# 全局声明\n\n**全局声明（global declaration）**在任何 TypeScript 项目或者 TypeScript 代码片段中都会起作用的。例如当你写下const p = new Promise();时，TypeScript编译器不会去编译你的代码，因为const p = new Promise();语法错误了。\n\n\n\n从IDE的提示中，可以看到Promise类型是定义在lib.es2015.promise.d.ts文件中的，由 TypeScript 提供，TypeScript 提供的很多这样的声明文件，被称作标准库（这些声明文件会随TypeScript一起安装）。\n\n\n# 编写声明文件\n\n详见以下两篇文章：\n\n * 声明文件 *.d.ts\n * TypeScirpt类型声明完全指南",normalizedContent:"# typescirpt类型声明文件\n\n类型声明（type declaration）或者 类型定义（type definition）文件是一个以.d.ts作为文件后缀名的typescript文件。\n\n类型声明文件用来帮助开发者在 typescript 中使用已有的 javascript 工具包。\n\n\n# .d.ts\n\n类型声明文件的后缀名为.d.ts，文件中只包含与类型相关的代码，不包含逻辑代码，它们的作用旨在为开发者提供类型信息，所以它们只在开发阶段起作用。\n\n> 我们知道第三方库一般会使用 ts 代码编写，ts 代码会编译成 js 代码，发布后供他人使用。这个时候类型信息就丢失了。当我们在 ide 中引入第三方库时，如果该库没有提供类型声明，typescript 则不知道该库是什么类型，有什么东西，进而 ide 会进行报错。\n\n比如我们在项目中使用jquery，直接在全局使用变量$或jquery：\n\n$('#foo');\n// 找不到名称 \"$\"。是否需要安装 jquery 的类型定义? 请尝试使用 `npm i --save-dev @types/jquery`。ts(2581)\n\n\ndefinitelytyped 社区为我们提供了很多第三方 npm 声明文件包，例如@types/lodash和@types/node等等。你可以使用npm安装@types下的声明包。\n\nnpm install -d @types/jquery\n\n\n这些包会被下载到 node_modules/@types文件夹下。\n\n声明文件有两种使用方法：\n\n * 将声明文件和源码放在一起\n * 将声明文件发布到 @types 下\n\n我们一般不需要手动去写声明文件，如果我们的文件本身是用 ts 编写的，在编译的时候让 ts 自动生成声明文件，并在发布的时候将 .d.ts 文件一起发布即可。\n\n如果是手动写的声明文件，那么需要满足以下任一一项条件，才能被正确的识别：\n\n * 给 package.json 中的 types 或 typings 字段指定类型声明文件的路径。\n * 声明文件放在项目根目录下，命名为 index.d.ts\n * 与入口文件（package.json 中的 main 字段指定的入口文件）一起，编写一个同名 .d.ts 文件\n\n\n# 全局声明\n\n**全局声明（global declaration）**在任何 typescript 项目或者 typescript 代码片段中都会起作用的。例如当你写下const p = new promise();时，typescript编译器不会去编译你的代码，因为const p = new promise();语法错误了。\n\n\n\n从ide的提示中，可以看到promise类型是定义在lib.es2015.promise.d.ts文件中的，由 typescript 提供，typescript 提供的很多这样的声明文件，被称作标准库（这些声明文件会随typescript一起安装）。\n\n\n# 编写声明文件\n\n详见以下两篇文章：\n\n * 声明文件 *.d.ts\n * typescirpt类型声明完全指南",charsets:{cjk:!0}},{title:"模拟实现snbbDom排行实例",frontmatter:{title:"模拟实现snbbDom排行实例",date:"2020-10-09T14:47:00.000Z",categories:"VirtualDOM"},regularPath:"/virtual-dom/example.html",relativePath:"virtual-dom/example.md",key:"v-1d8b151f",path:"/virtual-dom/example.html",headers:[{level:2,title:"parcel",slug:"parcel",normalizedTitle:"parcel",charIndex:175},{level:2,title:"安装 snabbdom",slug:"安装-snabbdom",normalizedTitle:"安装 snabbdom",charIndex:434},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:4}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"parcel 安装 snabbdom 实现",content:'# 模拟实现snbbDom排行实例\n\n * 官网示例：http://snabbdom.github.io/snabbdom/examples/reorder-animation/\n * 代码地址：https://github.com/jinjingxuan/part3_module1_task/tree/master/code_3\n * 构建工具 parcel\n\n\n# parcel\n\nparcel 官网：https://zh.parceljs.org/getting_started.html\n\n安装流程\n\nnpm install -g parcel-bundler\n\n\n在你正在使用的项目目录下创建一个 package.json 文件：\n\nnpm init -y\n\n\nParcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换。只需要在入口文件指出：\n\nparcel index.html\n\n\n\n# 安装 snabbdom\n\ncnpm i -D snabbdom\n\n\n\n# 实现\n\ngithub地址：https://github.com/jinjingxuan/part3_module1_task/tree/master/code_3\n\n * 关键代码\n\nimport { Data } from \'./Data.js\'\nimport { init } from "snabbdom/build/package/init";\nimport { styleModule } from "snabbdom/build/package/modules/style";\nimport { eventListenersModule } from "snabbdom/build/package/modules/eventlisteners";\nimport { h } from "snabbdom/build/package/h";\n\nvar patch = init([styleModule, eventListenersModule]);\nvar container = document.getElementById("app");\n\n// title\nvar title = function () {\n    return h("h2", {}, "Top 10 movies")\n}\n\n// list-item\nvar item = function (itemIdx, itemData) {\n    return h("li", { \n        style: { \n            listStyle: "none", \n            display: "flex",\n            marginTop: "20px"\n        }\n    }, [\n        h("div", {\n            style: { \n                width: "5%"\n            }\n        }, itemData.rank),\n        h("div", {\n            style: { \n                width: "30%"\n            }\n        }, itemData.title),\n        h("div", {\n            style: { \n                width: "65%"\n            }\n        }, itemData.desc)\n    ]);\n};\n\n// list\nvar list = function () {\n    let items = [];\n    for (let i = 0; i < Data.length; i++) {\n        items.push(item(i, Data[i]));\n    }\n    return h("ul", {\n        style: {\n            padding: "0",\n        }\n    }, items);\n};\n\n// btns\nvar btns = function () {\n    return h("div", { style: { float: "left", display: "flex" } }, [\n        h("span", {}, "Sort by:"),\n        h(\n            "div",\n            {\n                style: {\n                    marginLeft: "20px"\n                },\n                on: {\n                    click: sortByRank,\n                },\n            },\n            "Rank"\n        ),\n        h(\n            "div",\n            {\n                style: {\n                    marginLeft: "20px"\n                },\n                on: {\n                    click: sortByTitle,\n                },\n            },\n            "Title"\n        ),\n        h(\n            "div",\n            {\n                style: {\n                    marginLeft: "20px"\n                },\n                on: {\n                    click: sortByDes,\n                },\n            },\n            "Description"\n        ),\n    ]);\n};\n\n// clearBoth\nvar clear = h("div", { style: { clear: "both" } });\n\n// 主节点\nvar pageNode = function () {\n    return h(\n        "div#main",\n        {\n            style: {\n                width: "800px",\n                paddingTop: "30px",\n                margin: "0 auto",\n            },\n        },\n        [title(), btns(), clear, list()]\n    );\n};\n\n// 首次渲染保存当前节点为老节点\nvar oldPageNode = patch(container, pageNode());\n\n// 刷新节点，并重新保存老节点\nfunction updateNode() {\n    oldPageNode = patch(oldPageNode, pageNode());\n}\n\nfunction sortByRank() {\n    Data.sort((a, b) =>  a.rank - b.rank )\n    updateNode();\n}\n\nfunction sortByTitle() {\n    Data.sort((a, b) =>  a.title.localeCompare(b.title) )\n    updateNode();\n}\n\nfunction sortByDes() {\n    Data.sort((a, b) =>  a.desc.localeCompare(b.desc) )\n    updateNode();\n}\n\n',normalizedContent:'# 模拟实现snbbdom排行实例\n\n * 官网示例：http://snabbdom.github.io/snabbdom/examples/reorder-animation/\n * 代码地址：https://github.com/jinjingxuan/part3_module1_task/tree/master/code_3\n * 构建工具 parcel\n\n\n# parcel\n\nparcel 官网：https://zh.parceljs.org/getting_started.html\n\n安装流程\n\nnpm install -g parcel-bundler\n\n\n在你正在使用的项目目录下创建一个 package.json 文件：\n\nnpm init -y\n\n\nparcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换。只需要在入口文件指出：\n\nparcel index.html\n\n\n\n# 安装 snabbdom\n\ncnpm i -d snabbdom\n\n\n\n# 实现\n\ngithub地址：https://github.com/jinjingxuan/part3_module1_task/tree/master/code_3\n\n * 关键代码\n\nimport { data } from \'./data.js\'\nimport { init } from "snabbdom/build/package/init";\nimport { stylemodule } from "snabbdom/build/package/modules/style";\nimport { eventlistenersmodule } from "snabbdom/build/package/modules/eventlisteners";\nimport { h } from "snabbdom/build/package/h";\n\nvar patch = init([stylemodule, eventlistenersmodule]);\nvar container = document.getelementbyid("app");\n\n// title\nvar title = function () {\n    return h("h2", {}, "top 10 movies")\n}\n\n// list-item\nvar item = function (itemidx, itemdata) {\n    return h("li", { \n        style: { \n            liststyle: "none", \n            display: "flex",\n            margintop: "20px"\n        }\n    }, [\n        h("div", {\n            style: { \n                width: "5%"\n            }\n        }, itemdata.rank),\n        h("div", {\n            style: { \n                width: "30%"\n            }\n        }, itemdata.title),\n        h("div", {\n            style: { \n                width: "65%"\n            }\n        }, itemdata.desc)\n    ]);\n};\n\n// list\nvar list = function () {\n    let items = [];\n    for (let i = 0; i < data.length; i++) {\n        items.push(item(i, data[i]));\n    }\n    return h("ul", {\n        style: {\n            padding: "0",\n        }\n    }, items);\n};\n\n// btns\nvar btns = function () {\n    return h("div", { style: { float: "left", display: "flex" } }, [\n        h("span", {}, "sort by:"),\n        h(\n            "div",\n            {\n                style: {\n                    marginleft: "20px"\n                },\n                on: {\n                    click: sortbyrank,\n                },\n            },\n            "rank"\n        ),\n        h(\n            "div",\n            {\n                style: {\n                    marginleft: "20px"\n                },\n                on: {\n                    click: sortbytitle,\n                },\n            },\n            "title"\n        ),\n        h(\n            "div",\n            {\n                style: {\n                    marginleft: "20px"\n                },\n                on: {\n                    click: sortbydes,\n                },\n            },\n            "description"\n        ),\n    ]);\n};\n\n// clearboth\nvar clear = h("div", { style: { clear: "both" } });\n\n// 主节点\nvar pagenode = function () {\n    return h(\n        "div#main",\n        {\n            style: {\n                width: "800px",\n                paddingtop: "30px",\n                margin: "0 auto",\n            },\n        },\n        [title(), btns(), clear, list()]\n    );\n};\n\n// 首次渲染保存当前节点为老节点\nvar oldpagenode = patch(container, pagenode());\n\n// 刷新节点，并重新保存老节点\nfunction updatenode() {\n    oldpagenode = patch(oldpagenode, pagenode());\n}\n\nfunction sortbyrank() {\n    data.sort((a, b) =>  a.rank - b.rank )\n    updatenode();\n}\n\nfunction sortbytitle() {\n    data.sort((a, b) =>  a.title.localecompare(b.title) )\n    updatenode();\n}\n\nfunction sortbydes() {\n    data.sort((a, b) =>  a.desc.localecompare(b.desc) )\n    updatenode();\n}\n\n',charsets:{cjk:!0}},{title:"TypeScript中的装饰器(@)",frontmatter:{},regularPath:"/ts/decorator.html",relativePath:"ts/decorator.md",key:"v-545d6c55",path:"/ts/decorator.html",headers:[{level:2,title:"装饰器模式",slug:"装饰器模式",normalizedTitle:"装饰器模式",charIndex:143},{level:3,title:"装饰器模式的优势",slug:"装饰器模式的优势",normalizedTitle:"装饰器模式的优势",charIndex:1317},{level:2,title:"TS 装饰器",slug:"ts-装饰器",normalizedTitle:"ts 装饰器",charIndex:153},{level:3,title:"装饰器写法",slug:"装饰器写法",normalizedTitle:"装饰器写法",charIndex:1598},{level:3,title:"装饰器分类",slug:"装饰器分类",normalizedTitle:"装饰器分类",charIndex:2296},{level:3,title:"装饰器原理",slug:"装饰器原理",normalizedTitle:"装饰器原理",charIndex:4859}],lastUpdated:"4/8/2022, 3:26:25 PM",lastUpdatedTimestamp:1649402785e3,headersStr:"装饰器模式 装饰器模式的优势 TS 装饰器 装饰器写法 装饰器分类 装饰器原理",content:'# TypeScript中的装饰器(@)\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入，详见官方文档。\n\n\n# 装饰器模式\n\n介绍 TS 装饰器之前，我们从设计模式出发，了解一下其中的装饰器模式\n\n> 装饰器模式实现了不改变原有对象，在原有对象上实现功能的添加。这是一种对原有对象的一种包装。\n\n假设现在有两个形状，一个矩形一个圆形，这时候我们希望能在形状上实现一些特殊的功能，但又不改变原来的类，我们要如何做呢？\n\nclass Rectangle {\n    draw() {\n       console.log("Shape: Rectangle");\n    }\n}\nclass Circle {\n    draw() {\n       console.log("Shape: Circle");\n    }\n}\n\n\n这时我们可以用装饰器来实现，假设我们要给形状添加颜色功能\n\nclass RedShapeDecorator {\n    constructor(decoratedShape) {\n       this.decoratedShape = decoratedShape;    \n    }\n    draw() {\n       this.decoratedShape.draw();        \n       this.setRedBorder();\n    }\n    setRedBorder(){\n       console.log("Border Color: Red");\n    }\n}\n\n\n那么在使用装饰器的类，在画圆的时候就实现了了画边框的颜色。\n\nconst circle = new Circle();\nconst redCircle = new RedShapeDecorator(new Circle());\nconst redRectangle = new RedShapeDecorator(new Rectangle());\nconsole.log("Circle with normal border");\ncircle.draw();\nconsole.log("\\nCircle of red border");\nredCircle.draw();\nconsole.log("\\nRectangle of red border");\nredRectangle.draw();\n/**\n * output:\n * Circle with normal border\n * Shape: Circle\n * \n * Circle of red border\n * Shape: Circle\n * Border Color: Red\n * \n * Rectangle of red border\n * Shape: Rectangle\n * Border Color: Red\n */\n\n\n\n# 装饰器模式的优势\n\n即使原有对象发生改变，装饰器是种非侵入式功能添加，对原有对象的影响也能降低到最小。\n\n\n# TS 装饰器\n\n * 语法：装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\n\n * 若要启用实验性的装饰器特性，必须tsconfig.json里启用experimentalDecorators编译器选项\n\n * 常见的装饰器有: 类装饰器、属性装饰器、方法装饰器、参数装饰器\n\n * 装饰器的写法: 分为普通装饰器(无法传参）和装饰器工厂(可以传参)\n\n\n# 装饰器写法\n\n# 1. 普通装饰器\n\nfunction decorator(target: Function) {\n  // do something with "target" ...\n  console.log(target)\n}\n\n@decorator\nclass A {\n  constructor() {}\n}\n\n// 编译后输出的 target 其实就是 class A\n// class 本质上是构造函数的语法糖，所以类型注解是 Function\nclass A {\n    constructor() { }\n} \n\n\n个人理解 ts 中的装饰器的含义其实和装饰器模式的本质相同，都是把原有的对象（A）拿过来通过 decorator 装饰（处理）一下。\n\n# 2. 装饰器工厂\n\n装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\nfunction color(value: string) { // 这是一个装饰器工厂\n    return function (target: Function) { //  这是装饰器\n        // do something with "target" and "value"...\n        target.prototype.color = value\n    }\n}\n\n@color(\'red\')\nclass Apple {\n  constructor() {}\n}\n\nconst apple = new Apple()\nconsole.log(apple.color) // \'red\'\n\n\n\n# 装饰器分类\n\n# 1. 类装饰器\n\n * 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。\n\n * 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n\nfunction decorator(target: any) {\n  target.xx = \'test\' ; // 给类增加属性\n  target.prototype.name = \'tom\'\n  target.prototype.age = \'18\'\n}\n\n@decorator\nclass Person {\n  constructor() { }\n}\n\nlet p = new Person()\nconsole.log(Person.xx); // test\nconsole.log(p.age) // 18\n\n\n * 如果类装饰器返回一个构造函数, 它会使用提供的构造函数来替换类之前的声明。\n\nfunction decorator (target: any) {\n  return class B extends target {\n    name = \'B\'\n  }\n}\n\n@decorator\nclass A {\n  name = \'A\'\n  constructor() {}\n}\n\nconsole.log(new A().name) // \'B\'\n\n\n# 2. 属性装饰器\n\n属性装饰器声明在一个属性声明之前（紧靠着属性声明）\n\n属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n\n> 属性描述符不会做为参数传入属性装饰器，\n\nfunction decorator(target: any, propertyKey: string) {\n  console.log(target) // Person: {}\n  console.log(propertyKey) // "name" \n}\n\nclass Person {\n  constructor() { }\n\n  @decorator\n  name: string = \'Tom\'\n}\n\n\n# 3. 方法装饰器\n\n方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。\n\n方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n 3. 成员的属性描述符，即 Object.getOwnPropertyDescriptor(target,key)。\n\nfunction decorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  console.log(target) // Person: {} \n  console.log(propertyKey) // "say" \n  console.log(descriptor) // {"writable":true,"enumerable":false,"configurable":true} \n  descriptor.writable = false;\n}\n\nclass Person {\n  constructor() { }\n\n  @decorator\n  say() {\n    console.log(\'say hi\')\n  }\n}\nlet p = new Person()\n\n// 因为已经设置 writable 为 false，不可以修改所以下面这段代码会报错\np.say = function() {\n  console.log(\'say hello\')\n}\n\n\n静态成员\n\nfunction decorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  console.log(target)\n  console.log(propertyKey)\n  console.log(descriptor)\n}\n\nclass Person {\n  constructor() { }\n\n  @decorator\n  static say() {\n    console.log(\'say hi\')\n  }\n}\n\n// 输出的 target 为类的构造函数\nclass Person {\n    constructor() { }\n    static say() {\n        console.log(\'say hi\');\n    }\n} \n\n\n# 4. 参数装饰器\n\n参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。\n\n参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n 3. 参数在函数参数列表中的索引。\n\nfunction decorator(target: any, propertyKey: string, parameterIndex: number) {\n  console.log(target) // Person: {} \n  console.log(propertyKey) // "say" \n  console.log(parameterIndex) // 0\n}\n\nclass Person {\n  word: string\n  constructor() {\n    this.word  = \'hi\'\n  }\n\n  say(@decorator word: string) {\n    console.log(word)\n  }\n}\n\n\n\n# 装饰器原理\n\n装饰器的编译结果如下：\n\n\n\n我们来具体看一下代码：\n\nvar __decorate = \n    // 当前上下文是否有 __decorate 这个函数，如果有就返回这个函数，如果没有就定义一个\n    (this && this.__decorate) || function (decorators, target, key, desc) {\n      \n    // c: 参数个数，此例为 2\n    // r: 此例为 target 即构造函数\n    var c = arguments.length, \n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, \n        d;\n    \n    // 如果系统支持反射，则直接使用Reflect.decorate(decorators,target, key, desc)方法。\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {\n      r = Reflect.decorate(decorators, target, key, desc);\n    }\n    // 否则自行定义实现装饰器机制的代码。\n    else for (var i = decorators.length - 1; i >= 0; i--) {\n      if (d = decorators[i]) {\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n      }\n    }\n    if (c > 3 && r) {\n      return Object.defineProperty(target, key, r)\n    }\n    return r;\n};\n\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") {\n      return Reflect.metadata(k, v);\n    }\n};\n\nfunction decorator(target) {\n    // do something with "target" ...\n    console.log(target);\n}\nlet A = class A {\n    constructor() { }\n};\nA = __decorate([\n    decorator,\n    __metadata("design:paramtypes", [])\n], A);\n',normalizedContent:'# typescript中的装饰器(@)\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入，详见官方文档。\n\n\n# 装饰器模式\n\n介绍 ts 装饰器之前，我们从设计模式出发，了解一下其中的装饰器模式\n\n> 装饰器模式实现了不改变原有对象，在原有对象上实现功能的添加。这是一种对原有对象的一种包装。\n\n假设现在有两个形状，一个矩形一个圆形，这时候我们希望能在形状上实现一些特殊的功能，但又不改变原来的类，我们要如何做呢？\n\nclass rectangle {\n    draw() {\n       console.log("shape: rectangle");\n    }\n}\nclass circle {\n    draw() {\n       console.log("shape: circle");\n    }\n}\n\n\n这时我们可以用装饰器来实现，假设我们要给形状添加颜色功能\n\nclass redshapedecorator {\n    constructor(decoratedshape) {\n       this.decoratedshape = decoratedshape;    \n    }\n    draw() {\n       this.decoratedshape.draw();        \n       this.setredborder();\n    }\n    setredborder(){\n       console.log("border color: red");\n    }\n}\n\n\n那么在使用装饰器的类，在画圆的时候就实现了了画边框的颜色。\n\nconst circle = new circle();\nconst redcircle = new redshapedecorator(new circle());\nconst redrectangle = new redshapedecorator(new rectangle());\nconsole.log("circle with normal border");\ncircle.draw();\nconsole.log("\\ncircle of red border");\nredcircle.draw();\nconsole.log("\\nrectangle of red border");\nredrectangle.draw();\n/**\n * output:\n * circle with normal border\n * shape: circle\n * \n * circle of red border\n * shape: circle\n * border color: red\n * \n * rectangle of red border\n * shape: rectangle\n * border color: red\n */\n\n\n\n# 装饰器模式的优势\n\n即使原有对象发生改变，装饰器是种非侵入式功能添加，对原有对象的影响也能降低到最小。\n\n\n# ts 装饰器\n\n * 语法：装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\n\n * 若要启用实验性的装饰器特性，必须tsconfig.json里启用experimentaldecorators编译器选项\n\n * 常见的装饰器有: 类装饰器、属性装饰器、方法装饰器、参数装饰器\n\n * 装饰器的写法: 分为普通装饰器(无法传参）和装饰器工厂(可以传参)\n\n\n# 装饰器写法\n\n# 1. 普通装饰器\n\nfunction decorator(target: function) {\n  // do something with "target" ...\n  console.log(target)\n}\n\n@decorator\nclass a {\n  constructor() {}\n}\n\n// 编译后输出的 target 其实就是 class a\n// class 本质上是构造函数的语法糖，所以类型注解是 function\nclass a {\n    constructor() { }\n} \n\n\n个人理解 ts 中的装饰器的含义其实和装饰器模式的本质相同，都是把原有的对象（a）拿过来通过 decorator 装饰（处理）一下。\n\n# 2. 装饰器工厂\n\n装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\nfunction color(value: string) { // 这是一个装饰器工厂\n    return function (target: function) { //  这是装饰器\n        // do something with "target" and "value"...\n        target.prototype.color = value\n    }\n}\n\n@color(\'red\')\nclass apple {\n  constructor() {}\n}\n\nconst apple = new apple()\nconsole.log(apple.color) // \'red\'\n\n\n\n# 装饰器分类\n\n# 1. 类装饰器\n\n * 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。\n\n * 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n\nfunction decorator(target: any) {\n  target.xx = \'test\' ; // 给类增加属性\n  target.prototype.name = \'tom\'\n  target.prototype.age = \'18\'\n}\n\n@decorator\nclass person {\n  constructor() { }\n}\n\nlet p = new person()\nconsole.log(person.xx); // test\nconsole.log(p.age) // 18\n\n\n * 如果类装饰器返回一个构造函数, 它会使用提供的构造函数来替换类之前的声明。\n\nfunction decorator (target: any) {\n  return class b extends target {\n    name = \'b\'\n  }\n}\n\n@decorator\nclass a {\n  name = \'a\'\n  constructor() {}\n}\n\nconsole.log(new a().name) // \'b\'\n\n\n# 2. 属性装饰器\n\n属性装饰器声明在一个属性声明之前（紧靠着属性声明）\n\n属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n\n> 属性描述符不会做为参数传入属性装饰器，\n\nfunction decorator(target: any, propertykey: string) {\n  console.log(target) // person: {}\n  console.log(propertykey) // "name" \n}\n\nclass person {\n  constructor() { }\n\n  @decorator\n  name: string = \'tom\'\n}\n\n\n# 3. 方法装饰器\n\n方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。\n\n方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n 3. 成员的属性描述符，即 object.getownpropertydescriptor(target,key)。\n\nfunction decorator(target: any, propertykey: string, descriptor: propertydescriptor) {\n  console.log(target) // person: {} \n  console.log(propertykey) // "say" \n  console.log(descriptor) // {"writable":true,"enumerable":false,"configurable":true} \n  descriptor.writable = false;\n}\n\nclass person {\n  constructor() { }\n\n  @decorator\n  say() {\n    console.log(\'say hi\')\n  }\n}\nlet p = new person()\n\n// 因为已经设置 writable 为 false，不可以修改所以下面这段代码会报错\np.say = function() {\n  console.log(\'say hello\')\n}\n\n\n静态成员\n\nfunction decorator(target: any, propertykey: string, descriptor: propertydescriptor) {\n  console.log(target)\n  console.log(propertykey)\n  console.log(descriptor)\n}\n\nclass person {\n  constructor() { }\n\n  @decorator\n  static say() {\n    console.log(\'say hi\')\n  }\n}\n\n// 输出的 target 为类的构造函数\nclass person {\n    constructor() { }\n    static say() {\n        console.log(\'say hi\');\n    }\n} \n\n\n# 4. 参数装饰器\n\n参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。\n\n参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n 2. 成员的名字。\n 3. 参数在函数参数列表中的索引。\n\nfunction decorator(target: any, propertykey: string, parameterindex: number) {\n  console.log(target) // person: {} \n  console.log(propertykey) // "say" \n  console.log(parameterindex) // 0\n}\n\nclass person {\n  word: string\n  constructor() {\n    this.word  = \'hi\'\n  }\n\n  say(@decorator word: string) {\n    console.log(word)\n  }\n}\n\n\n\n# 装饰器原理\n\n装饰器的编译结果如下：\n\n\n\n我们来具体看一下代码：\n\nvar __decorate = \n    // 当前上下文是否有 __decorate 这个函数，如果有就返回这个函数，如果没有就定义一个\n    (this && this.__decorate) || function (decorators, target, key, desc) {\n      \n    // c: 参数个数，此例为 2\n    // r: 此例为 target 即构造函数\n    var c = arguments.length, \n        r = c < 3 ? target : desc === null ? desc = object.getownpropertydescriptor(target, key) : desc, \n        d;\n    \n    // 如果系统支持反射，则直接使用reflect.decorate(decorators,target, key, desc)方法。\n    if (typeof reflect === "object" && typeof reflect.decorate === "function") {\n      r = reflect.decorate(decorators, target, key, desc);\n    }\n    // 否则自行定义实现装饰器机制的代码。\n    else for (var i = decorators.length - 1; i >= 0; i--) {\n      if (d = decorators[i]) {\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n      }\n    }\n    if (c > 3 && r) {\n      return object.defineproperty(target, key, r)\n    }\n    return r;\n};\n\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof reflect === "object" && typeof reflect.metadata === "function") {\n      return reflect.metadata(k, v);\n    }\n};\n\nfunction decorator(target) {\n    // do something with "target" ...\n    console.log(target);\n}\nlet a = class a {\n    constructor() { }\n};\na = __decorate([\n    decorator,\n    __metadata("design:paramtypes", [])\n], a);\n',charsets:{cjk:!0}},{title:"Vue源码学习（一）",frontmatter:{title:"Vue源码学习（一）",date:"2020-10-13T09:47:00.000Z",categories:"Vue"},regularPath:"/vue/code-1.html",relativePath:"vue/code-1.md",key:"v-be252d12",path:"/vue/code-1.html",headers:[{level:2,title:"调试与打包",slug:"调试与打包",normalizedTitle:"调试与打包",charIndex:17},{level:2,title:"通过看源码解决问题",slug:"通过看源码解决问题",normalizedTitle:"通过看源码解决问题",charIndex:579},{level:2,title:"平台无关与平台相关",slug:"平台无关与平台相关",normalizedTitle:"平台无关与平台相关",charIndex:49},{level:2,title:"Vue的构造函数",slug:"vue的构造函数",normalizedTitle:"vue的构造函数",charIndex:62},{level:2,title:"源码报错的两个小问题",slug:"源码报错的两个小问题",normalizedTitle:"源码报错的两个小问题",charIndex:74},{level:2,title:"Vue初始化-静态成员",slug:"vue初始化-静态成员",normalizedTitle:"vue初始化-静态成员",charIndex:88},{level:2,title:"Vue的实例属性和方法",slug:"vue的实例属性和方法",normalizedTitle:"vue的实例属性和方法",charIndex:103}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"调试与打包 通过看源码解决问题 平台无关与平台相关 Vue的构造函数 源码报错的两个小问题 Vue初始化-静态成员 Vue的实例属性和方法",content:"# Vue源码学习（一）\n\n * 调试与打包\n * template和render同时存在\n * 平台无关与平台相关\n * Vue的构造函数\n * 源码报错的两个小问题\n * Vue初始化-静态成员\n * Vue的实例属性和方法\n\n\n# 调试与打包\n\n * vue源码中的打包工具 Rollup\n   * Vue.js 源码的打包工具使用的是 Rollup，比 Webpack 轻量\n   * Webpack 把所有文件当做模块，Rollup 只处理 js 文件更适合在 Vue.js 这样的库中使用\n   * Rollup 打包不会生成冗余的代码\n * 安装依赖后设置 sourcemap\n\n\"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web- full-dev\"\n\n\n * 执行npm run dev打包，发现dist目录下生成许多文件\n\n此处参考：官方文档\n\n * 推荐使用运行时版本，因为运行时版本相比完整版体积要小大约 30%\n\n * 基于 Vue-CLI 创建的项目默认使用的是 vue.runtime.esm.js\n\n * *.vue 文件中的模板是在构建时预编译的，最终打包后的结果不需要编译器，只需要运行\n   \n   时版本即可\n\n\n# 通过看源码解决问题\n\nconst vm = new Vue({ \n    el: '#app', \n    template: '<h3>Hello template</h3>', \n    render (h) { \n        return h('h4', 'Hello render') \n    } \n})\n// 同时存在template和render函数时页面输出 Hello render\n\n\n * el 不能是 body 或者 html 标签\n * 如果没有 render，把 template 转换成 render 函数\n * 如果有 render 方法，直接调用 mount 挂载 DOM\n\n// 1. el 不能是 body 或者 html \nif (el === document.body || el === document.documentElement) { \n    process.env.NODE_ENV !== 'production' && warn( \n        `Do not mount Vue to <html> or <body> - mount to normal elements \ninstead.` \n    )\n    return this \n}\nconst options = this.$options \nif (!options.render) \n{ \n    // 2. 把 template/el 转换成 render 函数 \n    …… \n}\n// 3. 调用 mount 方法，挂载 DOM \nreturn mount.call(this, el, hydrating)\n\n\n\n# 平台无关与平台相关\n\n源码的src目录下有这样的结构\n\n|--core\n|--platforms\n\t  |--web\n\t  |--weex\n\n\n其中core存放的就是平台无关代码，platforms中存放的就是平台相关代码\n\n什么是平台无关性:\n\n * 平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行 。\n\n平台无关有两种：\n\n * 源代码级和目标代码级。而C和C++具有一定程度的源代码级平台无关，表明用C或C++写的应用程序不用修改只需重新编译就可以在不同平台上运行。\n\n * 而Java编译出来的是字节码，去到哪个平台都能用，只要有那个平台的JDK就可以运行，所以，Java程序的最大优势就是平台无关。\n\n\n# Vue的构造函数\n\n * src/platform/web中有一些entry-文件，引用了 '/runtime/index'\n\n * src/platform/web/runtime/index.js 中引用了 'core/index'\n\n * src/core/index.js\n   \n   * 定义了 Vue 的静态方法\n   * initGlobalAPI(Vue)\n\n * src/core/index.js 中引用了 './instance/index'\n\n * src/core/instance/index.js\n   \n   * 定义了 Vue 的构造函数\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 _init() 方法，在 initMixin 中定义\n  this._init(options)\n}\n\nexport default Vue\n\n\n\n# 源码报错的两个小问题\n\n例如在src/core/global/index.js中会有报错\n\n// 例如此处不支持泛型会报错  \nVue.observable = <T>(obj: T): T => {\n    observe(obj)\n    return obj\n  }\n// 而且这段代码之后的部分不会高亮显示\n\n\n解决：文件 => 首选项 => 设置 => 右上角json格式\n\n// 不检查 js 语法问题\n\"javascript.validate.enable\": false\n\n\n高亮显示：安装Babel JavaScript插件，但是之后的代码有些功能丢失了，不能跳转定义\n\n\n# Vue初始化-静态成员\n\n静态方法目录在：src/core/global-api中\n\nsrc/core/global-api/index.js：初始化 Vue 的静态方法\n\nexport function initGlobalAPI (Vue: GlobalAPI) {\n\n  // src/core/global-api/index.js \n  // 初始化 Vue.config 对象\n  Object.defineProperty(Vue, 'config', configDef)\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn,\n    extend,\n    mergeOptions,\n    defineReactive\n  }\n \n  // 静态方法 set/delete/nextTick\n  Vue.set = set\n  Vue.delete = del\n  Vue.nextTick = nextTick\n\n  // 2.6 explicit observable API\n  // 让一个对象可响应\n  Vue.observable = <T>(obj: T): T => {\n    observe(obj)\n    return obj\n  }\n  \n  // 初始化 Vue.options 对象，并给其扩展\n  Vue.options = Object.create(null)\n  ASSET_TYPES.forEach(type => {\n    Vue.options[type + 's'] = Object.create(null)\n  })\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue\n\n  // 设置 keep-alive 组件\n  extend(Vue.options.components, builtInComponents)\n  \n  // 注册 Vue.use() 用来注册插件\n  initUse(Vue)\n  // 注册 Vue.mixin() 实现混入\n  initMixin(Vue)\n  // 注册 Vue.extend() 基于传入的 options 返回一个组件的构造函数\n  initExtend(Vue)\n  // 注册 Vue.directive()、 Vue.component()、Vue.filter()\n  initAssetRegisters(Vue)\n}\n\n\n上面所注册的全局API在官方文档中。\n\n关于Vue.directive可参考这篇博客。\n\n\n# Vue的实例属性和方法\n\n定义实例属性和方法的目录在：src/core/instance中\n\nsrc/core/instance/index.js：定义Vue的构造函数和实例成员\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 _init() 方法，在 initMixin 中定义\n  this._init(options)\n}\n\n// 下面这些方法都是在 Vue 的原型上增加属性,即实例上也可以调用\n\n// 注册 vm 的 _init() 方法，初始化 vm\ninitMixin(Vue)\n// 注册 vm 的 $data/$props/$set/$delete/$watch\nstateMixin(Vue)\n// 初始化事件相关方法 $on/$once/$off/$emit\neventsMixin(Vue)\n// 初始化生命周期相关的混入方法 _update/$forceUpdate/$destroy\nlifecycleMixin(Vue)\n// 混入 render $nextTick/_render\nrenderMixin(Vue)\n\nexport default Vue\n",normalizedContent:"# vue源码学习（一）\n\n * 调试与打包\n * template和render同时存在\n * 平台无关与平台相关\n * vue的构造函数\n * 源码报错的两个小问题\n * vue初始化-静态成员\n * vue的实例属性和方法\n\n\n# 调试与打包\n\n * vue源码中的打包工具 rollup\n   * vue.js 源码的打包工具使用的是 rollup，比 webpack 轻量\n   * webpack 把所有文件当做模块，rollup 只处理 js 文件更适合在 vue.js 这样的库中使用\n   * rollup 打包不会生成冗余的代码\n * 安装依赖后设置 sourcemap\n\n\"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment target:web- full-dev\"\n\n\n * 执行npm run dev打包，发现dist目录下生成许多文件\n\n此处参考：官方文档\n\n * 推荐使用运行时版本，因为运行时版本相比完整版体积要小大约 30%\n\n * 基于 vue-cli 创建的项目默认使用的是 vue.runtime.esm.js\n\n * *.vue 文件中的模板是在构建时预编译的，最终打包后的结果不需要编译器，只需要运行\n   \n   时版本即可\n\n\n# 通过看源码解决问题\n\nconst vm = new vue({ \n    el: '#app', \n    template: '<h3>hello template</h3>', \n    render (h) { \n        return h('h4', 'hello render') \n    } \n})\n// 同时存在template和render函数时页面输出 hello render\n\n\n * el 不能是 body 或者 html 标签\n * 如果没有 render，把 template 转换成 render 函数\n * 如果有 render 方法，直接调用 mount 挂载 dom\n\n// 1. el 不能是 body 或者 html \nif (el === document.body || el === document.documentelement) { \n    process.env.node_env !== 'production' && warn( \n        `do not mount vue to <html> or <body> - mount to normal elements \ninstead.` \n    )\n    return this \n}\nconst options = this.$options \nif (!options.render) \n{ \n    // 2. 把 template/el 转换成 render 函数 \n    …… \n}\n// 3. 调用 mount 方法，挂载 dom \nreturn mount.call(this, el, hydrating)\n\n\n\n# 平台无关与平台相关\n\n源码的src目录下有这样的结构\n\n|--core\n|--platforms\n\t  |--web\n\t  |--weex\n\n\n其中core存放的就是平台无关代码，platforms中存放的就是平台相关代码\n\n什么是平台无关性:\n\n * 平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行 。\n\n平台无关有两种：\n\n * 源代码级和目标代码级。而c和c++具有一定程度的源代码级平台无关，表明用c或c++写的应用程序不用修改只需重新编译就可以在不同平台上运行。\n\n * 而java编译出来的是字节码，去到哪个平台都能用，只要有那个平台的jdk就可以运行，所以，java程序的最大优势就是平台无关。\n\n\n# vue的构造函数\n\n * src/platform/web中有一些entry-文件，引用了 '/runtime/index'\n\n * src/platform/web/runtime/index.js 中引用了 'core/index'\n\n * src/core/index.js\n   \n   * 定义了 vue 的静态方法\n   * initglobalapi(vue)\n\n * src/core/index.js 中引用了 './instance/index'\n\n * src/core/instance/index.js\n   \n   * 定义了 vue 的构造函数\n\nfunction vue (options) {\n  if (process.env.node_env !== 'production' &&\n    !(this instanceof vue)\n  ) {\n    warn('vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 _init() 方法，在 initmixin 中定义\n  this._init(options)\n}\n\nexport default vue\n\n\n\n# 源码报错的两个小问题\n\n例如在src/core/global/index.js中会有报错\n\n// 例如此处不支持泛型会报错  \nvue.observable = <t>(obj: t): t => {\n    observe(obj)\n    return obj\n  }\n// 而且这段代码之后的部分不会高亮显示\n\n\n解决：文件 => 首选项 => 设置 => 右上角json格式\n\n// 不检查 js 语法问题\n\"javascript.validate.enable\": false\n\n\n高亮显示：安装babel javascript插件，但是之后的代码有些功能丢失了，不能跳转定义\n\n\n# vue初始化-静态成员\n\n静态方法目录在：src/core/global-api中\n\nsrc/core/global-api/index.js：初始化 vue 的静态方法\n\nexport function initglobalapi (vue: globalapi) {\n\n  // src/core/global-api/index.js \n  // 初始化 vue.config 对象\n  object.defineproperty(vue, 'config', configdef)\n\n  // exposed util methods.\n  // note: these are not considered part of the public api - avoid relying on\n  // them unless you are aware of the risk.\n  vue.util = {\n    warn,\n    extend,\n    mergeoptions,\n    definereactive\n  }\n \n  // 静态方法 set/delete/nexttick\n  vue.set = set\n  vue.delete = del\n  vue.nexttick = nexttick\n\n  // 2.6 explicit observable api\n  // 让一个对象可响应\n  vue.observable = <t>(obj: t): t => {\n    observe(obj)\n    return obj\n  }\n  \n  // 初始化 vue.options 对象，并给其扩展\n  vue.options = object.create(null)\n  asset_types.foreach(type => {\n    vue.options[type + 's'] = object.create(null)\n  })\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in weex's multi-instance scenarios.\n  vue.options._base = vue\n\n  // 设置 keep-alive 组件\n  extend(vue.options.components, builtincomponents)\n  \n  // 注册 vue.use() 用来注册插件\n  inituse(vue)\n  // 注册 vue.mixin() 实现混入\n  initmixin(vue)\n  // 注册 vue.extend() 基于传入的 options 返回一个组件的构造函数\n  initextend(vue)\n  // 注册 vue.directive()、 vue.component()、vue.filter()\n  initassetregisters(vue)\n}\n\n\n上面所注册的全局api在官方文档中。\n\n关于vue.directive可参考这篇博客。\n\n\n# vue的实例属性和方法\n\n定义实例属性和方法的目录在：src/core/instance中\n\nsrc/core/instance/index.js：定义vue的构造函数和实例成员\n\nfunction vue (options) {\n  if (process.env.node_env !== 'production' &&\n    !(this instanceof vue)\n  ) {\n    warn('vue is a constructor and should be called with the `new` keyword')\n  }\n  // 调用 _init() 方法，在 initmixin 中定义\n  this._init(options)\n}\n\n// 下面这些方法都是在 vue 的原型上增加属性,即实例上也可以调用\n\n// 注册 vm 的 _init() 方法，初始化 vm\ninitmixin(vue)\n// 注册 vm 的 $data/$props/$set/$delete/$watch\nstatemixin(vue)\n// 初始化事件相关方法 $on/$once/$off/$emit\neventsmixin(vue)\n// 初始化生命周期相关的混入方法 _update/$forceupdate/$destroy\nlifecyclemixin(vue)\n// 混入 render $nexttick/_render\nrendermixin(vue)\n\nexport default vue\n",charsets:{cjk:!0}},{title:"Vue源码学习（二）",frontmatter:{title:"Vue源码学习（二）",date:"2020-10-16T09:47:00.000Z",categories:"Vue"},regularPath:"/vue/code-2.html",relativePath:"vue/code-2.md",key:"v-eb77cf16",path:"/vue/code-2.html",headers:[{level:2,title:"watch的两个参数",slug:"watch的两个参数",normalizedTitle:"watch的两个参数",charIndex:17},{level:2,title:"三种类型的 Watcher 对象",slug:"三种类型的-watcher-对象",normalizedTitle:"三种类型的 watcher 对象",charIndex:31},{level:2,title:"异步更新队列-nextTick",slug:"异步更新队列-nexttick",normalizedTitle:"异步更新队列-nexttick",charIndex:51}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"watch的两个参数 三种类型的 Watcher 对象 异步更新队列-nextTick",content:"# Vue源码学习（二）\n\n * watch的两个参数\n * 三种类型的 Watcher 对象\n * 异步更新队列-nextTick\n\n\n# watch的两个参数\n\n * immediate：代表立即执行，而不是等监听对象改变再执行\n * deep：深度监听，对象的属性改变也可以监听的到\n\n可以参考这篇文章\n\n// 两种写法\nwatch: {\n    'user.firstName': function (newValue, oldValue) {\n        this.user.fullName = this.user.firstName + '' + this.user.lastName\n    }\n}\n\nwatch: {\n    'user': {\n        handler: function (newValue, oldValue) {\n        \tthis.user.fullName = this.user.firstName + '' + this.user.lastName\n    \t},\n        deep: true,\n        immediate: true\n    }\n}\n\n\n\n# 三种类型的 Watcher 对象\n\n * 没有静态方法，因为 $watch 方法中要使用 Vue 的实例\n\n * Watcher 分三种：计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher\n   \n   * 计算属性 Watcher 在 initComputd 中创建\n   * 用户 Watcher (侦听器) 在 Vue.$watch 中创建\n   * 渲染 Watcher 在 mountComponent 中创建\n\n * Watcher内部实现是一样的，src/core/observer/watcher.js中，并且每一个Watcher都有一个id\n\n * 创建顺序：计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher\n\n * vm.$watch()\n   \n   * src\\core\\instance\\state.js\n\nVue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    // 获取 Vue 实例 this\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      // 判断如果 cb 是对象执行 createWatcher\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    // 创建用户 watcher 对象\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    // 判断 immediate 如果为 true\n    if (options.immediate) {\n      // 立即执行一次 cb 回调，并且把当前值传入\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    // 返回取消监听的方法\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n\n\n\n# 异步更新队列-nextTick\n\n可以查看Vue.nextTick 的原理和用途\n\n * 首先修改数据，在script代码块中，这是宏任务，同一事件循环的所有的宏任务都在主线程上执行，形成一个执行栈，此时还未涉及DOM.\n\n * Vue开启一个异步队列，并缓冲在此事件循环中发生的所有数据变化。如果同一个watcher被多次触发，只会被推入 queueWatcher 队列中一次，这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要\n\n# 定义位置\n\n * src\\core\\instance\\render.js\n\nVue.prototype.$nextTick = function (fn: Function) { \n    return nextTick(fn, this) \n}\n\n\n# 源码\n\n * 手动调用 vm.$nextTick()\n * 在 Watcher 的 queueWatcher 中执行 nextTick()\n * src\\core\\util\\next-tick.js\n\n# 注意\n\n * 在修改完数据时，想要获取更新后 DOM 上最新数据，需要使用 nextTick，因为 DOM 的更新过程是异步的\n\n * nextTick 会把传入的回调函数 cb 压入 callbacks 数组，这里使用 callbacks 而不是直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick时不会开启多个异步任务，而是把这些任务放在一起一同执行。\n\n * 那么这些回调函数如何调用呢，nextTick 内部优先使用微任务执行异步的回调函数，microtask 因为其高优先级特性能确保队列中的微任务在一次事件循环前被执行完毕，如果浏览器不支持 Promise 的话会降级成 MutationObserver，如果浏览器再不支持微任务，会降级成宏任务，如果 IE 优先使用 setImmediate，否则使用 setTimeout\n\n * 然后其实Vue进行 DOM 更新内部也是调用 nextTick 来做异步队列控制，而当我们自己调用 nextTick 时，更新 DOM 的回调函数已经加入了callback，在他后面后追加了我们自己的回调函数，从而确保我们的代码在 DOM 更新后执行，所以我们可以拿到更新后的 DOM\n\n * 问题： 按照 macrotask => microtask => ui渲染的顺序，若 nextTick 在微任务队列中，此时ui还没渲染，那他是怎么拿到 DOM 的呢\n   \n   * 首先解释：其实macrotask => microtask => ui渲染的规则是为了 JS 引擎线程和 GUI 渲染线程有序切换\n   \n   * 因为已经保证了我们的 nextTick 在更新 DOM 的 nextTick 之后，可以拿到，就是还没渲染而已\n\n// 支持 Promise 使用 Promise\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n// 否则使用 MutationObserver\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n// 否则使用 setImmediate\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n// 否则使用 setTimeout\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\n// 如果有回调函数 cb 则加入一个队列，如果没有则返回 Promise，第二个参数是上下文\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc() // 取出所有的回调函数调用\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n",normalizedContent:"# vue源码学习（二）\n\n * watch的两个参数\n * 三种类型的 watcher 对象\n * 异步更新队列-nexttick\n\n\n# watch的两个参数\n\n * immediate：代表立即执行，而不是等监听对象改变再执行\n * deep：深度监听，对象的属性改变也可以监听的到\n\n可以参考这篇文章\n\n// 两种写法\nwatch: {\n    'user.firstname': function (newvalue, oldvalue) {\n        this.user.fullname = this.user.firstname + '' + this.user.lastname\n    }\n}\n\nwatch: {\n    'user': {\n        handler: function (newvalue, oldvalue) {\n        \tthis.user.fullname = this.user.firstname + '' + this.user.lastname\n    \t},\n        deep: true,\n        immediate: true\n    }\n}\n\n\n\n# 三种类型的 watcher 对象\n\n * 没有静态方法，因为 $watch 方法中要使用 vue 的实例\n\n * watcher 分三种：计算属性 watcher、用户 watcher (侦听器)、渲染 watcher\n   \n   * 计算属性 watcher 在 initcomputd 中创建\n   * 用户 watcher (侦听器) 在 vue.$watch 中创建\n   * 渲染 watcher 在 mountcomponent 中创建\n\n * watcher内部实现是一样的，src/core/observer/watcher.js中，并且每一个watcher都有一个id\n\n * 创建顺序：计算属性 watcher、用户 watcher (侦听器)、渲染 watcher\n\n * vm.$watch()\n   \n   * src\\core\\instance\\state.js\n\nvue.prototype.$watch = function (\n    exporfn: string | function,\n    cb: any,\n    options?: object\n  ): function {\n    // 获取 vue 实例 this\n    const vm: component = this\n    if (isplainobject(cb)) {\n      // 判断如果 cb 是对象执行 createwatcher\n      return createwatcher(vm, exporfn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    // 创建用户 watcher 对象\n    const watcher = new watcher(vm, exporfn, cb, options)\n    // 判断 immediate 如果为 true\n    if (options.immediate) {\n      // 立即执行一次 cb 回调，并且把当前值传入\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleerror(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    // 返回取消监听的方法\n    return function unwatchfn () {\n      watcher.teardown()\n    }\n  }\n\n\n\n# 异步更新队列-nexttick\n\n可以查看vue.nexttick 的原理和用途\n\n * 首先修改数据，在script代码块中，这是宏任务，同一事件循环的所有的宏任务都在主线程上执行，形成一个执行栈，此时还未涉及dom.\n\n * vue开启一个异步队列，并缓冲在此事件循环中发生的所有数据变化。如果同一个watcher被多次触发，只会被推入 queuewatcher 队列中一次，这种在缓冲时去除重复数据对于避免不必要的计算和 dom 操作上非常重要\n\n# 定义位置\n\n * src\\core\\instance\\render.js\n\nvue.prototype.$nexttick = function (fn: function) { \n    return nexttick(fn, this) \n}\n\n\n# 源码\n\n * 手动调用 vm.$nexttick()\n * 在 watcher 的 queuewatcher 中执行 nexttick()\n * src\\core\\util\\next-tick.js\n\n# 注意\n\n * 在修改完数据时，想要获取更新后 dom 上最新数据，需要使用 nexttick，因为 dom 的更新过程是异步的\n\n * nexttick 会把传入的回调函数 cb 压入 callbacks 数组，这里使用 callbacks 而不是直接在 nexttick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nexttick时不会开启多个异步任务，而是把这些任务放在一起一同执行。\n\n * 那么这些回调函数如何调用呢，nexttick 内部优先使用微任务执行异步的回调函数，microtask 因为其高优先级特性能确保队列中的微任务在一次事件循环前被执行完毕，如果浏览器不支持 promise 的话会降级成 mutationobserver，如果浏览器再不支持微任务，会降级成宏任务，如果 ie 优先使用 setimmediate，否则使用 settimeout\n\n * 然后其实vue进行 dom 更新内部也是调用 nexttick 来做异步队列控制，而当我们自己调用 nexttick 时，更新 dom 的回调函数已经加入了callback，在他后面后追加了我们自己的回调函数，从而确保我们的代码在 dom 更新后执行，所以我们可以拿到更新后的 dom\n\n * 问题： 按照 macrotask => microtask => ui渲染的顺序，若 nexttick 在微任务队列中，此时ui还没渲染，那他是怎么拿到 dom 的呢\n   \n   * 首先解释：其实macrotask => microtask => ui渲染的规则是为了 js 引擎线程和 gui 渲染线程有序切换\n   \n   * 因为已经保证了我们的 nexttick 在更新 dom 的 nexttick 之后，可以拿到，就是还没渲染而已\n\n// 支持 promise 使用 promise\nif (typeof promise !== 'undefined' && isnative(promise)) {\n  const p = promise.resolve()\n  timerfunc = () => {\n    p.then(flushcallbacks)\n    if (isios) settimeout(noop)\n  }\n  isusingmicrotask = true\n// 否则使用 mutationobserver\n} else if (!isie && typeof mutationobserver !== 'undefined' && (\n  isnative(mutationobserver) ||\n  // phantomjs and ios 7.x\n  mutationobserver.tostring() === '[object mutationobserverconstructor]'\n)) {\n  // use mutationobserver where native promise is not available,\n  // e.g. phantomjs, ios7, android 4.4\n  // (#6466 mutationobserver is unreliable in ie11)\n  let counter = 1\n  const observer = new mutationobserver(flushcallbacks)\n  const textnode = document.createtextnode(string(counter))\n  observer.observe(textnode, {\n    characterdata: true\n  })\n  timerfunc = () => {\n    counter = (counter + 1) % 2\n    textnode.data = string(counter)\n  }\n  isusingmicrotask = true\n// 否则使用 setimmediate\n} else if (typeof setimmediate !== 'undefined' && isnative(setimmediate)) {\n  // fallback to setimmediate.\n  // technically it leverages the (macro) task queue,\n  // but it is still a better choice than settimeout.\n  timerfunc = () => {\n    setimmediate(flushcallbacks)\n  }\n// 否则使用 settimeout\n} else {\n  // fallback to settimeout.\n  timerfunc = () => {\n    settimeout(flushcallbacks, 0)\n  }\n}\n\n// 如果有回调函数 cb 则加入一个队列，如果没有则返回 promise，第二个参数是上下文\nexport function nexttick (cb?: function, ctx?: object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleerror(e, ctx, 'nexttick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerfunc() // 取出所有的回调函数调用\n  }\n  // $flow-disable-line\n  if (!cb && typeof promise !== 'undefined') {\n    return new promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n",charsets:{cjk:!0}},{title:"Vue源码学习（三）",frontmatter:{title:"Vue源码学习（三）",date:"2020-10-20T09:47:00.000Z",categories:"Vue"},regularPath:"/vue/code-3.html",relativePath:"vue/code-3.md",key:"v-739ac773",path:"/vue/code-3.html",headers:[{level:2,title:"Array.prototype.concat.apply",slug:"array-prototype-concat-apply",normalizedTitle:"array.prototype.concat.apply",charIndex:17},{level:2,title:"模板编译",slug:"模板编译",normalizedTitle:"模板编译",charIndex:49},{level:2,title:"简述 Vue 首次渲染过程",slug:"简述-vue-首次渲染过程",normalizedTitle:"简述 vue 首次渲染过程",charIndex:57},{level:2,title:"简述 Vue 首次模板编译过程",slug:"简述-vue-首次模板编译过程",normalizedTitle:"简述 vue 首次模板编译过程",charIndex:74}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"Array.prototype.concat.apply 模板编译 简述 Vue 首次渲染过程 简述 Vue 首次模板编译过程",content:"# Vue源码学习（三）\n\n * Array.prototype.concat.apply\n * 模板编译\n * 简述 Vue 首次渲染过程\n * 简述 Vue 首次模板编译过程\n\n\n# Array.prototype.concat.apply\n\n * 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；将该特性应用到代码中完成数组降维\n\n// vue 源码中的一段\nfunction simpleNormalizeChildren (children: any) {\n    for (let i = 0; i < children.length; i++) {\n        // 如果第 i 项是数组则降维\n        if (Array.isArray(children[i])) {\n            return Array.prototype.concat.apply([], children)\n        }\n    }\n    return children\n}\n\n// 测试\nlet children = [1, 2, 3, [4, 5, 6], 7, 8, [9, 10]];\nsimpleNormalizeChildren(children);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n# 模板编译\n\n * 模板编译的主要目的是将模板 (template) 转换为渲染函数 (render)\n\n<div> \n    <h1 @click=\"handler\">title</h1> \n    <p>some content</p> \n</div>\n\n\n * 渲染函数 render\n\nrender (h) { \n    return h('div', [ \n        h('h1', { on: { click: this.handler} }, 'title'), \n        h('p', 'some content') \n    ]) \n}\n\n\n * 模板编译的作用\n   \n   * Vue 2.x 使用 VNode 描述视图以及各种交互，用户自己编写 VNode 比较复杂\n   * 用户只需要编写类似 HTML 的代码 - Vue 模板，通过编译器将模板转换为返回 VNode 的 render 函数\n   * .vue 文件会被 webpack 在构建的过程中转换成 render 函数（Vue-loader）\n\n * 在线编译\n   \n   * vue2.xx版本在线编译:https://template-explorer.vuejs.org/#\n   * vue3.xx版本在线编译:https://vue-next-template-explorer.netlify.app/#\n\n\n# 简述 Vue 首次渲染过程\n\n参考大前端学习-Vue首次渲染过程\n\n\n# 简述 Vue 首次模板编译过程\n\n参考Vue 中模板的编译过程概述",normalizedContent:"# vue源码学习（三）\n\n * array.prototype.concat.apply\n * 模板编译\n * 简述 vue 首次渲染过程\n * 简述 vue 首次模板编译过程\n\n\n# array.prototype.concat.apply\n\n * 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；将该特性应用到代码中完成数组降维\n\n// vue 源码中的一段\nfunction simplenormalizechildren (children: any) {\n    for (let i = 0; i < children.length; i++) {\n        // 如果第 i 项是数组则降维\n        if (array.isarray(children[i])) {\n            return array.prototype.concat.apply([], children)\n        }\n    }\n    return children\n}\n\n// 测试\nlet children = [1, 2, 3, [4, 5, 6], 7, 8, [9, 10]];\nsimplenormalizechildren(children);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n# 模板编译\n\n * 模板编译的主要目的是将模板 (template) 转换为渲染函数 (render)\n\n<div> \n    <h1 @click=\"handler\">title</h1> \n    <p>some content</p> \n</div>\n\n\n * 渲染函数 render\n\nrender (h) { \n    return h('div', [ \n        h('h1', { on: { click: this.handler} }, 'title'), \n        h('p', 'some content') \n    ]) \n}\n\n\n * 模板编译的作用\n   \n   * vue 2.x 使用 vnode 描述视图以及各种交互，用户自己编写 vnode 比较复杂\n   * 用户只需要编写类似 html 的代码 - vue 模板，通过编译器将模板转换为返回 vnode 的 render 函数\n   * .vue 文件会被 webpack 在构建的过程中转换成 render 函数（vue-loader）\n\n * 在线编译\n   \n   * vue2.xx版本在线编译:https://template-explorer.vuejs.org/#\n   * vue3.xx版本在线编译:https://vue-next-template-explorer.netlify.app/#\n\n\n# 简述 vue 首次渲染过程\n\n参考大前端学习-vue首次渲染过程\n\n\n# 简述 vue 首次模板编译过程\n\n参考vue 中模板的编译过程概述",charsets:{cjk:!0}},{title:"Virtual DOM 与 Diff 算法",frontmatter:{title:"Virtual DOM 与 Diff 算法",date:"2021-01-15T11:27:54.000Z",categories:"VirtualDOM"},regularPath:"/virtual-dom/virtualdom.html",relativePath:"virtual-dom/virtualdom.md",key:"v-9d022a42",path:"/virtual-dom/virtualdom.html",headers:[{level:2,title:"什么是虚拟DOM",slug:"什么是虚拟dom",normalizedTitle:"什么是虚拟dom",charIndex:28},{level:3,title:"Virtual DOM 库",slug:"virtual-dom-库",normalizedTitle:"virtual dom 库",charIndex:689},{level:2,title:"使用 Snabbdom",slug:"使用-snabbdom",normalizedTitle:"使用 snabbdom",charIndex:40},{level:3,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:1347},{level:3,title:"snabbdom的模块",slug:"snabbdom的模块",normalizedTitle:"snabbdom的模块",charIndex:1899},{level:2,title:"源码解读",slug:"源码解读",normalizedTitle:"源码解读",charIndex:55},{level:3,title:"h函数：",slug:"h函数",normalizedTitle:"h函数：",charIndex:2507},{level:3,title:"VNode对象",slug:"vnode对象",normalizedTitle:"vnode对象",charIndex:74},{level:3,title:"patch过程",slug:"patch过程",normalizedTitle:"patch过程",charIndex:4274},{level:3,title:"init函数",slug:"init函数",normalizedTitle:"init函数",charIndex:87},{level:3,title:"patch函数",slug:"patch函数",normalizedTitle:"patch函数",charIndex:1410},{level:3,title:"patchVnode函数",slug:"patchvnode函数",normalizedTitle:"patchvnode函数",charIndex:7582},{level:3,title:"updateChildren",slug:"updatechildren",normalizedTitle:"updatechildren",charIndex:7953},{level:2,title:"关于 V-for 带 key",slug:"关于-v-for-带-key",normalizedTitle:"关于 v-for 带 key",charIndex:9641},{level:2,title:"场景：list 三条数据删除中间的那条",slug:"场景-list-三条数据删除中间的那条",normalizedTitle:"场景：list 三条数据删除中间的那条",charIndex:10040},{level:2,title:"vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快",slug:"vue-和-react-在虚拟dom的diff上-做了哪些改进使得速度很快",normalizedTitle:"vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快",charIndex:123},{level:2,title:"React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？",slug:"react-和-vue-的-diff-时间复杂度从-o-n-3-优化到-o-n-那么-o-n-3-和-o-n-是如何计算出来的",normalizedTitle:"react 和 vue 的 diff 时间复杂度从 o(n^3) 优化到 o(n) ，那么 o(n^3) 和 o(n) 是如何计算出来的？",charIndex:164}],lastUpdated:"2/14/2023, 7:39:21 PM",lastUpdatedTimestamp:1676374761e3,headersStr:"什么是虚拟DOM Virtual DOM 库 使用 Snabbdom 如何使用 snabbdom的模块 源码解读 h函数： VNode对象 patch过程 init函数 patch函数 patchVnode函数 updateChildren 关于 V-for 带 key 场景：list 三条数据删除中间的那条 vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快 React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？",content:"# Virtual DOM 与 Diff 算法\n\n * 什么是虚拟DOM\n * 使用 Snabbdom\n * 源码解读\n   * h函数\n   * VNode对象\n   * init函数\n * Diff 算法\n * v-for 带 key\n * vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快\n * React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？\n\n\n# 什么是虚拟DOM\n\n * 虚拟DOM是由普通的 JS 对象来描述 DOM 对象，因为不是真实的 DOM 对象，所以叫虚拟 DOM\n\n * 创建虚拟 DOM 的开销比真实 DOM 小很多\n\n * 虚拟 DOM 的好处是当状态改变时不需要立即更新 DOM，只需要一个虚拟树来描述 DOM，虚拟DOM内部将弄清楚如何有效（diff）的更新 DOM\n\n * 如果每次更改应用程序状态都重新创建整个 DOM，则程序非常缓慢，而虚拟DOM可以跟踪上一次的状态\n\n * 除了渲染 DOM 以外,还可以实现 SSR(Nuxt.js/Next.js),原生应用(Weex/React Native),小程序(mpvue/uni-app)\n\n * 关于服务端渲染（SSR）可查看：\n   \n   * https://www.jianshu.com/p/b8cfa496b7ec\n   * https://blog.csdn.net/github_34708151/article/details/98344114\n\n\n# Virtual DOM 库\n\n * Snabbdom\n   * Vue 2.x 内部使用的 Virtual DOM 就是改造的 Snabbom\n   * 大约 200 SLOC（single line of code）\n   * 通过模块可扩展\n   * 源码使用 TS 开发\n   * 最快的 Virtual DOM 之一\n\n\n# 使用 Snabbdom\n\n * 可以使用parcel构建工具，比较轻便\n\nyarn add snabbdom\n\n\n * Snabbdom 官网 demo 中导入使用的是 common.js 模块化语法，我们使用 ES Modules 语法 import\n\nrequire snabbdom from 'snabbdom' // 导入所有函数\nimport { init, h, thunk } from 'snabbdom'\n\n// 不使用 import snabbdom from 'snabbdom' 是因为\n// snabbdom.ts 末尾导出使用的语法是 export 导出，而没有使用 export default\n\n\n * init 是一个高阶函数，返回 patch()\n * h()返回虚拟结点 VNode，这个函数在Vue.js中见过\n\nnew Vue({\n    router,\n    store,\n    render: h => h(App)\n}).$mount('#app')\n\n\n * thunk()是一种优化策略，可以在处理不可变数据时使用\n\n\n# 如何使用\n\n// div中放置子元素 h1,p\nimport { h, init } from 'snabbdom'\n\n// patch函数，作用对比两个vnode的差异更新到真实DOM\nlet patch = init([])\n\n// 第一个参数：标签+选择器\n// 第二个参数：如果是字符串的话就是标签中的内容\nlet vnode = h('div#container', [\n  h('h1', 'Hello Snabbdom'),\n  h('p', '这是一个p标签')\n])\n\nlet app = document.querySelector('#app')\n\nlet oldVnode = patch(app, vnode)\n\n// 两秒之后继续更新\nsetTimeout(() => {\n  vnode = h('div#container', [\n    h('h1', 'Hello World'),\n    h('p', 'Hello P')\n  ])\n  patch(oldVnode, vnode)\n\n  // 清空页面元素 -- 错误\n  // patch(oldVnode, null)\n  // patch(oldVnode, h('!'))\n}, 2000);\n\n\n\n# snabbdom的模块\n\n类似于插件机制\n\nimport { init, h } from 'snabbdom'\n// 1. 导入模块\nimport style from 'snabbdom/modules/style'\nimport eventlisteners from 'snabbdom/modules/eventlisteners'\n// 2. 注册模块\nlet patch = init([\n  style,\n  eventlisteners\n])\n// 3. 使用 h() 函数的第二个参数传入模块需要的数据（对象）\nlet vnode = h('div', {\n  style: {\n    backgroundColor: 'red'\n  },\n  on: {\n    click: eventHandler\n  }\n}, [\n  h('h1', 'Hello Snabbdom'),\n  h('p', '这是p标签')\n])\n\nfunction eventHandler () {\n  console.log('点击我了')\n}\n\nlet app = document.querySelector('#app')\n\nlet oldVnode = patch(app, vnode)\n\n\n\n# 源码解读\n\n源码地址：https://github.com/snabbdom/snabbdom\n\n\n# h函数：\n\n * h 函数主要根据传进来的参数，返回一个 vnode 对象\n\n// h函数的重载，TS支持\nexport function h (sel: string): VNode\nexport function h (sel: string, data: VNodeData | null): VNode\nexport function h (sel: string, children: VNodeChildren): VNode\nexport function h (sel: string, data: VNodeData | null, children: VNodeChildren): VNode\nexport function h (sel: any, b?: any, c?: any): VNode {\n  var data: VNodeData = {}, children: any, text: any, i: number\n  // 处理参数，实现重载的机制\n  if (c !== undefined) {\n    // 处理三个参数的情况\n    // ...\n  // 处理两个参数的情况\n  } else if (b !== undefined && b !== null) {\n\t// ...\n  }\n  if (children !== undefined) {\n    // 处理 children 中的原始值（string/number）\n    for (i = 0; i < children.length; ++i) {\n      // 如果 child 是 string/number，创建文本节点\n    }\n  }\n  // 如果是 svg ，创建命名空间\n  if (\n    sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n    (sel.length === 3 || sel[3] === '.' || sel[3] === '#')\n  ) {\n    addNS(data, children, sel)\n  }\n  // 返回vnode\n  return vnode(sel, data, children, text, undefined)\n};\n\n\n\n# VNode对象\n\n * 一个 VNode 就是一个虚拟节点用来描述一个 DOM 元素，如果这个 VNode 有 children 就是Virtual DOM\n\n * 源码位置：src/vnode.ts\n\nexport type Key = string | number\n\n// 接口\nexport interface VNode {\n  // 选择器  \n  sel: string | undefined\n  // 节点数据：属性/样式/事件等\n  data: VNodeData | undefined\n  // 子节点\n  children: Array<VNode | string> | undefined\n  // 记录 vnode 对应的真实 DOM\n  elm: Node | undefined\n  // 节点中的内容，和 children 只能互斥\n  text: string | undefined\n  key: Key | undefined\n}\n\n// 实现接口\nexport function vnode (sel: string | undefined,\n  data: any | undefined,\n  children: Array<VNode | string> | undefined,\n  text: string | undefined,\n  elm: Element | Text | undefined): VNode {\n  const key = data === undefined ? undefined : data.key\n  // 使用js对象描述DOM\n  return { sel, data, children, text, elm, key }\n}\n\n\n\n# patch过程\n\n * patch(oldVnode, newVnode)\n * 打补丁，把新节点中变化的内容渲染到真实DOM，最后返回新节点作为下一次处理的旧节点\n * 对比新旧 VNode 是否相同节点（节点的 key 和 sel 相同）\n * 如果不是相同节点，删除之前的内容，重新渲染\n * 如果是相同节点，再判断新的 VNode 是否有 text，如果有并且和旧节点 text 不同，直接更新\n * 如果新的 VNode 有 children，判断子节点是否有变化，判断子节点的过程使用的就是 diff 算法\n * diff 过程只进行同层级比较\n\n\n# init函数\n\n * 功能: init(modules, domApi)，返回 patch() 函数（高阶函数）\n\n * 为什么要使用高阶函数？\n   \n   * 因为 patch() 函数在外部会调用多次，每次调用依赖一些参数，比如：modules/domApi/cbs\n   \n   * 通过高阶函数让 init() 内部形成闭包，返回的 patch() 可以访问到 modules/domApi/cbs，而不需要重新创建\n\n * init() 在返回 patch() 之前，首先收集了所有模块中的钩子函数存储到 cbs 对象中\n\n * 源码位置：src/snabbdom.ts\n\n// 钩子函数\nconst hooks: (keyof Module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\n// 第一个参数是模块，参考上面模块使用的部分\nexport function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) { \n    let i: number, j: number, cbs = ({} as ModuleHooks); \n    // 初始化 api ，htmlDomApi里是一些原生 DOM api，用于创建真实 DOM\n    // 如果想把虚拟 DOM 转化为其他类型时，可以传入第二个参数\n    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi; \n    // 把传入的所有模块的钩子方法，统一存储到 cbs 对象中 \n    // 最终构建的 cbs 对象的形式 cbs = [ create: [fn1, fn2], update: [], ... ] \n    for (i = 0; i < hooks.length; ++i) { \n        // cbs['create'] = [] \n        cbs[hooks[i]] = []; \n        for (j = 0; j < modules.length; ++j) { \n         \t// const hook = modules[0]['create'] \n            // 每一个模块都会导出钩子函数的方法，例如 attributes.ts 中导出\n            // export const attributesModule: Module = \n            // { create: updateAttrs, update: updateAttrs }\n            const hook = modules[j][hooks[i]]; \n            if (hook !== undefined) { \n                (cbs[hooks[i]] as Array<any>).push(hook);\n            } \n        } \n    }\n    …\n    return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {}\n}\n\n\n\n# patch函数\n\n * 功能：\n   \n   * 传入新旧 VNode，对比差异，把差异渲染到 DOM\n   * 返回新的 VNode，作为下一次 patch() 的 oldVnode\n\n * 执行过程：\n   \n   * vnode 不存在，但是 oldVnode 存在，说明是需要销毁旧节点\n   * vnode 存在，但是 oldVnode 不存在，说明是需要创建新节点\n   * 如果 oldVnode 和 vnode 都存在且是相同节点时\n     * 调用 patchVnode()，找节点的差异并更新 DOM\n   * 如果 oldVnode 和 vnode 都存在且是不同节点时\n     * 根据 vnode 创建一个真实的 DOM 节点，删除老节点，增加新节点\n\n// vnode 不存在，但是 oldVnode 存在，说明是需要销毁旧节点\nif (isUndef(vnode)) {\n  if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n  return\n}\n\n// vnode 存在，但是 oldVnode 不存在，说明是需要创建新节点\nif (isUndef(oldVnode)) {\n  isInitialPatch = true\n  createElm(vnode, insertedVnodeQueue)\n}\n\n// 如果新旧节点是相同节点\nif (sameVnode(oldVnode, vnode)) { \n  // 找节点的差异并更新 DOM \n  patchVnode(oldVnode, vnode, insertedVnodeQueue); \n} else { \n  // 如果新旧节点不同，vnode 创建对应的 DOM \n  // 获取当前的 DOM 元素 \n  elm = oldVnode.elm!; \n  parent = api.parentNode(elm); \n  // createElm 是为 VNode 创建真实的 DOM \n  createElm(vnode, insertedVnodeQueue); \n  if (parent !== null) { \n    // 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中 \n    api.insertBefore(parent, vnode.elm!, api.nextSibling(elm)); \n    // 移除老节点 \n    removeVnodes(parent, [oldVnode], 0, 0);\n  } \n}\nreturn vnode\n\n// 当可以比较时，调用 patchVnode 找差异并更新 DOM\n// 当不值得比较时，新节点直接把老节点整个替换了\n// 最后会返回 VNode，可以继续进行下一个 patch 过程\n\n// sameVnode 判断了 key、 tag、 isComment（是否为注释节点）\nfunction sameVnode(a, b) {\n  return (\n    a.key === b.key &&\n    a.asyncFactory === b.asyncFactory &&\n    ((a.tag === b.tag &&\n      a.isComment === b.isComment &&\n      isDef(a.data) === isDef(b.data) &&\n      sameInputType(a, b)) ||\n      (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error)))\n  )\n}\n\n\n\n# patchVnode函数\n\n * 功能：\n   \n   * patchVnode(oldVnode, vnode, insertedVnodeQueue)\n   * 对比 oldVnode 和 vnode 的差异，把差异渲染到 DOM\n\n * 执行过程：\n   \n   * if(oldVnode === vnode)则没有变化\n   * if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用Node.textContent = vnode.text。\n   * if(oldVnode.children && vnode.children), 两个节点都有子节点，而且它们不一样，这样我们会调用updateChildren函数比较子节点，这是diff的核心。\n   * 如果 vnode.children 有值， oldVnode.children 无值\n     * 清空 DOM 元素\n     * 调用 addVnodes() ，批量添加子节点\n   * 如果 oldVnode.children 有值， vnode.children 无值\n     * 调用 removeVnodes() ，批量移除子节点\n\n\n# updateChildren\n\n * 功能：\n   \n   * diff 算法的核心，对比新旧节点的 children，更新 DOM\n\n * 执行过程：\n   \n   * 此外可参考：https://juejin.im/post/6844903607913938951\n   * 在对开始和结束节点比较的时候，总共有四种情况\n     * oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)\n     * oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)\n     * oldStartVnode / oldEndVnode (旧开始节点 / 新结束节点)\n     * oldEndVnode / newStartVnode (旧结束节点 / 新开始节点)\n\n\n\n * 开始节点和结束节点比较，这两种情况类似\n   \n   * oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)\n   * oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)\n\n * 如果 oldStartVnode 和 newStartVnode 是 sameVnode\n   \n   * 调用 patchVnode() 对比和更新节点\n   * 把旧开始和新开始索引往后移动 oldStartIdx++ / oldEndIdx++\n\n----------------------------------------\n\n\n\n * oldStartVnode / newEndVnode (旧开始节点 / 新结束节点) 相同\n   * 调用 patchVnode() 对比和更新节点\n   * 把 oldStartVnode 对应的 DOM 元素，移动到右边\n     * 更新索引\n\n----------------------------------------\n\n\n\n * oldEndVnode / newStartVnode (旧结束节点 / 新开始节点) 相同\n   * 调用 patchVnode() 对比和更新节点\n   * 把 oldEndVnode 对应的 DOM 元素，移动到左边\n     * 更新索引\n\n----------------------------------------\n\n * 如果不是以上四种情况\n   * 遍历新节点，使用 newStartNode 的 key 在老节点数组中找相同节点\n   * 如果没有找到，说明 newStartNode 是新节点\n     * 创建新节点对应的 DOM 元素，插入到 DOM 树中\n   * 如果找到了\n     * 判断新节点和找到的老节点是否 sameVnode\n     * 如果不相同，说明节点被修改了，重新创建对应的 DOM 元素，插入到 DOM 树中\n     * 如果相同，把 elmToMove 对应的 DOM 元素，移动到左边\n\n----------------------------------------\n\n * 当老节点的所有子节点先遍历完 (oldStartIdx > oldEndIdx)，循环结束\n   * 说明新节点有剩余，把剩余节点批量插入到右边\n\n\n\n * 新节点的所有子节点先遍历完 (newStartIdx > newEndIdx)，循环结束\n   * 说明老节点有剩余，把剩余节点批量删除\n\n\n\n\n# 关于 V-for 带 key\n\n参考：https://juejin.im/post/6844903577215827982\n\n官方：https://cn.vuejs.org/v2/api/#key\n\n除了上述所说，更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1),源码如下:\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  let i, key;\n  const map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n  return map;\n}\n\n\n\n# 场景：list 三条数据删除中间的那条\n\n# index作为key，错误的删除了第三条\n\n> 至于为什么，根据 diff 算法，首先生成旧节点和新节点的虚拟 dom , 根据 key 判断是否为相同节点，再去更新内部内容，此时以 index 作为 key，算法会认为前两条key是相同的，即相同的节点，就不去更新内部了，造成的结果就是实际第二条没删除，而是删除了第三条\n\n之前的数据                         之后的数据\n\nkey: 0  index: 0 name: test1     key: 0  index: 0 name: test1\nkey: 1  index: 1 name: test2     key: 1  index: 1 name: test2\nkey: 2  index: 2 name: test3     \n\n\n# id作为key\n\n之前的数据                              删除之后的数据\n\nkey: 1  id: 1 index: 0 name: test1     key: 1  id: 1 index: 0  name: test1\nkey: 2  id: 2 index: 1 name: test2     key: 3  id: 3 index: 3  name: test3\nkey: 3  id: 3 index: 2 name: test3     \n\n\n再比如中间插入的时候，如果使用index作为key会造成复用\n\n\n# vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快\n\nhttps://juejin.cn/post/6878892606307172365\n\n 1. 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；\n 2. 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n 3. 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）\n\n\n# React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？\n\n原来的 O(n^3) 的 diff 流程是：\n\n老树的每一个节点都去遍历新树的节点，直到找到新树对应的节点。那么这个流程就是 O(n^2)，再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 O(n^3)\n\n所以前端框架的 diff 约定了两种处理原则：只做同层的对比，type 变了就不再对比子节点。 因为 dom 节点做跨层级移动的情况还是比较少的，一般情况下都是同一层级的 dom 的增删改。 这样只要遍历一遍，对比一下 type 就行了，是 O(n) 的复杂度，而且 type 变了就不再对比子节点，能省下一大片节点的遍历。",normalizedContent:"# virtual dom 与 diff 算法\n\n * 什么是虚拟dom\n * 使用 snabbdom\n * 源码解读\n   * h函数\n   * vnode对象\n   * init函数\n * diff 算法\n * v-for 带 key\n * vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快\n * react 和 vue 的 diff 时间复杂度从 o(n^3) 优化到 o(n) ，那么 o(n^3) 和 o(n) 是如何计算出来的？\n\n\n# 什么是虚拟dom\n\n * 虚拟dom是由普通的 js 对象来描述 dom 对象，因为不是真实的 dom 对象，所以叫虚拟 dom\n\n * 创建虚拟 dom 的开销比真实 dom 小很多\n\n * 虚拟 dom 的好处是当状态改变时不需要立即更新 dom，只需要一个虚拟树来描述 dom，虚拟dom内部将弄清楚如何有效（diff）的更新 dom\n\n * 如果每次更改应用程序状态都重新创建整个 dom，则程序非常缓慢，而虚拟dom可以跟踪上一次的状态\n\n * 除了渲染 dom 以外,还可以实现 ssr(nuxt.js/next.js),原生应用(weex/react native),小程序(mpvue/uni-app)\n\n * 关于服务端渲染（ssr）可查看：\n   \n   * https://www.jianshu.com/p/b8cfa496b7ec\n   * https://blog.csdn.net/github_34708151/article/details/98344114\n\n\n# virtual dom 库\n\n * snabbdom\n   * vue 2.x 内部使用的 virtual dom 就是改造的 snabbom\n   * 大约 200 sloc（single line of code）\n   * 通过模块可扩展\n   * 源码使用 ts 开发\n   * 最快的 virtual dom 之一\n\n\n# 使用 snabbdom\n\n * 可以使用parcel构建工具，比较轻便\n\nyarn add snabbdom\n\n\n * snabbdom 官网 demo 中导入使用的是 common.js 模块化语法，我们使用 es modules 语法 import\n\nrequire snabbdom from 'snabbdom' // 导入所有函数\nimport { init, h, thunk } from 'snabbdom'\n\n// 不使用 import snabbdom from 'snabbdom' 是因为\n// snabbdom.ts 末尾导出使用的语法是 export 导出，而没有使用 export default\n\n\n * init 是一个高阶函数，返回 patch()\n * h()返回虚拟结点 vnode，这个函数在vue.js中见过\n\nnew vue({\n    router,\n    store,\n    render: h => h(app)\n}).$mount('#app')\n\n\n * thunk()是一种优化策略，可以在处理不可变数据时使用\n\n\n# 如何使用\n\n// div中放置子元素 h1,p\nimport { h, init } from 'snabbdom'\n\n// patch函数，作用对比两个vnode的差异更新到真实dom\nlet patch = init([])\n\n// 第一个参数：标签+选择器\n// 第二个参数：如果是字符串的话就是标签中的内容\nlet vnode = h('div#container', [\n  h('h1', 'hello snabbdom'),\n  h('p', '这是一个p标签')\n])\n\nlet app = document.queryselector('#app')\n\nlet oldvnode = patch(app, vnode)\n\n// 两秒之后继续更新\nsettimeout(() => {\n  vnode = h('div#container', [\n    h('h1', 'hello world'),\n    h('p', 'hello p')\n  ])\n  patch(oldvnode, vnode)\n\n  // 清空页面元素 -- 错误\n  // patch(oldvnode, null)\n  // patch(oldvnode, h('!'))\n}, 2000);\n\n\n\n# snabbdom的模块\n\n类似于插件机制\n\nimport { init, h } from 'snabbdom'\n// 1. 导入模块\nimport style from 'snabbdom/modules/style'\nimport eventlisteners from 'snabbdom/modules/eventlisteners'\n// 2. 注册模块\nlet patch = init([\n  style,\n  eventlisteners\n])\n// 3. 使用 h() 函数的第二个参数传入模块需要的数据（对象）\nlet vnode = h('div', {\n  style: {\n    backgroundcolor: 'red'\n  },\n  on: {\n    click: eventhandler\n  }\n}, [\n  h('h1', 'hello snabbdom'),\n  h('p', '这是p标签')\n])\n\nfunction eventhandler () {\n  console.log('点击我了')\n}\n\nlet app = document.queryselector('#app')\n\nlet oldvnode = patch(app, vnode)\n\n\n\n# 源码解读\n\n源码地址：https://github.com/snabbdom/snabbdom\n\n\n# h函数：\n\n * h 函数主要根据传进来的参数，返回一个 vnode 对象\n\n// h函数的重载，ts支持\nexport function h (sel: string): vnode\nexport function h (sel: string, data: vnodedata | null): vnode\nexport function h (sel: string, children: vnodechildren): vnode\nexport function h (sel: string, data: vnodedata | null, children: vnodechildren): vnode\nexport function h (sel: any, b?: any, c?: any): vnode {\n  var data: vnodedata = {}, children: any, text: any, i: number\n  // 处理参数，实现重载的机制\n  if (c !== undefined) {\n    // 处理三个参数的情况\n    // ...\n  // 处理两个参数的情况\n  } else if (b !== undefined && b !== null) {\n\t// ...\n  }\n  if (children !== undefined) {\n    // 处理 children 中的原始值（string/number）\n    for (i = 0; i < children.length; ++i) {\n      // 如果 child 是 string/number，创建文本节点\n    }\n  }\n  // 如果是 svg ，创建命名空间\n  if (\n    sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n    (sel.length === 3 || sel[3] === '.' || sel[3] === '#')\n  ) {\n    addns(data, children, sel)\n  }\n  // 返回vnode\n  return vnode(sel, data, children, text, undefined)\n};\n\n\n\n# vnode对象\n\n * 一个 vnode 就是一个虚拟节点用来描述一个 dom 元素，如果这个 vnode 有 children 就是virtual dom\n\n * 源码位置：src/vnode.ts\n\nexport type key = string | number\n\n// 接口\nexport interface vnode {\n  // 选择器  \n  sel: string | undefined\n  // 节点数据：属性/样式/事件等\n  data: vnodedata | undefined\n  // 子节点\n  children: array<vnode | string> | undefined\n  // 记录 vnode 对应的真实 dom\n  elm: node | undefined\n  // 节点中的内容，和 children 只能互斥\n  text: string | undefined\n  key: key | undefined\n}\n\n// 实现接口\nexport function vnode (sel: string | undefined,\n  data: any | undefined,\n  children: array<vnode | string> | undefined,\n  text: string | undefined,\n  elm: element | text | undefined): vnode {\n  const key = data === undefined ? undefined : data.key\n  // 使用js对象描述dom\n  return { sel, data, children, text, elm, key }\n}\n\n\n\n# patch过程\n\n * patch(oldvnode, newvnode)\n * 打补丁，把新节点中变化的内容渲染到真实dom，最后返回新节点作为下一次处理的旧节点\n * 对比新旧 vnode 是否相同节点（节点的 key 和 sel 相同）\n * 如果不是相同节点，删除之前的内容，重新渲染\n * 如果是相同节点，再判断新的 vnode 是否有 text，如果有并且和旧节点 text 不同，直接更新\n * 如果新的 vnode 有 children，判断子节点是否有变化，判断子节点的过程使用的就是 diff 算法\n * diff 过程只进行同层级比较\n\n\n# init函数\n\n * 功能: init(modules, domapi)，返回 patch() 函数（高阶函数）\n\n * 为什么要使用高阶函数？\n   \n   * 因为 patch() 函数在外部会调用多次，每次调用依赖一些参数，比如：modules/domapi/cbs\n   \n   * 通过高阶函数让 init() 内部形成闭包，返回的 patch() 可以访问到 modules/domapi/cbs，而不需要重新创建\n\n * init() 在返回 patch() 之前，首先收集了所有模块中的钩子函数存储到 cbs 对象中\n\n * 源码位置：src/snabbdom.ts\n\n// 钩子函数\nconst hooks: (keyof module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\n// 第一个参数是模块，参考上面模块使用的部分\nexport function init(modules: array<partial<module>>, domapi?: domapi) { \n    let i: number, j: number, cbs = ({} as modulehooks); \n    // 初始化 api ，htmldomapi里是一些原生 dom api，用于创建真实 dom\n    // 如果想把虚拟 dom 转化为其他类型时，可以传入第二个参数\n    const api: domapi = domapi !== undefined ? domapi : htmldomapi; \n    // 把传入的所有模块的钩子方法，统一存储到 cbs 对象中 \n    // 最终构建的 cbs 对象的形式 cbs = [ create: [fn1, fn2], update: [], ... ] \n    for (i = 0; i < hooks.length; ++i) { \n        // cbs['create'] = [] \n        cbs[hooks[i]] = []; \n        for (j = 0; j < modules.length; ++j) { \n         \t// const hook = modules[0]['create'] \n            // 每一个模块都会导出钩子函数的方法，例如 attributes.ts 中导出\n            // export const attributesmodule: module = \n            // { create: updateattrs, update: updateattrs }\n            const hook = modules[j][hooks[i]]; \n            if (hook !== undefined) { \n                (cbs[hooks[i]] as array<any>).push(hook);\n            } \n        } \n    }\n    …\n    return function patch(oldvnode: vnode | element, vnode: vnode): vnode {}\n}\n\n\n\n# patch函数\n\n * 功能：\n   \n   * 传入新旧 vnode，对比差异，把差异渲染到 dom\n   * 返回新的 vnode，作为下一次 patch() 的 oldvnode\n\n * 执行过程：\n   \n   * vnode 不存在，但是 oldvnode 存在，说明是需要销毁旧节点\n   * vnode 存在，但是 oldvnode 不存在，说明是需要创建新节点\n   * 如果 oldvnode 和 vnode 都存在且是相同节点时\n     * 调用 patchvnode()，找节点的差异并更新 dom\n   * 如果 oldvnode 和 vnode 都存在且是不同节点时\n     * 根据 vnode 创建一个真实的 dom 节点，删除老节点，增加新节点\n\n// vnode 不存在，但是 oldvnode 存在，说明是需要销毁旧节点\nif (isundef(vnode)) {\n  if (isdef(oldvnode)) invokedestroyhook(oldvnode)\n  return\n}\n\n// vnode 存在，但是 oldvnode 不存在，说明是需要创建新节点\nif (isundef(oldvnode)) {\n  isinitialpatch = true\n  createelm(vnode, insertedvnodequeue)\n}\n\n// 如果新旧节点是相同节点\nif (samevnode(oldvnode, vnode)) { \n  // 找节点的差异并更新 dom \n  patchvnode(oldvnode, vnode, insertedvnodequeue); \n} else { \n  // 如果新旧节点不同，vnode 创建对应的 dom \n  // 获取当前的 dom 元素 \n  elm = oldvnode.elm!; \n  parent = api.parentnode(elm); \n  // createelm 是为 vnode 创建真实的 dom \n  createelm(vnode, insertedvnodequeue); \n  if (parent !== null) { \n    // 如果父节点不为空，把 vnode 对应的 dom 插入到文档中 \n    api.insertbefore(parent, vnode.elm!, api.nextsibling(elm)); \n    // 移除老节点 \n    removevnodes(parent, [oldvnode], 0, 0);\n  } \n}\nreturn vnode\n\n// 当可以比较时，调用 patchvnode 找差异并更新 dom\n// 当不值得比较时，新节点直接把老节点整个替换了\n// 最后会返回 vnode，可以继续进行下一个 patch 过程\n\n// samevnode 判断了 key、 tag、 iscomment（是否为注释节点）\nfunction samevnode(a, b) {\n  return (\n    a.key === b.key &&\n    a.asyncfactory === b.asyncfactory &&\n    ((a.tag === b.tag &&\n      a.iscomment === b.iscomment &&\n      isdef(a.data) === isdef(b.data) &&\n      sameinputtype(a, b)) ||\n      (istrue(a.isasyncplaceholder) && isundef(b.asyncfactory.error)))\n  )\n}\n\n\n\n# patchvnode函数\n\n * 功能：\n   \n   * patchvnode(oldvnode, vnode, insertedvnodequeue)\n   * 对比 oldvnode 和 vnode 的差异，把差异渲染到 dom\n\n * 执行过程：\n   \n   * if(oldvnode === vnode)则没有变化\n   * if(oldvnode.text !== null && vnode.text !== null && oldvnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用node.textcontent = vnode.text。\n   * if(oldvnode.children && vnode.children), 两个节点都有子节点，而且它们不一样，这样我们会调用updatechildren函数比较子节点，这是diff的核心。\n   * 如果 vnode.children 有值， oldvnode.children 无值\n     * 清空 dom 元素\n     * 调用 addvnodes() ，批量添加子节点\n   * 如果 oldvnode.children 有值， vnode.children 无值\n     * 调用 removevnodes() ，批量移除子节点\n\n\n# updatechildren\n\n * 功能：\n   \n   * diff 算法的核心，对比新旧节点的 children，更新 dom\n\n * 执行过程：\n   \n   * 此外可参考：https://juejin.im/post/6844903607913938951\n   * 在对开始和结束节点比较的时候，总共有四种情况\n     * oldstartvnode / newstartvnode (旧开始节点 / 新开始节点)\n     * oldendvnode / newendvnode (旧结束节点 / 新结束节点)\n     * oldstartvnode / oldendvnode (旧开始节点 / 新结束节点)\n     * oldendvnode / newstartvnode (旧结束节点 / 新开始节点)\n\n\n\n * 开始节点和结束节点比较，这两种情况类似\n   \n   * oldstartvnode / newstartvnode (旧开始节点 / 新开始节点)\n   * oldendvnode / newendvnode (旧结束节点 / 新结束节点)\n\n * 如果 oldstartvnode 和 newstartvnode 是 samevnode\n   \n   * 调用 patchvnode() 对比和更新节点\n   * 把旧开始和新开始索引往后移动 oldstartidx++ / oldendidx++\n\n----------------------------------------\n\n\n\n * oldstartvnode / newendvnode (旧开始节点 / 新结束节点) 相同\n   * 调用 patchvnode() 对比和更新节点\n   * 把 oldstartvnode 对应的 dom 元素，移动到右边\n     * 更新索引\n\n----------------------------------------\n\n\n\n * oldendvnode / newstartvnode (旧结束节点 / 新开始节点) 相同\n   * 调用 patchvnode() 对比和更新节点\n   * 把 oldendvnode 对应的 dom 元素，移动到左边\n     * 更新索引\n\n----------------------------------------\n\n * 如果不是以上四种情况\n   * 遍历新节点，使用 newstartnode 的 key 在老节点数组中找相同节点\n   * 如果没有找到，说明 newstartnode 是新节点\n     * 创建新节点对应的 dom 元素，插入到 dom 树中\n   * 如果找到了\n     * 判断新节点和找到的老节点是否 samevnode\n     * 如果不相同，说明节点被修改了，重新创建对应的 dom 元素，插入到 dom 树中\n     * 如果相同，把 elmtomove 对应的 dom 元素，移动到左边\n\n----------------------------------------\n\n * 当老节点的所有子节点先遍历完 (oldstartidx > oldendidx)，循环结束\n   * 说明新节点有剩余，把剩余节点批量插入到右边\n\n\n\n * 新节点的所有子节点先遍历完 (newstartidx > newendidx)，循环结束\n   * 说明老节点有剩余，把剩余节点批量删除\n\n\n\n\n# 关于 v-for 带 key\n\n参考：https://juejin.im/post/6844903577215827982\n\n官方：https://cn.vuejs.org/v2/api/#key\n\n除了上述所说，更快速 : key 的唯一性可以被 map 数据结构充分利用,相比于遍历查找的时间复杂度 o(n),map 的时间复杂度仅仅为 o(1),源码如下:\n\nfunction createkeytooldidx(children, beginidx, endidx) {\n  let i, key;\n  const map = {};\n  for (i = beginidx; i <= endidx; ++i) {\n    key = children[i].key;\n    if (isdef(key)) map[key] = i;\n  }\n  return map;\n}\n\n\n\n# 场景：list 三条数据删除中间的那条\n\n# index作为key，错误的删除了第三条\n\n> 至于为什么，根据 diff 算法，首先生成旧节点和新节点的虚拟 dom , 根据 key 判断是否为相同节点，再去更新内部内容，此时以 index 作为 key，算法会认为前两条key是相同的，即相同的节点，就不去更新内部了，造成的结果就是实际第二条没删除，而是删除了第三条\n\n之前的数据                         之后的数据\n\nkey: 0  index: 0 name: test1     key: 0  index: 0 name: test1\nkey: 1  index: 1 name: test2     key: 1  index: 1 name: test2\nkey: 2  index: 2 name: test3     \n\n\n# id作为key\n\n之前的数据                              删除之后的数据\n\nkey: 1  id: 1 index: 0 name: test1     key: 1  id: 1 index: 0  name: test1\nkey: 2  id: 2 index: 1 name: test2     key: 3  id: 3 index: 3  name: test3\nkey: 3  id: 3 index: 2 name: test3     \n\n\n再比如中间插入的时候，如果使用index作为key会造成复用\n\n\n# vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快\n\nhttps://juejin.cn/post/6878892606307172365\n\n 1. 虚拟dom在比较时只比较同一层级节点，复杂度都为 o(n)，降低了算法复杂度；\n 2. 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n 3. 都是操作虚拟dom，最小化操作真实dom，提高性能（其实虚拟dom的优势 并不是在于它操作dom快）\n\n\n# react 和 vue 的 diff 时间复杂度从 o(n^3) 优化到 o(n) ，那么 o(n^3) 和 o(n) 是如何计算出来的？\n\n原来的 o(n^3) 的 diff 流程是：\n\n老树的每一个节点都去遍历新树的节点，直到找到新树对应的节点。那么这个流程就是 o(n^2)，再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 o(n^3)\n\n所以前端框架的 diff 约定了两种处理原则：只做同层的对比，type 变了就不再对比子节点。 因为 dom 节点做跨层级移动的情况还是比较少的，一般情况下都是同一层级的 dom 的增删改。 这样只要遍历一遍，对比一下 type 就行了，是 o(n) 的复杂度，而且 type 变了就不再对比子节点，能省下一大片节点的遍历。",charsets:{cjk:!0}},{title:"Vue组件通信的方式",frontmatter:{},regularPath:"/vue/communication.html",relativePath:"vue/communication.md",key:"v-2df2cd1f",path:"/vue/communication.html",headers:[{level:2,title:"$root",slug:"root",normalizedTitle:"$root",charIndex:17},{level:2,title:"$parent/$children",slug:"parent-children",normalizedTitle:"$parent/$children",charIndex:384},{level:2,title:"$refs",slug:"refs",normalizedTitle:"$refs",charIndex:48},{level:2,title:"provide/inject",slug:"provide-inject",normalizedTitle:"provide/inject",charIndex:1845},{level:2,title:"$attrs / $listeners",slug:"attrs-listeners",normalizedTitle:"$attrs / $listeners",charIndex:77},{level:2,title:"props / $emit",slug:"props-emit",normalizedTitle:"props / $emit",charIndex:100},{level:2,title:"vuex",slug:"vuex",normalizedTitle:"vuex",charIndex:117},{level:2,title:"event bus",slug:"event-bus",normalizedTitle:"event bus",charIndex:3899},{level:2,title:"v-model",slug:"v-model",normalizedTitle:"v-model",charIndex:137}],lastUpdated:"6/25/2025, 8:09:31 PM",lastUpdatedTimestamp:1750853371e3,headersStr:"$root $parent/$children $refs provide/inject $attrs / $listeners props / $emit vuex event bus v-model",content:"# Vue组件通信的方式\n\n * $root / $parent / $children\n * $refs\n * provide / inject\n * $attrs / $listeners\n * props / $emit\n * vuex\n * EventBus\n * v-model\n\n\n# $root\n\n<template>\n  <div>\n    \x3c!--\n      小型应用中可以在 vue 根实例里存储共享数据\n      组件中可以通过 $root 访问根实例\n    --\x3e\n    $root.title：{{ $root.title }}\n    <br>\n    <button @click=\"$root.title = 'Hello $root'\">改变 title</button>\n  </div>\n</template>\n\n\n\n# $parent/$children\n\n指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。\n\n节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信\n\n\x3c!-- parent.vue --\x3e\n<template>\n  <div class=\"parent\">\n    parent\n    <child></child>\n  </div>\n</template>\n\n<script>\nexport default {\n  components: {\n    child\n  },\n  data () {\n    return {\n      title: '获取父组件实例'\n    }\n  },\n  methods: {\n    handle () {\n      console.log(this.title)\n    }\n  }\n}\n<\/script>\n\n\x3c!-- children.vue --\x3e\n<template>\n  <div class=\"child\">\n    child<br>\n    $parent.title：{{ $parent.title }}<br>\n    <button @click=\"$parent.handle\">获取 $parent.title</button>\n    <button @click=\"$parent.title = 'Hello $parent.title'\">改变 $parent.title</button>\n  \n    <grandson></grandson>\n  </div>\n</template>\n\n\n\n# $refs\n\n\x3c!-- parent.vue --\x3e\n<template>\n  <div>\n    <myinput ref=\"mytxt\"></myinput>\n    <button @click=\"focus\">获取焦点</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  components: {\n    myinput\n  },\n  methods: {\n    focus () {\n      this.$refs.mytxt.focus() // 调用的是子组件的 focus 方法\n      this.$refs.mytxt.value = 'hello'\n    }\n  }\n}\n<\/script>\n\n\x3c!-- myinput.vue --\x3e\n<template>\n  <div>\n    <input v-model=\"value\" type=\"text\" ref=\"txt\">\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      value: 'default'\n    }\n  },\n  methods: {\n    focus () {\n      this.$refs.txt.focus() // this.$refs.txt 获取 DOM 对象，focus 方法获取焦点\n    }\n  }\n}\n<\/script>\n\n\n\n# provide/inject\n\n> provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。\n\n这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。\n\n提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。并且在子组件中不可修改\n\n// 父级组件提供 'foo'\nvar Provider = {\n  provide: {\n    foo: 'bar'\n  },\n  // ...\n}\n\n// 子组件注入 'foo'\nvar Child = {\n  inject: ['foo'],\n  created () {\n    console.log(this.foo) // => \"bar\"\n  }\n  // ...\n}\n\n\n\n# $attrs / $listeners\n\n * $attrs ：把父组件中非 prop 属性绑定到内部组件\n * $listeners：把父组件中的 DOM 对象的原生事件绑定到内部组件\n * 可查看文章Vue - 组件通信之$attrs、$listeners\n * 如何理解vue中的native\n\n\n# props / $emit\n\n> 父组件通过props向子组件传递数据，子组件通过$emit触发父组件的方法，从而实现子到父的通信\n\n# 父组件传子组件：通过props\n\n\x3c!--父组件--\x3e\n<template>\n    <div>我是父组件,我的值是{{ msg }}\n        <child :logo=\"msg\"></child>\n    </div>\n</template>\n\n<script>\nimport child from './child'\nexport default {\n  data () {\n    return {\n      msg: '123'\n    }\n  },\n  components: {\n    child\n  }\n}\n<\/script>\n\n\n\x3c!--子组件--\x3e\n<template>\n    <div>\n      <div>我是子组件,这是父组件的值：{{ logo }}</div>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'child',\n  data () {\n    return {\n    }\n  },\n  props: ['logo']\n}\n<\/script>\n\n\x3c!--\n\t我是父组件,我的值是123\n\t我是子组件,这是父组件的值：123\n--\x3e\n\n\n# 子组件传父组件：$emit\n\n * 输入框的onchange事件，要在 input 失去焦点的时候才会触发；\n * oninput 事件在用户输入时触发，它是在元素值发生变化时立即触发；\n\n\x3c!--父组件--\x3e\n<template>\n    <div>\n        <child @transfer=\"get\"></child>\n        <div>我是父组件：这是子组件传来的值：{{ msg }}</div>\n    </div>\n\n</template>\n\n<script>\nimport child from './child'\nexport default {\n  data () {\n    return {\n      msg: ''\n    }\n  },\n  components: {\n    child\n  },\n  methods: {\n    get (msg) {\n      this.msg = msg\n    }\n  }\n}\n<\/script>\n\n\x3c!--子组件--\x3e\n<template>\n    <div>\n        <input type=\"text\" v-model=\"msg\" @input=\"set\">\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'child',\n  data () {\n    return {\n      msg: ''\n    }\n  },\n  methods: {\n    set: function () {\n      this.$emit('transfer', this.msg)\n      console.log(1)\n    }\n  }\n}\n<\/script>\n\n\x3c!--\n    23131 //输入框\n    我是父组件：这是子组件传来的值：23131\n--\x3e\n\n\n\n# vuex\n\nvuex\n\n\n# event bus\n\n一个完整的eventBus主要分为三个部分：eventBus组件、注册事件（$on）、发送事件（$emit）\n\n\n# v-model\n\n父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input',val)自动修改v-model绑定的值\n\nVue.component('child',{\n    props:{\n      value:String, //v-model会自动传递一个字段为value的prop属性\n    },\n    data(){\n      return {\n        mymessage:this.value\n      }\n    },\n    methods:{\n      changeValue(){\n        this.$emit('input',this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值\n      }\n    },\n    template:`\n      <div>\n        <input type=\"text\" v-model=\"mymessage\" @change=\"changeValue\">\n      </div>\n  })\n\n\n  Vue.component('parent',{\n    template:`\n      <div>\n        <p>this is parent compoent!</p>\n        <p>{{message}}</p>\n        <child v-model=\"message\"></child>\n      </div>\n    `,\n    data(){\n      return {\n        message:'hello'\n      }\n    }\n  })\n",normalizedContent:"# vue组件通信的方式\n\n * $root / $parent / $children\n * $refs\n * provide / inject\n * $attrs / $listeners\n * props / $emit\n * vuex\n * eventbus\n * v-model\n\n\n# $root\n\n<template>\n  <div>\n    \x3c!--\n      小型应用中可以在 vue 根实例里存储共享数据\n      组件中可以通过 $root 访问根实例\n    --\x3e\n    $root.title：{{ $root.title }}\n    <br>\n    <button @click=\"$root.title = 'hello $root'\">改变 title</button>\n  </div>\n</template>\n\n\n\n# $parent/$children\n\n指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。\n\n节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信\n\n\x3c!-- parent.vue --\x3e\n<template>\n  <div class=\"parent\">\n    parent\n    <child></child>\n  </div>\n</template>\n\n<script>\nexport default {\n  components: {\n    child\n  },\n  data () {\n    return {\n      title: '获取父组件实例'\n    }\n  },\n  methods: {\n    handle () {\n      console.log(this.title)\n    }\n  }\n}\n<\/script>\n\n\x3c!-- children.vue --\x3e\n<template>\n  <div class=\"child\">\n    child<br>\n    $parent.title：{{ $parent.title }}<br>\n    <button @click=\"$parent.handle\">获取 $parent.title</button>\n    <button @click=\"$parent.title = 'hello $parent.title'\">改变 $parent.title</button>\n  \n    <grandson></grandson>\n  </div>\n</template>\n\n\n\n# $refs\n\n\x3c!-- parent.vue --\x3e\n<template>\n  <div>\n    <myinput ref=\"mytxt\"></myinput>\n    <button @click=\"focus\">获取焦点</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  components: {\n    myinput\n  },\n  methods: {\n    focus () {\n      this.$refs.mytxt.focus() // 调用的是子组件的 focus 方法\n      this.$refs.mytxt.value = 'hello'\n    }\n  }\n}\n<\/script>\n\n\x3c!-- myinput.vue --\x3e\n<template>\n  <div>\n    <input v-model=\"value\" type=\"text\" ref=\"txt\">\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      value: 'default'\n    }\n  },\n  methods: {\n    focus () {\n      this.$refs.txt.focus() // this.$refs.txt 获取 dom 对象，focus 方法获取焦点\n    }\n  }\n}\n<\/script>\n\n\n\n# provide/inject\n\n> provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。\n\n这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 react，这与 react 的上下文特性很相似。\n\n提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。并且在子组件中不可修改\n\n// 父级组件提供 'foo'\nvar provider = {\n  provide: {\n    foo: 'bar'\n  },\n  // ...\n}\n\n// 子组件注入 'foo'\nvar child = {\n  inject: ['foo'],\n  created () {\n    console.log(this.foo) // => \"bar\"\n  }\n  // ...\n}\n\n\n\n# $attrs / $listeners\n\n * $attrs ：把父组件中非 prop 属性绑定到内部组件\n * $listeners：把父组件中的 dom 对象的原生事件绑定到内部组件\n * 可查看文章vue - 组件通信之$attrs、$listeners\n * 如何理解vue中的native\n\n\n# props / $emit\n\n> 父组件通过props向子组件传递数据，子组件通过$emit触发父组件的方法，从而实现子到父的通信\n\n# 父组件传子组件：通过props\n\n\x3c!--父组件--\x3e\n<template>\n    <div>我是父组件,我的值是{{ msg }}\n        <child :logo=\"msg\"></child>\n    </div>\n</template>\n\n<script>\nimport child from './child'\nexport default {\n  data () {\n    return {\n      msg: '123'\n    }\n  },\n  components: {\n    child\n  }\n}\n<\/script>\n\n\n\x3c!--子组件--\x3e\n<template>\n    <div>\n      <div>我是子组件,这是父组件的值：{{ logo }}</div>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'child',\n  data () {\n    return {\n    }\n  },\n  props: ['logo']\n}\n<\/script>\n\n\x3c!--\n\t我是父组件,我的值是123\n\t我是子组件,这是父组件的值：123\n--\x3e\n\n\n# 子组件传父组件：$emit\n\n * 输入框的onchange事件，要在 input 失去焦点的时候才会触发；\n * oninput 事件在用户输入时触发，它是在元素值发生变化时立即触发；\n\n\x3c!--父组件--\x3e\n<template>\n    <div>\n        <child @transfer=\"get\"></child>\n        <div>我是父组件：这是子组件传来的值：{{ msg }}</div>\n    </div>\n\n</template>\n\n<script>\nimport child from './child'\nexport default {\n  data () {\n    return {\n      msg: ''\n    }\n  },\n  components: {\n    child\n  },\n  methods: {\n    get (msg) {\n      this.msg = msg\n    }\n  }\n}\n<\/script>\n\n\x3c!--子组件--\x3e\n<template>\n    <div>\n        <input type=\"text\" v-model=\"msg\" @input=\"set\">\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'child',\n  data () {\n    return {\n      msg: ''\n    }\n  },\n  methods: {\n    set: function () {\n      this.$emit('transfer', this.msg)\n      console.log(1)\n    }\n  }\n}\n<\/script>\n\n\x3c!--\n    23131 //输入框\n    我是父组件：这是子组件传来的值：23131\n--\x3e\n\n\n\n# vuex\n\nvuex\n\n\n# event bus\n\n一个完整的eventbus主要分为三个部分：eventbus组件、注册事件（$on）、发送事件（$emit）\n\n\n# v-model\n\n父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input',val)自动修改v-model绑定的值\n\nvue.component('child',{\n    props:{\n      value:string, //v-model会自动传递一个字段为value的prop属性\n    },\n    data(){\n      return {\n        mymessage:this.value\n      }\n    },\n    methods:{\n      changevalue(){\n        this.$emit('input',this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值\n      }\n    },\n    template:`\n      <div>\n        <input type=\"text\" v-model=\"mymessage\" @change=\"changevalue\">\n      </div>\n  })\n\n\n  vue.component('parent',{\n    template:`\n      <div>\n        <p>this is parent compoent!</p>\n        <p>{{message}}</p>\n        <child v-model=\"message\"></child>\n      </div>\n    `,\n    data(){\n      return {\n        message:'hello'\n      }\n    }\n  })\n",charsets:{cjk:!0}},{title:"TypeScript 基础",frontmatter:{},regularPath:"/ts/ts-base.html",relativePath:"ts/ts-base.md",key:"v-d2732a66",path:"/ts/ts-base.html",headers:[{level:2,title:"语言类型",slug:"语言类型",normalizedTitle:"语言类型",charIndex:61},{level:3,title:"TS是静态类型+弱类型",slug:"ts是静态类型-弱类型",normalizedTitle:"ts是静态类型+弱类型",charIndex:466},{level:2,title:"TypeScript项目",slug:"typescript项目",normalizedTitle:"typescript项目",charIndex:535},{level:3,title:"编译上下文",slug:"编译上下文",normalizedTitle:"编译上下文",charIndex:688},{level:3,title:"声明空间",slug:"声明空间",normalizedTitle:"声明空间",charIndex:989},{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:1241},{level:2,title:"TypeScript类型系统",slug:"typescript类型系统",normalizedTitle:"typescript类型系统",charIndex:1512},{level:3,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:1230},{level:3,title:"原始类型",slug:"原始类型",normalizedTitle:"原始类型",charIndex:1767},{level:3,title:"特殊类型",slug:"特殊类型",normalizedTitle:"特殊类型",charIndex:1990},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2553},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:407},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:3059},{level:3,title:"interface 和 type 的区别",slug:"interface-和-type-的区别",normalizedTitle:"interface 和 type 的区别",charIndex:3610},{level:3,title:"内联类型注解",slug:"内联类型注解",normalizedTitle:"内联类型注解",charIndex:4172},{level:3,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:4528},{level:3,title:"联合类型(|)",slug:"联合类型",normalizedTitle:"联合类型(|)",charIndex:5064},{level:3,title:"交叉类型(&)",slug:"交叉类型",normalizedTitle:"交叉类型(&amp;)",charIndex:null},{level:3,title:"元组类型",slug:"元组类型",normalizedTitle:"元组类型",charIndex:5556},{level:3,title:"类型别名",slug:"类型别名",normalizedTitle:"类型别名",charIndex:5850},{level:3,title:"枚举类型",slug:"枚举类型",normalizedTitle:"枚举类型",charIndex:6070},{level:3,title:"类",slug:"类",normalizedTitle:"类",charIndex:63},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:7808},{level:2,title:"高级类型",slug:"高级类型",normalizedTitle:"高级类型",charIndex:8261},{level:3,title:"partial",slug:"partial",normalizedTitle:"partial",charIndex:8270},{level:3,title:"Record",slug:"record",normalizedTitle:"record",charIndex:8560},{level:3,title:"Pick",slug:"pick",normalizedTitle:"pick",charIndex:9286},{level:3,title:"Omit",slug:"omit",normalizedTitle:"omit",charIndex:9604}],lastUpdated:"6/25/2025, 8:09:31 PM",lastUpdatedTimestamp:1750853371e3,headersStr:"语言类型 TS是静态类型+弱类型 TypeScript项目 编译上下文 声明空间 模块 TypeScript类型系统 类型注解 原始类型 特殊类型 数组 对象 接口 interface 和 type 的区别 内联类型注解 泛型 联合类型(|) 交叉类型(&) 元组类型 类型别名 枚举类型 类 抽象类 高级类型 partial Record Pick Omit",content:"# TypeScript 基础\n\n《官方文档》\n\n《深入理解TypeScript》\n\nTS Platground\n\n\n# 语言类型\n\n强类型：不允许随意的隐式类型转换\n\n弱类型：允许隐式类型转换（1+ '2'）\n\n静态类型：声明过后，它的类型就不允许再修改\n\n动态类型：变量的类型可以随时改变（a=1; a='1'）\n\n> 基于以上，所有编程语言分为四类，JS即是弱类型也是动态类型，例如：\n\nconst obj = {}\nobj.foo()  //这样写没问题，只有等到运行时才会报错\n\n// 如果加了一个时间\nsetTimeout(() => {\n    obj.foo()\n},10000)  // 错误就会保留在代码中\n\n// 又或者\nfunction sum (a, b) {\n    return a + b\n}\nconsole.log(sun(100, '100')) //100100\n\n// 还有对象键会自动转化成字符串\nobj[true] = 100\nconsole.log(obj['true'])\n\n\n\n# TS是静态类型+弱类型\n\n 1. 错误更早暴露\n 2. 代码更智能，编码更准确\n 3. 重构更牢靠\n 4. 减少不必要的类型判断\n\n\n# TypeScript项目\n\nyarn init：初始化package.json\n\nyarn add typescript --dev：安装typescript\n\n新建ts文件demo.ts\n\nyarn tsc demo.ts：编译demo.ts\n\n根目录下出现demo.js，已经自动转化为ES5\n\n\n# 编译上下文\n\n编译上下文算是一个比较花哨的术语，可以用它来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。除了有效文件所携带信息外，编译上下文还包含有正在被使用的编译选项的信息。定义这种逻辑分组，一个比较好的方式是使用 tsconfig.json 文件。\n\nyarn tsc --init：生成tsconfig.json\n\n\"sourceMap\": true, \n\"outDir\": \"dist\",                        \n\"rootDir\": \"src\",  \n\n\n创建src文件夹放ts文件，运行yarn tsc编译整个项目\n\n具体编译选项\n\n\n# 声明空间\n\n在 TypeScript 里存在两种声明空间：类型声明空间与变量声明空间。\n\ninterface Bar {}\nconst bar = Bar; // Error: \"cannot find name 'Bar'\"\n\n// 因为 Bar 定义在类型声明空间中，而未定义在变量声明空间中。\n\n\nconst foo = 123;\nlet bar: foo; // ERROR: \"cannot find name 'foo'\"\n\n// foo 定义在变量声明空间中，不能用作类型注解。\n\n\n\n# 模块\n\n在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如在 foo.ts 里的以下代码可以在 bar.ts 中使用。\n\n// foo.ts\nconst foo = 123;\n\n// bar.ts\nconst bar = foo; // allowed\n\n\n所以需要使用文件模块：\n\n// foo.ts\nexport const foo = 123;\n\n// bar.ts\nimport { foo } from './foo';\nconst bar = foo; // allow\n\n\n\n# TypeScript类型系统\n\n\n# 类型注解\n\n类型注解使用 :TypeAnnotation 语法。在类型声明空间中可用的任何内容都可以用作类型注解。例如：\n\n// 函数声明\nfunction func1 (a: number, b?:number): string {\n    return 'func1'\n}\n\n// 函数表达式\nconst func2: (a: number, b:number) => string = function () {\n    return 'func2'\n}\n\n\n\n# 原始类型\n\nstring、number、boolean\n\nlet num: number;\nlet str: string;\nlet bool: boolean;\n\nnum = 123;\nnum = 123.456;\nnum = '123'; // Error\n\nstr = '123';\nstr = 123; // Error\n\nbool = true;\nbool = false;\nbool = 'false'; // Error\n\n\n\n# 特殊类型\n\nany、 null、 undefined 以及 void\n\n# any\n\nany 类型在 TypeScript 类型系统中占有特殊的地位。它提供给你一个类型系统的「后门」,TypeScript 将会把类型检查关闭。在类型系统里 any 能够兼容所有的类型（包括它自己）。因此，所有类型都能被赋值给它，它也能被赋值给其他任何类型。\n\nlet power: any;\n\n// 赋值任意类型\npower = '123';\npower = 123;\n\n// 它也兼容任何类型\nlet power: any;\nlet num: number;\n\npower = '123'\nnum = power\n\n// 反过来也可\nnum = 123\npower = num\n\n\n# null 和 undefined\n\n默认情况下它们是所有类型的子类型，即可以赋值给任意类型\n\nlet num: number;\nlet str: string;\n\n// 这些类型能被赋予\nnum = null;\nstr = undefined;\n\n\n# void\n\n使用 :void 来表示一个函数没有一个返回值\n\nfunction log(message: string): void {\n  console.log(message);\n}\n\n\n\n# 数组\n\n// 两种写法，常使用第二种\nconst arr1: Array<number> = [1, 2, 3]\nconst arr2: number[] = [1, 2, 3]\n\nlet boolArray: boolean[];\n\nboolArray = [true, false];\nconsole.log(boolArray[0]); // true\nconsole.log(boolArray.length); // 2\n\nboolArray[1] = true;\nboolArray = [false, false];\n\nboolArray[0] = 'false'; // Error\nboolArray = 'false'; // Error\nboolArray = [true, 'false']; // Error\n\n\n\n# 对象\n\n除了 Object之外，函数和数组也属于对象\n\nconst obj: { foo: number } = { foo:123 }\n\nconst foo: object = function () {}\nconst bar: object = []\n\n\n\n# 接口\n\n为什么需要接口？可以看这个例子：\n\nfunction print(obj: { a: string }) {\n  console.log(obj.a);\n}\n\nlet myObj = { a: '10', b: 20 };\nprint(myObj);\n\n\n类型检查器会查看print的调用。 print有一个参数，并要求这个对象参数有一个名为a类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些a是否存在，而没有检查b\n\n接口可以合并众多类型声明至一个类型声明，在这里，我们把类型注解：a: string + b: number 合并到了一个新的类型注解 Obj 里，这样能强制对每个成员进行类型检查。\n\ninterface Obj {\n  a: string;\n  b: number;\n}\n\nlet obj: Obj;\nobj = {\n  a: '10',\n  b: 20\n};\n\n// Error: Property 'b' is missing\nobj = {\n  a: '10'\n};\n\n// Error: Property 'b' is missing\nobj = {\n  a: '10',\n  b: '20'\n};\n\n\n\n# interface 和 type 的区别\n\n在 TypeScript 中，interface 和 type 都可以用来定义类型，但它们有一些区别。以下是它们的主要区别：\n\n 1. 语法和用途：\n    * interface 主要用于定义对象的结构。\n    * type 更灵活，可以用于定义各种类型，包括对象、联合类型、交叉类型等。\n 2. 扩展性：\n    * interface 可以被继承和实现，支持 extends 关键字。\n    * type 不能被继承，但可以使用交叉类型 (&) 来组合类型。\n 3. 声明合并：\n    * interface 支持声明合并，可以多次声明同名接口，它们会自动合并。\n    * type 不支持声明合并，重复声明会报错。\n 4. 计算属性：\n    * type 支持使用 in 关键字创建映射类型。\n    * interface 不支持映射类型。\n 5. 元组和数组：\n    * type 可以更容易地定义元组和复杂的数组类型。\n    * interface 在定义元组和复杂数组类型时相对不够灵活。\n 6. 联合类型和交叉类型：\n    * type 可以直接创建联合类型和交叉类型。\n    * interface 不能直接创建联合类型和交叉类型。\n\n\n# 内联类型注解\n\n内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦（你可能会使用一个很糟糕的名称）。然而，如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias）\n\nlet foo: {\n  first: string;\n  second: string;\n};\n\nfoo = {\n  first: 'John',\n  second: 'Doe'\n};\n\nfoo = {\n  // Error: 'Second is missing'\n  first: 'John'\n};\n\nfoo = {\n  // Error: 'Second is the wrong type'\n  first: 'John',\n  second: 1337\n};\n\n\n\n# 泛型\n\n在计算机科学中，许多算法和数据结构并不会依赖于对象的实际类型。但是，你仍然会想在每个变量里强制提供约束。\n\nfunction createNumberArray (length: number, value: number): number[] {\n    const arr = Array<number>(length).fill(value)\n    return arr\n}\n\nfunction createStringArray (length: number, value: string): string[] {\n    const arr = Array<string>(length).fill(value)\n    return arr\n}\n\n// 泛型解决冗余问题,在函数后面加 <T>\nfunction createArray<T> (length: number, value: T): T[] {\n    const arr = Array<T>(length).fill(value)\n    return arr\n}\nconst res = createArray<string>(3, 'foo')\n\n\n具体例子请看泛型\n\n\n# 联合类型(|)\n\n在 JavaScript 中，你可能希望属性为多种类型之一，如字符串或者数组。它使用 | 作为标记，如 string | number\n\nfunction formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n}\n\n\n\n# 交叉类型(&)\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n\ninterface A {\n  name: string;\n  sex: number;\n}\n\ninterface B {\n  age: number;\n  sex: number;\n}\n\nlet c: A&B = { name: 'xxx', age: 18, sex: 1 }\n\n\n\n# 元组类型\n\n元组可以看作是数组的拓展，它表示已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。\n\nlet nameNumber: [string, number];\n\n// Ok\nnameNumber = ['Jenny', 221345];\n\n// Error\nnameNumber = ['Jenny', '221345'];\n\n// 与解构一起使用\nlet nameNumber: [string, number];\nnameNumber = ['Jenny', 322134];\n\nconst [name, num] = nameNumber;\n\n\n\n# 类型别名\n\nTypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 type SomeName = someValidTypeAnnotation 来创建别名：\n\ntype StrOrNum = string | number;\n\n// 使用\nlet sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // Error\n\n\n\n# 枚举类型\n\n枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。默认情况下，枚举是基于 0 的，也就是说第一个值是 0，后面的值依次递增。\n\n// 例如文章对象\nconst post = {\n    title: 'aaaaa'\n    content: 'abbb',\n    status: 0 // 0, 1, 2 代表不同状态，但是不直观\n}\n\n// 枚举类型\nconst enum PostStatus {\n    Draft = 0,\n    Unpublished = 1,\n    Published = 2\n}\n\nconst post = {\n    title: 'aaaaa',\n    content: 'abbb',\n    status: PostStatus.Draft\n}\n\n\n枚举是基于 0 的，后面的值依次递增。\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;  // 1\n\nenum Color {Red = 1, Green, Blue = 4}\nlet c: Color = Color.Green;  // 2\n\n\n\n# 类\n\nclass Person {\n    public name: string\n    private age: number\n    protected readonly gender: boolean // protected 只允许子类访问   readonly 只读属性\n    \n    constructor (name: string, age: number, gender: boolean) {\n        this.name = name\n        this.age = age\n        this.gender = gender\n    }\n    \n    sayHi (msg: string): void {\n        console.log(this.name, msg)\n    }\n}\n\nclass Student extends Person {\n    constructor (name: string, age: number, gender: boolean) {\n        super(name, age, gender)\n        console.log(gender) // 只有在这里能访问 gender\n    }\n}\n\n\n# 用类实现接口\n\n> 实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\ninterface Eat {\n    eat（food: string): void\n}\ninterface Run {\n    run（distance: number): void\n}\n\nclass Person implements Eat, Run {\n    eat (food: string): void {\n        console.log(`优雅地进餐：${food}`)\n    }\n    \n    run (distance: number): void {\n        console.log(`直立行走：${distance}`)\n    }\n}\n\nclass Animal implements Eat, Run {\n    eat (food: string): void {\n        console.log(`呼噜呼噜地吃：${food}`)\n    }\n    \n    run (distance: number): void {\n        console.log(`爬行：${distance}`)\n    }\n}\n\n\n\n# 抽象类\n\n抽象类作为其他派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节。abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。\n\nabstract class Animal { // 抽象类只能被继承\n    eat (food: string): void {\n        console.log(`呼噜呼噜地吃：${food}`)\n    }\n\n    abstract run (distance: number): void // 抽象方法在子类中必须实现\n}\n\nclass Dog extends Animal {\n    run (distance: number): void { \n         console.log('爬行：' + distance);\n    }\n}\nconst d = new Dog();\nd.eat('food')\nd.run(100)\n\n\n\n# 高级类型\n\n\n# partial\n\n> Partial 形容词，译为 部分的/局部的/不完全的。使一个 interface/class 或 其他 k/v 形式的 类型的每一个属性完全可选。\n\n类型声明：\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n\n示例：\n\ninterface A {\n  id: number;\n  name: string;\n  age: number;\n}\ntype PartialA = Partial<A>;\n\n\n\n\n\n# Record\n\n> Record<K,T>构造具有给定类型T的一组属性K的类型。在将一个类型的属性映射到另一个类型的属性时，Record非常方便。（是一个对象类型）\n\n类型声明：\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n\n示例：\n\ninterface EmployeeType {\n    id: number\n    fullname: string\n    role: string\n}\n \nlet employees: Record<number, EmployeeType> = {\n    0: { id: 1, fullname: \"John Doe\", role: \"Designer\" },\n    1: { id: 2, fullname: \"Ibrahima Fall\", role: \"Developer\" },\n    2: { id: 3, fullname: \"Sara Duckson\", role: \"Developer\" },\n}\n \n// 0: { id: 1, fullname: \"John Doe\", role: \"Designer\" },\n// 1: { id: 2, fullname: \"Ibrahima Fall\", role: \"Developer\" },\n// 2: { id: 3, fullname: \"Sara Duckson\", role: \"Developer\" }\n\n\n\n# Pick\n\n> 从 T 中，选择一组键在并集 K 中的属性。实际就是说在原有的类型 T 上 筛选出想要的全部或极个别的属性和类型。\n\n类型声明：\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\n\n示例：\n\ninterface B {\n  id: number;\n  name: string;\n  age: number;\n}\n\ntype PickB = Pick<B, \"id\" | \"name\">;\n\n\n\n\n\n# Omit\n\n> 作用与Pick相反，Omit是排除一个字段，剩下的所有，\n\ninterface C {\n  id: number;\n  name: string;\n  age: number;\n}\n\ntype OmitC = Omit<C, \"id\">;\n",normalizedContent:"# typescript 基础\n\n《官方文档》\n\n《深入理解typescript》\n\nts platground\n\n\n# 语言类型\n\n强类型：不允许随意的隐式类型转换\n\n弱类型：允许隐式类型转换（1+ '2'）\n\n静态类型：声明过后，它的类型就不允许再修改\n\n动态类型：变量的类型可以随时改变（a=1; a='1'）\n\n> 基于以上，所有编程语言分为四类，js即是弱类型也是动态类型，例如：\n\nconst obj = {}\nobj.foo()  //这样写没问题，只有等到运行时才会报错\n\n// 如果加了一个时间\nsettimeout(() => {\n    obj.foo()\n},10000)  // 错误就会保留在代码中\n\n// 又或者\nfunction sum (a, b) {\n    return a + b\n}\nconsole.log(sun(100, '100')) //100100\n\n// 还有对象键会自动转化成字符串\nobj[true] = 100\nconsole.log(obj['true'])\n\n\n\n# ts是静态类型+弱类型\n\n 1. 错误更早暴露\n 2. 代码更智能，编码更准确\n 3. 重构更牢靠\n 4. 减少不必要的类型判断\n\n\n# typescript项目\n\nyarn init：初始化package.json\n\nyarn add typescript --dev：安装typescript\n\n新建ts文件demo.ts\n\nyarn tsc demo.ts：编译demo.ts\n\n根目录下出现demo.js，已经自动转化为es5\n\n\n# 编译上下文\n\n编译上下文算是一个比较花哨的术语，可以用它来给文件分组，告诉 typescript 哪些文件是有效的，哪些是无效的。除了有效文件所携带信息外，编译上下文还包含有正在被使用的编译选项的信息。定义这种逻辑分组，一个比较好的方式是使用 tsconfig.json 文件。\n\nyarn tsc --init：生成tsconfig.json\n\n\"sourcemap\": true, \n\"outdir\": \"dist\",                        \n\"rootdir\": \"src\",  \n\n\n创建src文件夹放ts文件，运行yarn tsc编译整个项目\n\n具体编译选项\n\n\n# 声明空间\n\n在 typescript 里存在两种声明空间：类型声明空间与变量声明空间。\n\ninterface bar {}\nconst bar = bar; // error: \"cannot find name 'bar'\"\n\n// 因为 bar 定义在类型声明空间中，而未定义在变量声明空间中。\n\n\nconst foo = 123;\nlet bar: foo; // error: \"cannot find name 'foo'\"\n\n// foo 定义在变量声明空间中，不能用作类型注解。\n\n\n\n# 模块\n\n在默认情况下，当你开始在一个新的 typescript 文件中写下代码时，它处于全局命名空间中。如在 foo.ts 里的以下代码可以在 bar.ts 中使用。\n\n// foo.ts\nconst foo = 123;\n\n// bar.ts\nconst bar = foo; // allowed\n\n\n所以需要使用文件模块：\n\n// foo.ts\nexport const foo = 123;\n\n// bar.ts\nimport { foo } from './foo';\nconst bar = foo; // allow\n\n\n\n# typescript类型系统\n\n\n# 类型注解\n\n类型注解使用 :typeannotation 语法。在类型声明空间中可用的任何内容都可以用作类型注解。例如：\n\n// 函数声明\nfunction func1 (a: number, b?:number): string {\n    return 'func1'\n}\n\n// 函数表达式\nconst func2: (a: number, b:number) => string = function () {\n    return 'func2'\n}\n\n\n\n# 原始类型\n\nstring、number、boolean\n\nlet num: number;\nlet str: string;\nlet bool: boolean;\n\nnum = 123;\nnum = 123.456;\nnum = '123'; // error\n\nstr = '123';\nstr = 123; // error\n\nbool = true;\nbool = false;\nbool = 'false'; // error\n\n\n\n# 特殊类型\n\nany、 null、 undefined 以及 void\n\n# any\n\nany 类型在 typescript 类型系统中占有特殊的地位。它提供给你一个类型系统的「后门」,typescript 将会把类型检查关闭。在类型系统里 any 能够兼容所有的类型（包括它自己）。因此，所有类型都能被赋值给它，它也能被赋值给其他任何类型。\n\nlet power: any;\n\n// 赋值任意类型\npower = '123';\npower = 123;\n\n// 它也兼容任何类型\nlet power: any;\nlet num: number;\n\npower = '123'\nnum = power\n\n// 反过来也可\nnum = 123\npower = num\n\n\n# null 和 undefined\n\n默认情况下它们是所有类型的子类型，即可以赋值给任意类型\n\nlet num: number;\nlet str: string;\n\n// 这些类型能被赋予\nnum = null;\nstr = undefined;\n\n\n# void\n\n使用 :void 来表示一个函数没有一个返回值\n\nfunction log(message: string): void {\n  console.log(message);\n}\n\n\n\n# 数组\n\n// 两种写法，常使用第二种\nconst arr1: array<number> = [1, 2, 3]\nconst arr2: number[] = [1, 2, 3]\n\nlet boolarray: boolean[];\n\nboolarray = [true, false];\nconsole.log(boolarray[0]); // true\nconsole.log(boolarray.length); // 2\n\nboolarray[1] = true;\nboolarray = [false, false];\n\nboolarray[0] = 'false'; // error\nboolarray = 'false'; // error\nboolarray = [true, 'false']; // error\n\n\n\n# 对象\n\n除了 object之外，函数和数组也属于对象\n\nconst obj: { foo: number } = { foo:123 }\n\nconst foo: object = function () {}\nconst bar: object = []\n\n\n\n# 接口\n\n为什么需要接口？可以看这个例子：\n\nfunction print(obj: { a: string }) {\n  console.log(obj.a);\n}\n\nlet myobj = { a: '10', b: 20 };\nprint(myobj);\n\n\n类型检查器会查看print的调用。 print有一个参数，并要求这个对象参数有一个名为a类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些a是否存在，而没有检查b\n\n接口可以合并众多类型声明至一个类型声明，在这里，我们把类型注解：a: string + b: number 合并到了一个新的类型注解 obj 里，这样能强制对每个成员进行类型检查。\n\ninterface obj {\n  a: string;\n  b: number;\n}\n\nlet obj: obj;\nobj = {\n  a: '10',\n  b: 20\n};\n\n// error: property 'b' is missing\nobj = {\n  a: '10'\n};\n\n// error: property 'b' is missing\nobj = {\n  a: '10',\n  b: '20'\n};\n\n\n\n# interface 和 type 的区别\n\n在 typescript 中，interface 和 type 都可以用来定义类型，但它们有一些区别。以下是它们的主要区别：\n\n 1. 语法和用途：\n    * interface 主要用于定义对象的结构。\n    * type 更灵活，可以用于定义各种类型，包括对象、联合类型、交叉类型等。\n 2. 扩展性：\n    * interface 可以被继承和实现，支持 extends 关键字。\n    * type 不能被继承，但可以使用交叉类型 (&) 来组合类型。\n 3. 声明合并：\n    * interface 支持声明合并，可以多次声明同名接口，它们会自动合并。\n    * type 不支持声明合并，重复声明会报错。\n 4. 计算属性：\n    * type 支持使用 in 关键字创建映射类型。\n    * interface 不支持映射类型。\n 5. 元组和数组：\n    * type 可以更容易地定义元组和复杂的数组类型。\n    * interface 在定义元组和复杂数组类型时相对不够灵活。\n 6. 联合类型和交叉类型：\n    * type 可以直接创建联合类型和交叉类型。\n    * interface 不能直接创建联合类型和交叉类型。\n\n\n# 内联类型注解\n\n内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦（你可能会使用一个很糟糕的名称）。然而，如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias）\n\nlet foo: {\n  first: string;\n  second: string;\n};\n\nfoo = {\n  first: 'john',\n  second: 'doe'\n};\n\nfoo = {\n  // error: 'second is missing'\n  first: 'john'\n};\n\nfoo = {\n  // error: 'second is the wrong type'\n  first: 'john',\n  second: 1337\n};\n\n\n\n# 泛型\n\n在计算机科学中，许多算法和数据结构并不会依赖于对象的实际类型。但是，你仍然会想在每个变量里强制提供约束。\n\nfunction createnumberarray (length: number, value: number): number[] {\n    const arr = array<number>(length).fill(value)\n    return arr\n}\n\nfunction createstringarray (length: number, value: string): string[] {\n    const arr = array<string>(length).fill(value)\n    return arr\n}\n\n// 泛型解决冗余问题,在函数后面加 <t>\nfunction createarray<t> (length: number, value: t): t[] {\n    const arr = array<t>(length).fill(value)\n    return arr\n}\nconst res = createarray<string>(3, 'foo')\n\n\n具体例子请看泛型\n\n\n# 联合类型(|)\n\n在 javascript 中，你可能希望属性为多种类型之一，如字符串或者数组。它使用 | 作为标记，如 string | number\n\nfunction formatcommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n}\n\n\n\n# 交叉类型(&)\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n\ninterface a {\n  name: string;\n  sex: number;\n}\n\ninterface b {\n  age: number;\n  sex: number;\n}\n\nlet c: a&b = { name: 'xxx', age: 18, sex: 1 }\n\n\n\n# 元组类型\n\n元组可以看作是数组的拓展，它表示已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。\n\nlet namenumber: [string, number];\n\n// ok\nnamenumber = ['jenny', 221345];\n\n// error\nnamenumber = ['jenny', '221345'];\n\n// 与解构一起使用\nlet namenumber: [string, number];\nnamenumber = ['jenny', 322134];\n\nconst [name, num] = namenumber;\n\n\n\n# 类型别名\n\ntypescript 提供了为类型注解设置别名的便捷语法，你可以使用 type somename = somevalidtypeannotation 来创建别名：\n\ntype strornum = string | number;\n\n// 使用\nlet sample: strornum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // error\n\n\n\n# 枚举类型\n\n枚举（enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。默认情况下，枚举是基于 0 的，也就是说第一个值是 0，后面的值依次递增。\n\n// 例如文章对象\nconst post = {\n    title: 'aaaaa'\n    content: 'abbb',\n    status: 0 // 0, 1, 2 代表不同状态，但是不直观\n}\n\n// 枚举类型\nconst enum poststatus {\n    draft = 0,\n    unpublished = 1,\n    published = 2\n}\n\nconst post = {\n    title: 'aaaaa',\n    content: 'abbb',\n    status: poststatus.draft\n}\n\n\n枚举是基于 0 的，后面的值依次递增。\n\nenum color {red, green, blue}\nlet c: color = color.green;  // 1\n\nenum color {red = 1, green, blue = 4}\nlet c: color = color.green;  // 2\n\n\n\n# 类\n\nclass person {\n    public name: string\n    private age: number\n    protected readonly gender: boolean // protected 只允许子类访问   readonly 只读属性\n    \n    constructor (name: string, age: number, gender: boolean) {\n        this.name = name\n        this.age = age\n        this.gender = gender\n    }\n    \n    sayhi (msg: string): void {\n        console.log(this.name, msg)\n    }\n}\n\nclass student extends person {\n    constructor (name: string, age: number, gender: boolean) {\n        super(name, age, gender)\n        console.log(gender) // 只有在这里能访问 gender\n    }\n}\n\n\n# 用类实现接口\n\n> 实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\ninterface eat {\n    eat（food: string): void\n}\ninterface run {\n    run（distance: number): void\n}\n\nclass person implements eat, run {\n    eat (food: string): void {\n        console.log(`优雅地进餐：${food}`)\n    }\n    \n    run (distance: number): void {\n        console.log(`直立行走：${distance}`)\n    }\n}\n\nclass animal implements eat, run {\n    eat (food: string): void {\n        console.log(`呼噜呼噜地吃：${food}`)\n    }\n    \n    run (distance: number): void {\n        console.log(`爬行：${distance}`)\n    }\n}\n\n\n\n# 抽象类\n\n抽象类作为其他派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节。abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。\n\nabstract class animal { // 抽象类只能被继承\n    eat (food: string): void {\n        console.log(`呼噜呼噜地吃：${food}`)\n    }\n\n    abstract run (distance: number): void // 抽象方法在子类中必须实现\n}\n\nclass dog extends animal {\n    run (distance: number): void { \n         console.log('爬行：' + distance);\n    }\n}\nconst d = new dog();\nd.eat('food')\nd.run(100)\n\n\n\n# 高级类型\n\n\n# partial\n\n> partial 形容词，译为 部分的/局部的/不完全的。使一个 interface/class 或 其他 k/v 形式的 类型的每一个属性完全可选。\n\n类型声明：\n\n/**\n * make all properties in t optional\n */\ntype partial<t> = {\n  [p in keyof t]?: t[p];\n};\n\n\n示例：\n\ninterface a {\n  id: number;\n  name: string;\n  age: number;\n}\ntype partiala = partial<a>;\n\n\n\n\n\n# record\n\n> record<k,t>构造具有给定类型t的一组属性k的类型。在将一个类型的属性映射到另一个类型的属性时，record非常方便。（是一个对象类型）\n\n类型声明：\n\n/**\n * construct a type with a set of properties k of type t\n */\ntype record<k extends keyof any, t> = {\n  [p in k]: t;\n};\n\n\n示例：\n\ninterface employeetype {\n    id: number\n    fullname: string\n    role: string\n}\n \nlet employees: record<number, employeetype> = {\n    0: { id: 1, fullname: \"john doe\", role: \"designer\" },\n    1: { id: 2, fullname: \"ibrahima fall\", role: \"developer\" },\n    2: { id: 3, fullname: \"sara duckson\", role: \"developer\" },\n}\n \n// 0: { id: 1, fullname: \"john doe\", role: \"designer\" },\n// 1: { id: 2, fullname: \"ibrahima fall\", role: \"developer\" },\n// 2: { id: 3, fullname: \"sara duckson\", role: \"developer\" }\n\n\n\n# pick\n\n> 从 t 中，选择一组键在并集 k 中的属性。实际就是说在原有的类型 t 上 筛选出想要的全部或极个别的属性和类型。\n\n类型声明：\n\n/**\n * from t, pick a set of properties whose keys are in the union k\n */\ntype pick<t, k extends keyof t> = {\n  [p in k]: t[p];\n};\n\n\n示例：\n\ninterface b {\n  id: number;\n  name: string;\n  age: number;\n}\n\ntype pickb = pick<b, \"id\" | \"name\">;\n\n\n\n\n\n# omit\n\n> 作用与pick相反，omit是排除一个字段，剩下的所有，\n\ninterface c {\n  id: number;\n  name: string;\n  age: number;\n}\n\ntype omitc = omit<c, \"id\">;\n",charsets:{cjk:!0}},{title:"Vite原理解析",frontmatter:{},regularPath:"/vue/vite.html",relativePath:"vue/vite.md",key:"v-3b654611",path:"/vue/vite.html",lastUpdated:"5/9/2022, 3:52:37 PM",lastUpdatedTimestamp:1652082757e3,headersStr:null,content:"# Vite原理解析",normalizedContent:"# vite原理解析",charsets:{cjk:!0}},{title:"Vue响应式原理详解",frontmatter:{title:"Vue响应式原理详解",date:"2020-11-12T11:27:54.000Z",categories:"Vue"},regularPath:"/vue/responsive.html",relativePath:"vue/responsive.md",key:"v-7a32bc31",path:"/vue/responsive.html",headers:[{level:2,title:"发布订阅模式",slug:"发布订阅模式",normalizedTitle:"发布订阅模式",charIndex:17},{level:2,title:"Vue的自定义事件",slug:"vue的自定义事件",normalizedTitle:"vue的自定义事件",charIndex:125},{level:3,title:"兄弟组件通信过程",slug:"兄弟组件通信过程",normalizedTitle:"兄弟组件通信过程",charIndex:323},{level:3,title:"模拟实现vue的自定义事件",slug:"模拟实现vue的自定义事件",normalizedTitle:"模拟实现vue的自定义事件",charIndex:651},{level:2,title:"观察者模式",slug:"观察者模式",normalizedTitle:"观察者模式",charIndex:1333},{level:2,title:"Vue实例初始化过程",slug:"vue实例初始化过程",normalizedTitle:"vue实例初始化过程",charIndex:2015},{level:3,title:"1. 数据是object类型",slug:"_1-数据是object类型",normalizedTitle:"1. 数据是object类型",charIndex:3446},{level:3,title:"2. 数据是array类型",slug:"_2-数据是array类型",normalizedTitle:"2. 数据是array类型",charIndex:4232},{level:2,title:"组件渲染过程",slug:"组件渲染过程",normalizedTitle:"组件渲染过程",charIndex:6319},{level:2,title:"响应式的整体流程",slug:"响应式的整体流程",normalizedTitle:"响应式的整体流程",charIndex:10571},{level:2,title:"Vue 3.0 Proxy",slug:"vue-3-0-proxy",normalizedTitle:"vue 3.0 proxy",charIndex:10991},{level:3,title:"Proxy 中的 receiver",slug:"proxy-中的-receiver",normalizedTitle:"proxy 中的 receiver",charIndex:13928}],lastUpdated:"2/22/2023, 4:12:20 PM",lastUpdatedTimestamp:167705354e4,headersStr:"发布订阅模式 Vue的自定义事件 兄弟组件通信过程 模拟实现vue的自定义事件 观察者模式 Vue实例初始化过程 1. 数据是object类型 2. 数据是array类型 组件渲染过程 响应式的整体流程 Vue 3.0 Proxy Proxy 中的 receiver",content:"# Vue响应式原理详解\n\n\n# 发布订阅模式\n\n * 订阅者\n * 发布者\n * 信号中心\n\n> 假定存在一个信号中心，某个任务执行完成，就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而知道自己什么时候自己可以开始执行。\n\n\n# Vue的自定义事件\n\nlet vm = new Vue()\n\n// 注册事件\nvm.$on('dataChange', ()=>{\n    console.log('dataChange')\n})\n\nvm.$on('dataChange', ()=>{\n    console.log('dataChange1')\n})\n\n// 发起事件\nvm.$emit('dataChange')\n\n\n\n# 兄弟组件通信过程\n\n两个组件不相互依赖，即发布者和订阅者被事件中心隔离\n\n// 信号中心\nlet eventHub = new Vue()\n\n// ComponentA.vue\n// 发布者\naddTodo: function () {\n    // 发布事件\n    eventHub.$emit('add-todo', { text: this.newTodoText })\n    this.newTodoText = ''\n}\n// ComponentB.vue\n// 订阅者\ncreated: function () {\n    // 订阅事件\n    eventHub.$on('add-todo', this.addTodo)\n}\n\n\n\n# 模拟实现vue的自定义事件\n\n// 类内部存储一个对象，包含事件名和对应的触发函数\n// { click: [fn1, fn2], change: fn }\nclass EventEmitter {\n  constructor () {\n    this.subs = Object.create(null)\n  }\n  // 注册事件\n  $on (eventType, handler) {\n    this.subs[eventType] = this.subs[eventType] || []\n    this.subs[eventType].push(handler)\n  }\n\n  // 触发事件\n  $emit (eventType) {\n    if (this.subs[eventType]) {\n      this.subs[eventType].forEach(handler => handler())\n    }\n  }\n\n  $off(eventType) {\n    this.subs[eventType] = []\n  }\n}\n\n// 测试\nlet em = new EventEmitter() // 信号中心\nem.$on('click', () => {\n  console.log('click1')\n})\nem.$on('click', () => {\n  console.log('click2')\n})\nem.$emit('click')\n\n\nObject.create(null) 和 {} 的区别\n\n\n# 观察者模式\n\n * 观察者 -- watcher\n   * update()：当事件发生时，具体要做的事情\n * 发布者 -- Dep\n   * subs数组：存储所有观察者\n   * addSub()：添加观察者\n   * notify()：当事件发生，调用所有观察者的update方法\n * 没有事件中心\n\n    // 发布者-目标\n    class Dep {\n      constructor () {\n        // 记录所有的订阅者\n        this.subs = []\n      }\n      // 添加订阅者\n      addSub (sub) {\n        if (sub && sub.update) {\n          this.subs.push(sub)\n        }\n      }\n      // 发布通知\n      notify () {\n        this.subs.forEach(sub => sub.update())\n      }\n    }\n\n    // 订阅者-观察者\n    class Watcher {\n      update () {\n        console.log('update')\n      }\n    }\n\n    // 测试\n    let dep = new Dep()\n    let watcher = new Watcher()\n\n    dep.addSub(watcher)\n    dep.notify()\n\n\n\n# Vue实例初始化过程\n\n在 Vue 实例初始化的时候会调用_init方法，_init方法中有很多初始化的过程，比如\n\n//初始化生命周期\ninitLifecycle(vm)\n//初始化事件\ninitEvents(vm)\n//初始化render\ninitRender(vm)\n// ...\ninitState(vm)\n\n\n这里的重点就是initState方法，initState中也初始化了很多，如下：\n\n  //初始化props\n  if (opts.props) initProps(vm, opts.props)\n  //初始化methods\n  if (opts.methods) initMethods(vm, opts.methods)\n  //初始化data！！！再次划重点！！！\n  if (opts.data) {\n    initData(vm)\n  } else {\n    //即使没有data，也要调用observe观测_data对象\n    observe(vm._data = {}, true /* asRootData */)\n  }\n\n\n这里的重点就是initData方法，在其内部调用了observe方法，到这里才是真正响应式的开始\n\n  //将vm中的属性转至vm._data中\n  proxy(vm, `_data`, key)\n  //调用observe观测data对象\n  observe(data, true /* asRootData */)\n\n\nobserve是一个工厂函数，用于为对象生成一个Observe实例。而真正将对象转化为响应式对象的是observe工厂函数返回的Observe实例。\n\nexport class Observer {\n  constructor (value: any) {\n    //对象本身\n    this.value = value\n    //依赖收集器\n    this.dep = new Dep()\n    this.vmCount = 0\n    //为对象添加__ob__属性\n    def(value, '__ob__', this)\n    //若对象是array类型\n    if (Array.isArray(value)) {\n      ...\n    } else {\n      //若对象是object类型\n      ...\n    }\n  }\n\n\n从代码分析，Observe构造函数做了三件事：\n\n * 为对象添加 __ob__属性， __ob__中包含value数据对象本身、dep依赖收集器、vmCount。数据经过这个步骤以后的变化如下：\n\n//原数据\n  const data = {\n        name: 'summer'\n  }\n  //变化后数据\n  const data = {\n        name: 'summer',\n        __ob__: {\n            value: data, //data数据本身\n            dep: new Dep(), //dep依赖收集器\n            vmCount: 0\n        }\n  }\n\n\n * 若对象是array类型，则进行array类型操作\n * 若对象是object类型，则进行object类型操作\n\n\n# 1. 数据是object类型\n\n当数据是object类型时，调用了一个walk方法，在walk方法中遍历数据的所有属性，并调用defineReactive方法。\n\nexport function defineReactive (...) {\n  //dep存储依赖的变量，每个属性字段都有一个属于自己的dep，用于收集属于该字段的依赖\n  const dep = new Dep()\n\n  //为属性加入getter/setter方法\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get () {\n      // 收集依赖，target会在watcher类中定义\n      Dep.target && dep.addSub(Dep.target)\n      return val\n    },\n    set (newValue) {\n      if (newValue === val) {\n        return\n      }\n       val = newValue\n       that.walk(newValue)\n       // 发送通知\n       dep.notify()\n    }\n  })\n}\n\n\n在getter中收集依赖，在setter中触发依赖。\n\n * 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。\n * 在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。\n\n\n# 2. 数据是array类型\n\n调用arrayMethods拦截修改数组方法：\n\n * 需要拦截的修改数组的方法有：push、pop、shift、unshift、splice、sort、reverse\n * 当数组有新增元素时，使用observeArray对新增的元素进行观测\n\n对于对象\n\nVue 无法检测 property 的添加或移除。这是因为 Vue 通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：\n\nvar vm = new Vue({\n  data:{\n    a:1\n  }\n})\n\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 是非响应式的\n\n\n对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于：\n\nVue.set(vm.someObject, 'b', 2)\n\n\n您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：\n\nthis.$set(this.someObject,'b',2)\n\n\n * 给data对象的某个属性设置为一个新的对象this.o = { name: 'xxx' }，此对象是响应式的\n * 给data对象的obj新增一个name属性时，this.obj.name = 'xxx'，该属性不是响应式的\n\n对于数组\n\nObject.defineProperty 不能监听数组的一些方法，push/pop/splice等等改变原数组的方法不能触发set，需要进行数组方法的重写。（Vue3中使用proxy则不存在这些问题）\n\n因为 Vue2.x 的响应式是通过 Object.defineProperty() 实现的，这个 api 没办法监听数组长度的变化，也就没办法监听数组的新增，push/pop/splice等也就不能触发set\n\n\n此外 Vue 不能检测以下数组的变动：\n\n 1. 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n 2. 当你修改数组的长度时，例如：vm.items.length = newLength\n\n举个例子：\n\nvar vm = new Vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n\n\n为什么数组方法可以重写，但是不去监听数组属性(索引和length)呢？\n\n * 性能问题：数组数据可能有很多\n\n为了解决这个问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：\n\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n\n你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：\n\nvm.$set(vm.items, indexOfItem, newValue)\n\n\n为了解决不监听数组长度的问题，你可以使用 splice和重写数组方法：\n\nvm.items.splice(newLength)\n\n\n * Vue.set 和 vm.$set内部是同一个方法，原理是手动触发 notify\n\n  // 获取 target 中的 observer 对象\n  const ob = (target: any).__ob__\n  // 如果 target 是 vue 实例或者$data 直接返回\n  if (target._isVue || (ob && ob.vmCount)) {\n    return val\n  }\n  // 如果 ob 不存在，target 不是响应式对象直接赋值\n  if (!ob) {\n    target[key] = val\n    return val\n  }\n  // 把 key 设置成响应式属性\n  defineReactive(ob.value, key, val)\n  // 发送通知\n  ob.dep.notify()\n  return val\n}\n\n\n\n# 组件渲染过程\n\n那么究竟是如何触发依赖实现响应式的呢，从组件渲染阶段开始说起\n\nvue源码的 instance/init.js 中是初始化的入口，其中初始化中除了初始化的几个步骤以外，在最后有这样一段代码，要实现的功能是挂载到el上，要么是运行时有render直接挂载，要么将template/el编译一下再挂载\n\nif (vm.$options.el) {\n  vm.$mount(vm.$options.el)\n}\n\n\n * 一共有两个$mount,第一个定义在entry-runtime-with-compiler.js文件中，这是完整构建版本的入口，首先会判断一下当前是否传入了render选项，如果没有传入的话，它会去获取我们的template选项，如果template选项也没有的话，他会把el中的内容作为我们的模板，然后把模板编译成render函数，存在我们的options.render中，优先级render > template > el\n * 另一个$mount是src/platforms/web/runtime/index.js文件中的$mount方法\n   * 运行时版本的挂载入口，可以直接调用，因为运行时存在render，直接挂载到el上即可\n   * 完整版本的$mount函数的最后调用，因为完整版本经过template编译之后，也有了render\n\nVue.prototype.$mount = function(\n    el?: string | Element,\n    hydrating?: boolean\n): Component {\n    // 判断el, 以及宿主环境, 然后通过工具函数query重写el。\n    el = el && inBrowser ? query(el) : undefined\n    // 执行真正的挂载并返回\n    return mountComponent(this, el, hydrating)\n}\n\n\n * 接下来调用mountComponent()，首先会判断render选项，如果没有render选项，会报出警告\n   * 如果我们传入了template或el，然后还没有render，会告诉我们如果是运行时版本不支持编译器。\n   * 否则会警告template or render function not defined\n * 接下来会触发beforeMount这个生命周期中的钩子函数，也就是开始挂载之前。\n\nexport function mountComponent(\n    vm: Component, // 组件实例vm\n    el: ?Element, // 挂载点\n    hydrating?: boolean\n): Component {\n    // 在组件实例对象上添加$el属性\n    // $el的值是组件模板根元素的引用\n    vm.$el = el\n    if (!vm.$options.render) {\n        // 渲染函数不存在, 这时将会创建一个空的vnode对象\n        vm.$options.render = createEmptyVNode\n        if (process.env.NODE_ENV !== \"production\") {\n            /* istanbul ignore if */\n            if (\n                (vm.$options.template &&\n                    vm.$options.template.charAt(0) !== \"#\") ||\n                vm.$options.el ||\n                el\n            ) {\n                warn(\n                    \"You are using the runtime-only build of Vue where the template \" +\n                        \"compiler is not available. Either pre-compile the templates into \"+\n                        \"render functions, or use the compiler-included build.\",\n                    vm\n                )\n            } else {\n                warn(\n                    \"Failed to mount component: template or render function not defined.\",\n                    vm\n                )\n            }\n        }\n    }\n    // 触发 beforeMount 生命周期钩子\n    callHook(vm, \"beforeMount\")\n\n\n * 然后定义了updateComponent()，在这个函数中，调用vm._render和vm._update，vm._render的作用是生成虚拟DOM，vm._update的作用是将虚拟DOM转换成真实DOM，并且挂载到页面上，这里只是定义\n * 然后创建Watcher对象，在创建Watcher时，传递了updateComponent这个函数，这个函数最终是在Watcher内部调用的。在Watcher内部会用get方法，当Watcher创建完成之后,会触发生命周期中的mounted钩子函数\n\nnew Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n\n// vm ：与Wather对应的Vue Component实例，这种对应关系通过Wather去管理\n// updateComponent：可以理解成Vue Component的更新函数，调用实例render和update两个方法，render作用是将Vue对象渲染成虚拟DOM,update是通过虚拟DOM创建或者更新真实DOM\n\n\n上面说在创建 Watcher 实例的时候会调用get方法，在get方法中，会调用updateComponent()，调用其中的_render函数找到传入或者编译生成的render函数去生成虚拟DOM，然后调用_update方法将虚拟DOM转换成真实DOM\n\n * 更多详细请看\n\nWatcher 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种：\n\n 1. initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集\n 2. initState 时,对侦听属性初始化时,触发 user watcher 依赖收集\n 3. render()的过程,触发 render watcher 依赖收集\n 4. re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。\n\nwatcher类\n\nclass Watcher {\n    constructor (\n    vm: Component, \n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      // 将渲染函数的观察者存入_watcher\n      vm._watcher = this\n    }\n    // 将所有观察者push到_watchers列表\n    vm._watchers.push(this)\n  }\n    \n  get () { // 触发取值操作，进而触发属性的getter\n    pushTarget(this) // Dep 中提到的：给 Dep.target 赋值 watcher\n    let value\n    const vm = this.vm\n    try {\n      // 核心，运行观察者表达式，进行取值，触发getter，从而在闭包中添加watcher\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      if (this.deep) { // 如果要深度监测，再对 value 执行操作\n        traverse(value)\n      }\n      // 清理依赖收集\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  // 当依赖变化时，触发更新\n  update () {\n    ...\n  }\n}\n\n\n\n# 响应式的整体流程\n\nVue响应式原理-理解Observer、Dep、Watcher\n\n * 组件实例初始化过程中，walk 方法遍历 data 利用Object.defineProperty为每个属性添加getter、setter方法，用于收集依赖和触发依赖，每个属性都会有一个 Dep 用来收集依赖。\n * 组件渲染过程中（mountComponent方法），初始化组件自己的 watcher 对象，当外界通过 watcher 读取数据时，会触发 getter 从而将 watcher 添加到 Dep 中。watcher 可以是渲染 watcher、computed watcher、watch watcher\n * data 中的属性变化，会调用 setter 中的方法（Dep.notify）通知收集到的 watcher 执行 update 方法。\n * watcher 收到依赖变化的消息，重新渲染虚拟dom，实现页面响应\n\n\n# Vue 3.0 Proxy\n\n> Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。\n\nProxy可以理解成，在目标对象之前架设一层 \"拦截\"，当外界对该对象访问的时候，都必须经过这层拦截，而Proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。\n\n> proxy不存在Object.defineProperty()的三个问题,并且Proxy有多达13种拦截方法\n\nvar proxy = new Proxy(target, handler);\n\n\n> new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为\n\nlet obj = {\n  name: 'Eason',\n  age: 30\n}\nlet handler = {\n  get (target, key, receiver) {\n    console.log('get', key)                   // 如果什么操作也没有就直接return Reflect..\n    // return target[key]\n    return Reflect.get(target, key, receiver) //函数式行为\n  },\n  set (target, key, value, receiver) {\n    console.log('set', key, value)\n    // target[key] = value\n    return Reflect.set(target, key, value, receiver)\n  }\n}\nlet proxy = new Proxy(obj, handler)\n\nproxy.name = 'Zoe' // set name Zoe\nproxy.age = 18     // set age 18\nproxy.name         //22 get name\n\t              //\"Eason\"\n\n\n * proxy 读取属性的值时，实际上执行的是 Handler.get ：在控制台输出信息，并且读取被代理对象 obj 的属性。\n * 在 proxy 设置属性值时，实际上执行的是 Handler.set ：在控制台输出信息，并且设置被代理对象 obj 的属性的值\n\n> Reflect是一个内置的对象，没有构造函数，所有的属性与方法都是静态的（就像Math对象）\n> \n> Reflect.get():获取对象身上某个属性的值，类似于 target[name]。\n> \n> Reflect.set():将值分配给属性的函数,返回一个Boolean，如果更新成功，则返回true。\n> \n> Reflect对象的静态方法和Proxy对象的静态方法一一对应 ，一共13种\n> \n> Reflect设计的目的是为了优化Object的一些操作方法以及合理的返回Object操作返回的结果，对于一些命令式的Object行为，Reflect对象可以将其变为函数式的行为\n\nconst obj = {\n    name: 'ace',\n    age: 18\n}\n\nconsole.log('name' in obj)\nconsole.log(delete obj['age'])\nconsole.log(Object.keys(obj))\n\nconsole.log(Reflect.has(obj, 'name'))\nconsole.log(Reflect.deleteProperty(obj, 'age'))\nconsole.log(Reflect.ownKeys(obj))\n\n\nReflect.apply(target, thisArgument, argumentsList)\n// 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。\n\nReflect.construct(target, argumentsList[, newTarget])\n// 对构造函数进行 new 操作，相当于执行 new target(...args)。\n\nReflect.defineProperty(target, propertyKey, attributes)\n// 和 Object.defineProperty() 类似。如果设置成功就会返回 true\n\nReflect.deleteProperty(target, propertyKey)\n//作为函数的delete操作符，相当于执行 delete target[name]。\n\nReflect.get(target, propertyKey[, receiver])\n// 获取对象身上某个属性的值，类似于 target[name]。\n\nReflect.getOwnPropertyDescriptor(target, propertyKey)\n// 类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 undefined.\n\nReflect.getPrototypeOf(target)\n// 类似于 Object.getPrototypeOf()。\n\nReflect.has(target, propertyKey)\n// 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。\n\nReflect.isExtensible(target)\n// 类似于 Object.isExtensible().\n\nReflect.ownKeys(target)\n// 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).\n\nReflect.preventExtensions(target)\n// 类似于 Object.preventExtensions()。返回一个Boolean。\n\nReflect.set(target, propertyKey, value[, receiver])\n// 将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。\n\nReflect.setPrototypeOf(target, prototype)\n// 设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true。\n\n\n\n# Proxy 中的 receiver\n\nProxy 和 Reflect\n\n> 在 Reflect.get 的场景下，receiver 可以改变计算属性中 this 的指向。\n\nvar target = {\n  get a() { return this.c }\n}\n\nReflect.get(target, 'a', { c: 4 }) // 4\n\n\n> receiver是接受者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver参数是无需使用的，但是如果发生了继承，为了明确调用主体，receiver参数就需要出马了。\n\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*) target = user\n    return Reflect.get(target, prop, receiver); // receiver = admin\n  }\n});\n\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\n// 期望输出：Admin\nalert(admin.name); // 输出：Guest (?!?)\n\n\n * target —— 是目标对象，该对象被作为第一个参数传递给 new Proxy，\n * prop —— 目标属性名，\n * receiver —— 如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。通常，这就是 proxy 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。",normalizedContent:"# vue响应式原理详解\n\n\n# 发布订阅模式\n\n * 订阅者\n * 发布者\n * 信号中心\n\n> 假定存在一个信号中心，某个任务执行完成，就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而知道自己什么时候自己可以开始执行。\n\n\n# vue的自定义事件\n\nlet vm = new vue()\n\n// 注册事件\nvm.$on('datachange', ()=>{\n    console.log('datachange')\n})\n\nvm.$on('datachange', ()=>{\n    console.log('datachange1')\n})\n\n// 发起事件\nvm.$emit('datachange')\n\n\n\n# 兄弟组件通信过程\n\n两个组件不相互依赖，即发布者和订阅者被事件中心隔离\n\n// 信号中心\nlet eventhub = new vue()\n\n// componenta.vue\n// 发布者\naddtodo: function () {\n    // 发布事件\n    eventhub.$emit('add-todo', { text: this.newtodotext })\n    this.newtodotext = ''\n}\n// componentb.vue\n// 订阅者\ncreated: function () {\n    // 订阅事件\n    eventhub.$on('add-todo', this.addtodo)\n}\n\n\n\n# 模拟实现vue的自定义事件\n\n// 类内部存储一个对象，包含事件名和对应的触发函数\n// { click: [fn1, fn2], change: fn }\nclass eventemitter {\n  constructor () {\n    this.subs = object.create(null)\n  }\n  // 注册事件\n  $on (eventtype, handler) {\n    this.subs[eventtype] = this.subs[eventtype] || []\n    this.subs[eventtype].push(handler)\n  }\n\n  // 触发事件\n  $emit (eventtype) {\n    if (this.subs[eventtype]) {\n      this.subs[eventtype].foreach(handler => handler())\n    }\n  }\n\n  $off(eventtype) {\n    this.subs[eventtype] = []\n  }\n}\n\n// 测试\nlet em = new eventemitter() // 信号中心\nem.$on('click', () => {\n  console.log('click1')\n})\nem.$on('click', () => {\n  console.log('click2')\n})\nem.$emit('click')\n\n\nobject.create(null) 和 {} 的区别\n\n\n# 观察者模式\n\n * 观察者 -- watcher\n   * update()：当事件发生时，具体要做的事情\n * 发布者 -- dep\n   * subs数组：存储所有观察者\n   * addsub()：添加观察者\n   * notify()：当事件发生，调用所有观察者的update方法\n * 没有事件中心\n\n    // 发布者-目标\n    class dep {\n      constructor () {\n        // 记录所有的订阅者\n        this.subs = []\n      }\n      // 添加订阅者\n      addsub (sub) {\n        if (sub && sub.update) {\n          this.subs.push(sub)\n        }\n      }\n      // 发布通知\n      notify () {\n        this.subs.foreach(sub => sub.update())\n      }\n    }\n\n    // 订阅者-观察者\n    class watcher {\n      update () {\n        console.log('update')\n      }\n    }\n\n    // 测试\n    let dep = new dep()\n    let watcher = new watcher()\n\n    dep.addsub(watcher)\n    dep.notify()\n\n\n\n# vue实例初始化过程\n\n在 vue 实例初始化的时候会调用_init方法，_init方法中有很多初始化的过程，比如\n\n//初始化生命周期\ninitlifecycle(vm)\n//初始化事件\ninitevents(vm)\n//初始化render\ninitrender(vm)\n// ...\ninitstate(vm)\n\n\n这里的重点就是initstate方法，initstate中也初始化了很多，如下：\n\n  //初始化props\n  if (opts.props) initprops(vm, opts.props)\n  //初始化methods\n  if (opts.methods) initmethods(vm, opts.methods)\n  //初始化data！！！再次划重点！！！\n  if (opts.data) {\n    initdata(vm)\n  } else {\n    //即使没有data，也要调用observe观测_data对象\n    observe(vm._data = {}, true /* asrootdata */)\n  }\n\n\n这里的重点就是initdata方法，在其内部调用了observe方法，到这里才是真正响应式的开始\n\n  //将vm中的属性转至vm._data中\n  proxy(vm, `_data`, key)\n  //调用observe观测data对象\n  observe(data, true /* asrootdata */)\n\n\nobserve是一个工厂函数，用于为对象生成一个observe实例。而真正将对象转化为响应式对象的是observe工厂函数返回的observe实例。\n\nexport class observer {\n  constructor (value: any) {\n    //对象本身\n    this.value = value\n    //依赖收集器\n    this.dep = new dep()\n    this.vmcount = 0\n    //为对象添加__ob__属性\n    def(value, '__ob__', this)\n    //若对象是array类型\n    if (array.isarray(value)) {\n      ...\n    } else {\n      //若对象是object类型\n      ...\n    }\n  }\n\n\n从代码分析，observe构造函数做了三件事：\n\n * 为对象添加 __ob__属性， __ob__中包含value数据对象本身、dep依赖收集器、vmcount。数据经过这个步骤以后的变化如下：\n\n//原数据\n  const data = {\n        name: 'summer'\n  }\n  //变化后数据\n  const data = {\n        name: 'summer',\n        __ob__: {\n            value: data, //data数据本身\n            dep: new dep(), //dep依赖收集器\n            vmcount: 0\n        }\n  }\n\n\n * 若对象是array类型，则进行array类型操作\n * 若对象是object类型，则进行object类型操作\n\n\n# 1. 数据是object类型\n\n当数据是object类型时，调用了一个walk方法，在walk方法中遍历数据的所有属性，并调用definereactive方法。\n\nexport function definereactive (...) {\n  //dep存储依赖的变量，每个属性字段都有一个属于自己的dep，用于收集属于该字段的依赖\n  const dep = new dep()\n\n  //为属性加入getter/setter方法\n  object.defineproperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get () {\n      // 收集依赖，target会在watcher类中定义\n      dep.target && dep.addsub(dep.target)\n      return val\n    },\n    set (newvalue) {\n      if (newvalue === val) {\n        return\n      }\n       val = newvalue\n       that.walk(newvalue)\n       // 发送通知\n       dep.notify()\n    }\n  })\n}\n\n\n在getter中收集依赖，在setter中触发依赖。\n\n * 当外界通过watcher读取数据时，会触发getter从而将watcher添加到依赖中。\n * 在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 dep 中的每一个 watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 watcher就会开始调用 update 来更新视图。\n\n\n# 2. 数据是array类型\n\n调用arraymethods拦截修改数组方法：\n\n * 需要拦截的修改数组的方法有：push、pop、shift、unshift、splice、sort、reverse\n * 当数组有新增元素时，使用observearray对新增的元素进行观测\n\n对于对象\n\nvue 无法检测 property 的添加或移除。这是因为 vue 通过object.defineproperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。由于 vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 vue 将它转换为响应式的。例如：\n\nvar vm = new vue({\n  data:{\n    a:1\n  }\n})\n\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 是非响应式的\n\n\n对于已经创建的实例，vue 不允许动态添加根级别的响应式 property。但是，可以使用 vue.set(object, propertyname, value) 方法向嵌套对象添加响应式 property。例如，对于：\n\nvue.set(vm.someobject, 'b', 2)\n\n\n您还可以使用 vm.$set 实例方法，这也是全局 vue.set 方法的别名：\n\nthis.$set(this.someobject,'b',2)\n\n\n * 给data对象的某个属性设置为一个新的对象this.o = { name: 'xxx' }，此对象是响应式的\n * 给data对象的obj新增一个name属性时，this.obj.name = 'xxx'，该属性不是响应式的\n\n对于数组\n\nobject.defineproperty 不能监听数组的一些方法，push/pop/splice等等改变原数组的方法不能触发set，需要进行数组方法的重写。（vue3中使用proxy则不存在这些问题）\n\n因为 vue2.x 的响应式是通过 object.defineproperty() 实现的，这个 api 没办法监听数组长度的变化，也就没办法监听数组的新增，push/pop/splice等也就不能触发set\n\n\n此外 vue 不能检测以下数组的变动：\n\n 1. 当你利用索引直接设置一个数组项时，例如：vm.items[indexofitem] = newvalue\n 2. 当你修改数组的长度时，例如：vm.items.length = newlength\n\n举个例子：\n\nvar vm = new vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n\n\n为什么数组方法可以重写，但是不去监听数组属性(索引和length)呢？\n\n * 性能问题：数组数据可能有很多\n\n为了解决这个问题，以下两种方式都可以实现和 vm.items[indexofitem] = newvalue 相同的效果，同时也将在响应式系统内触发状态更新：\n\n// vue.set\nvue.set(vm.items, indexofitem, newvalue)\n// array.prototype.splice\nvm.items.splice(indexofitem, 1, newvalue)\n\n\n你也可以使用 vm.$set 实例方法，该方法是全局方法 vue.set 的一个别名：\n\nvm.$set(vm.items, indexofitem, newvalue)\n\n\n为了解决不监听数组长度的问题，你可以使用 splice和重写数组方法：\n\nvm.items.splice(newlength)\n\n\n * vue.set 和 vm.$set内部是同一个方法，原理是手动触发 notify\n\n  // 获取 target 中的 observer 对象\n  const ob = (target: any).__ob__\n  // 如果 target 是 vue 实例或者$data 直接返回\n  if (target._isvue || (ob && ob.vmcount)) {\n    return val\n  }\n  // 如果 ob 不存在，target 不是响应式对象直接赋值\n  if (!ob) {\n    target[key] = val\n    return val\n  }\n  // 把 key 设置成响应式属性\n  definereactive(ob.value, key, val)\n  // 发送通知\n  ob.dep.notify()\n  return val\n}\n\n\n\n# 组件渲染过程\n\n那么究竟是如何触发依赖实现响应式的呢，从组件渲染阶段开始说起\n\nvue源码的 instance/init.js 中是初始化的入口，其中初始化中除了初始化的几个步骤以外，在最后有这样一段代码，要实现的功能是挂载到el上，要么是运行时有render直接挂载，要么将template/el编译一下再挂载\n\nif (vm.$options.el) {\n  vm.$mount(vm.$options.el)\n}\n\n\n * 一共有两个$mount,第一个定义在entry-runtime-with-compiler.js文件中，这是完整构建版本的入口，首先会判断一下当前是否传入了render选项，如果没有传入的话，它会去获取我们的template选项，如果template选项也没有的话，他会把el中的内容作为我们的模板，然后把模板编译成render函数，存在我们的options.render中，优先级render > template > el\n * 另一个$mount是src/platforms/web/runtime/index.js文件中的$mount方法\n   * 运行时版本的挂载入口，可以直接调用，因为运行时存在render，直接挂载到el上即可\n   * 完整版本的$mount函数的最后调用，因为完整版本经过template编译之后，也有了render\n\nvue.prototype.$mount = function(\n    el?: string | element,\n    hydrating?: boolean\n): component {\n    // 判断el, 以及宿主环境, 然后通过工具函数query重写el。\n    el = el && inbrowser ? query(el) : undefined\n    // 执行真正的挂载并返回\n    return mountcomponent(this, el, hydrating)\n}\n\n\n * 接下来调用mountcomponent()，首先会判断render选项，如果没有render选项，会报出警告\n   * 如果我们传入了template或el，然后还没有render，会告诉我们如果是运行时版本不支持编译器。\n   * 否则会警告template or render function not defined\n * 接下来会触发beforemount这个生命周期中的钩子函数，也就是开始挂载之前。\n\nexport function mountcomponent(\n    vm: component, // 组件实例vm\n    el: ?element, // 挂载点\n    hydrating?: boolean\n): component {\n    // 在组件实例对象上添加$el属性\n    // $el的值是组件模板根元素的引用\n    vm.$el = el\n    if (!vm.$options.render) {\n        // 渲染函数不存在, 这时将会创建一个空的vnode对象\n        vm.$options.render = createemptyvnode\n        if (process.env.node_env !== \"production\") {\n            /* istanbul ignore if */\n            if (\n                (vm.$options.template &&\n                    vm.$options.template.charat(0) !== \"#\") ||\n                vm.$options.el ||\n                el\n            ) {\n                warn(\n                    \"you are using the runtime-only build of vue where the template \" +\n                        \"compiler is not available. either pre-compile the templates into \"+\n                        \"render functions, or use the compiler-included build.\",\n                    vm\n                )\n            } else {\n                warn(\n                    \"failed to mount component: template or render function not defined.\",\n                    vm\n                )\n            }\n        }\n    }\n    // 触发 beforemount 生命周期钩子\n    callhook(vm, \"beforemount\")\n\n\n * 然后定义了updatecomponent()，在这个函数中，调用vm._render和vm._update，vm._render的作用是生成虚拟dom，vm._update的作用是将虚拟dom转换成真实dom，并且挂载到页面上，这里只是定义\n * 然后创建watcher对象，在创建watcher时，传递了updatecomponent这个函数，这个函数最终是在watcher内部调用的。在watcher内部会用get方法，当watcher创建完成之后,会触发生命周期中的mounted钩子函数\n\nnew watcher(vm, updatecomponent, noop, {\n    before () {\n      if (vm._ismounted && !vm._isdestroyed) {\n        callhook(vm, 'beforeupdate')\n      }\n    }\n  }, true /* isrenderwatcher */)\n\n// vm ：与wather对应的vue component实例，这种对应关系通过wather去管理\n// updatecomponent：可以理解成vue component的更新函数，调用实例render和update两个方法，render作用是将vue对象渲染成虚拟dom,update是通过虚拟dom创建或者更新真实dom\n\n\n上面说在创建 watcher 实例的时候会调用get方法，在get方法中，会调用updatecomponent()，调用其中的_render函数找到传入或者编译生成的render函数去生成虚拟dom，然后调用_update方法将虚拟dom转换成真实dom\n\n * 更多详细请看\n\nwatcher 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种：\n\n 1. initstate 时,对 computed 属性初始化时,触发 computed watcher 依赖收集\n 2. initstate 时,对侦听属性初始化时,触发 user watcher 依赖收集\n 3. render()的过程,触发 render watcher 依赖收集\n 4. re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。\n\nwatcher类\n\nclass watcher {\n    constructor (\n    vm: component, \n    exporfn: string | function,\n    cb: function,\n    options?: ?object,\n    isrenderwatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isrenderwatcher) {\n      // 将渲染函数的观察者存入_watcher\n      vm._watcher = this\n    }\n    // 将所有观察者push到_watchers列表\n    vm._watchers.push(this)\n  }\n    \n  get () { // 触发取值操作，进而触发属性的getter\n    pushtarget(this) // dep 中提到的：给 dep.target 赋值 watcher\n    let value\n    const vm = this.vm\n    try {\n      // 核心，运行观察者表达式，进行取值，触发getter，从而在闭包中添加watcher\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleerror(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      if (this.deep) { // 如果要深度监测，再对 value 执行操作\n        traverse(value)\n      }\n      // 清理依赖收集\n      poptarget()\n      this.cleanupdeps()\n    }\n    return value\n  }\n\n  // 当依赖变化时，触发更新\n  update () {\n    ...\n  }\n}\n\n\n\n# 响应式的整体流程\n\nvue响应式原理-理解observer、dep、watcher\n\n * 组件实例初始化过程中，walk 方法遍历 data 利用object.defineproperty为每个属性添加getter、setter方法，用于收集依赖和触发依赖，每个属性都会有一个 dep 用来收集依赖。\n * 组件渲染过程中（mountcomponent方法），初始化组件自己的 watcher 对象，当外界通过 watcher 读取数据时，会触发 getter 从而将 watcher 添加到 dep 中。watcher 可以是渲染 watcher、computed watcher、watch watcher\n * data 中的属性变化，会调用 setter 中的方法（dep.notify）通知收集到的 watcher 执行 update 方法。\n * watcher 收到依赖变化的消息，重新渲染虚拟dom，实现页面响应\n\n\n# vue 3.0 proxy\n\n> object.defineproperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。proxy 可以劫持整个对象,并返回一个新的对象。proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。\n\nproxy可以理解成，在目标对象之前架设一层 \"拦截\"，当外界对该对象访问的时候，都必须经过这层拦截，而proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。\n\n> proxy不存在object.defineproperty()的三个问题,并且proxy有多达13种拦截方法\n\nvar proxy = new proxy(target, handler);\n\n\n> new proxy()表示生成一个proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为\n\nlet obj = {\n  name: 'eason',\n  age: 30\n}\nlet handler = {\n  get (target, key, receiver) {\n    console.log('get', key)                   // 如果什么操作也没有就直接return reflect..\n    // return target[key]\n    return reflect.get(target, key, receiver) //函数式行为\n  },\n  set (target, key, value, receiver) {\n    console.log('set', key, value)\n    // target[key] = value\n    return reflect.set(target, key, value, receiver)\n  }\n}\nlet proxy = new proxy(obj, handler)\n\nproxy.name = 'zoe' // set name zoe\nproxy.age = 18     // set age 18\nproxy.name         //22 get name\n\t              //\"eason\"\n\n\n * proxy 读取属性的值时，实际上执行的是 handler.get ：在控制台输出信息，并且读取被代理对象 obj 的属性。\n * 在 proxy 设置属性值时，实际上执行的是 handler.set ：在控制台输出信息，并且设置被代理对象 obj 的属性的值\n\n> reflect是一个内置的对象，没有构造函数，所有的属性与方法都是静态的（就像math对象）\n> \n> reflect.get():获取对象身上某个属性的值，类似于 target[name]。\n> \n> reflect.set():将值分配给属性的函数,返回一个boolean，如果更新成功，则返回true。\n> \n> reflect对象的静态方法和proxy对象的静态方法一一对应 ，一共13种\n> \n> reflect设计的目的是为了优化object的一些操作方法以及合理的返回object操作返回的结果，对于一些命令式的object行为，reflect对象可以将其变为函数式的行为\n\nconst obj = {\n    name: 'ace',\n    age: 18\n}\n\nconsole.log('name' in obj)\nconsole.log(delete obj['age'])\nconsole.log(object.keys(obj))\n\nconsole.log(reflect.has(obj, 'name'))\nconsole.log(reflect.deleteproperty(obj, 'age'))\nconsole.log(reflect.ownkeys(obj))\n\n\nreflect.apply(target, thisargument, argumentslist)\n// 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 function.prototype.apply() 功能类似。\n\nreflect.construct(target, argumentslist[, newtarget])\n// 对构造函数进行 new 操作，相当于执行 new target(...args)。\n\nreflect.defineproperty(target, propertykey, attributes)\n// 和 object.defineproperty() 类似。如果设置成功就会返回 true\n\nreflect.deleteproperty(target, propertykey)\n//作为函数的delete操作符，相当于执行 delete target[name]。\n\nreflect.get(target, propertykey[, receiver])\n// 获取对象身上某个属性的值，类似于 target[name]。\n\nreflect.getownpropertydescriptor(target, propertykey)\n// 类似于 object.getownpropertydescriptor()。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 undefined.\n\nreflect.getprototypeof(target)\n// 类似于 object.getprototypeof()。\n\nreflect.has(target, propertykey)\n// 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。\n\nreflect.isextensible(target)\n// 类似于 object.isextensible().\n\nreflect.ownkeys(target)\n// 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 object.keys(), 但不会受enumerable影响).\n\nreflect.preventextensions(target)\n// 类似于 object.preventextensions()。返回一个boolean。\n\nreflect.set(target, propertykey, value[, receiver])\n// 将值分配给属性的函数。返回一个boolean，如果更新成功，则返回true。\n\nreflect.setprototypeof(target, prototype)\n// 设置对象原型的函数. 返回一个 boolean， 如果更新成功，则返回true。\n\n\n\n# proxy 中的 receiver\n\nproxy 和 reflect\n\n> 在 reflect.get 的场景下，receiver 可以改变计算属性中 this 的指向。\n\nvar target = {\n  get a() { return this.c }\n}\n\nreflect.get(target, 'a', { c: 4 }) // 4\n\n\n> receiver是接受者的意思，表示调用对应属性或方法的主体对象，通常情况下，receiver参数是无需使用的，但是如果发生了继承，为了明确调用主体，receiver参数就需要出马了。\n\nlet user = {\n  _name: \"guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userproxy = new proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*) target = user\n    return reflect.get(target, prop, receiver); // receiver = admin\n  }\n});\n\nlet admin = {\n  __proto__: userproxy,\n  _name: \"admin\"\n};\n\n// 期望输出：admin\nalert(admin.name); // 输出：guest (?!?)\n\n\n * target —— 是目标对象，该对象被作为第一个参数传递给 new proxy，\n * prop —— 目标属性名，\n * receiver —— 如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。通常，这就是 proxy 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。",charsets:{cjk:!0}},{title:"Vue3.0（二）",frontmatter:{title:"Vue3.0（二）",date:"2021-02-10T11:27:54.000Z",categories:"Vue"},regularPath:"/vue/vue3.0-2.html",relativePath:"vue/vue3.0-2.md",key:"v-6ee223b1",path:"/vue/vue3.0-2.html",headers:[{level:2,title:"reactive",slug:"reactive",normalizedTitle:"reactive",charIndex:149},{level:2,title:"收集依赖",slug:"收集依赖",normalizedTitle:"收集依赖",charIndex:309},{level:2,title:"收集依赖实现：effect && track",slug:"收集依赖实现-effect-track",normalizedTitle:"收集依赖实现：effect &amp;&amp; track",charIndex:null},{level:2,title:"触发更新：trigger",slug:"触发更新-trigger",normalizedTitle:"触发更新：trigger",charIndex:2758},{level:2,title:"ref",slug:"ref",normalizedTitle:"ref",charIndex:158},{level:2,title:"reactive vs ref",slug:"reactive-vs-ref",normalizedTitle:"reactive vs ref",charIndex:3732},{level:2,title:"toRefs",slug:"torefs",normalizedTitle:"torefs",charIndex:162},{level:2,title:"computed",slug:"computed",normalizedTitle:"computed",charIndex:169}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"reactive 收集依赖 收集依赖实现：effect && track 触发更新：trigger ref reactive vs ref toRefs computed",content:"# Vue.js 3.0响应式原理\n\n * 使用 Proxy 对象实现属性监听\n * 多层属性嵌套，只有在访问属性过程中处理下一级属性\n * 默认监听动态添加的属性\n * 默认监听属性的删除操作\n * 默认监听数组索引和 length 属性\n * 可以作为单独的模块使用\n\n\n# 核心方法\n\n * reactive/ref/toRefs/computed\n * 三个底层方法，一般不会直接调用\n   * effect\n   * track\n   * trigger\n\n> effect 函数用于定义副作用，它的参数就是副作用函数，会默认执行一次，当响应数据变化后，会导致副作用函数重新执行。\n> \n> track 用来收集依赖（收集effect），trigger 用来触发响应（执行effect）\n\n\n# reactive\n\n * 接收一个参数，判断参数是否是对象，不是对象则返回（只能处理对象）\n * 创建拦截器对象 handler，设置 get / set /deleteProperty\n * 返回 Proxy 对象\n\n// 判断是否为对象\nconst isObject = val => val !== null && typeof val === 'object'\n// 对象的键仍为对象继续调用 reactive 处理\nconst convert = target => isObject(target) ? reactive(target) ? target\n// 判断对象是否有某个属性\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n// call 方法相当于 target.hasOwnProperty(key)\nconst hasOwn = (target, key) => hasOwnProperty.call(target, key) \n\n// reactive 方法\nexport function reactive(target) {\n\tif(!isObject(target)) return target\n\t\n\tconst handler = {\n    get(target, key, receiver) {\n      // 收集依赖\n      track(target, key)\n      const result = Reflect.get(target, key, receiver)\n      return convert(result)\n    },\n    set(target, key, value, receiver) {\n      const oldValue = Reflect.get(target, key, receiver)\n      let result = true // 返回 boolean 值\n      if (oldValue !== value) {\n        result = Reflect.set(target, key, value, receiver)\n        // 触发更新\n        trigger(target, key)\n      }\n      return result\n    },\n    deleteProperty(target, key) {\n      const hadKey = hasOwn(target, key)\n      const result = Reflect.deleteProperty(target, key)\n      if (hadKey && result) {\n        // 触发更新\n        trigger(target, key)\n      }\n    }\n  }\n  \n  return new Proxy(target, handler)\n}\n\n\n测试\n\nimport { reactive } from './index.js'\nconst obj = reactive({\n  name: 'zs',\n  age: 18\n})\nobj.name = 'ls'\ndelete obj.age\nconsole.log(obj)\n\n\n\n# 收集依赖\n\n如何收集依赖，先看一个例子\n\nimport { reactive, effect } from './reactivity/index.js'\n\nconst product = reactive({\n  name: 'iPhone',\n  price: 5000,\n  count: 3\n})\nlet total = 0 \n\neffect(() => {\n  total = product.price * product.count\n  // 此处访问时会执行 price 和 count 属性的 get 方法，收集依赖\n})\n\nconsole.log(total)\n\nproduct.price = 4000 // 此处访问时会执行 price 和 count 属性的 set 方法，触发更新\nconsole.log(total)\n\nproduct.count = 1\nconsole.log(total)\n\n\n\n\n * JavaScript中的Map、WeakMap、Set和WeakSet介绍\n\n\n# 收集依赖实现：effect && track\n\nlet activeEffect = null\nexport function effect(callback) {\n  activeEffect = callback\n  callback() // 访问响应式对象属性，收集依赖\n  activeEffect = null\n}\n\nlet targetMap = new WeakMap()\n\nexport function track(target, key) {\n  if (!activeEffect) return\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()))\n  }\n  dep.add(activeEffect)\n}\n\n\n\n# 触发更新：trigger\n\nexport function trigger(target, key) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) return\n  const dep = depsMap.get(key)\n  if (dep) {\n    dep.forEach(() => {\n      effect()\n    })\n  }\n}\n\n\n\n# ref\n\nexport function ref(raw) {\n  // 判断 raw 是否是 ref 创建的对象，如果是直接返回\n  if (isObject(raw) && raw.__v_isRef) {\n    return\n  }\n  let value = convert(raw)\n  const r = {\n    __v_isRef: true,\n    get value() {\n      track(r, 'value')\n      return value\n    },\n    set value(newValue) {\n      if (newValue !== value) {\n        raw = newValue\n        value = convert(raw)\n        trigger(r, 'value')\n      }\n    }\n  }\n  return r\n}\n\n\nref测试\n\n    import { reactive, effect, ref } from './reactivity/index.js'\n\n    const price = ref(5000)\n    const count = ref(3)\n   \n    let total = 0 \n    effect(() => {\n      total = price.value * count.value\n    })\n    console.log(total)\n\n    price.value = 4000\n    console.log(total)\n\n    count.value = 1\n    console.log(total)\n\n\n\n# reactive vs ref\n\n * ref 可以把基本数据类型数据，转成响应式对象\n * ref 返回的对象，重新赋值成对象也是响应式的\n * reactive 返回的对象，重新赋值丢失响应式\n * reactive 返回的对象不可以解构\n\n\n# toRefs\n\nexport function toRefs (proxy) {\n  const ret = proxy instanceof Array ? new Array(proxy.length) : {}\n\n  for (const key in proxy) {\n    // 把每个属性都转换成 ref 对象\n    ret[key] = toProxyRef(proxy, key)\n  }\n\n  return ret\n}\n\nfunction toProxyRef (proxy, key) {\n  const r = {\n    __v_isRef: true,\n    get value () {\n      // 访问的已经是响应式对象，不需要收集依赖\n      return proxy[key]\n    },\n    set value (newValue) {\n      proxy[key] = newValue\n    }\n  }\n  return r\n}\n\n\ntoRefs测试\n\nimport { reactive, effect, toRefs } from './reactivity/index.js'\n\nfunction useProduct () {\n  const product = reactive({\n    name: 'iPhone',\n    price: 5000,\n    count: 3\n  })\n\t\n  // 直接返回 product 解构之后不是响应式的\n  // toRefs 将每个属性转换成了响应式，解构之后依旧是响应式\n  return toRefs(product)\n}\n\nconst { price, count } = useProduct() \n\nlet total = 0 \neffect(() => {\n  total = price.value * count.value\n})\nconsole.log(total)\n\nprice.value = 4000\nconsole.log(total)\n\ncount.value = 1\nconsole.log(total)\n\n\n\n# computed\n\n> Computed 实际上就是一个 effect 函数，computed 返回的是一个 ref 对象。\n\n// 返回 ref 创建的对象\nexport function computed (getter) {\n  const result = ref()\n\n  effect(() => (result.value = getter()))\n\n  return result\n}\n\n\ncomputed测试\n\nimport { reactive, effect, computed } from './reactivity/index.js'\n\nconst product = reactive({\n  name: 'iPhone',\n  price: 5000,\n  count: 3\n})\nlet total = computed(() => {\n  return product.price * product.count\n})\n\nconsole.log(total.value)\n\nproduct.price = 4000\nconsole.log(total.value)\n\nproduct.count = 1\nconsole.log(total.value)\n",normalizedContent:"# vue.js 3.0响应式原理\n\n * 使用 proxy 对象实现属性监听\n * 多层属性嵌套，只有在访问属性过程中处理下一级属性\n * 默认监听动态添加的属性\n * 默认监听属性的删除操作\n * 默认监听数组索引和 length 属性\n * 可以作为单独的模块使用\n\n\n# 核心方法\n\n * reactive/ref/torefs/computed\n * 三个底层方法，一般不会直接调用\n   * effect\n   * track\n   * trigger\n\n> effect 函数用于定义副作用，它的参数就是副作用函数，会默认执行一次，当响应数据变化后，会导致副作用函数重新执行。\n> \n> track 用来收集依赖（收集effect），trigger 用来触发响应（执行effect）\n\n\n# reactive\n\n * 接收一个参数，判断参数是否是对象，不是对象则返回（只能处理对象）\n * 创建拦截器对象 handler，设置 get / set /deleteproperty\n * 返回 proxy 对象\n\n// 判断是否为对象\nconst isobject = val => val !== null && typeof val === 'object'\n// 对象的键仍为对象继续调用 reactive 处理\nconst convert = target => isobject(target) ? reactive(target) ? target\n// 判断对象是否有某个属性\nconst hasownproperty = object.prototype.hasownproperty\n// call 方法相当于 target.hasownproperty(key)\nconst hasown = (target, key) => hasownproperty.call(target, key) \n\n// reactive 方法\nexport function reactive(target) {\n\tif(!isobject(target)) return target\n\t\n\tconst handler = {\n    get(target, key, receiver) {\n      // 收集依赖\n      track(target, key)\n      const result = reflect.get(target, key, receiver)\n      return convert(result)\n    },\n    set(target, key, value, receiver) {\n      const oldvalue = reflect.get(target, key, receiver)\n      let result = true // 返回 boolean 值\n      if (oldvalue !== value) {\n        result = reflect.set(target, key, value, receiver)\n        // 触发更新\n        trigger(target, key)\n      }\n      return result\n    },\n    deleteproperty(target, key) {\n      const hadkey = hasown(target, key)\n      const result = reflect.deleteproperty(target, key)\n      if (hadkey && result) {\n        // 触发更新\n        trigger(target, key)\n      }\n    }\n  }\n  \n  return new proxy(target, handler)\n}\n\n\n测试\n\nimport { reactive } from './index.js'\nconst obj = reactive({\n  name: 'zs',\n  age: 18\n})\nobj.name = 'ls'\ndelete obj.age\nconsole.log(obj)\n\n\n\n# 收集依赖\n\n如何收集依赖，先看一个例子\n\nimport { reactive, effect } from './reactivity/index.js'\n\nconst product = reactive({\n  name: 'iphone',\n  price: 5000,\n  count: 3\n})\nlet total = 0 \n\neffect(() => {\n  total = product.price * product.count\n  // 此处访问时会执行 price 和 count 属性的 get 方法，收集依赖\n})\n\nconsole.log(total)\n\nproduct.price = 4000 // 此处访问时会执行 price 和 count 属性的 set 方法，触发更新\nconsole.log(total)\n\nproduct.count = 1\nconsole.log(total)\n\n\n\n\n * javascript中的map、weakmap、set和weakset介绍\n\n\n# 收集依赖实现：effect && track\n\nlet activeeffect = null\nexport function effect(callback) {\n  activeeffect = callback\n  callback() // 访问响应式对象属性，收集依赖\n  activeeffect = null\n}\n\nlet targetmap = new weakmap()\n\nexport function track(target, key) {\n  if (!activeeffect) return\n  let depsmap = targetmap.get(target)\n  if (!depsmap) {\n    targetmap.set(target, (depsmap = new map()))\n  }\n  let dep = depsmap.get(key)\n  if (!dep) {\n    depsmap.set(key, (dep = new set()))\n  }\n  dep.add(activeeffect)\n}\n\n\n\n# 触发更新：trigger\n\nexport function trigger(target, key) {\n  const depsmap = targetmap.get(target)\n  if (!depsmap) return\n  const dep = depsmap.get(key)\n  if (dep) {\n    dep.foreach(() => {\n      effect()\n    })\n  }\n}\n\n\n\n# ref\n\nexport function ref(raw) {\n  // 判断 raw 是否是 ref 创建的对象，如果是直接返回\n  if (isobject(raw) && raw.__v_isref) {\n    return\n  }\n  let value = convert(raw)\n  const r = {\n    __v_isref: true,\n    get value() {\n      track(r, 'value')\n      return value\n    },\n    set value(newvalue) {\n      if (newvalue !== value) {\n        raw = newvalue\n        value = convert(raw)\n        trigger(r, 'value')\n      }\n    }\n  }\n  return r\n}\n\n\nref测试\n\n    import { reactive, effect, ref } from './reactivity/index.js'\n\n    const price = ref(5000)\n    const count = ref(3)\n   \n    let total = 0 \n    effect(() => {\n      total = price.value * count.value\n    })\n    console.log(total)\n\n    price.value = 4000\n    console.log(total)\n\n    count.value = 1\n    console.log(total)\n\n\n\n# reactive vs ref\n\n * ref 可以把基本数据类型数据，转成响应式对象\n * ref 返回的对象，重新赋值成对象也是响应式的\n * reactive 返回的对象，重新赋值丢失响应式\n * reactive 返回的对象不可以解构\n\n\n# torefs\n\nexport function torefs (proxy) {\n  const ret = proxy instanceof array ? new array(proxy.length) : {}\n\n  for (const key in proxy) {\n    // 把每个属性都转换成 ref 对象\n    ret[key] = toproxyref(proxy, key)\n  }\n\n  return ret\n}\n\nfunction toproxyref (proxy, key) {\n  const r = {\n    __v_isref: true,\n    get value () {\n      // 访问的已经是响应式对象，不需要收集依赖\n      return proxy[key]\n    },\n    set value (newvalue) {\n      proxy[key] = newvalue\n    }\n  }\n  return r\n}\n\n\ntorefs测试\n\nimport { reactive, effect, torefs } from './reactivity/index.js'\n\nfunction useproduct () {\n  const product = reactive({\n    name: 'iphone',\n    price: 5000,\n    count: 3\n  })\n\t\n  // 直接返回 product 解构之后不是响应式的\n  // torefs 将每个属性转换成了响应式，解构之后依旧是响应式\n  return torefs(product)\n}\n\nconst { price, count } = useproduct() \n\nlet total = 0 \neffect(() => {\n  total = price.value * count.value\n})\nconsole.log(total)\n\nprice.value = 4000\nconsole.log(total)\n\ncount.value = 1\nconsole.log(total)\n\n\n\n# computed\n\n> computed 实际上就是一个 effect 函数，computed 返回的是一个 ref 对象。\n\n// 返回 ref 创建的对象\nexport function computed (getter) {\n  const result = ref()\n\n  effect(() => (result.value = getter()))\n\n  return result\n}\n\n\ncomputed测试\n\nimport { reactive, effect, computed } from './reactivity/index.js'\n\nconst product = reactive({\n  name: 'iphone',\n  price: 5000,\n  count: 3\n})\nlet total = computed(() => {\n  return product.price * product.count\n})\n\nconsole.log(total.value)\n\nproduct.price = 4000\nconsole.log(total.value)\n\nproduct.count = 1\nconsole.log(total.value)\n",charsets:{cjk:!0}},{title:"Vue3.0（三）",frontmatter:{title:"Vue3.0（三）",date:"2021-02-22T11:27:54.000Z",categories:"Vue"},regularPath:"/vue/vue3.0-3.html",relativePath:"vue/vue3.0-3.md",key:"v-11c69222",path:"/vue/vue3.0-3.html",headers:[{level:2,title:"vite serve",slug:"vite-serve",normalizedTitle:"vite serve",charIndex:252},{level:2,title:"vue-cli serve",slug:"vue-cli-serve",normalizedTitle:"vue-cli serve",charIndex:411},{level:2,title:"打包 or 不打包",slug:"打包-or-不打包",normalizedTitle:"打包 or 不打包",charIndex:499}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"vite serve vue-cli serve 打包 or 不打包",content:"# Vite 概念\n\n * Vite 是一个面向现代浏览器的一个更轻，更快的 web 应用开发工具\n * 它基于 ECMAScript 标准原生模块系统（ES Modules）实现\n * 主要为了解决开发阶段使用 webpack-dev-server 仍启动过慢，HMR 热更新反应慢\n\n\n# Vite 项目依赖\n\n * Vite：命令行工具\n * @vue/compiler-sfc：编译 .vue 单文件组件，在 vue2 中是 vue=template-compiler\n\n\n# 基础使用\n\n * vite serve：开启 web 服务器，不需要编译所有文件，启动速度十分快\n * vite build\n   * Rollup\n   * Dynamic import\n     * Polyfill\n\n\n# vite serve\n\n> 只有具体使用模块的时候才会编译，HMR也立即编译当前所修改的文件\n\n\n\n\n# vue-cli serve\n\n> 不管模块是否被执行，都会被打包\n> \n> HMR：会自动以这个文件为入口重新 build 一次，所有涉及到的依赖也都会被加载一遍\n\n\n\n\n# 打包 or 不打包\n\n使用 webpack 打包的两个原因\n\n * 浏览器环境并不支持模块化（已渐渐不存在 ）\n * 零散的模块文件会产生大量的 http 请求\n\n\n# 开箱即用\n\n * TypeScript - 内置支持\n * less / sass / stylus / postcss - 内置支持（需要单独安装）\n * JSX\n * Web Assembly\n\n\n# Vite 特性\n\n * 快速冷启动\n * 模块热更新\n * 按需编译\n * 开箱即用\n\n> webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS",normalizedContent:"# vite 概念\n\n * vite 是一个面向现代浏览器的一个更轻，更快的 web 应用开发工具\n * 它基于 ecmascript 标准原生模块系统（es modules）实现\n * 主要为了解决开发阶段使用 webpack-dev-server 仍启动过慢，hmr 热更新反应慢\n\n\n# vite 项目依赖\n\n * vite：命令行工具\n * @vue/compiler-sfc：编译 .vue 单文件组件，在 vue2 中是 vue=template-compiler\n\n\n# 基础使用\n\n * vite serve：开启 web 服务器，不需要编译所有文件，启动速度十分快\n * vite build\n   * rollup\n   * dynamic import\n     * polyfill\n\n\n# vite serve\n\n> 只有具体使用模块的时候才会编译，hmr也立即编译当前所修改的文件\n\n\n\n\n# vue-cli serve\n\n> 不管模块是否被执行，都会被打包\n> \n> hmr：会自动以这个文件为入口重新 build 一次，所有涉及到的依赖也都会被加载一遍\n\n\n\n\n# 打包 or 不打包\n\n使用 webpack 打包的两个原因\n\n * 浏览器环境并不支持模块化（已渐渐不存在 ）\n * 零散的模块文件会产生大量的 http 请求\n\n\n# 开箱即用\n\n * typescript - 内置支持\n * less / sass / stylus / postcss - 内置支持（需要单独安装）\n * jsx\n * web assembly\n\n\n# vite 特性\n\n * 快速冷启动\n * 模块热更新\n * 按需编译\n * 开箱即用\n\n> webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持es module，会自动向依赖的module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在hmr方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是es module，因此在代码中不可以使用commonjs",charsets:{cjk:!0}},{title:"vue-loader原理解析",frontmatter:{title:"vue-loader原理解析",date:"2021-11-01T09:47:00.000Z",categories:"Vue"},regularPath:"/vue/template.html",relativePath:"vue/template.md",key:"v-3cfb1de5",path:"/vue/template.html",headers:[{level:2,title:"vue-loader",slug:"vue-loader",normalizedTitle:"vue-loader",charIndex:2},{level:3,title:"vue-loader 处理 SFC",slug:"vue-loader-处理-sfc",normalizedTitle:"vue-loader 处理 sfc",charIndex:221},{level:3,title:"Pitch Loader",slug:"pitch-loader",normalizedTitle:"pitch loader",charIndex:1490},{level:3,title:"VueLoaderPlugin",slug:"vueloaderplugin",normalizedTitle:"vueloaderplugin",charIndex:1470},{level:2,title:"@vue/component-compiler-utils",slug:"vue-component-compiler-utils",normalizedTitle:"@vue/component-compiler-utils",charIndex:274},{level:3,title:"API",slug:"api",normalizedTitle:"api",charIndex:4950},{level:2,title:"vue-template-compiler",slug:"vue-template-compiler",normalizedTitle:"vue-template-compiler",charIndex:154},{level:3,title:"模板编译的作用",slug:"模板编译的作用",normalizedTitle:"模板编译的作用",charIndex:7904},{level:3,title:"体验模板编译的结果",slug:"体验模板编译的结果",normalizedTitle:"体验模板编译的结果",charIndex:8590},{level:3,title:"Vue Template Explorer",slug:"vue-template-explorer",normalizedTitle:"vue template explorer",charIndex:9475},{level:3,title:"模板编译过程",slug:"模板编译过程",normalizedTitle:"模板编译过程",charIndex:8677}],lastUpdated:"2/16/2022, 6:55:14 PM",lastUpdatedTimestamp:1645008914e3,headersStr:"vue-loader vue-loader 处理 SFC Pitch Loader VueLoaderPlugin @vue/component-compiler-utils API vue-template-compiler 模板编译的作用 体验模板编译的结果 Vue Template Explorer 模板编译过程",content:"# vue-loader原理解析\n\n\n# vue-loader\n\n> vue-loader 是用于 webpack 的加载器，允许你用 Single-File Components 单文件组件的格式来写 Vue 组件。其作用就是提取 *.vue 文件中的template，script，style等，再通过 vue-template-compiler，style-loader 等插件，最终形成一个可以在浏览器中运行的 js 文件。\n\n\n# vue-loader 处理 SFC\n\n * 首先 vue-loader 是怎么处理 SFC 的？他会使用 @vue/component-compiler-utils （下文会介绍）将 SFC 源码解析成 SFC 描述符 ，源码地址\n\n// vue-loader lib/index.js\nconst { parse } = require('@vue/component-compiler-utils');\n\nmodule.exports = function (source) {\n  // 解析源码，得到描述符\n  const descriptor = parse({ source, ... });\n\t\n  // 打印结果\n  console.log(descriptor);\n  /**\n  \tdescriptor {\n      template: { ... },\n      script: { ... },\n      styles: [ ... ],\n      customBlocks: [],\n      errors: []\n    }\n  */\n}\n\n\n * 然后根据 SFC描述符 为每个语言块进行处理，源码地址\n\n  // 如果 template 块存在\n  if (descriptor.template) { ... }\n  // 如果 script 块存在\n  if (descriptor.script) { ... }\n  // 如果 style 块存在（支持多 style 块）\n  if (descriptor.styles.length) { ... }\n  // Vue 还支持自定义块\n  if (descriptor.customBlocks && descriptor.customBlocks.length) { ... }\n\n\n * 处理后打印出的结果：\n\n// 从主加载程序返回的代码source.vue的代码\n\n// import the <template> block\nimport render from 'source.vue?vue&type=template'\n\n// import the <script> block\nimport script from 'source.vue?vue&type=script'\nexport * from 'source.vue?vue&type=script'\n\n// import <style> blocks\nimport 'source.vue?vue&type=style&index=1'\n\nscript.render = render\nexport default script\n\n\n * 以上就是使用 vue-loader 处理 SFC 的结果，那么问题来了语句中?vue&type=template 的作用是什么？这首先需要了解一下 pitch loader 和 VueLoaderPlugin\n\n\n# Pitch Loader\n\n * Normal loader：Loader 本质上是导出函数的 JavaScript 模块，而该模块导出的函数（若是 ES6 模块，则是默认导出的函数）就被称为 Normal Loader。需要注意的是， Normal Loader 与 Webpack Loader 分类中定义的 Loader 是不一样的。在 Webpack 中，loader 可以被分为 4 类：pre 前置、post 后置、normal 普通和 inline 行内。其中 pre 和 post loader，可以通过 rule 对象的 enforce 属性来指定\n * Pitch loader：在开发 Loader 时，我们可以在导出的函数上添加一个 pitch 属性，它的值也是一个函数。该函数被称为 Pitching Loader\n\n请看例子，我们定义 3 个 loader：\n\n// aLoader\nfunction aLoader(content, map, meta) {\n  console.log(\"开始执行aLoader Normal Loader\");\n  content += \"aLoader]\";\n  return `module.exports = '${content}'`;\n}\n\naLoader.pitch = function (remainingRequest, precedingRequest, data) {\n  console.log(\"开始执行aLoader Pitching Loader\");\n};\n\n// bLoader\nfunction bLoader(content, map, meta) {\n  console.log(\"开始执行bLoader Normal Loader\");\n  return content + \"bLoader->\";\n}\n\nbLoader.pitch = function (remainingRequest, precedingRequest, data) {\n  console.log(\"开始执行bLoader Pitching Loader\");\n};\n\n// cLoader\nfunction cLoader(content, map, meta) {\n  console.log(\"开始执行cLoader Normal Loader\");\n  return content + \"[cLoader->\";\n}\n\ncLoader.pitch = function (remainingRequest, precedingRequest, data) {\n  console.log(\"开始执行cLoader Pitching Loader\");\n};\n\n// config\nmodule: {\n  rules: [\n    {\n      test: /.txt$/i,\n      use: [\"a-loader\", \"b-loader\", \"c-loader\"],\n    },\n  ],\n},\n\n\nPitching Loader 和 Normal Loader 的执行顺序：\n\n开始执行aLoader Pitching Loader\n...\n开始执行bLoader Pitching Loader\n...\n开始执行cLoader Pitching Loader\n...\n开始执行cLoader Normal Loader\n开始执行bLoader Normal Loader\n开始执行aLoader Normal Loader\n\n\n很明显对于我们的示例来说，Pitching Loader 的执行顺序是 从左到右，而 Normal Loader 的执行顺序是 从右到左。其实Pitching Loader的另一个作用是当某个 Pitching Loader 返回非 undefined 值时，就会实现熔断效果。例如在 bLoader.pitch 中返回值时，执行效果会如下图所示：\n\n\n\n\n# VueLoaderPlugin\n\n> 我们知道 Webpack 插件的作用是能够 hook 到在每个编译(compilation)中触发的所有关键事件，并且在插件实例的 apply 方法中，可以通过 compiler.options 获取 Webpack 配置，并进行修改。\n\nVueLoaderPlugin 的处理流程中，修改了 module.rules，在原来的规则基础上加入了 pitcher 和 cloneRules 。新增的 rule ，能识别形如 ?vue&type=template 的 querystring，让不同语言的代码块匹配到对应的 rule。\n\nclass VueLoaderPlugin {\n  apply (compiler) {\n    // 对 Webpack 配置进行修改\n    const rawRules = compiler.options.module.rules;\n    const { rules } = new RuleSet(rawRules);\n    ...\n    \n    // pitcher\n    const pitcher = {\n      loader: require.resolve('./loaders/pitcher'),\n      resourceQuery: query => {\n        if (!query) { return false }\n        const parsed = qs.parse(query.slice(1))\n        // 匹配第一个查询条件是否是 vue\n        return parsed.vue != null\n      },\n      options: { ... }\n    }\n\n    // 替换初始 module.rules，在原有 rule 上，增加 pitcher、clonedRules\n    compiler.options.module.rules = [\n       pitcher,\n       ...clonedRules,\n       ...rules\n     ];\n  }\n}\n\n\n\n\n * 在这里由于我们注入了 pitcher 规则，上面的 source.vue?vue&type=script 被 pitcher 规则匹配到，就会被 pitch函数 处理，且 pitch 中返回了结果，由于熔断机制会跳过剩余的 loader。这个函数根据参数 type 来生成 行内lodaer ：\n\nexport * from \"-!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=template&id=21fec300&\"\n\n\n * 行内loader 按照从右到左的顺序执行，在得到上述的 request 之后，webpack会先使用 vue-loader 处理，然后再使用 template-loader 来处理，最终得到的就是 render 函数。\n\n> 在 PitchLoader 的转化结果中，还是会以 vue-loader 作为第一个处理的 loader，与第一次 vue-loader 处理不同的是，这次 vue-loader 的作用，仅仅是把 SFC 中语法块的源码提取出来，并交给后面的 loader 进行处理。\n\n\n\n\n# @vue/component-compiler-utils\n\n> 用来编译 vue 单文件组件\n\n@vue/component-compiler-utils 的作用是解析 vue SFC 并分别得到 html(模板) 和 JavaScript(script块) 的源码。对于 html 源码我们可以再次使用 vue-template-compiler 模块将其解析为模板对应的 render函数。\n\n\n# API\n\n# parse(ParseOptions): SFCDescriptor\n\n将 SFC 解析为一个带有 source map 的 SFC 描述器。编译器 (vue-template-compiler) 通过 compiler 传入。\n\ninterface ParseOptions {\n  source: string\n  filename?: string\n  compiler: VueTemplateCompiler\n  // https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#compilerparsecomponentfile-options\n  // default: { pad: 'line' }\n  compilerParseOptions?: VueTemplateCompilerParseOptions\n  sourceRoot?: string\n  needMap?: boolean\n}\n\ninterface SFCDescriptor {\n  template: SFCBlock | null\n  script: SFCBlock | null\n  styles: SFCBlock[]\n  customBlocks: SFCCustomBlock[]\n}\n\ninterface SFCCustomBlock {\n  type: string\n  content: string\n  attrs: { [key: string]: string | true }\n  start: number\n  end: number\n  map?: RawSourceMap\n}\n\ninterface SFCBlock extends SFCCustomBlock {\n  lang?: string\n  src?: string\n  scoped?: boolean\n  module?: string | boolean\n}\n\n\n# compileTemplate(TemplateCompileOptions): TemplateCompileResults\n\n将 template 编译为 JavaScript 代码。编译器 (vue-template-compiler) 通过 compiler 选项被传入。\n\n它也可以通过 consolidate 可选地为任何模板引擎进行预处理。\n\ninterface TemplateCompileOptions {\n  source: string\n  filename: string\n\n  compiler: VueTemplateCompiler\n  https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#compilercompiletemplate-options\n  // default: {}\n  compilerOptions?: VueTemplateCompilerOptions\n\n  // Template preprocessor\n  preprocessLang?: string\n  preprocessOptions?: any\n\n  // 将模板里找到的资源 URL 转换为 `require()` 调用\n  // 这个选项默认是关闭的。如果设置为 true，则默认值为：\n  // {\n  //   video: ['src', 'poster'],\n  //   source: 'src',\n  //   img: 'src',\n  //   image: 'xlink:href'\n  //   use: 'xlink:href'\n  // }\n  transformAssetUrls?: AssetURLOptions | boolean\n\n  // 为 vue-template-es2015-compiler，即一个 Buble 的 fork，指定的选项\n  transpileOptions?: any\n\n  isProduction?: boolean  // default: false\n  isFunctional?: boolean  // default: false\n  optimizeSSR?: boolean   // default: false\n\n  // 是否美化编译后的渲染函数 (只在开发环境下有效)\n  // 默认值：true\n  prettify?: boolean\n}\n\ninterface TemplateCompileResult {\n  code: string\n  source: string\n  tips: string[]\n  errors: string[]\n}\n\ninterface AssetURLOptions {\n  [name: string]: string | string[]\n}\n\n\n处理得到的 JavaScript 代码形如；\n\nvar render = function (h) { /* ... */}\nvar staticRenderFns = [function (h) { /* ... */}, function (h) { /* ... */}]\n\n\n它不会假定任何模块系统。你要在必要的时候负责处理导出。\n\n# compileStyle(StyleCompileOptions)\n\n将输入的原始 CSS 进行 scoped CSS 转换。它不会处理预处理器。如果组件没有使用 scoped CSS 那么这一步会被跳过。\n\ninterface StyleCompileOptions {\n  source: string\n  filename: string\n  id: string\n  map?: any\n  scoped?: boolean\n  trim?: boolean\n  preprocessLang?: string\n  preprocessOptions?: any\n  postcssOptions?: any\n  postcssPlugins?: any[]\n}\n\ninterface StyleCompileResults {\n  code: string\n  map: any | void\n  rawResult: LazyResult | void // 来自 PostCSS 的懒处理原始结果\n  errors: string[]\n}\n\n\n# compileStyleAsync(StyleCompileOptions)\n\n和 compileStyle(StyleCompileOptions) 相同，但是返回一个解析 StyleCompileResults 的 Promise 对象。可用于异步的 PostCSS 插件。\n\n\n# vue-template-compiler\n\n\n\n模板编译的作用是将模板（template）转换为渲染函数（render），template => ast => render\n\n * 模板\n\n<div>\n  <h1 @click=\"handler\">title</h1>\n  <p>some content</p>\n</div>\n\n\n * 渲染函数\n\nrender (h) {\n  return h('div', [\n    h('h1', { on: { click: this.handler } }, 'title'),\n    h('p', 'some content')\n  ])\n}\n\n\n渲染函数中的 h 函数内部调用 vm.$createElement 生成虚拟 DOM\n\n\n# 模板编译的作用\n\n * Vue 2.x 中使用 VNode 描述视图以及各种操作，但是不可能让用户自己写 VNode 或者 渲染函数，用户只需要写类似 HTML 代码，通过编译器将模板转换成返回 VNode 的 render 函数\n\n * .vue文件会被 webpack 构建过程中转换成 render 函数，webpack 本身是不支持转换的，是通过 vue-loader来支持的\n\n * 运行时编译：运行时编译的前提是必须使用完整版的 vue（包含编译器），会在项目运行的过程中把模板编译成 render 函数，但是缺点是 vue 体积过大。\n\n * 构建时编译：vue-cli自带的是运行时版本的 vue，使用 webpack + vue-loader完成编译，这样不仅体积小而且运行时不需要额外操作时间更快。\n\n\n# 体验模板编译的结果\n\n * 带编译器版本的 Vue.js 中，使用 template 或 el 的方式设置模板\n\n<div id=\"app\">\n  <h1>Vue<span>模板编译过程</span></h1>\n  <p>{{ msg }}</p>\n\t<comp @myclick=\"handler\"></comp>\n</div>\n<script src=\"../../dist/vue.js\"><\/script>\n<script>\n  Vue.component('comp', {\n    template: '<div>I am a comp</div>'\n  })\n  const vm = new Vue({\n    el: '#app',\n    data: {\n      msg: 'Hello compiler'\n    },\n    methods: {\n      handler () {\n        console.log('test')\n      }\n     } \n  })\n  console.log(vm.$options.render)\n<\/script>\n\n\n * 编译后 render 输出的结果\n\n(function anonymous() {\n  with (this) {\n    return _c(\n      \"div\",\n      { attrs: { id: \"app\" } },\n      [\n        _m(0),\n        _v(\" \"),\n        _c(\"p\", [_v(_s(msg))]),\n        _v(\" \"),\n        _c(\"comp\", { on: { myclick: handler } }),\n\t\t\t],\n\t\t\t1\n\t\t);\n  }\n});\n\n\n> _c： createElement\n> \n> _m：renderStatic，处理静态节点\n> \n> _v：createTextVNode，处理文本节点\n> \n> _s：处理字符串\n\n\n# Vue Template Explorer\n\n * vue-template-explorer：Vue 2.6 把模板编译成 render 函数的工具\n * vue-next-template-explorer：Vue 3.0 beta 把模板编译成 render 函数的工具\n\n\n# 模板编译过程\n\n * 解析、优化、生成\n\n# 编译入口\n\n * src\\platforms\\web\\entry-runtime-with-compiler.js\n\nVue.prototype.$mount = function (\n  ......\n// 把 template 转换成 render 函数\nconst { render, staticRenderFns } = compileToFunctions(template, {\n    outputSourceRange: process.env.NODE_ENV !== 'production',\n    shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref,\n    delimiters: options.delimiters,\n    comments: options.comments\n  }, this)\n  options.render = render\n  options.staticRenderFns = staticRenderFns\n  ......\n)\n\n\n * 调试 compileToFunctions() 执行过程，生成渲染函数的过程：\n   * compileToFunctions: src\\compiler\\to-function.js\n   * complie(template, options):src\\compiler\\create-compiler.js，主要作用是合并 options\n   * baseCompile(template.trim(), finalOptions):src\\compiler\\index.js，核心编译函数\n\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 把模板转换成 ast 抽象语法树\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化抽象语法树\n    optimize(ast, options)\n  }\n  // 把抽象语法树生成字符串形式的 js 代码\n  const code = generate(ast, options)\n  return {\n    ast,\n    // 渲染函数\n    render: code.render,\n    // 静态渲染函数，生成静态 VNode 树\n    staticRenderFns: code.staticRenderFns\n  }\n})\n\n\n# 解析-parse\n\n * 解析器将模板解析为抽象语树 AST，只有将模板解析成 AST 后，才能基于它做优化或者生成代码字符串。\n\nconst ast = parse(template.trim(), options)\n\n//src\\compiler\\parser\\index.js\nparse()\n\n\n# 优化-optimize\n\n * 优化抽象语法树，检测子节点中是否是纯静态节点\n * 一旦检测到纯静态节点，例如永远不会更改的节点\n   * 提升为常量，重新渲染的时候不在重新创建节点\n   * 在 patch 的时候直接跳过静态子树\n\n# 生成-generate\n\n// src\\compiler\\index.js\nconst code = generate(ast, options)\n\n// src\\compiler\\codegen\\index.js\nexport function generate (\n  ast: ASTElement | void,\n  options: CompilerOptions\n): CodegenResult {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns // 静态根节点对应的渲染函数\n  }\n}\n\n// 把字符串转换成函数\n// src\\compiler\\to-function.js\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n} }\n\n\n参考链接\n\n * vue-loader\n\n * 多图详解，一次性搞懂Webpack Loader\n\n * 图解 VueLoader : .vue 文件是如何被打包的?\n\n * vue-loader都做了些什么\n\n * 深入 vue-loader 原理\n\n * Webpack 案例 —— vue-loader 原理分析",normalizedContent:"# vue-loader原理解析\n\n\n# vue-loader\n\n> vue-loader 是用于 webpack 的加载器，允许你用 single-file components 单文件组件的格式来写 vue 组件。其作用就是提取 *.vue 文件中的template，script，style等，再通过 vue-template-compiler，style-loader 等插件，最终形成一个可以在浏览器中运行的 js 文件。\n\n\n# vue-loader 处理 sfc\n\n * 首先 vue-loader 是怎么处理 sfc 的？他会使用 @vue/component-compiler-utils （下文会介绍）将 sfc 源码解析成 sfc 描述符 ，源码地址\n\n// vue-loader lib/index.js\nconst { parse } = require('@vue/component-compiler-utils');\n\nmodule.exports = function (source) {\n  // 解析源码，得到描述符\n  const descriptor = parse({ source, ... });\n\t\n  // 打印结果\n  console.log(descriptor);\n  /**\n  \tdescriptor {\n      template: { ... },\n      script: { ... },\n      styles: [ ... ],\n      customblocks: [],\n      errors: []\n    }\n  */\n}\n\n\n * 然后根据 sfc描述符 为每个语言块进行处理，源码地址\n\n  // 如果 template 块存在\n  if (descriptor.template) { ... }\n  // 如果 script 块存在\n  if (descriptor.script) { ... }\n  // 如果 style 块存在（支持多 style 块）\n  if (descriptor.styles.length) { ... }\n  // vue 还支持自定义块\n  if (descriptor.customblocks && descriptor.customblocks.length) { ... }\n\n\n * 处理后打印出的结果：\n\n// 从主加载程序返回的代码source.vue的代码\n\n// import the <template> block\nimport render from 'source.vue?vue&type=template'\n\n// import the <script> block\nimport script from 'source.vue?vue&type=script'\nexport * from 'source.vue?vue&type=script'\n\n// import <style> blocks\nimport 'source.vue?vue&type=style&index=1'\n\nscript.render = render\nexport default script\n\n\n * 以上就是使用 vue-loader 处理 sfc 的结果，那么问题来了语句中?vue&type=template 的作用是什么？这首先需要了解一下 pitch loader 和 vueloaderplugin\n\n\n# pitch loader\n\n * normal loader：loader 本质上是导出函数的 javascript 模块，而该模块导出的函数（若是 es6 模块，则是默认导出的函数）就被称为 normal loader。需要注意的是， normal loader 与 webpack loader 分类中定义的 loader 是不一样的。在 webpack 中，loader 可以被分为 4 类：pre 前置、post 后置、normal 普通和 inline 行内。其中 pre 和 post loader，可以通过 rule 对象的 enforce 属性来指定\n * pitch loader：在开发 loader 时，我们可以在导出的函数上添加一个 pitch 属性，它的值也是一个函数。该函数被称为 pitching loader\n\n请看例子，我们定义 3 个 loader：\n\n// aloader\nfunction aloader(content, map, meta) {\n  console.log(\"开始执行aloader normal loader\");\n  content += \"aloader]\";\n  return `module.exports = '${content}'`;\n}\n\naloader.pitch = function (remainingrequest, precedingrequest, data) {\n  console.log(\"开始执行aloader pitching loader\");\n};\n\n// bloader\nfunction bloader(content, map, meta) {\n  console.log(\"开始执行bloader normal loader\");\n  return content + \"bloader->\";\n}\n\nbloader.pitch = function (remainingrequest, precedingrequest, data) {\n  console.log(\"开始执行bloader pitching loader\");\n};\n\n// cloader\nfunction cloader(content, map, meta) {\n  console.log(\"开始执行cloader normal loader\");\n  return content + \"[cloader->\";\n}\n\ncloader.pitch = function (remainingrequest, precedingrequest, data) {\n  console.log(\"开始执行cloader pitching loader\");\n};\n\n// config\nmodule: {\n  rules: [\n    {\n      test: /.txt$/i,\n      use: [\"a-loader\", \"b-loader\", \"c-loader\"],\n    },\n  ],\n},\n\n\npitching loader 和 normal loader 的执行顺序：\n\n开始执行aloader pitching loader\n...\n开始执行bloader pitching loader\n...\n开始执行cloader pitching loader\n...\n开始执行cloader normal loader\n开始执行bloader normal loader\n开始执行aloader normal loader\n\n\n很明显对于我们的示例来说，pitching loader 的执行顺序是 从左到右，而 normal loader 的执行顺序是 从右到左。其实pitching loader的另一个作用是当某个 pitching loader 返回非 undefined 值时，就会实现熔断效果。例如在 bloader.pitch 中返回值时，执行效果会如下图所示：\n\n\n\n\n# vueloaderplugin\n\n> 我们知道 webpack 插件的作用是能够 hook 到在每个编译(compilation)中触发的所有关键事件，并且在插件实例的 apply 方法中，可以通过 compiler.options 获取 webpack 配置，并进行修改。\n\nvueloaderplugin 的处理流程中，修改了 module.rules，在原来的规则基础上加入了 pitcher 和 clonerules 。新增的 rule ，能识别形如 ?vue&type=template 的 querystring，让不同语言的代码块匹配到对应的 rule。\n\nclass vueloaderplugin {\n  apply (compiler) {\n    // 对 webpack 配置进行修改\n    const rawrules = compiler.options.module.rules;\n    const { rules } = new ruleset(rawrules);\n    ...\n    \n    // pitcher\n    const pitcher = {\n      loader: require.resolve('./loaders/pitcher'),\n      resourcequery: query => {\n        if (!query) { return false }\n        const parsed = qs.parse(query.slice(1))\n        // 匹配第一个查询条件是否是 vue\n        return parsed.vue != null\n      },\n      options: { ... }\n    }\n\n    // 替换初始 module.rules，在原有 rule 上，增加 pitcher、clonedrules\n    compiler.options.module.rules = [\n       pitcher,\n       ...clonedrules,\n       ...rules\n     ];\n  }\n}\n\n\n\n\n * 在这里由于我们注入了 pitcher 规则，上面的 source.vue?vue&type=script 被 pitcher 规则匹配到，就会被 pitch函数 处理，且 pitch 中返回了结果，由于熔断机制会跳过剩余的 loader。这个函数根据参数 type 来生成 行内lodaer ：\n\nexport * from \"-!../../node_modules/vue-loader/lib/loaders/templateloader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=template&id=21fec300&\"\n\n\n * 行内loader 按照从右到左的顺序执行，在得到上述的 request 之后，webpack会先使用 vue-loader 处理，然后再使用 template-loader 来处理，最终得到的就是 render 函数。\n\n> 在 pitchloader 的转化结果中，还是会以 vue-loader 作为第一个处理的 loader，与第一次 vue-loader 处理不同的是，这次 vue-loader 的作用，仅仅是把 sfc 中语法块的源码提取出来，并交给后面的 loader 进行处理。\n\n\n\n\n# @vue/component-compiler-utils\n\n> 用来编译 vue 单文件组件\n\n@vue/component-compiler-utils 的作用是解析 vue sfc 并分别得到 html(模板) 和 javascript(script块) 的源码。对于 html 源码我们可以再次使用 vue-template-compiler 模块将其解析为模板对应的 render函数。\n\n\n# api\n\n# parse(parseoptions): sfcdescriptor\n\n将 sfc 解析为一个带有 source map 的 sfc 描述器。编译器 (vue-template-compiler) 通过 compiler 传入。\n\ninterface parseoptions {\n  source: string\n  filename?: string\n  compiler: vuetemplatecompiler\n  // https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#compilerparsecomponentfile-options\n  // default: { pad: 'line' }\n  compilerparseoptions?: vuetemplatecompilerparseoptions\n  sourceroot?: string\n  needmap?: boolean\n}\n\ninterface sfcdescriptor {\n  template: sfcblock | null\n  script: sfcblock | null\n  styles: sfcblock[]\n  customblocks: sfccustomblock[]\n}\n\ninterface sfccustomblock {\n  type: string\n  content: string\n  attrs: { [key: string]: string | true }\n  start: number\n  end: number\n  map?: rawsourcemap\n}\n\ninterface sfcblock extends sfccustomblock {\n  lang?: string\n  src?: string\n  scoped?: boolean\n  module?: string | boolean\n}\n\n\n# compiletemplate(templatecompileoptions): templatecompileresults\n\n将 template 编译为 javascript 代码。编译器 (vue-template-compiler) 通过 compiler 选项被传入。\n\n它也可以通过 consolidate 可选地为任何模板引擎进行预处理。\n\ninterface templatecompileoptions {\n  source: string\n  filename: string\n\n  compiler: vuetemplatecompiler\n  https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#compilercompiletemplate-options\n  // default: {}\n  compileroptions?: vuetemplatecompileroptions\n\n  // template preprocessor\n  preprocesslang?: string\n  preprocessoptions?: any\n\n  // 将模板里找到的资源 url 转换为 `require()` 调用\n  // 这个选项默认是关闭的。如果设置为 true，则默认值为：\n  // {\n  //   video: ['src', 'poster'],\n  //   source: 'src',\n  //   img: 'src',\n  //   image: 'xlink:href'\n  //   use: 'xlink:href'\n  // }\n  transformasseturls?: asseturloptions | boolean\n\n  // 为 vue-template-es2015-compiler，即一个 buble 的 fork，指定的选项\n  transpileoptions?: any\n\n  isproduction?: boolean  // default: false\n  isfunctional?: boolean  // default: false\n  optimizessr?: boolean   // default: false\n\n  // 是否美化编译后的渲染函数 (只在开发环境下有效)\n  // 默认值：true\n  prettify?: boolean\n}\n\ninterface templatecompileresult {\n  code: string\n  source: string\n  tips: string[]\n  errors: string[]\n}\n\ninterface asseturloptions {\n  [name: string]: string | string[]\n}\n\n\n处理得到的 javascript 代码形如；\n\nvar render = function (h) { /* ... */}\nvar staticrenderfns = [function (h) { /* ... */}, function (h) { /* ... */}]\n\n\n它不会假定任何模块系统。你要在必要的时候负责处理导出。\n\n# compilestyle(stylecompileoptions)\n\n将输入的原始 css 进行 scoped css 转换。它不会处理预处理器。如果组件没有使用 scoped css 那么这一步会被跳过。\n\ninterface stylecompileoptions {\n  source: string\n  filename: string\n  id: string\n  map?: any\n  scoped?: boolean\n  trim?: boolean\n  preprocesslang?: string\n  preprocessoptions?: any\n  postcssoptions?: any\n  postcssplugins?: any[]\n}\n\ninterface stylecompileresults {\n  code: string\n  map: any | void\n  rawresult: lazyresult | void // 来自 postcss 的懒处理原始结果\n  errors: string[]\n}\n\n\n# compilestyleasync(stylecompileoptions)\n\n和 compilestyle(stylecompileoptions) 相同，但是返回一个解析 stylecompileresults 的 promise 对象。可用于异步的 postcss 插件。\n\n\n# vue-template-compiler\n\n\n\n模板编译的作用是将模板（template）转换为渲染函数（render），template => ast => render\n\n * 模板\n\n<div>\n  <h1 @click=\"handler\">title</h1>\n  <p>some content</p>\n</div>\n\n\n * 渲染函数\n\nrender (h) {\n  return h('div', [\n    h('h1', { on: { click: this.handler } }, 'title'),\n    h('p', 'some content')\n  ])\n}\n\n\n渲染函数中的 h 函数内部调用 vm.$createelement 生成虚拟 dom\n\n\n# 模板编译的作用\n\n * vue 2.x 中使用 vnode 描述视图以及各种操作，但是不可能让用户自己写 vnode 或者 渲染函数，用户只需要写类似 html 代码，通过编译器将模板转换成返回 vnode 的 render 函数\n\n * .vue文件会被 webpack 构建过程中转换成 render 函数，webpack 本身是不支持转换的，是通过 vue-loader来支持的\n\n * 运行时编译：运行时编译的前提是必须使用完整版的 vue（包含编译器），会在项目运行的过程中把模板编译成 render 函数，但是缺点是 vue 体积过大。\n\n * 构建时编译：vue-cli自带的是运行时版本的 vue，使用 webpack + vue-loader完成编译，这样不仅体积小而且运行时不需要额外操作时间更快。\n\n\n# 体验模板编译的结果\n\n * 带编译器版本的 vue.js 中，使用 template 或 el 的方式设置模板\n\n<div id=\"app\">\n  <h1>vue<span>模板编译过程</span></h1>\n  <p>{{ msg }}</p>\n\t<comp @myclick=\"handler\"></comp>\n</div>\n<script src=\"../../dist/vue.js\"><\/script>\n<script>\n  vue.component('comp', {\n    template: '<div>i am a comp</div>'\n  })\n  const vm = new vue({\n    el: '#app',\n    data: {\n      msg: 'hello compiler'\n    },\n    methods: {\n      handler () {\n        console.log('test')\n      }\n     } \n  })\n  console.log(vm.$options.render)\n<\/script>\n\n\n * 编译后 render 输出的结果\n\n(function anonymous() {\n  with (this) {\n    return _c(\n      \"div\",\n      { attrs: { id: \"app\" } },\n      [\n        _m(0),\n        _v(\" \"),\n        _c(\"p\", [_v(_s(msg))]),\n        _v(\" \"),\n        _c(\"comp\", { on: { myclick: handler } }),\n\t\t\t],\n\t\t\t1\n\t\t);\n  }\n});\n\n\n> _c： createelement\n> \n> _m：renderstatic，处理静态节点\n> \n> _v：createtextvnode，处理文本节点\n> \n> _s：处理字符串\n\n\n# vue template explorer\n\n * vue-template-explorer：vue 2.6 把模板编译成 render 函数的工具\n * vue-next-template-explorer：vue 3.0 beta 把模板编译成 render 函数的工具\n\n\n# 模板编译过程\n\n * 解析、优化、生成\n\n# 编译入口\n\n * src\\platforms\\web\\entry-runtime-with-compiler.js\n\nvue.prototype.$mount = function (\n  ......\n// 把 template 转换成 render 函数\nconst { render, staticrenderfns } = compiletofunctions(template, {\n    outputsourcerange: process.env.node_env !== 'production',\n    shoulddecodenewlines,\n    shoulddecodenewlinesforhref,\n    delimiters: options.delimiters,\n    comments: options.comments\n  }, this)\n  options.render = render\n  options.staticrenderfns = staticrenderfns\n  ......\n)\n\n\n * 调试 compiletofunctions() 执行过程，生成渲染函数的过程：\n   * compiletofunctions: src\\compiler\\to-function.js\n   * complie(template, options):src\\compiler\\create-compiler.js，主要作用是合并 options\n   * basecompile(template.trim(), finaloptions):src\\compiler\\index.js，核心编译函数\n\nexport const createcompiler = createcompilercreator(function basecompile (\n  template: string,\n  options: compileroptions\n): compiledresult {\n  // 把模板转换成 ast 抽象语法树\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化抽象语法树\n    optimize(ast, options)\n  }\n  // 把抽象语法树生成字符串形式的 js 代码\n  const code = generate(ast, options)\n  return {\n    ast,\n    // 渲染函数\n    render: code.render,\n    // 静态渲染函数，生成静态 vnode 树\n    staticrenderfns: code.staticrenderfns\n  }\n})\n\n\n# 解析-parse\n\n * 解析器将模板解析为抽象语树 ast，只有将模板解析成 ast 后，才能基于它做优化或者生成代码字符串。\n\nconst ast = parse(template.trim(), options)\n\n//src\\compiler\\parser\\index.js\nparse()\n\n\n# 优化-optimize\n\n * 优化抽象语法树，检测子节点中是否是纯静态节点\n * 一旦检测到纯静态节点，例如永远不会更改的节点\n   * 提升为常量，重新渲染的时候不在重新创建节点\n   * 在 patch 的时候直接跳过静态子树\n\n# 生成-generate\n\n// src\\compiler\\index.js\nconst code = generate(ast, options)\n\n// src\\compiler\\codegen\\index.js\nexport function generate (\n  ast: astelement | void,\n  options: compileroptions\n): codegenresult {\n  const state = new codegenstate(options)\n  const code = ast ? genelement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticrenderfns: state.staticrenderfns // 静态根节点对应的渲染函数\n  }\n}\n\n// 把字符串转换成函数\n// src\\compiler\\to-function.js\nfunction createfunction (code, errors) {\n  try {\n    return new function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n} }\n\n\n参考链接\n\n * vue-loader\n\n * 多图详解，一次性搞懂webpack loader\n\n * 图解 vueloader : .vue 文件是如何被打包的?\n\n * vue-loader都做了些什么\n\n * 深入 vue-loader 原理\n\n * webpack 案例 —— vue-loader 原理分析",charsets:{cjk:!0}},{title:"Vuex",frontmatter:{title:"Vuex",date:"2020-10-22T11:27:54.000Z",categories:"Vue"},regularPath:"/vue/vuex.html",relativePath:"vue/vuex.md",key:"v-f35fd416",path:"/vue/vuex.html",headers:[{level:2,title:"什么是 Vuex",slug:"什么是-vuex",normalizedTitle:"什么是 vuex",charIndex:11},{level:2,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:23},{level:2,title:"vue-devtools",slug:"vue-devtools",normalizedTitle:"vue-devtools",charIndex:31},{level:2,title:"模拟 Vuex",slug:"模拟-vuex",normalizedTitle:"模拟 vuex",charIndex:47}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"什么是 Vuex 核心概念 vue-devtools 模拟 Vuex",content:"# Vuex\n\n * 什么是 Vuex\n * 核心概念\n * vue-devtools\n * 模拟 Vuex\n\n\n# 什么是 Vuex\n\n * Vuex 是专门为 Vue.js 设计的状态管理库\n * 它采用集中式的方式存储需要共享的数据\n * 从使用角度，它就是一个 JavaScript 库\n * 它的作用是进行状态管理，解决复杂组件通信，数据共享\n * 如果不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。\n * 官网\n\n\n# 核心概念\n\n每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：\n\n 1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n\n * State：单一状态树，用一个对象就包含了全部的应用层级状态。它作为一个“唯一数据源”而存在。\n\n * Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n * Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation\n   \n   * 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：\n     \n     // ...\n     mutations: {\n       increment (state, n) {\n         state.count += n\n       }\n     }\n     \n     store.commit('increment', 10)\n     \n   \n   * 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n     \n     // mutation-types.js\n     export const SOME_MUTATION = 'SOME_MUTATION'\n     \n     // store.js\n     import Vuex from 'vuex'\n     import { SOME_MUTATION } from './mutation-types'\n     \n     const store = new Vuex.Store({\n       state: { ... },\n       mutations: {\n         // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n         [SOME_MUTATION] (state) {\n           // mutate state\n         }\n       }\n     })\n         \n     // JavaScript语言定义对象的属性，有两种方法\n         \n     // 方法一\n     obj.foo = true;\n     \n     // 方法二\n     obj['a' + 'bc'] = 123;\n     \n\n * Action：Action 类似于 mutation，不同在于：\n   \n   * Action 提交的是 mutation，而不是直接变更状态。\n   \n   * Action 可以包含任意异步操作。\n     \n     const store = new Vuex.Store({\n       state: {\n         count: 0\n       },\n       mutations: {\n         increment (state) {\n           state.count++\n         }\n       },\n       actions: {\n         increment (context) {\n           context.commit('increment')\n         }\n       }\n     })\n     \n   \n   * Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）\n     \n     actions: {\n       increment ({ commit }) {\n         commit('increment')\n       }\n     }\n     \n   \n   * Actions 支持同样的载荷方式和对象方式进行分发：\n     \n     // 以载荷形式分发\n     store.dispatch('incrementAsync', {\n       amount: 10\n     })\n     \n     // 以对象形式分发\n     store.dispatch({\n       type: 'incrementAsync',\n       amount: 10\n     })\n     \n\n * Module：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n   \n   * 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\n\n * 具体使用请看官方文档\n\n\n# vue-devtools\n\nvue-devtools是一款基于chrome浏览器的插件,用于vue应用的调试,帮助我们快速的调试开发vue应用\n\n\n# 模拟 Vuex\n\nlet _Vue = null\nclass Store {\n  constructor (options) {\n    const {\n      state = {},\n      getters = {},\n      mutations = {},\n      actions = {}\n    } = options\n    this.state = _Vue.observable(state)\n    this.getters = Object.create(null)\n    Object.keys(getters).forEach(key => {\n      Object.defineProperty(this.getters, key, {\n        get: () => getters[key](state)\n      })\n    })\n    this._mutations = mutations\n    this._actions = actions\n  }\n\n  commit (type, payload) {\n    this._mutations[type](this.state, payload)\n  }\n\n  dispatch (type, payload) {\n    this._actions[type](this, payload)\n  }\n}\n\nfunction install (Vue) {\n  _Vue = Vue\n  _Vue.mixin({\n    beforeCreate () {\n      if (this.$options.store) {\n        _Vue.prototype.$store = this.$options.store\n      }\n    }\n  })\n}\n\nexport default {\n  Store,\n  install\n}\n\n\n * 测试\n\nimport Vue from 'vue'\nimport Vuex from '../myvuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state: {\n    count: 0,\n    msg: 'Hello World'\n  },\n  getters: {\n    reverseMsg (state) {\n      return state.msg.split('').reverse().join('')\n    }\n  },\n  mutations: {\n    increate (state, payload) {\n      state.count += payload\n    }\n  },\n  actions: {\n    increateAsync (context, payload) {\n      setTimeout(() => {\n        context.commit('increate', payload)\n      }, 2000)\n    }\n  }\n})\n",normalizedContent:"# vuex\n\n * 什么是 vuex\n * 核心概念\n * vue-devtools\n * 模拟 vuex\n\n\n# 什么是 vuex\n\n * vuex 是专门为 vue.js 设计的状态管理库\n * 它采用集中式的方式存储需要共享的数据\n * 从使用角度，它就是一个 javascript 库\n * 它的作用是进行状态管理，解决复杂组件通信，数据共享\n * 如果不打算开发大型单页应用，使用 vuex 可能是繁琐冗余的。\n * 官网\n\n\n# 核心概念\n\n每一个 vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。vuex 和单纯的全局对象有以下两点不同：\n\n 1. vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\nimport vue from 'vue'\nimport vuex from 'vuex'\n\nvue.use(vuex);\n\nconst store = new vuex.store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n\n * state：单一状态树，用一个对象就包含了全部的应用层级状态。它作为一个“唯一数据源”而存在。\n\n * getter：vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n * mutation：更改 vuex 的 store 中的状态的唯一方法是提交 mutation\n   \n   * 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：\n     \n     // ...\n     mutations: {\n       increment (state, n) {\n         state.count += n\n       }\n     }\n     \n     store.commit('increment', 10)\n     \n   \n   * 使用常量替代 mutation 事件类型在各种 flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n     \n     // mutation-types.js\n     export const some_mutation = 'some_mutation'\n     \n     // store.js\n     import vuex from 'vuex'\n     import { some_mutation } from './mutation-types'\n     \n     const store = new vuex.store({\n       state: { ... },\n       mutations: {\n         // 我们可以使用 es2015 风格的计算属性命名功能来使用一个常量作为函数名\n         [some_mutation] (state) {\n           // mutate state\n         }\n       }\n     })\n         \n     // javascript语言定义对象的属性，有两种方法\n         \n     // 方法一\n     obj.foo = true;\n     \n     // 方法二\n     obj['a' + 'bc'] = 123;\n     \n\n * action：action 类似于 mutation，不同在于：\n   \n   * action 提交的是 mutation，而不是直接变更状态。\n   \n   * action 可以包含任意异步操作。\n     \n     const store = new vuex.store({\n       state: {\n         count: 0\n       },\n       mutations: {\n         increment (state) {\n           state.count++\n         }\n       },\n       actions: {\n         increment (context) {\n           context.commit('increment')\n         }\n       }\n     })\n     \n   \n   * action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。实践中，我们会经常用到 es2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）\n     \n     actions: {\n       increment ({ commit }) {\n         commit('increment')\n       }\n     }\n     \n   \n   * actions 支持同样的载荷方式和对象方式进行分发：\n     \n     // 以载荷形式分发\n     store.dispatch('incrementasync', {\n       amount: 10\n     })\n     \n     // 以对象形式分发\n     store.dispatch({\n       type: 'incrementasync',\n       amount: 10\n     })\n     \n\n * module：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n   \n   * 为了解决以上问题，vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\n\n * 具体使用请看官方文档\n\n\n# vue-devtools\n\nvue-devtools是一款基于chrome浏览器的插件,用于vue应用的调试,帮助我们快速的调试开发vue应用\n\n\n# 模拟 vuex\n\nlet _vue = null\nclass store {\n  constructor (options) {\n    const {\n      state = {},\n      getters = {},\n      mutations = {},\n      actions = {}\n    } = options\n    this.state = _vue.observable(state)\n    this.getters = object.create(null)\n    object.keys(getters).foreach(key => {\n      object.defineproperty(this.getters, key, {\n        get: () => getters[key](state)\n      })\n    })\n    this._mutations = mutations\n    this._actions = actions\n  }\n\n  commit (type, payload) {\n    this._mutations[type](this.state, payload)\n  }\n\n  dispatch (type, payload) {\n    this._actions[type](this, payload)\n  }\n}\n\nfunction install (vue) {\n  _vue = vue\n  _vue.mixin({\n    beforecreate () {\n      if (this.$options.store) {\n        _vue.prototype.$store = this.$options.store\n      }\n    }\n  })\n}\n\nexport default {\n  store,\n  install\n}\n\n\n * 测试\n\nimport vue from 'vue'\nimport vuex from '../myvuex'\n\nvue.use(vuex)\n\nexport default new vuex.store({\n  state: {\n    count: 0,\n    msg: 'hello world'\n  },\n  getters: {\n    reversemsg (state) {\n      return state.msg.split('').reverse().join('')\n    }\n  },\n  mutations: {\n    increate (state, payload) {\n      state.count += payload\n    }\n  },\n  actions: {\n    increateasync (context, payload) {\n      settimeout(() => {\n        context.commit('increate', payload)\n      }, 2000)\n    }\n  }\n})\n",charsets:{cjk:!0}},{title:"Vue Router",frontmatter:{title:"Vue Router",date:"2020-09-13T14:47:00.000Z",categories:"Vue"},regularPath:"/vue/vue-router.html",relativePath:"vue/vue-router.md",key:"v-1213428e",path:"/vue/vue-router.html",headers:[{level:2,title:"Vue Router 使用步骤",slug:"vue-router-使用步骤",normalizedTitle:"vue router 使用步骤",charIndex:17},{level:2,title:"动态路由",slug:"动态路由",normalizedTitle:"动态路由",charIndex:36},{level:2,title:"嵌套路由",slug:"嵌套路由",normalizedTitle:"嵌套路由",charIndex:44},{level:2,title:"编程式导航的几种方法",slug:"编程式导航的几种方法",normalizedTitle:"编程式导航的几种方法",charIndex:3941},{level:2,title:"hash模式和history模式",slug:"hash模式和history模式",normalizedTitle:"hash模式和history模式",charIndex:61},{level:3,title:"history模式的使用",slug:"history模式的使用",normalizedTitle:"history模式的使用",charIndex:4341},{level:3,title:"hash模式的使用",slug:"hash模式的使用",normalizedTitle:"hash模式的使用",charIndex:5035},{level:2,title:"模拟实现 Vue Route",slug:"模拟实现-vue-route",normalizedTitle:"模拟实现 vue route",charIndex:81},{level:2,title:"模拟hash模式vueRouter",slug:"模拟hash模式vuerouter",normalizedTitle:"模拟hash模式vuerouter",charIndex:10324}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"Vue Router 使用步骤 动态路由 嵌套路由 编程式导航的几种方法 hash模式和history模式 history模式的使用 hash模式的使用 模拟实现 Vue Route 模拟hash模式vueRouter",content:"# Vue Router\n\n * Vue Router 使用步骤\n * 动态路由\n * 嵌套路由\n * 编程式导航\n * hash模式和history模式\n * 模拟实现 Vue Router\n\n\n# Vue Router 使用步骤\n\n├───public\n└───src\n    ├───assets\n    ├───components\n    ├───router\n    \t  ├───index.js\n    ├───views\n    \t  ├───Blog.vue\n    \t  ├───Index.vue\n    \t  ├───Photo.vue\n    ├───App.vue\n    └───main.js\n\n\n// router/index.js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Index from '../views/Index.vue'\n// 1. 注册路由插件\nVue.use(VueRouter)\n\n// 路由规则\nconst routes = [\n  {\n    path: '/',\n    name: 'Index',\n    component: Index\n  },\n  {\n    path: '/blog',\n    name: 'Blog',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"blog\" */ '../views/Blog.vue')\n  },\n  {\n    path: '/photo',\n    name: 'Photo',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"photo\" */ '../views/Photo.vue')\n  }\n]\n// 2. 创建 router 对象\nconst router = new VueRouter({\n  routes\n})\n\nexport default router\n\n\n// main.js\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\nVue.config.productionTip = false\n\nnew Vue({\n  // 3. 注册 router 对象\n  router,\n  render: h => h(App)\n}).$mount('#app')\n\n\n\x3c!-- App.vue --\x3e\n<template>\n  <div id=\"app\">\n    <div>\n      <img src=\"@/assets/logo.png\" alt=\"\">\n    </div>\n    <div id=\"nav\">\n      \x3c!-- 5. 创建链接 --\x3e\n      <router-link to=\"/\">Index</router-link> |\n      <router-link to=\"/blog\">Blog</router-link> |\n      <router-link to=\"/photo\">Photo</router-link>\n    </div>\n    \x3c!-- 4. 创建路由组建的占位 --\x3e\n    <router-view/>\n  </div>\n</template>\n\n\n> router-view 是用来渲染通过路由映射过来的组件，当路径更改时， 中的内容也会发生更改\n> \n> 主要应用于单页面中，与router-link配合，渲染router-link 映射过来的组件。\n\n\n# 动态路由\n\n在vue项目中，使用vue-router如果进行不传递参数的路由模式，则称为静态路由；如果能够传递参数，对应的路由数量是不确定的，此时的路由称为动态路由。动态路由，是以冒号为开头的(😃，例子如下：\n\n// index.js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Index from '../views/Index.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path: '/',\n    name: 'Index',\n    component: Index\n  },\n  {\n    path: '/detail/:id', // id占位符\n    name: 'Detail',\n    // 开启 props，会把 URL 中的参数传递给组件\n    // 在组件中通过 props 来接收 URL 参数\n    props: true,\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    // 只有使用的时候才加载详情页\n    component: () => import(/* webpackChunkName: \"detail\" */ '../views/Detail.vue')\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nexport default router\n\n\n\x3c!-- App.vue --\x3e\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/\">Index</router-link> |\n      <router-link to=\"/detail/11\">Detail</router-link>\n    </div>\n    <router-view/>\n  </div>\n</template>\n\n\x3c!-- Detail.vue --\x3e\n<template>\n  <div>\n    \x3c!-- 方式1： 通过当前路由规则，获取数据 --\x3e\n    通过当前路由规则获取：{{ $route.params.id }}\n\n    <br>\n    \x3c!-- 方式2：路由规则中开启 props 传参 --\x3e\n    通过开启 props 获取：{{ id }}\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Detail',\n  props: ['id']\n}\n<\/script>\n\n\n\n# 嵌套路由\n\n\n\n> 抽取公共组件 layout.vue 存储 header 和 footer\n\n//index.js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\n// 加载组件\nimport Layout from '@/components/Layout.vue'\nimport Index from '@/views/Index.vue'\nimport Login from '@/views/Login.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    name: 'login',\n    path: '/login',\n    component: Login\n  },\n  // 嵌套路由\n  {\n    path: '/',\n    component: Layout,\n    children: [\n      {\n        name: 'index',\n        path: '',\n        component: Index\n      },\n      {\n        name: 'detail',\n        path: 'detail/:id',\n        props: true,\n        component: () => import('@/views/Detail.vue')\n      }\n    ]\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nexport default router\n\n\n\n# 编程式导航的几种方法\n\n * this.$router.push：跳转到指定URL，向history栈添加一个新的记录，点击后退会返回至上一个页面\n\n * this.$router.replace：跳转到指定URL，替换history栈中最后一个记录，点击后退会返回至上上一个页面\n\n * this.$router.go(n)：向前或向后跳转n个页面，n可正（向后跳转）可负（向前跳转）\n\nthis.$router.push({ name: 'Detail', params: { id: 1 } })\nthis.$router.replace('/login')\nthis.$router.go(-2)\n\n// 返回主页\nthis.$router.push('/')\n// this.$router.push({ name: 'Home' })\n\n\n\n# hash模式和history模式\n\n\n# history模式的使用\n\n * 通过history.pushState()方法改变地址栏\n\n * 监听popstate事件\n\n * 根据当前路由地址找到对应组件进行重新渲染\n\n * History需要服务器的支持\n\n * 单页应用中，服务端不存在http:www.testurl.com/login这样的地址会返回找不到该页面\n\n * 在服务端应该除了静态资源外都返回单页应用的index.html\n\n// 这是一个简单的 node 服务器\nconst path = require('path')\n// 导入处理 history 模式的模块\nconst history = require('connect-history-api-fallback')\n// 导入 express\nconst express = require('express')\n\nconst app = express()\n// 注册处理 history 模式的中间件，一旦客户端请求不存在的地址，服务端都会返回单页的index.html\napp.use(history())\n// 处理静态资源的中间件，网站根目录 ../web\napp.use(express.static(path.join(__dirname, '../web')))\n\n// 开启服务器，端口是 3000\napp.listen(3000, () => {\n  console.log('服务器开启，端口：3000')\n})\n\n\n同样的在nginx服务器中也可以配置返回index.html，客户端来判断路由地址对应展示内容。\n\n\n# hash模式的使用\n\n * URL中#后面的内容作为路径地址\n * 监听hashchange事件\n * 根据当前路由地址找到对应组件重新渲染\n\n\n# 模拟实现 Vue Route\n\n前置知识：\n\n * vue的构建版本\n\n> 运行时版：不支持 template 模板，需要打包的时候提前编译，如果你打包的时候是用vue-loader 或者 vueify，将`*.vue文件内的templates编译成JavaScript代码， 你就不需要compiler, 可以使用 runtime-only版本编译。\n> \n> 完整版：包含运行时和编译器，体积比运行时版大10K左右，程序运行时把模板转换成render函数\n> \n> vue-cli默认创建运行时版\n\n * slot插槽\n\n\t<div id = \"app\">\n        <aaa>\n            <p slot = \"s1\">在上面的内容</p>\n            <p slot = \"s2\">在下面的内容</p>\n        </aaa>\n    </div>\n\t\n\t\x3c!-- 子组件 --\x3e\n    <template id=\"aaa\">\n        <div class = \"aaa\">\n            <slot name = \"s1\"></slot>\n            <p>我是aaa组件</p>\n            <slot name = \"s2\"></slot>\n        </div>\n    </template>\n\n\n * 混入mixin\n\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项\n\n// 定义一个混入对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// 定义一个使用混入对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // => \"hello from mixin!\"\n\n\n\n * render函数\n\n> 简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM\n> \n> 因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。\n> \n> 当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。官网上给他起了个名字叫createElement。还有约定的简写叫h,\n\n<div>\n    <myslot>\n    \t<p>hello world</p>\n    </myslot>\n</div>\t\n\n<template id=\"myslot\">\n\t<h1 v-if=\"level==1\">\n    \t<slot></slot>    \n    </h1>\n    <h2 v-if=\"level==2\">\n    \t<slot></slot>    \n    </h2>\n    <h3 v-if=\"level==3\">\n    \t<slot></slot>    \n    </h3>\n    <h4 v-if=\"level==4\">\n    \t<slot></slot>    \n    </h4>\n</template>\n\n\n使用render函数将myslot动态生成\n\n'myslot':{\n    render: function(createElement) {\n        return createElement('h' + this.level, this.$slot.default) //h(n),helloworld\n    }\n}\n\n\n * Vue.use(plugin, arguments)\n\n * 参数：plugin(Function | Object)\n\n * 用法： 如果vue安装的组件类型必须为Function或者是Object\n   \n   如果是个对象，必须提供install方法\n   \n   如果是一个函数，会被直接当作install函数执行\n   \n   install函数接受参数，默认第一个参数为Vue,其后参数为注册组件时传入的arguments\n\n实现思路\n\n * 创建VueRouter插件，静态方法 install\n   * 判断插件是否已经被加载\n   * 当Vue加载时把传入的router对象挂载到Vue实例上\n * 创建VueRouter类\n   * 初始化，options，routeMap，app\n   * createRouteMap()遍历所有路由信息，把组件和路由的映射记录到routeMap对象中\n   * 注册popstate事件，当路由地址发生变化，重新记录当前路径\n   * 创建router-link和router-view组件\n   * 当路径改变时，在routerMap中找到对应的组件，渲染router-view\n\nlet _Vue = null\nclass VueRouter {\n    // Vue.use(VueRouter) 表示使用VueRouter插件，调用 install 方法\n    static install(Vue){\n        //1 判断当前插件是否被安装\n        if(VueRouter.install.installed) return;\n        \n        VueRouter.install.installed = true\n        //2 把Vue的构造函数记录在全局，后面使用vue.component时会用到\n        _Vue = Vue\n        \n        //3 把创建Vue的实例传入的router对象注入到Vue实例\n        _Vue.mixin({\n            beforeCreate(){\n                if(this.$options.router){\n                    _Vue.prototype.$router = this.$options.router // 给所有的vue实例添加     \n                \t// $ 一般是vue中自带的，和普通的属性没什么区别\n                    // 在vue的原型上添加一个 $router，令其注册在vue实例上的 router\n                    // 即等于 vue.$options.router\n                } \n            }\n        })\n    }\n    constructor(options){\n        this.options = options\n        this.routeMap = {}\n        // observable\n        this.data = _Vue.observable({ \n            current:\"/\"    // current记录当前路由地址，\"/\"为当前的默认路径，为响应式数据\n        })\n        this.init()\n    }\n    init(){\n        this.createRouteMap()\n        this.initComponent(_Vue)\n        this.initEvent()\n    }\n    createRouteMap(){\n        //遍历所有的路由规则 吧路由规则解析成键值对的形式存储到routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component\n        });\n    }\n    initComponent(Vue){\n        Vue.component(\"router-link\",{\n            props:{\n                to:String\n            },\n            // template: '<a :href=\"to\"><slot></slot></a>'\n            // <router-link to=\"/blog\">Blog</router-link> 就会把Blog替换插槽\n            // 但是上面这种方式在运行时Vue不可用，不支持template\n            // 完整版本的Vue就是把template编译成render函数，所以可以直接写render函数\n            render(h){\n                return h(\"a\",{ // 三个参数：标签，属性，子元素slot\n                    attrs:{\n                        href:this.to\n                    },\n                    on:{\n                        click:this.clickhander\n                    }\n                },[this.$slots.default]) // 默认插槽就是<slot></slot>\n            },\n            methods:{\n                clickhander(e){\n                    history.pushState({},\"\",this.to) // pushState改地址而且不向服务器发请求\n                    this.$router.data.current=this.to\n                    e.preventDefault() // 阻止默认行为\n                }\n            }\n        })\n        const self = this\n        Vue.component(\"router-view\",{\n            render(h){\n                // 获取组件\n                const cm=self.routeMap[self.data.current] // current响应式数据，会重新渲染组件\n                return h(cm)\n            }\n        })\n        \n    }\n    initEvent(){\n        // 点击浏览器的前进后退时，重新获取当前路径并记录到current\n        window.addEventListener(\"popstate\",()=>{\n            this.data.current = window.location.pathname\n        })\n    }\n}\n\n\n * 前端路由是实现单页应用的基础\n\n * 可以通过this.$router对象获取当前路由对象中信息\n\n * window.pushState不会触发popstate时间，浏览器前进后退时会触发\n\n * 当浏览器地址的路由为#/artical，router-link to=\"/artical/101\"生成的超链接的class属性会被设置为exact-active-class中的类样式，因为exact-active-class是用来设置路由地址精确匹配元素的样式\n\n\n# 模拟hash模式vueRouter\n\nlet _Vue = null\nclass VueRouter {\n    // Vue.use(VueRouter) 表示使用VueRouter插件，调用 install 方法\n    static install(Vue){\n        //1 判断当前插件是否被安装\n        if(VueRouter.install.installed) return;\n        \n        VueRouter.install.installed = true\n        //2 把Vue的构造函数记录在全局，后面使用vue.component时会用到\n        _Vue = Vue\n        \n        //3 把创建Vue的实例传入的router对象注入到Vue实例\n        _Vue.mixin({\n            beforeCreate(){\n                if(this.$options.router){\n                    _Vue.prototype.$router = this.$options.router // 给所有的vue实例添加     \n                \t// $ 一般是vue中自带的，和普通的属性没什么区别\n                    // 在vue的原型上添加一个 $router，令其注册在vue实例上的 router\n                    // 即等于 vue.$options.router\n                } \n            }\n        })\n    }\n    constructor(options){\n        this.options = options\n        this.routeMap = {}\n        // observable\n        this.data = _Vue.observable({ \n            current:\"/\"    // current记录当前路由地址，\"/\"为当前的默认路径，为响应式数据\n        })\n        this.init()\n    }\n    init(){\n        this.createRouteMap()\n        this.initComponent(_Vue)\n        this.initEvent()\n    }\n    createRouteMap(){\n        //遍历所有的路由规则 吧路由规则解析成键值对的形式存储到routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component\n        });\n    }\n    initComponent(Vue){\n        Vue.component(\"router-link\",{\n            props:{\n                to:String\n            },\n            // template: '<a :href=\"to\"><slot></slot></a>'\n            // <router-link to=\"/blog\">Blog</router-link> 就会把Blog替换插槽\n            // 但是上面这种方式在运行时Vue不可用，不支持template\n            // 完整版本的Vue就是把template编译成render函数，所以可以直接写render函数\n            render(h){\n                return h(\"a\",{ // 三个参数：标签，属性，子元素slot\n                    attrs:{\n                        href: '#' + this.to\n                    },\n                    on:{\n                        click:this.clickhander\n                    }\n                },[this.$slots.default]) // 默认插槽就是<slot></slot>\n            },\n            methods:{\n                clickhander(e){\n                    window.location.hash = '#' + this.to\n                    this.$router.data.current=this.to\n                    e.preventDefault() // 阻止默认行为\n                }\n            }\n        })\n        const self = this\n        Vue.component(\"router-view\",{\n            render(h){\n                // 获取组件\n                const cm=self.routeMap[self.data.current] // current响应式数据，会重新渲染组件\n                return h(cm)\n            }\n        })\n        \n    }\n    initEvent() {\n        window.addEventListener('load', this.hashChange())\n        window.addEventListener('hashchange', this.hashChange())\n    }\n    hashChange() {\n        if (!window.location.hash) {\n            window.location.hash = '#/'\n        }\n        this.data.current = window.location.hash.substr(1)\n    }\n}\n",normalizedContent:"# vue router\n\n * vue router 使用步骤\n * 动态路由\n * 嵌套路由\n * 编程式导航\n * hash模式和history模式\n * 模拟实现 vue router\n\n\n# vue router 使用步骤\n\n├───public\n└───src\n    ├───assets\n    ├───components\n    ├───router\n    \t  ├───index.js\n    ├───views\n    \t  ├───blog.vue\n    \t  ├───index.vue\n    \t  ├───photo.vue\n    ├───app.vue\n    └───main.js\n\n\n// router/index.js\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\nimport index from '../views/index.vue'\n// 1. 注册路由插件\nvue.use(vuerouter)\n\n// 路由规则\nconst routes = [\n  {\n    path: '/',\n    name: 'index',\n    component: index\n  },\n  {\n    path: '/blog',\n    name: 'blog',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackchunkname: \"blog\" */ '../views/blog.vue')\n  },\n  {\n    path: '/photo',\n    name: 'photo',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackchunkname: \"photo\" */ '../views/photo.vue')\n  }\n]\n// 2. 创建 router 对象\nconst router = new vuerouter({\n  routes\n})\n\nexport default router\n\n\n// main.js\nimport vue from 'vue'\nimport app from './app.vue'\nimport router from './router'\n\nvue.config.productiontip = false\n\nnew vue({\n  // 3. 注册 router 对象\n  router,\n  render: h => h(app)\n}).$mount('#app')\n\n\n\x3c!-- app.vue --\x3e\n<template>\n  <div id=\"app\">\n    <div>\n      <img src=\"@/assets/logo.png\" alt=\"\">\n    </div>\n    <div id=\"nav\">\n      \x3c!-- 5. 创建链接 --\x3e\n      <router-link to=\"/\">index</router-link> |\n      <router-link to=\"/blog\">blog</router-link> |\n      <router-link to=\"/photo\">photo</router-link>\n    </div>\n    \x3c!-- 4. 创建路由组建的占位 --\x3e\n    <router-view/>\n  </div>\n</template>\n\n\n> router-view 是用来渲染通过路由映射过来的组件，当路径更改时， 中的内容也会发生更改\n> \n> 主要应用于单页面中，与router-link配合，渲染router-link 映射过来的组件。\n\n\n# 动态路由\n\n在vue项目中，使用vue-router如果进行不传递参数的路由模式，则称为静态路由；如果能够传递参数，对应的路由数量是不确定的，此时的路由称为动态路由。动态路由，是以冒号为开头的(😃，例子如下：\n\n// index.js\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\nimport index from '../views/index.vue'\n\nvue.use(vuerouter)\n\nconst routes = [\n  {\n    path: '/',\n    name: 'index',\n    component: index\n  },\n  {\n    path: '/detail/:id', // id占位符\n    name: 'detail',\n    // 开启 props，会把 url 中的参数传递给组件\n    // 在组件中通过 props 来接收 url 参数\n    props: true,\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    // 只有使用的时候才加载详情页\n    component: () => import(/* webpackchunkname: \"detail\" */ '../views/detail.vue')\n  }\n]\n\nconst router = new vuerouter({\n  routes\n})\n\nexport default router\n\n\n\x3c!-- app.vue --\x3e\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/\">index</router-link> |\n      <router-link to=\"/detail/11\">detail</router-link>\n    </div>\n    <router-view/>\n  </div>\n</template>\n\n\x3c!-- detail.vue --\x3e\n<template>\n  <div>\n    \x3c!-- 方式1： 通过当前路由规则，获取数据 --\x3e\n    通过当前路由规则获取：{{ $route.params.id }}\n\n    <br>\n    \x3c!-- 方式2：路由规则中开启 props 传参 --\x3e\n    通过开启 props 获取：{{ id }}\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'detail',\n  props: ['id']\n}\n<\/script>\n\n\n\n# 嵌套路由\n\n\n\n> 抽取公共组件 layout.vue 存储 header 和 footer\n\n//index.js\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\n// 加载组件\nimport layout from '@/components/layout.vue'\nimport index from '@/views/index.vue'\nimport login from '@/views/login.vue'\n\nvue.use(vuerouter)\n\nconst routes = [\n  {\n    name: 'login',\n    path: '/login',\n    component: login\n  },\n  // 嵌套路由\n  {\n    path: '/',\n    component: layout,\n    children: [\n      {\n        name: 'index',\n        path: '',\n        component: index\n      },\n      {\n        name: 'detail',\n        path: 'detail/:id',\n        props: true,\n        component: () => import('@/views/detail.vue')\n      }\n    ]\n  }\n]\n\nconst router = new vuerouter({\n  routes\n})\n\nexport default router\n\n\n\n# 编程式导航的几种方法\n\n * this.$router.push：跳转到指定url，向history栈添加一个新的记录，点击后退会返回至上一个页面\n\n * this.$router.replace：跳转到指定url，替换history栈中最后一个记录，点击后退会返回至上上一个页面\n\n * this.$router.go(n)：向前或向后跳转n个页面，n可正（向后跳转）可负（向前跳转）\n\nthis.$router.push({ name: 'detail', params: { id: 1 } })\nthis.$router.replace('/login')\nthis.$router.go(-2)\n\n// 返回主页\nthis.$router.push('/')\n// this.$router.push({ name: 'home' })\n\n\n\n# hash模式和history模式\n\n\n# history模式的使用\n\n * 通过history.pushstate()方法改变地址栏\n\n * 监听popstate事件\n\n * 根据当前路由地址找到对应组件进行重新渲染\n\n * history需要服务器的支持\n\n * 单页应用中，服务端不存在http:www.testurl.com/login这样的地址会返回找不到该页面\n\n * 在服务端应该除了静态资源外都返回单页应用的index.html\n\n// 这是一个简单的 node 服务器\nconst path = require('path')\n// 导入处理 history 模式的模块\nconst history = require('connect-history-api-fallback')\n// 导入 express\nconst express = require('express')\n\nconst app = express()\n// 注册处理 history 模式的中间件，一旦客户端请求不存在的地址，服务端都会返回单页的index.html\napp.use(history())\n// 处理静态资源的中间件，网站根目录 ../web\napp.use(express.static(path.join(__dirname, '../web')))\n\n// 开启服务器，端口是 3000\napp.listen(3000, () => {\n  console.log('服务器开启，端口：3000')\n})\n\n\n同样的在nginx服务器中也可以配置返回index.html，客户端来判断路由地址对应展示内容。\n\n\n# hash模式的使用\n\n * url中#后面的内容作为路径地址\n * 监听hashchange事件\n * 根据当前路由地址找到对应组件重新渲染\n\n\n# 模拟实现 vue route\n\n前置知识：\n\n * vue的构建版本\n\n> 运行时版：不支持 template 模板，需要打包的时候提前编译，如果你打包的时候是用vue-loader 或者 vueify，将`*.vue文件内的templates编译成javascript代码， 你就不需要compiler, 可以使用 runtime-only版本编译。\n> \n> 完整版：包含运行时和编译器，体积比运行时版大10k左右，程序运行时把模板转换成render函数\n> \n> vue-cli默认创建运行时版\n\n * slot插槽\n\n\t<div id = \"app\">\n        <aaa>\n            <p slot = \"s1\">在上面的内容</p>\n            <p slot = \"s2\">在下面的内容</p>\n        </aaa>\n    </div>\n\t\n\t\x3c!-- 子组件 --\x3e\n    <template id=\"aaa\">\n        <div class = \"aaa\">\n            <slot name = \"s1\"></slot>\n            <p>我是aaa组件</p>\n            <slot name = \"s2\"></slot>\n        </div>\n    </template>\n\n\n * 混入mixin\n\n混入 (mixin) 提供了一种非常灵活的方式，来分发 vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项\n\n// 定义一个混入对象\nvar mymixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// 定义一个使用混入对象的组件\nvar component = vue.extend({\n  mixins: [mymixin]\n})\n\nvar component = new component() // => \"hello from mixin!\"\n\n\n\n * render函数\n\n> 简单的说，在vue中我们使用模板html语法组建页面的，使用render函数我们可以用js语言来构建dom\n> \n> 因为vue是虚拟dom，所以在拿到template模板时也要转译成vnode的函数，而用render函数构建dom，vue就免去了转译的过程。\n> \n> 当使用render函数描述虚拟dom时，vue提供一个函数，这个函数是就构建虚拟dom所需要的工具。官网上给他起了个名字叫createelement。还有约定的简写叫h,\n\n<div>\n    <myslot>\n    \t<p>hello world</p>\n    </myslot>\n</div>\t\n\n<template id=\"myslot\">\n\t<h1 v-if=\"level==1\">\n    \t<slot></slot>    \n    </h1>\n    <h2 v-if=\"level==2\">\n    \t<slot></slot>    \n    </h2>\n    <h3 v-if=\"level==3\">\n    \t<slot></slot>    \n    </h3>\n    <h4 v-if=\"level==4\">\n    \t<slot></slot>    \n    </h4>\n</template>\n\n\n使用render函数将myslot动态生成\n\n'myslot':{\n    render: function(createelement) {\n        return createelement('h' + this.level, this.$slot.default) //h(n),helloworld\n    }\n}\n\n\n * vue.use(plugin, arguments)\n\n * 参数：plugin(function | object)\n\n * 用法： 如果vue安装的组件类型必须为function或者是object\n   \n   如果是个对象，必须提供install方法\n   \n   如果是一个函数，会被直接当作install函数执行\n   \n   install函数接受参数，默认第一个参数为vue,其后参数为注册组件时传入的arguments\n\n实现思路\n\n * 创建vuerouter插件，静态方法 install\n   * 判断插件是否已经被加载\n   * 当vue加载时把传入的router对象挂载到vue实例上\n * 创建vuerouter类\n   * 初始化，options，routemap，app\n   * createroutemap()遍历所有路由信息，把组件和路由的映射记录到routemap对象中\n   * 注册popstate事件，当路由地址发生变化，重新记录当前路径\n   * 创建router-link和router-view组件\n   * 当路径改变时，在routermap中找到对应的组件，渲染router-view\n\nlet _vue = null\nclass vuerouter {\n    // vue.use(vuerouter) 表示使用vuerouter插件，调用 install 方法\n    static install(vue){\n        //1 判断当前插件是否被安装\n        if(vuerouter.install.installed) return;\n        \n        vuerouter.install.installed = true\n        //2 把vue的构造函数记录在全局，后面使用vue.component时会用到\n        _vue = vue\n        \n        //3 把创建vue的实例传入的router对象注入到vue实例\n        _vue.mixin({\n            beforecreate(){\n                if(this.$options.router){\n                    _vue.prototype.$router = this.$options.router // 给所有的vue实例添加     \n                \t// $ 一般是vue中自带的，和普通的属性没什么区别\n                    // 在vue的原型上添加一个 $router，令其注册在vue实例上的 router\n                    // 即等于 vue.$options.router\n                } \n            }\n        })\n    }\n    constructor(options){\n        this.options = options\n        this.routemap = {}\n        // observable\n        this.data = _vue.observable({ \n            current:\"/\"    // current记录当前路由地址，\"/\"为当前的默认路径，为响应式数据\n        })\n        this.init()\n    }\n    init(){\n        this.createroutemap()\n        this.initcomponent(_vue)\n        this.initevent()\n    }\n    createroutemap(){\n        //遍历所有的路由规则 吧路由规则解析成键值对的形式存储到routemap中\n        this.options.routes.foreach(route => {\n            this.routemap[route.path] = route.component\n        });\n    }\n    initcomponent(vue){\n        vue.component(\"router-link\",{\n            props:{\n                to:string\n            },\n            // template: '<a :href=\"to\"><slot></slot></a>'\n            // <router-link to=\"/blog\">blog</router-link> 就会把blog替换插槽\n            // 但是上面这种方式在运行时vue不可用，不支持template\n            // 完整版本的vue就是把template编译成render函数，所以可以直接写render函数\n            render(h){\n                return h(\"a\",{ // 三个参数：标签，属性，子元素slot\n                    attrs:{\n                        href:this.to\n                    },\n                    on:{\n                        click:this.clickhander\n                    }\n                },[this.$slots.default]) // 默认插槽就是<slot></slot>\n            },\n            methods:{\n                clickhander(e){\n                    history.pushstate({},\"\",this.to) // pushstate改地址而且不向服务器发请求\n                    this.$router.data.current=this.to\n                    e.preventdefault() // 阻止默认行为\n                }\n            }\n        })\n        const self = this\n        vue.component(\"router-view\",{\n            render(h){\n                // 获取组件\n                const cm=self.routemap[self.data.current] // current响应式数据，会重新渲染组件\n                return h(cm)\n            }\n        })\n        \n    }\n    initevent(){\n        // 点击浏览器的前进后退时，重新获取当前路径并记录到current\n        window.addeventlistener(\"popstate\",()=>{\n            this.data.current = window.location.pathname\n        })\n    }\n}\n\n\n * 前端路由是实现单页应用的基础\n\n * 可以通过this.$router对象获取当前路由对象中信息\n\n * window.pushstate不会触发popstate时间，浏览器前进后退时会触发\n\n * 当浏览器地址的路由为#/artical，router-link to=\"/artical/101\"生成的超链接的class属性会被设置为exact-active-class中的类样式，因为exact-active-class是用来设置路由地址精确匹配元素的样式\n\n\n# 模拟hash模式vuerouter\n\nlet _vue = null\nclass vuerouter {\n    // vue.use(vuerouter) 表示使用vuerouter插件，调用 install 方法\n    static install(vue){\n        //1 判断当前插件是否被安装\n        if(vuerouter.install.installed) return;\n        \n        vuerouter.install.installed = true\n        //2 把vue的构造函数记录在全局，后面使用vue.component时会用到\n        _vue = vue\n        \n        //3 把创建vue的实例传入的router对象注入到vue实例\n        _vue.mixin({\n            beforecreate(){\n                if(this.$options.router){\n                    _vue.prototype.$router = this.$options.router // 给所有的vue实例添加     \n                \t// $ 一般是vue中自带的，和普通的属性没什么区别\n                    // 在vue的原型上添加一个 $router，令其注册在vue实例上的 router\n                    // 即等于 vue.$options.router\n                } \n            }\n        })\n    }\n    constructor(options){\n        this.options = options\n        this.routemap = {}\n        // observable\n        this.data = _vue.observable({ \n            current:\"/\"    // current记录当前路由地址，\"/\"为当前的默认路径，为响应式数据\n        })\n        this.init()\n    }\n    init(){\n        this.createroutemap()\n        this.initcomponent(_vue)\n        this.initevent()\n    }\n    createroutemap(){\n        //遍历所有的路由规则 吧路由规则解析成键值对的形式存储到routemap中\n        this.options.routes.foreach(route => {\n            this.routemap[route.path] = route.component\n        });\n    }\n    initcomponent(vue){\n        vue.component(\"router-link\",{\n            props:{\n                to:string\n            },\n            // template: '<a :href=\"to\"><slot></slot></a>'\n            // <router-link to=\"/blog\">blog</router-link> 就会把blog替换插槽\n            // 但是上面这种方式在运行时vue不可用，不支持template\n            // 完整版本的vue就是把template编译成render函数，所以可以直接写render函数\n            render(h){\n                return h(\"a\",{ // 三个参数：标签，属性，子元素slot\n                    attrs:{\n                        href: '#' + this.to\n                    },\n                    on:{\n                        click:this.clickhander\n                    }\n                },[this.$slots.default]) // 默认插槽就是<slot></slot>\n            },\n            methods:{\n                clickhander(e){\n                    window.location.hash = '#' + this.to\n                    this.$router.data.current=this.to\n                    e.preventdefault() // 阻止默认行为\n                }\n            }\n        })\n        const self = this\n        vue.component(\"router-view\",{\n            render(h){\n                // 获取组件\n                const cm=self.routemap[self.data.current] // current响应式数据，会重新渲染组件\n                return h(cm)\n            }\n        })\n        \n    }\n    initevent() {\n        window.addeventlistener('load', this.hashchange())\n        window.addeventlistener('hashchange', this.hashchange())\n    }\n    hashchange() {\n        if (!window.location.hash) {\n            window.location.hash = '#/'\n        }\n        this.data.current = window.location.hash.substr(1)\n    }\n}\n",charsets:{cjk:!0}},{title:"Vue3.0（一）",frontmatter:{title:"Vue3.0（一）",date:"2021-02-01T11:27:54.000Z",categories:"Vue"},regularPath:"/vue/vue3.0-1.html",relativePath:"vue/vue3.0-1.md",key:"v-32b0df1a",path:"/vue/vue3.0-1.html",headers:[{level:2,title:"Vue.js 3.0",slug:"vue-js-3-0",normalizedTitle:"vue.js 3.0",charIndex:16},{level:2,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:30},{level:2,title:"构建版本",slug:"构建版本",normalizedTitle:"构建版本",charIndex:38},{level:2,title:"Options API",slug:"options-api",normalizedTitle:"options api",charIndex:1285},{level:2,title:"Composition API",slug:"composition-api",normalizedTitle:"composition api",charIndex:46},{level:2,title:"函数式编程",slug:"函数式编程",normalizedTitle:"函数式编程",charIndex:65},{level:2,title:"性能提升",slug:"性能提升",normalizedTitle:"性能提升",charIndex:74},{level:2,title:"Vite",slug:"vite",normalizedTitle:"vite",charIndex:82},{level:3,title:"ES Module",slug:"es-module",normalizedTitle:"es module",charIndex:2616},{level:3,title:"Vite vs Vue-CLI",slug:"vite-vs-vue-cli",normalizedTitle:"vite vs vue-cli",charIndex:3393},{level:3,title:"Vite 特点",slug:"vite-特点",normalizedTitle:"vite 特点",charIndex:3544},{level:3,title:"Vite创建项目",slug:"vite创建项目",normalizedTitle:"vite创建项目",charIndex:3583},{level:3,title:"基于模板创建项目",slug:"基于模板创建项目",normalizedTitle:"基于模板创建项目",charIndex:3673},{level:2,title:"Composition API 详解",slug:"composition-api-详解",normalizedTitle:"composition api 详解",charIndex:3723},{level:3,title:"setup 入口函数",slug:"setup-入口函数",normalizedTitle:"setup 入口函数",charIndex:3746},{level:3,title:"一个简单的例子：实时显示鼠标位置",slug:"一个简单的例子-实时显示鼠标位置",normalizedTitle:"一个简单的例子：实时显示鼠标位置",charIndex:4238},{level:2,title:"生命周期钩子函数",slug:"生命周期钩子函数",normalizedTitle:"生命周期钩子函数",charIndex:5387},{level:2,title:"reactive/toRefs/ref",slug:"reactive-torefs-ref",normalizedTitle:"reactive/torefs/ref",charIndex:90},{level:2,title:"Computed/Watch/WatchEffect",slug:"computed-watch-watcheffect",normalizedTitle:"computed/watch/watcheffect",charIndex:113},{level:3,title:"Computed",slug:"computed",normalizedTitle:"computed",charIndex:113},{level:2,title:"Watch",slug:"watch",normalizedTitle:"watch",charIndex:122},{level:3,title:"WatchEffect",slug:"watcheffect",normalizedTitle:"watcheffect",charIndex:128},{level:3,title:"进阶",slug:"进阶",normalizedTitle:"进阶",charIndex:9312}],lastUpdated:"6/25/2025, 8:09:31 PM",lastUpdatedTimestamp:1750853371e3,headersStr:"Vue.js 3.0 目录结构 构建版本 Options API Composition API 函数式编程 性能提升 Vite ES Module Vite vs Vue-CLI Vite 特点 Vite创建项目 基于模板创建项目 Composition API 详解 setup 入口函数 一个简单的例子：实时显示鼠标位置 生命周期钩子函数 reactive/toRefs/ref Computed/Watch/WatchEffect Computed Watch WatchEffect 进阶",content:'# Vue3.0（一）\n\n * Vue.js 3.0\n * 目录结构\n * 构建版本\n * Composition API\n * 函数式编程\n * 性能提升\n * Vite\n * reactive/toRefs/ref\n * Computed/Watch/WatchEffect\n\n\n# Vue.js 3.0\n\n * 源码组织方式的变化\n   * 采用 TS 重写\n   * 使用 Monorepo 管理项目结构\n * Composition API\n * 性能提升\n * Vite\n\n\n# 目录结构\n\n> packages目录下有许多模块/包。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo。Vue3.0 中的 monorepo 管理模式，Monorepo 是什么，为什么大家都在用？\n\n * compiler-core：平台无关的编译器\n * compiler-dom：浏览器平台下的编译器，依赖于compiler-core\n * compiler-sfc：（single file component）编译单文件组件\n * compiler-ssr：服务端渲染的编译器\n * reactivity：数据响应式系统\n * runtime-core：平台无关的运行时\n * runtime-dom：浏览器平台下的运行时\n * runtime-test：为了测试的运行时，dom树是js对象，可运行于所有js环境里\n * server-renderer：服务端渲染\n * shared：vue内部使用的一些公共的API\n * size-check：一个私有的包，不会发布到npm，在treeshaking后检查包的大小\n * template-explorer：实时编译组件。输出render函数\n * vue：构建完整版的vue\n\n\n# 构建版本\n\n * cjs（commonJs规范）\n   * vue.cjs.js\n   * vue.cjs.prod.js\n * global（可以直接通过script引入，增加全局vue对象，runtime是只包含运行时）\n   * vue.global.js\n   * vue.global.prod.js\n   * vue.runtime.global.js\n   * vue.runtime.global.prod.js\n * browser（通过script type=module方式引入）\n   * vue.esm-browser.js\n   * vue.esm-browser.prod.js\n   * vue.runtime.esm-browser.js\n   * vue.runtime.esm-browser.prod.js\n * bundler（没有打包的代码，要配合打包工具）\n   * vue.esm-bundler.js\n   * vue.runtime.esm-bundler.js\n\n\n# Options API\n\n在 vue2.x 中采用的是 Options API\n\n> 在vue2中如何组织代码的，**我们会在一个vue文件中methods，computed，watch，data中等等定义属性和方法，共同处理页面逻辑，**我们称这种方式为Options API\n\n * 包含一个描述组件选项(data, methods, props等)的对象\n * Options API 开发复杂组件，同一个功能逻辑的代码被拆分到不同选项\n\n\n# Composition API\n\n * vue.js 3.0 新增的一组 API\n * 一组基于函数的 API\n * 可以更灵活的组织组件的逻辑\n\nComposition API图示\n\nVue3为什么要使用Composition API\n\n\n# 函数式编程\n\n> Vue2 对外表现的编程模式基本就是：对象调用自己的数据和方法——this + . 操作。所以在 Vue2 时代，我们通常会把相关的数据和操作写在同一个对象里。但是到了 Vue3 的 setup 里，你几乎不会用到 this 了；变成了让函数来调用对象或是另一个函数——就是 FP 的特点了。通俗来说，就是从基于对象的编程（OOP）转向了函数式编程（FP）。\n\n\n# 性能提升\n\n * 响应式系统升级：采用 Proxy\n\n * 编译优化\n   \n   * Vue.js 2.x中通过标记静态根节点，优化 diff 的过程，静态节点仍需要 diff\n   \n   * Vue.js 3.0中标记和提升所有的静态根节点，diff 的时候只需要对比动态节点内容\n     \n     * Fragments（升级 vetur 插件，没有根节点也不会报错，会创建一个 Fragment 片段）\n     * 静态提升（再次编译可以跳过静态根节点）\n     * Patch flag\n     * 缓存事件处理函数\n   \n   * 例子：vue2模板编译、vue3模板编译网址\n     \n     <div id=\'app\'>\n         <div>static root\n     \t\t<div>static node</div>\n         </div>\n         <div>static node</div>\n         <div>static node</div>\n         <div :id="id">{{ count }}</div>\n         <button @click="handler"></button>\n     </div>\n     \x3c!-- 1. 删掉根节点试一下\n          2. 右上角options中选择 hoistStatic 提升静态节点\n          3. 右侧可以找到 patch flag\n          4. 右上角options可以开启缓存 --\x3e\n     \n\n * 源码体积的优化\n   \n   * 移除一些不常用的 API：inline-template, filter\n   * Tree-shaking\n\n\n# Vite\n\n\n# ES Module\n\n * 现代浏览器都支持 ES Module（ie 不支持）\n * 通过下面的方式加载模块\n   * <script type="module" src="..."><\/script>\n * 支持模块的 script 默认延迟加载\n\n回顾浏览器加载模块（type=module会自动添加上defer属性）过程: 加载模块并执行是在DOM树创建完毕之后，DOMContentLoaded之前执行\n\n<div id="app">hello world</div>\n<script>\n\twindow.addEventListener(\'DOMContentLoaded\', () => {\n        console.log(\'DOMContentLoaded\')\n  })\n<\/script>\n<script type="module" src="./index.js"><\/script>\n\n\n// index.js\nimport { forEach } from \'./utils.js\'\n\nconst app = document.querySelector(\'#app\')\nconsole.log(app.innerHTML)\n\nconst arr = [1, 2, 3]\nforEach(arr, item => {\n    console.log(item)\n})\n\n\n// 输出\n// Hello World\n// 1 2 3\n// DOMContentLoaded\n\n// （1）DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)。\n\n// （2）load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。\n\n\n\n# Vite vs Vue-CLI\n\n * Vite 在开发模式下不需要打包可以直接运行（开发模式下使用script type=module，不需要打包代码）\n * Vue-CLI 开发模式下必须对项目打包才可以运行\n * 生产环境下使用 Rollup 打包（基于ES Modules的方式打包）\n\n\n# Vite 特点\n\n * 快速冷启动\n * 按需编译\n * 模块热更新\n\n\n# Vite创建项目\n\nnpm init vite-app <project-name>\ncd <project-name>\nnpm install\nnpm run dev\n\n\n\n# 基于模板创建项目\n\nnpm init vite-app --template react\n\n\n\n# Composition API 详解\n\n\n# setup 入口函数\n\n * setup 函数是组合式 API 的入口函数，它在 组件创建之前 被调用\n\n * 因为在 setup 执行时组件尚未创建，setup 函数中的 this 不是当前组件的实例\n\n * 函数接收两个参数，props 和 context，context 可以解构为 attrs、slots、emit 函数\n   \n   * props：通过 prop 传递过来的所有数据，我们都可以在这里进行接收。并且获取到的数据将保持响应性。\n   * context：context 是一个 JavaScript 对象，这个对象暴露了三个组件的属性，我们可以通过 解构 的方式来分别获取这三个属性\n     * attrs： 它是绑定到组件中的 非 props 数据，并且是非响应式的。\n     * slots： 是组件的插槽，同样也不是 响应式的。\n     * emit： 是一个方法，相当于 vue2 中的 this.$emit 方法。\n\n * 函数可以返回一个对象，对象的属性可以直接在模板中进行使用，就像之前使用 data 和 methods 一样。\n\n\n# 一个简单的例子：实时显示鼠标位置\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <div id="app">\n    x: {{ position.x }} <br>\n    y: {{ position.y }}\n  </div>\n  <script type="module">\n    \n    import { createApp, reactive, onMounted, onUnmounted } from \'./vue.esm-browser.js\'\n\t\t\n    // 把功能封装成一个函数，data，menthods，hooks都在这个函数中\n    function useMousePosition () {\n      \n      // reactive 处理成响应式\n      const position = reactive({\n        x: 0,\n        y: 0\n      })\n\n      const update = e => {\n        position.x = e.pageX\n        position.y = e.pageY\n      }\n\n      onMounted(() => {\n        window.addEventListener(\'mousemove\', update)\n      })\n\n      onUnmounted(() => {\n        window.removeEventListener(\'mousemove\', update)\n      })\n\n      return position\n    }\n\t\t\n    // creatAPP 创建 vue 对象\n    const app = createApp({\n      setup () {\n        const position = useMousePosition()\n        \n        // return 给模板使用\n        return {\n          position\n        }\n      }\n    })\n\n    app.mount(\'#app\')\n  <\/script>\n</body>\n</html>\n\n\n\n# 生命周期钩子函数\n\n> setup() 开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method\n\nOPTIONS API     HOOK INSIDE SETUP   说明\nbeforeCreate    setup               组件创建之前\ncreated         setup               组件创建完成\nbeforeMount     onBeforeMount       组件挂载之前\nmounted         onMounted           组件挂载完成\nbeforeUpdate    onBeforeUpdate      数据更新，虚拟dom打补丁之前\nupdated         onUpdated           数据更新，虚拟dom渲染完成\nbeforeDestroy   onBeforeUnmount     组件销毁之前\ndestroyed       onUnmounted         组件销毁后\n\n\n# reactive/toRefs/ref\n\n * reactive：处理复杂数据类型为响应式\n * ref：处理基本数据类型为响应式\n * toRefs：toRefs 是 toRef 的批量版本。会将传入对象的每个属性处理为 ref 的值\n\n> ref实现的内部创建了一个对象，将value值设置成响应式的。其实他也可以接受复杂数据类型作为参数，但是其内部依然是调用 reactive api 进行的响应式处理，这个过程对用户来说是隐藏的。所以，为了使代码更清晰，你应该使用 ref 去处理基本类型的影响式数据，而使用 reactive 去处理复杂类型的数据（注意，这里指的不是所有的负责类型的数据）\n\nconst a = ref(0)\nconsole.log(a.value) // 0\n\n\n * vue3 中的响应式处理---\x3e Ref\n\n再看上面的例子，如果在插值表达式中想直接使用x, y而不使用 position\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <div id="app">\n    x: {{ x }} <br>\n    y: {{ y }}\n  </div>\n  <script type="module">\n    import { createApp, reactive, onMounted, onUnmounted, toRefs } from \'./vue.esm-browser.js\'\n\n    function useMousePosition () {\n      \n      const position = reactive({\n        x: 0,\n        y: 0\n      })\n\n      const update = e => {\n        position.x = e.pageX\n        position.y = e.pageY\n      }\n\n      onMounted(() => {\n        window.addEventListener(\'mousemove\', update)\n      })\n\n      onUnmounted(() => {\n        window.removeEventListener(\'mousemove\', update)\n      })\n\t\t\t\n      // 把属性也设置成响应式的\n      return toRefs(position)\n    }\n\t\t\n    const app = createApp({\n      setup () {\n        // 解构时依旧为响应式\n        const { x, y } = useMousePosition()\n        return {\n          x,\n          y\n        }\n      }\n    })\n    \n    app.mount(\'#app\');\n  <\/script>\n</body>\n</html>\n\n\n\n# Computed/Watch/WatchEffect\n\n\n# Computed\n\n * 第一种用法\n   \n   * let plusOne = computed(() => count.value + 1)\n\n * 第二种用法\n   \n   * const count = ref(1)\n     const plusOne = computed({\n       get: () => count.value + 1\n       set: val => {\n         count.value = val - 1\n       }\n     })\n     \n\n\n# Watch\n\n * Watch的三个参数\n   * 第一个参数：要监听的数据\n   * 第二个参数：监听到数据变化后执行的函数，这个函数有两个参数分别为新值和旧值\n   * 第三个参数：选项对象，deep 和 immediate\n * Watch的返回值\n   * 取消监听的函数\n\n\x3c!-- 一个例子：自动回答 yes/no --\x3e\n<script type="module">\n\n    import { createApp, ref, watch } from \'./vue.esm-browser.js\'\n\n    createApp({\n      setup () {\n        const question = ref(\'\')\n        const answer = ref(\'\')\n\n        watch(question, async (newValue, oldValue) => {\n          const response = await fetch(\'https://www.yesno.wtf/api\')\n          answer.value = await response.json()\n        })\n\n        return {\n          question,\n          answer\n        }\n      }\n    }).mount(\'#app\');\n  \n  <\/script>\n\n\n\n# WatchEffect\n\n场景：自动记录操作日志 假设你有一个按钮，每点一次计数器 count +1，同时你希望自动记录每次点击的时间，不需要手动写监听逻辑。\n\n# 🔧 代码示例\n\nimport { ref, watchEffect } from \'vue\';\n \nexport default {\n  setup() {\n    const count = ref(0);\n    const log = ref([]); // 用来存储操作日志\n \n    // 使用 watchEffect 自动追踪 count 的变化\n    watchEffect(() => {\n      log.value.push(`点击了 ${count.value} 次，时间：${new Date().toLocaleTimeString()}`);\n    });\n \n    const increment = () => {\n      count.value++;\n    };\n \n    return { count, increment, log };\n  }\n};\n\n\n# 🤔 发生了什么？\n\n 1. 自动追踪依赖：watchEffect 会自动检测回调函数中用到的响应式变量（这里是 count），当 count 变化时，自动重新执行回调。\n\n 2. 立即执行一次：组件加载时，watchEffect 会立即执行一次回调，记录初始状态（此时 count 是 0）。\n\n 3. 依赖变化时触发：每次点击按钮 count 增加，watchEffect 会自动触发，记录新的日志。\n\n# 🌰 对比 watch 的区别\n\n如果用 watch 实现同样的功能，需要显式指定监听目标：\n\nwatch(count, (newVal) => {\n  log.value.push(`点击了 ${newVal} 次，时间：${new Date().toLocaleTimeString()}`);\n});\n\n\n# 💡 核心总结\n\n * watchEffect 的作用：自动追踪回调函数中用到的响应式变量，当这些变量变化时，自动重新执行回调。\n * 适用场景：当你需要基于多个响应式变量的变化执行副作用操作（如日志、数据同步、异步请求等），且不想手动管理监听逻辑时。\n * 对比 watch：watch 需要明确指定监听的变量，而 watchEffect 会自动收集依赖，代码更简洁。\n\n\n# 进阶\n\n作用： 用来追踪响应式依赖，并在追踪的时候自动触发一次，后序检测到响应式依赖的话，会再次更新，注意所有的里面的响应式数据（ref\\reactive） 都会自动被加入依赖中\n\n用法： 传入一个副作用方法，并会自动追踪里面的响应式依赖，另外还可以传入一个可选的options，用于控制副作用触发的时机：pre|post|sync，分别是组件渲染前后和同步，默认是pre。此外 watchEffect返回了一个停止监听的函数。\n\n * Vue3 学习笔记之 watchEffect\n * Vue3.0来袭，你想学的都在这里（二）',normalizedContent:'# vue3.0（一）\n\n * vue.js 3.0\n * 目录结构\n * 构建版本\n * composition api\n * 函数式编程\n * 性能提升\n * vite\n * reactive/torefs/ref\n * computed/watch/watcheffect\n\n\n# vue.js 3.0\n\n * 源码组织方式的变化\n   * 采用 ts 重写\n   * 使用 monorepo 管理项目结构\n * composition api\n * 性能提升\n * vite\n\n\n# 目录结构\n\n> packages目录下有许多模块/包。monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo。vue3.0 中的 monorepo 管理模式，monorepo 是什么，为什么大家都在用？\n\n * compiler-core：平台无关的编译器\n * compiler-dom：浏览器平台下的编译器，依赖于compiler-core\n * compiler-sfc：（single file component）编译单文件组件\n * compiler-ssr：服务端渲染的编译器\n * reactivity：数据响应式系统\n * runtime-core：平台无关的运行时\n * runtime-dom：浏览器平台下的运行时\n * runtime-test：为了测试的运行时，dom树是js对象，可运行于所有js环境里\n * server-renderer：服务端渲染\n * shared：vue内部使用的一些公共的api\n * size-check：一个私有的包，不会发布到npm，在treeshaking后检查包的大小\n * template-explorer：实时编译组件。输出render函数\n * vue：构建完整版的vue\n\n\n# 构建版本\n\n * cjs（commonjs规范）\n   * vue.cjs.js\n   * vue.cjs.prod.js\n * global（可以直接通过script引入，增加全局vue对象，runtime是只包含运行时）\n   * vue.global.js\n   * vue.global.prod.js\n   * vue.runtime.global.js\n   * vue.runtime.global.prod.js\n * browser（通过script type=module方式引入）\n   * vue.esm-browser.js\n   * vue.esm-browser.prod.js\n   * vue.runtime.esm-browser.js\n   * vue.runtime.esm-browser.prod.js\n * bundler（没有打包的代码，要配合打包工具）\n   * vue.esm-bundler.js\n   * vue.runtime.esm-bundler.js\n\n\n# options api\n\n在 vue2.x 中采用的是 options api\n\n> 在vue2中如何组织代码的，**我们会在一个vue文件中methods，computed，watch，data中等等定义属性和方法，共同处理页面逻辑，**我们称这种方式为options api\n\n * 包含一个描述组件选项(data, methods, props等)的对象\n * options api 开发复杂组件，同一个功能逻辑的代码被拆分到不同选项\n\n\n# composition api\n\n * vue.js 3.0 新增的一组 api\n * 一组基于函数的 api\n * 可以更灵活的组织组件的逻辑\n\ncomposition api图示\n\nvue3为什么要使用composition api\n\n\n# 函数式编程\n\n> vue2 对外表现的编程模式基本就是：对象调用自己的数据和方法——this + . 操作。所以在 vue2 时代，我们通常会把相关的数据和操作写在同一个对象里。但是到了 vue3 的 setup 里，你几乎不会用到 this 了；变成了让函数来调用对象或是另一个函数——就是 fp 的特点了。通俗来说，就是从基于对象的编程（oop）转向了函数式编程（fp）。\n\n\n# 性能提升\n\n * 响应式系统升级：采用 proxy\n\n * 编译优化\n   \n   * vue.js 2.x中通过标记静态根节点，优化 diff 的过程，静态节点仍需要 diff\n   \n   * vue.js 3.0中标记和提升所有的静态根节点，diff 的时候只需要对比动态节点内容\n     \n     * fragments（升级 vetur 插件，没有根节点也不会报错，会创建一个 fragment 片段）\n     * 静态提升（再次编译可以跳过静态根节点）\n     * patch flag\n     * 缓存事件处理函数\n   \n   * 例子：vue2模板编译、vue3模板编译网址\n     \n     <div id=\'app\'>\n         <div>static root\n     \t\t<div>static node</div>\n         </div>\n         <div>static node</div>\n         <div>static node</div>\n         <div :id="id">{{ count }}</div>\n         <button @click="handler"></button>\n     </div>\n     \x3c!-- 1. 删掉根节点试一下\n          2. 右上角options中选择 hoiststatic 提升静态节点\n          3. 右侧可以找到 patch flag\n          4. 右上角options可以开启缓存 --\x3e\n     \n\n * 源码体积的优化\n   \n   * 移除一些不常用的 api：inline-template, filter\n   * tree-shaking\n\n\n# vite\n\n\n# es module\n\n * 现代浏览器都支持 es module（ie 不支持）\n * 通过下面的方式加载模块\n   * <script type="module" src="..."><\/script>\n * 支持模块的 script 默认延迟加载\n\n回顾浏览器加载模块（type=module会自动添加上defer属性）过程: 加载模块并执行是在dom树创建完毕之后，domcontentloaded之前执行\n\n<div id="app">hello world</div>\n<script>\n\twindow.addeventlistener(\'domcontentloaded\', () => {\n        console.log(\'domcontentloaded\')\n  })\n<\/script>\n<script type="module" src="./index.js"><\/script>\n\n\n// index.js\nimport { foreach } from \'./utils.js\'\n\nconst app = document.queryselector(\'#app\')\nconsole.log(app.innerhtml)\n\nconst arr = [1, 2, 3]\nforeach(arr, item => {\n    console.log(item)\n})\n\n\n// 输出\n// hello world\n// 1 2 3\n// domcontentloaded\n\n// （1）domcontentloaded 事件触发时，仅当dom加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)。\n\n// （2）load 事件触发时，页面上所有的dom，样式表，脚本，图片都已经加载完成了。\n\n\n\n# vite vs vue-cli\n\n * vite 在开发模式下不需要打包可以直接运行（开发模式下使用script type=module，不需要打包代码）\n * vue-cli 开发模式下必须对项目打包才可以运行\n * 生产环境下使用 rollup 打包（基于es modules的方式打包）\n\n\n# vite 特点\n\n * 快速冷启动\n * 按需编译\n * 模块热更新\n\n\n# vite创建项目\n\nnpm init vite-app <project-name>\ncd <project-name>\nnpm install\nnpm run dev\n\n\n\n# 基于模板创建项目\n\nnpm init vite-app --template react\n\n\n\n# composition api 详解\n\n\n# setup 入口函数\n\n * setup 函数是组合式 api 的入口函数，它在 组件创建之前 被调用\n\n * 因为在 setup 执行时组件尚未创建，setup 函数中的 this 不是当前组件的实例\n\n * 函数接收两个参数，props 和 context，context 可以解构为 attrs、slots、emit 函数\n   \n   * props：通过 prop 传递过来的所有数据，我们都可以在这里进行接收。并且获取到的数据将保持响应性。\n   * context：context 是一个 javascript 对象，这个对象暴露了三个组件的属性，我们可以通过 解构 的方式来分别获取这三个属性\n     * attrs： 它是绑定到组件中的 非 props 数据，并且是非响应式的。\n     * slots： 是组件的插槽，同样也不是 响应式的。\n     * emit： 是一个方法，相当于 vue2 中的 this.$emit 方法。\n\n * 函数可以返回一个对象，对象的属性可以直接在模板中进行使用，就像之前使用 data 和 methods 一样。\n\n\n# 一个简单的例子：实时显示鼠标位置\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  <div id="app">\n    x: {{ position.x }} <br>\n    y: {{ position.y }}\n  </div>\n  <script type="module">\n    \n    import { createapp, reactive, onmounted, onunmounted } from \'./vue.esm-browser.js\'\n\t\t\n    // 把功能封装成一个函数，data，menthods，hooks都在这个函数中\n    function usemouseposition () {\n      \n      // reactive 处理成响应式\n      const position = reactive({\n        x: 0,\n        y: 0\n      })\n\n      const update = e => {\n        position.x = e.pagex\n        position.y = e.pagey\n      }\n\n      onmounted(() => {\n        window.addeventlistener(\'mousemove\', update)\n      })\n\n      onunmounted(() => {\n        window.removeeventlistener(\'mousemove\', update)\n      })\n\n      return position\n    }\n\t\t\n    // creatapp 创建 vue 对象\n    const app = createapp({\n      setup () {\n        const position = usemouseposition()\n        \n        // return 给模板使用\n        return {\n          position\n        }\n      }\n    })\n\n    app.mount(\'#app\')\n  <\/script>\n</body>\n</html>\n\n\n\n# 生命周期钩子函数\n\n> setup() 开始创建组件之前，在beforecreate和created之前执行。创建的是data和method\n\noptions api     hook inside setup   说明\nbeforecreate    setup               组件创建之前\ncreated         setup               组件创建完成\nbeforemount     onbeforemount       组件挂载之前\nmounted         onmounted           组件挂载完成\nbeforeupdate    onbeforeupdate      数据更新，虚拟dom打补丁之前\nupdated         onupdated           数据更新，虚拟dom渲染完成\nbeforedestroy   onbeforeunmount     组件销毁之前\ndestroyed       onunmounted         组件销毁后\n\n\n# reactive/torefs/ref\n\n * reactive：处理复杂数据类型为响应式\n * ref：处理基本数据类型为响应式\n * torefs：torefs 是 toref 的批量版本。会将传入对象的每个属性处理为 ref 的值\n\n> ref实现的内部创建了一个对象，将value值设置成响应式的。其实他也可以接受复杂数据类型作为参数，但是其内部依然是调用 reactive api 进行的响应式处理，这个过程对用户来说是隐藏的。所以，为了使代码更清晰，你应该使用 ref 去处理基本类型的影响式数据，而使用 reactive 去处理复杂类型的数据（注意，这里指的不是所有的负责类型的数据）\n\nconst a = ref(0)\nconsole.log(a.value) // 0\n\n\n * vue3 中的响应式处理---\x3e ref\n\n再看上面的例子，如果在插值表达式中想直接使用x, y而不使用 position\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  <div id="app">\n    x: {{ x }} <br>\n    y: {{ y }}\n  </div>\n  <script type="module">\n    import { createapp, reactive, onmounted, onunmounted, torefs } from \'./vue.esm-browser.js\'\n\n    function usemouseposition () {\n      \n      const position = reactive({\n        x: 0,\n        y: 0\n      })\n\n      const update = e => {\n        position.x = e.pagex\n        position.y = e.pagey\n      }\n\n      onmounted(() => {\n        window.addeventlistener(\'mousemove\', update)\n      })\n\n      onunmounted(() => {\n        window.removeeventlistener(\'mousemove\', update)\n      })\n\t\t\t\n      // 把属性也设置成响应式的\n      return torefs(position)\n    }\n\t\t\n    const app = createapp({\n      setup () {\n        // 解构时依旧为响应式\n        const { x, y } = usemouseposition()\n        return {\n          x,\n          y\n        }\n      }\n    })\n    \n    app.mount(\'#app\');\n  <\/script>\n</body>\n</html>\n\n\n\n# computed/watch/watcheffect\n\n\n# computed\n\n * 第一种用法\n   \n   * let plusone = computed(() => count.value + 1)\n\n * 第二种用法\n   \n   * const count = ref(1)\n     const plusone = computed({\n       get: () => count.value + 1\n       set: val => {\n         count.value = val - 1\n       }\n     })\n     \n\n\n# watch\n\n * watch的三个参数\n   * 第一个参数：要监听的数据\n   * 第二个参数：监听到数据变化后执行的函数，这个函数有两个参数分别为新值和旧值\n   * 第三个参数：选项对象，deep 和 immediate\n * watch的返回值\n   * 取消监听的函数\n\n\x3c!-- 一个例子：自动回答 yes/no --\x3e\n<script type="module">\n\n    import { createapp, ref, watch } from \'./vue.esm-browser.js\'\n\n    createapp({\n      setup () {\n        const question = ref(\'\')\n        const answer = ref(\'\')\n\n        watch(question, async (newvalue, oldvalue) => {\n          const response = await fetch(\'https://www.yesno.wtf/api\')\n          answer.value = await response.json()\n        })\n\n        return {\n          question,\n          answer\n        }\n      }\n    }).mount(\'#app\');\n  \n  <\/script>\n\n\n\n# watcheffect\n\n场景：自动记录操作日志 假设你有一个按钮，每点一次计数器 count +1，同时你希望自动记录每次点击的时间，不需要手动写监听逻辑。\n\n# 🔧 代码示例\n\nimport { ref, watcheffect } from \'vue\';\n \nexport default {\n  setup() {\n    const count = ref(0);\n    const log = ref([]); // 用来存储操作日志\n \n    // 使用 watcheffect 自动追踪 count 的变化\n    watcheffect(() => {\n      log.value.push(`点击了 ${count.value} 次，时间：${new date().tolocaletimestring()}`);\n    });\n \n    const increment = () => {\n      count.value++;\n    };\n \n    return { count, increment, log };\n  }\n};\n\n\n# 🤔 发生了什么？\n\n 1. 自动追踪依赖：watcheffect 会自动检测回调函数中用到的响应式变量（这里是 count），当 count 变化时，自动重新执行回调。\n\n 2. 立即执行一次：组件加载时，watcheffect 会立即执行一次回调，记录初始状态（此时 count 是 0）。\n\n 3. 依赖变化时触发：每次点击按钮 count 增加，watcheffect 会自动触发，记录新的日志。\n\n# 🌰 对比 watch 的区别\n\n如果用 watch 实现同样的功能，需要显式指定监听目标：\n\nwatch(count, (newval) => {\n  log.value.push(`点击了 ${newval} 次，时间：${new date().tolocaletimestring()}`);\n});\n\n\n# 💡 核心总结\n\n * watcheffect 的作用：自动追踪回调函数中用到的响应式变量，当这些变量变化时，自动重新执行回调。\n * 适用场景：当你需要基于多个响应式变量的变化执行副作用操作（如日志、数据同步、异步请求等），且不想手动管理监听逻辑时。\n * 对比 watch：watch 需要明确指定监听的变量，而 watcheffect 会自动收集依赖，代码更简洁。\n\n\n# 进阶\n\n作用： 用来追踪响应式依赖，并在追踪的时候自动触发一次，后序检测到响应式依赖的话，会再次更新，注意所有的里面的响应式数据（ref\\reactive） 都会自动被加入依赖中\n\n用法： 传入一个副作用方法，并会自动追踪里面的响应式依赖，另外还可以传入一个可选的options，用于控制副作用触发的时机：pre|post|sync，分别是组件渲染前后和同步，默认是pre。此外 watcheffect返回了一个停止监听的函数。\n\n * vue3 学习笔记之 watcheffect\n * vue3.0来袭，你想学的都在这里（二）',charsets:{cjk:!0}},{title:"webpack（一）",frontmatter:{title:"webpack（一）",date:"2020-09-06T09:47:00.000Z",categories:"webpack"},regularPath:"/webpack/webpack1.html",relativePath:"webpack/webpack1.md",key:"v-81716842",path:"/webpack/webpack1.html",headers:[{level:2,title:"为什么使用 webpack",slug:"为什么使用-webpack",normalizedTitle:"为什么使用 webpack",charIndex:17},{level:2,title:"webpack初体验",slug:"webpack初体验",normalizedTitle:"webpack初体验",charIndex:34},{level:3,title:"如何添加配置入口文件",slug:"如何添加配置入口文件",normalizedTitle:"如何添加配置入口文件",charIndex:849},{level:2,title:"如何打包css文件",slug:"如何打包css文件",normalizedTitle:"如何打包css文件",charIndex:1332},{level:3,title:"如何打包图片",slug:"如何打包图片",normalizedTitle:"如何打包图片",charIndex:1781},{level:2,title:"常用加载器分类",slug:"常用加载器分类",normalizedTitle:"常用加载器分类",charIndex:62},{level:2,title:"如何处理ES6语法",slug:"如何处理es6语法",normalizedTitle:"如何处理es6语法",charIndex:73},{level:2,title:"模块加载方式",slug:"模块加载方式",normalizedTitle:"模块加载方式",charIndex:86},{level:2,title:"自己创建一个loader",slug:"自己创建一个loader",normalizedTitle:"自己创建一个loader",charIndex:96}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"为什么使用 webpack webpack初体验 如何添加配置入口文件 如何打包css文件 如何打包图片 常用加载器分类 如何处理ES6语法 模块加载方式 自己创建一个loader",content:"# webpack（一）\n\n * 为什么使用 webpack\n * webpack初体验\n * 如何打包css和图片\n * 常用加载器分类\n * 如何处理ES6语法\n * 模块加载方式\n * 自己创建一个loader\n\n\n# 为什么使用 webpack\n\n个人理解我们平时开发的时候，比如使用es6，ts，采用模块化，使用不同的技术栈，大多数所写的代码是不能被浏览器直接运行的，所以需要一个工具来帮我们完成这些事情，另外还可以增加压缩代码，hmr这些功能，这就是 webpack。\n\n\n# webpack初体验\n\n> webpack是一种前端资源构建工具，一个静态模块打包器（module bundler）。在webpack看来，前端的所有资源文件（js/json/css/img/less…）都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）\n\n安装：cnpm install -D webpack webpack-cli，举例：比如此时有如下的目录结构\n\n|--src\n    --heading.js  // 遵循ES Modules\n    --index.js\n|--index.html\n|--package.json\n\n\n其中index.js模块中引入了heading.js模块导出的方法，而index.html中又引入了index.js，默认入口为src/index.js\n\n> html文件中原本的引入\n> \n> script type=\"module\" src=\"src/index.js\"\n\n运行webpack命令\n\n|--dist\n    --main.js // 打包后的js文件\n|--src\n    --heading.js\n    --index.js\n|--index.html\n|--package.json\n\n\n> html文件中，打包之后的引入\n> \n> script src=\"dist/main.js\"\n\n\n# 如何添加配置入口文件\n\n新建webpack.config.js文件，使用common.js规范\n\nconst path = require('path')\n\nmodule.exports = {\n  // mode这个属性有三种取值，分别是 production、development 和 none。\n  // 1. 生产模式下，Webpack 会自动优化打包结果；\n  // 2. 开发模式下，Webpack 会自动优化打包速度，添加一些调试过程中的辅助；\n  // 3. None 模式下，Webpack 就是运行最原始的打包，不做任何额外处理；\n  mode: 'development',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'output') //绝对路径，__dirname为当前文件夹路径 + output\n  }\n}\n\n\npath.join与path.resolve\n\n\n# 如何打包css文件\n\n因为webpack默认打包js文件，所以我们需要额外的loader来处理，cnpm install -D style-loader css-loader\n\n * css-loader：处理css文件，将其打包至js文件中\n * style-loader：用于展示打包后的css文件\n\n// 在webpack.config.js中新增\n module: {\n    rules: [\n      {\n        test: /.css$/, // 遇到css文件时\n        use: [\n          'style-loader', // 采用如下loader，从后向前调用\n          'css-loader'\n        ]\n      }\n    ]\n  }\n\n// 然后比如在main.js中通过import的方式引入main.css文件\nimport './main.css'\n\n// 此时运行webpack就会打包css文件\n\n\n\n# 如何打包图片\n\ncnpm install -D file-loader url-loader，首先在main.js使用import的方式中导入./icon.png\n\n * 超出10KB的文件单独提取存放在dist中\n * 小于10KB的文件转换为 Data URLs 嵌入代码中（base64编码）\n\n|--dist\n    --bundle.js \n    --aaa0e...png // 打包后的图片\n|--src\n    --heading.js\n    --main.js\n    --main.css\n    --icon.png\n|--index.html\n|--package.json\n\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    publicPath: 'dist/'                 // 因为index.html在根目录，所以图片也从根目录加载，不会显示，要加上dist\n  },\n  module: {\n    rules: [\n      {\n        test: /.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10KB的还会使用file-loader\n          options: {\n            limit: 10 * 1024 // 10 KB\n          }\n        }\n      }\n    ]\n  }\n}\n\n\n\n# 常用加载器分类\n\n * 编译转换类：比如css-loader将css编译并嵌入在bundle.js\n * 文件操作类：比如file-loader\n * 代码检查类：比如eslint-loader\n\n\n# 如何处理ES6语法\n\n虽然webpack支持import和export模块化，但并不支持ES6语法\n\ncnpm install -D babel-loader @babel/core @babel/preset-env\n\n// rules新增\n\t{\n        test: /.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n\n\n\n# 模块加载方式\n\n * 遵循 ES Modules 标准的 import 声明（非特殊情况只用这一种）\n * 遵循 CommonJS 标准的 require函数\n * 遵循 AMD 标准的 define 函数和 require 函数\n * * 样式代码中的@import指令和url函数\n   * HTML 代码中图片标签的 src 属性，a标签的href属性（需要配置）\n\n// html中的a标签的href属性需要配置\n\t {\n        test: /.html$/,\n        use: {\n          loader: 'html-loader',\n          options: {\n            attrs: ['img:src', 'a:href']\n          }\n        }\n      }\n\n\n\n# 自己创建一个loader\n\n根目录下新建一个markdown-loader.js作为处理md文件的loader，然后在webpack.config.js中配置：\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    publicPath: 'dist/'\n  },\n  module: {\n    rules: [\n      {\n        test: /.md$/,\n        use: [\n          'html-loader',\n          './markdown-loader'\n        ]\n      }\n    ]\n  }\n}\n\n\n// markdown-loader.js\n\nconst marked = require('marked')\n\nmodule.exports = source => {\n    \n  const html = marked(source)\n\n  // 返回 html 字符串交给下一个 loader 处理\n  return html\n}\n\n\n// loader管道示意\n\n// Source => md-loader => loader2 => loader3 => Result （js文件） \n",normalizedContent:"# webpack（一）\n\n * 为什么使用 webpack\n * webpack初体验\n * 如何打包css和图片\n * 常用加载器分类\n * 如何处理es6语法\n * 模块加载方式\n * 自己创建一个loader\n\n\n# 为什么使用 webpack\n\n个人理解我们平时开发的时候，比如使用es6，ts，采用模块化，使用不同的技术栈，大多数所写的代码是不能被浏览器直接运行的，所以需要一个工具来帮我们完成这些事情，另外还可以增加压缩代码，hmr这些功能，这就是 webpack。\n\n\n# webpack初体验\n\n> webpack是一种前端资源构建工具，一个静态模块打包器（module bundler）。在webpack看来，前端的所有资源文件（js/json/css/img/less…）都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）\n\n安装：cnpm install -d webpack webpack-cli，举例：比如此时有如下的目录结构\n\n|--src\n    --heading.js  // 遵循es modules\n    --index.js\n|--index.html\n|--package.json\n\n\n其中index.js模块中引入了heading.js模块导出的方法，而index.html中又引入了index.js，默认入口为src/index.js\n\n> html文件中原本的引入\n> \n> script type=\"module\" src=\"src/index.js\"\n\n运行webpack命令\n\n|--dist\n    --main.js // 打包后的js文件\n|--src\n    --heading.js\n    --index.js\n|--index.html\n|--package.json\n\n\n> html文件中，打包之后的引入\n> \n> script src=\"dist/main.js\"\n\n\n# 如何添加配置入口文件\n\n新建webpack.config.js文件，使用common.js规范\n\nconst path = require('path')\n\nmodule.exports = {\n  // mode这个属性有三种取值，分别是 production、development 和 none。\n  // 1. 生产模式下，webpack 会自动优化打包结果；\n  // 2. 开发模式下，webpack 会自动优化打包速度，添加一些调试过程中的辅助；\n  // 3. none 模式下，webpack 就是运行最原始的打包，不做任何额外处理；\n  mode: 'development',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'output') //绝对路径，__dirname为当前文件夹路径 + output\n  }\n}\n\n\npath.join与path.resolve\n\n\n# 如何打包css文件\n\n因为webpack默认打包js文件，所以我们需要额外的loader来处理，cnpm install -d style-loader css-loader\n\n * css-loader：处理css文件，将其打包至js文件中\n * style-loader：用于展示打包后的css文件\n\n// 在webpack.config.js中新增\n module: {\n    rules: [\n      {\n        test: /.css$/, // 遇到css文件时\n        use: [\n          'style-loader', // 采用如下loader，从后向前调用\n          'css-loader'\n        ]\n      }\n    ]\n  }\n\n// 然后比如在main.js中通过import的方式引入main.css文件\nimport './main.css'\n\n// 此时运行webpack就会打包css文件\n\n\n\n# 如何打包图片\n\ncnpm install -d file-loader url-loader，首先在main.js使用import的方式中导入./icon.png\n\n * 超出10kb的文件单独提取存放在dist中\n * 小于10kb的文件转换为 data urls 嵌入代码中（base64编码）\n\n|--dist\n    --bundle.js \n    --aaa0e...png // 打包后的图片\n|--src\n    --heading.js\n    --main.js\n    --main.css\n    --icon.png\n|--index.html\n|--package.json\n\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    publicpath: 'dist/'                 // 因为index.html在根目录，所以图片也从根目录加载，不会显示，要加上dist\n  },\n  module: {\n    rules: [\n      {\n        test: /.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10kb的还会使用file-loader\n          options: {\n            limit: 10 * 1024 // 10 kb\n          }\n        }\n      }\n    ]\n  }\n}\n\n\n\n# 常用加载器分类\n\n * 编译转换类：比如css-loader将css编译并嵌入在bundle.js\n * 文件操作类：比如file-loader\n * 代码检查类：比如eslint-loader\n\n\n# 如何处理es6语法\n\n虽然webpack支持import和export模块化，但并不支持es6语法\n\ncnpm install -d babel-loader @babel/core @babel/preset-env\n\n// rules新增\n\t{\n        test: /.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n\n\n\n# 模块加载方式\n\n * 遵循 es modules 标准的 import 声明（非特殊情况只用这一种）\n * 遵循 commonjs 标准的 require函数\n * 遵循 amd 标准的 define 函数和 require 函数\n * * 样式代码中的@import指令和url函数\n   * html 代码中图片标签的 src 属性，a标签的href属性（需要配置）\n\n// html中的a标签的href属性需要配置\n\t {\n        test: /.html$/,\n        use: {\n          loader: 'html-loader',\n          options: {\n            attrs: ['img:src', 'a:href']\n          }\n        }\n      }\n\n\n\n# 自己创建一个loader\n\n根目录下新建一个markdown-loader.js作为处理md文件的loader，然后在webpack.config.js中配置：\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    publicpath: 'dist/'\n  },\n  module: {\n    rules: [\n      {\n        test: /.md$/,\n        use: [\n          'html-loader',\n          './markdown-loader'\n        ]\n      }\n    ]\n  }\n}\n\n\n// markdown-loader.js\n\nconst marked = require('marked')\n\nmodule.exports = source => {\n    \n  const html = marked(source)\n\n  // 返回 html 字符串交给下一个 loader 处理\n  return html\n}\n\n\n// loader管道示意\n\n// source => md-loader => loader2 => loader3 => result （js文件） \n",charsets:{cjk:!0}},{title:"canvas",frontmatter:{},regularPath:"/webgl/canvas.html",relativePath:"webgl/canvas.md",key:"v-73ff258f",path:"/webgl/canvas.html",headers:[{level:2,title:"canvas 和 svg 区别",slug:"canvas-和-svg-区别",normalizedTitle:"canvas 和 svg 区别",charIndex:13}],lastUpdated:"7/21/2025, 11:28:01 AM",lastUpdatedTimestamp:1753068481e3,headersStr:"canvas 和 svg 区别",content:"# canvas\n\n\n# canvas 和 svg 区别\n\n特性         SVG                 CANVAS\n数据结构       矢量图形，DOM节点          位图，像素数组\n渲染方式       保留模式，自动重绘受影响元素      即时模式，需手动重绘\n交互性        直接绑定事件，精细交互         需手动检测碰撞，复杂交互成本高\n缩放质量       无损，矢量图形             有损，位图缩放\n性能（大量元素）   大量元素时性能下降（DOM节点多）   大量元素时性能更优\n适用场景       图标、图表、交互式图形         游戏、实时动画、像素操作\n\n选择建议：\n\n * 若需交互性、高清晰度、简单动态修改，选SVG；\n * 若需高性能渲染、复杂动画、像素级控制，选Canvas。\n * 实际项目中，两者也可结合使用（如用SVG做交互控件，Canvas做底层渲染）。",normalizedContent:"# canvas\n\n\n# canvas 和 svg 区别\n\n特性         svg                 canvas\n数据结构       矢量图形，dom节点          位图，像素数组\n渲染方式       保留模式，自动重绘受影响元素      即时模式，需手动重绘\n交互性        直接绑定事件，精细交互         需手动检测碰撞，复杂交互成本高\n缩放质量       无损，矢量图形             有损，位图缩放\n性能（大量元素）   大量元素时性能下降（dom节点多）   大量元素时性能更优\n适用场景       图标、图表、交互式图形         游戏、实时动画、像素操作\n\n选择建议：\n\n * 若需交互性、高清晰度、简单动态修改，选svg；\n * 若需高性能渲染、复杂动画、像素级控制，选canvas。\n * 实际项目中，两者也可结合使用（如用svg做交互控件，canvas做底层渲染）。",charsets:{cjk:!0}},{title:"webpack热更新原理",frontmatter:{title:"webpack热更新原理",date:"2021-08-09T14:47:00.000Z",categories:"webpack"},regularPath:"/webpack/hmr.html",relativePath:"webpack/hmr.md",key:"v-652b741f",path:"/webpack/hmr.html",headers:[{level:2,title:"watch，webpack-dev-server，hmr区别",slug:"watch-webpack-dev-server-hmr区别",normalizedTitle:"watch，webpack-dev-server，hmr区别",charIndex:86},{level:2,title:"如何使用HMR",slug:"如何使用hmr",normalizedTitle:"如何使用hmr",charIndex:275},{level:2,title:"如何自己处理热更新逻辑",slug:"如何自己处理热更新逻辑",normalizedTitle:"如何自己处理热更新逻辑",charIndex:1393},{level:2,title:"热更新的流程",slug:"热更新的流程",normalizedTitle:"热更新的流程",charIndex:2514},{level:3,title:"1. 启动 Server (express 和 websocket)",slug:"_1-启动-server-express-和-websocket",normalizedTitle:"1. 启动 server (express 和 websocket)",charIndex:2948},{level:3,title:"2. Webpack compiler 编译",slug:"_2-webpack-compiler-编译",normalizedTitle:"2. webpack compiler 编译",charIndex:3523},{level:3,title:"3. 客户端接收更新消息",slug:"_3-客户端接收更新消息",normalizedTitle:"3. 客户端接收更新消息",charIndex:4604},{level:3,title:"4. 请求 hot-update.json 和 hot-update.js",slug:"_4-请求-hot-update-json-和-hot-update-js",normalizedTitle:"4. 请求 hot-update.json 和 hot-update.js",charIndex:6395}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"watch，webpack-dev-server，hmr区别 如何使用HMR 如何自己处理热更新逻辑 热更新的流程 1. 启动 Server (express 和 websocket) 2. Webpack compiler 编译 3. 客户端接收更新消息 4. 请求 hot-update.json 和 hot-update.js",content:"# webpack 热更新\n\n> HMR：Hot Module Replacement 模块热更新\n> \n> 应用程序运行过程中实时替换某个模块，页面状态不会改变\n\n\n# watch，webpack-dev-server，hmr区别\n\n * watch 模式：使用 webpack --watch 开启，文件改变后自动重新编译，但是不会自动刷新浏览器。\n * webpack-dev-server：集成工具，综合了自动编译和自动刷新浏览器的功能。\n * HMR：不用刷新浏览器，实时更新，也集成在 webpack-dev-server 中。\n\n\n# 如何使用HMR\n\n 1. 引入内置 HotModuleReplacementPlugin 插件\n 2. 开启 hot: true\n\n// 使用 webpack 自带的 HotModuleReplacementPlugin\nplugins: {\n    HotModuleReplacementPlugin: new webpack.HotModuleReplacementPlugin()\n}\n// devServer 再配置一下\ndevServer: {\n    contentBase: path.resolve(__dirname, 'dist'),\n    hot: true,\n    hotonly: false, // hot: 出现错误刷新页面，不会发现错误，hotonly: 若有错误不会刷新，可以发现错误代码\n    historyApiFallback: true,\n    compress: true,\n    watchOptions: {\n      // 不监听的文件或文件夹\n      ignored: /node_modules/,\n      // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\n      aggregateTimeout: 300,\n      // 默认每隔1000毫秒询问一次\n      poll: 1000\n    }\n}\n\n\n注：webpack的HMR并不能开箱即用，其实是需要手动处理模块替换的逻辑。\n\n * 样式文件可以直接使用，style-loader中会处理热更新的逻辑，更新后的 CSS 直接覆盖掉之前的 CSS 即可。\n\n * js模块不能直接使用，因为我们所编写的 JavaScript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 Webpack 面对这些毫无规律的 JS 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。\n\n * 通过脚手架创建的项目内部都集成了 HMR 方案，不需要自己手动处理。\n   \n   * Vue.js HMR 方案：https://vue-loader.vuejs.org/guide/hot-reload.html\n   * React HMR 方案：https://github.com/gaearon/react-hot-loader\n   * San HMR 方案：https://github.com/ecomfe/san-hot-loader\n\n\n# 如何自己处理热更新逻辑\n\n以编辑器和图片热更新逻辑为例\n\nif (module.hot) {\n \tmodule.hot.accept('./editor.js', () => {\n     // 当 editor.js 更新，自动执行此函数\n     // 在这里写更新逻辑，则页面不会自动刷新，如果没有此处的手动处理，页面还会自动刷新\n  }) \n}\n\n// ================================================================\n// HMR 手动处理模块热更新\n// 不用担心这些代码在生产环境冗余的问题，因为通过 webpack 打包后，\n// 这些代码全部会被移除变为 if (false) ，这些只是开发阶段用到\nimport createEditor from './editor';\nif (module.hot) {\n  let hotEditor = editor\n  module.hot.accept('./editor.js', () => {\n    // 当 editor.js 更新，自动执行此函数\n    // 临时记录编辑器内容\n    const value = hotEditor.innerHTML\n    // 移除更新前的元素\n    document.body.removeChild(hotEditor)\n    // 创建新的编辑器\n    // 此时 createEditor 已经是更新过后的函数了\n    hotEditor = createEditor()\n    // 还原编辑器内容\n    hotEditor.innerHTML = value\n    // 追加到页面\n    document.body.appendChild(hotEditor)\n  })\n\n  module.hot.accept('./better.png', () => {\n    // 当 better.png 更新后执行\n    // 重写设置 src 会触发图片元素重新加载，从而局部更新图片\n    img.src = background\n  })\n}\n\n\n至此，对于 editor 模块的热替换逻辑就算是全部实现了。我们可以发现，为什么 Webpack 需要我们自己处理 JS 模块的热更新了：因为不同的模块有不同的情况，不同的情况，在这里处理时肯定也是不同的。就好像，我们这里是一个文本编辑器应用，所以需要保留状态，如果不是这种类型那就不需要这样做。所以说 Webpack 没法提供一个通用的 JS 模块替换方案。\n\n\n# 热更新的流程\n\n> 热更新用到了websoket，因为 Websocket 是一种全双工协议，它最大的特点就是 服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送信息。这是 HTTP 协议不具备的，热更新实际上就是服务器端的更新通知到客户端。\n\n\n\n> 本地启动了一个 HMR Server 服务（websocket），而且在启动 Bundle Server 的时候已经往我们的 bundle.js 中注入了 HMR Runtime\n\n * 首次构建：1->2->A->B，webpack compiler 编译文件传输给 bunder Server，浏览器可以进行访问\n\n * HMR：1->2->3->4，文件变化，然后还是 webpack compiler 进行编译，编译好了会将代码发送给 HMR Server，它就可以知道哪些资源、哪些模块发生了改变。然后 HMR server 会通知 HRM Runtime，浏览器就会进行对应的刷新。\n\n\n# 1. 启动 Server (express 和 websocket)\n\nwebpack-dev-server 中的 Server.js\n\nsetupApp() {\n  // 使用 express 框架启动本地 server，让浏览器可以请求本地的静态资源。\n  this.app = new express();\n}\n\nlisten(port, hostname, fn) {\n  return this.listeningApp.listen(port, hostname, (err) => {\n    \n    // 创建 SocketServer ，可以向浏览器端传递消息。\n    this.createSocketServer();\n\n    // ...\n  });\n}\n\n\n这中间还有一个关键环节，添加 webpack-dev-middleware 中间件：\n\n> webpack-dev-middleware 将 webpack 编译后文件会输出到内存中，webpack-dev-middleware 就在此基础上形成一个文件映射系统，每当应用程序请求一个文件，它匹配到了就把内存中缓存的对应结果以文件的格式返回给你，反之则进入到下一个中间件，因为是内存型文件系统，所以重建速度非常快，很适合于开发阶段用作静态资源服务器。\n\n\n# 2. Webpack compiler 编译\n\nWebpack compiler 的作用：监听本地文件的变化、文件改变自动编译、编译输出\n\nWebpack 监听文件变换是通过 watchpack 实现的，主要监听的是文件修改时间。\n\n文件改变后等待 Webpack compiler 编译完成，然后通知客户端进行更新，这个过程通过 done 钩子实现，即：每当监听到一次 webpack 编译结束，就会调用 sendStats 方法，会向客户端发送 hash 和 ok 事件。\n\nsetupHooks() {\n  const addHooks = (compiler) => {\n    const { compile, invalid, done } = compiler.hooks;\n\n    compile.tap('webpack-dev-server', invalidPlugin);\n    invalid.tap('webpack-dev-server', invalidPlugin);\n    done.tap('webpack-dev-server', (stats) => {\n      this._sendStats(this.sockets, this.getStats(stats));\n      this._stats = stats;\n    });\n  };\n\n  if (this.compiler.compilers) {\n    this.compiler.compilers.forEach(addHooks);\n  } else {\n    addHooks(this.compiler);\n  }\n}\n\n_sendStats(sockets, stats, force) {\n  // 发送 hash\n  this.sockWrite(sockets, 'hash', stats.hash);\n\n  if (stats.errors.length > 0) {\n    this.sockWrite(sockets, 'errors', stats.errors);\n  } else if (stats.warnings.length > 0) {\n    this.sockWrite(sockets, 'warnings', stats.warnings);\n  } else {\n    // 发送 ok\n    this.sockWrite(sockets, 'ok');\n  }\n}\n\n\n\n# 3. 客户端接收更新消息\n\nwebpack-dev-server 中的 client / index.js：更新 hash，并且在 ok 的时候去进行检查更新 reloadApp\n\nvar onSocketMessage = {\n  // 更新 hash\n  hash: function hash(_hash) {\n    status.currentHash = _hash;\n  },\n  \n  ok: function ok() {\n    sendMessage('Ok');\n\n    if (options.useWarningOverlay || options.useErrorOverlay) {\n      overlay.clear();\n    }\n\n    if (options.initial) {\n      return options.initial = false;\n    }\n\n\t\t// 进行更新检查操作\n    reloadApp(options, status);\n  },\n}\n\n\nreloadApp 发出 webpackHotUpdate 消息，让 webpack 去执行更新操作。\n\nfunction reloadApp(\n  { hotReload, hot, liveReload },\n  { isUnloading, currentHash }\n) {\n  // ...\n  if (hot) {\n    log.info('App hot update...');\n    //  hotEmitter 其实就是 EventEmitter 的实例\n    const hotEmitter = require('webpack/hot/emitter');\n    // 又利用 node.js 的 EventEmitter，发出 webpackHotUpdate 消息。\n    // websocket 仅仅用于客户端（浏览器）和服务端进行通信。而真正做事情的活还是交回给了 webpack。\n    hotEmitter.emit('webpackHotUpdate', currentHash);\n    if (typeof self !== 'undefined' && self.window) {\n      // broadcast update to window\n      self.postMessage(`webpackHotUpdate${currentHash}`, '*');\n    }\n  }\n  // ...\n}\n\n\n在 webpack 的 hot/dev-server.js 中，监听 webpackHotUpdate 事件，并执行 check 方法。并在 check 方法中调用 module.hot.check 方法进行热更新。至于 module.hot.check ，实际上通过 HotModuleReplacementPlugin 已经注入到我们 chunk 中了（也就是我们上面所说的 HMR Runtime）\n\n// hot/dev-server.js\n// 监听webpackHotUpdate事件\nhotEmitter.on(\"webpackHotUpdate\", function (currentHash) {\n  lastHash = currentHash;\n  if (!upToDate() && module.hot.status() === \"idle\") {\n    log(\"info\", \"[HMR] Checking for updates on the server...\");\n    check();\n  }\n});\n\nvar check = function check() {\n  //  moudle.hot.check 开始热更新\n  module.hot\n    .check(true)\n    .then(function (updatedModules) {\n      // ...\n    })\n    .catch(function (err) {\n      // ...\n    });\n};\n\n\n\n# 4. 请求 hot-update.json 和 hot-update.js\n\n调用 module.hot.check 的时候，实际上就是执行 hotCheck 函数，通过调用hotDownloadmainfest方法，向server端发送ajax请求，服务端返回一个Manifest文件（即hot-update.json），该文件包含所有要更新模块的hash值和chunk名。\n\nfunction hotCheck(apply) {\n\t\t// ...\n\t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n      hotEnsureUpdateChunk(chunkId);\n    })\n}\n\n// hot-update.json 文件，h 代表本次新生成的 Hash 值，c 表示当前要热更新的文件对应的是哪个模块\n{\n    \"h\": \"0c256052432b51ed32c8\",\n    \"c\": {\n        \"201\": true\n    }\n}\n\n\n然后根据描述文件调用hotDownloadUpdateChunk方法通过jsonp请求获取到最新的模块代码\n\nfunction hotEnsureUpdateChunk(chunkId) {\n  if (!hotAvailableFilesMap[chunkId]) {\n    hotWaitingFilesMap[chunkId] = true;\n  } else {\n    hotRequestedFilesMap[chunkId] = true;\n    hotWaitingFiles++;\n    hotDownloadUpdateChunk(chunkId); // jsonp 方式\n  }\n}\n\n\n * 补丁js取回后调用 JsonpMainTemplate.runtime 的 webpackHotUpdate方法，里面会调用hotAddUpdateChunk方法，用新的模块替换掉旧的模块。\n * 调用HotMoudleReplacement.runtime.js 的 hotAddUpdateChunk方法动态更新模块代码\n * 调用 hotApply 方法热更新\n\n参考文章：\n\n * 聊聊 Webpack 热更新以及原理\n * 彻底搞懂并实现webpack热更新原理",normalizedContent:"# webpack 热更新\n\n> hmr：hot module replacement 模块热更新\n> \n> 应用程序运行过程中实时替换某个模块，页面状态不会改变\n\n\n# watch，webpack-dev-server，hmr区别\n\n * watch 模式：使用 webpack --watch 开启，文件改变后自动重新编译，但是不会自动刷新浏览器。\n * webpack-dev-server：集成工具，综合了自动编译和自动刷新浏览器的功能。\n * hmr：不用刷新浏览器，实时更新，也集成在 webpack-dev-server 中。\n\n\n# 如何使用hmr\n\n 1. 引入内置 hotmodulereplacementplugin 插件\n 2. 开启 hot: true\n\n// 使用 webpack 自带的 hotmodulereplacementplugin\nplugins: {\n    hotmodulereplacementplugin: new webpack.hotmodulereplacementplugin()\n}\n// devserver 再配置一下\ndevserver: {\n    contentbase: path.resolve(__dirname, 'dist'),\n    hot: true,\n    hotonly: false, // hot: 出现错误刷新页面，不会发现错误，hotonly: 若有错误不会刷新，可以发现错误代码\n    historyapifallback: true,\n    compress: true,\n    watchoptions: {\n      // 不监听的文件或文件夹\n      ignored: /node_modules/,\n      // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高\n      aggregatetimeout: 300,\n      // 默认每隔1000毫秒询问一次\n      poll: 1000\n    }\n}\n\n\n注：webpack的hmr并不能开箱即用，其实是需要手动处理模块替换的逻辑。\n\n * 样式文件可以直接使用，style-loader中会处理热更新的逻辑，更新后的 css 直接覆盖掉之前的 css 即可。\n\n * js模块不能直接使用，因为我们所编写的 javascript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 webpack 面对这些毫无规律的 js 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。\n\n * 通过脚手架创建的项目内部都集成了 hmr 方案，不需要自己手动处理。\n   \n   * vue.js hmr 方案：https://vue-loader.vuejs.org/guide/hot-reload.html\n   * react hmr 方案：https://github.com/gaearon/react-hot-loader\n   * san hmr 方案：https://github.com/ecomfe/san-hot-loader\n\n\n# 如何自己处理热更新逻辑\n\n以编辑器和图片热更新逻辑为例\n\nif (module.hot) {\n \tmodule.hot.accept('./editor.js', () => {\n     // 当 editor.js 更新，自动执行此函数\n     // 在这里写更新逻辑，则页面不会自动刷新，如果没有此处的手动处理，页面还会自动刷新\n  }) \n}\n\n// ================================================================\n// hmr 手动处理模块热更新\n// 不用担心这些代码在生产环境冗余的问题，因为通过 webpack 打包后，\n// 这些代码全部会被移除变为 if (false) ，这些只是开发阶段用到\nimport createeditor from './editor';\nif (module.hot) {\n  let hoteditor = editor\n  module.hot.accept('./editor.js', () => {\n    // 当 editor.js 更新，自动执行此函数\n    // 临时记录编辑器内容\n    const value = hoteditor.innerhtml\n    // 移除更新前的元素\n    document.body.removechild(hoteditor)\n    // 创建新的编辑器\n    // 此时 createeditor 已经是更新过后的函数了\n    hoteditor = createeditor()\n    // 还原编辑器内容\n    hoteditor.innerhtml = value\n    // 追加到页面\n    document.body.appendchild(hoteditor)\n  })\n\n  module.hot.accept('./better.png', () => {\n    // 当 better.png 更新后执行\n    // 重写设置 src 会触发图片元素重新加载，从而局部更新图片\n    img.src = background\n  })\n}\n\n\n至此，对于 editor 模块的热替换逻辑就算是全部实现了。我们可以发现，为什么 webpack 需要我们自己处理 js 模块的热更新了：因为不同的模块有不同的情况，不同的情况，在这里处理时肯定也是不同的。就好像，我们这里是一个文本编辑器应用，所以需要保留状态，如果不是这种类型那就不需要这样做。所以说 webpack 没法提供一个通用的 js 模块替换方案。\n\n\n# 热更新的流程\n\n> 热更新用到了websoket，因为 websocket 是一种全双工协议，它最大的特点就是 服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送信息。这是 http 协议不具备的，热更新实际上就是服务器端的更新通知到客户端。\n\n\n\n> 本地启动了一个 hmr server 服务（websocket），而且在启动 bundle server 的时候已经往我们的 bundle.js 中注入了 hmr runtime\n\n * 首次构建：1->2->a->b，webpack compiler 编译文件传输给 bunder server，浏览器可以进行访问\n\n * hmr：1->2->3->4，文件变化，然后还是 webpack compiler 进行编译，编译好了会将代码发送给 hmr server，它就可以知道哪些资源、哪些模块发生了改变。然后 hmr server 会通知 hrm runtime，浏览器就会进行对应的刷新。\n\n\n# 1. 启动 server (express 和 websocket)\n\nwebpack-dev-server 中的 server.js\n\nsetupapp() {\n  // 使用 express 框架启动本地 server，让浏览器可以请求本地的静态资源。\n  this.app = new express();\n}\n\nlisten(port, hostname, fn) {\n  return this.listeningapp.listen(port, hostname, (err) => {\n    \n    // 创建 socketserver ，可以向浏览器端传递消息。\n    this.createsocketserver();\n\n    // ...\n  });\n}\n\n\n这中间还有一个关键环节，添加 webpack-dev-middleware 中间件：\n\n> webpack-dev-middleware 将 webpack 编译后文件会输出到内存中，webpack-dev-middleware 就在此基础上形成一个文件映射系统，每当应用程序请求一个文件，它匹配到了就把内存中缓存的对应结果以文件的格式返回给你，反之则进入到下一个中间件，因为是内存型文件系统，所以重建速度非常快，很适合于开发阶段用作静态资源服务器。\n\n\n# 2. webpack compiler 编译\n\nwebpack compiler 的作用：监听本地文件的变化、文件改变自动编译、编译输出\n\nwebpack 监听文件变换是通过 watchpack 实现的，主要监听的是文件修改时间。\n\n文件改变后等待 webpack compiler 编译完成，然后通知客户端进行更新，这个过程通过 done 钩子实现，即：每当监听到一次 webpack 编译结束，就会调用 sendstats 方法，会向客户端发送 hash 和 ok 事件。\n\nsetuphooks() {\n  const addhooks = (compiler) => {\n    const { compile, invalid, done } = compiler.hooks;\n\n    compile.tap('webpack-dev-server', invalidplugin);\n    invalid.tap('webpack-dev-server', invalidplugin);\n    done.tap('webpack-dev-server', (stats) => {\n      this._sendstats(this.sockets, this.getstats(stats));\n      this._stats = stats;\n    });\n  };\n\n  if (this.compiler.compilers) {\n    this.compiler.compilers.foreach(addhooks);\n  } else {\n    addhooks(this.compiler);\n  }\n}\n\n_sendstats(sockets, stats, force) {\n  // 发送 hash\n  this.sockwrite(sockets, 'hash', stats.hash);\n\n  if (stats.errors.length > 0) {\n    this.sockwrite(sockets, 'errors', stats.errors);\n  } else if (stats.warnings.length > 0) {\n    this.sockwrite(sockets, 'warnings', stats.warnings);\n  } else {\n    // 发送 ok\n    this.sockwrite(sockets, 'ok');\n  }\n}\n\n\n\n# 3. 客户端接收更新消息\n\nwebpack-dev-server 中的 client / index.js：更新 hash，并且在 ok 的时候去进行检查更新 reloadapp\n\nvar onsocketmessage = {\n  // 更新 hash\n  hash: function hash(_hash) {\n    status.currenthash = _hash;\n  },\n  \n  ok: function ok() {\n    sendmessage('ok');\n\n    if (options.usewarningoverlay || options.useerroroverlay) {\n      overlay.clear();\n    }\n\n    if (options.initial) {\n      return options.initial = false;\n    }\n\n\t\t// 进行更新检查操作\n    reloadapp(options, status);\n  },\n}\n\n\nreloadapp 发出 webpackhotupdate 消息，让 webpack 去执行更新操作。\n\nfunction reloadapp(\n  { hotreload, hot, livereload },\n  { isunloading, currenthash }\n) {\n  // ...\n  if (hot) {\n    log.info('app hot update...');\n    //  hotemitter 其实就是 eventemitter 的实例\n    const hotemitter = require('webpack/hot/emitter');\n    // 又利用 node.js 的 eventemitter，发出 webpackhotupdate 消息。\n    // websocket 仅仅用于客户端（浏览器）和服务端进行通信。而真正做事情的活还是交回给了 webpack。\n    hotemitter.emit('webpackhotupdate', currenthash);\n    if (typeof self !== 'undefined' && self.window) {\n      // broadcast update to window\n      self.postmessage(`webpackhotupdate${currenthash}`, '*');\n    }\n  }\n  // ...\n}\n\n\n在 webpack 的 hot/dev-server.js 中，监听 webpackhotupdate 事件，并执行 check 方法。并在 check 方法中调用 module.hot.check 方法进行热更新。至于 module.hot.check ，实际上通过 hotmodulereplacementplugin 已经注入到我们 chunk 中了（也就是我们上面所说的 hmr runtime）\n\n// hot/dev-server.js\n// 监听webpackhotupdate事件\nhotemitter.on(\"webpackhotupdate\", function (currenthash) {\n  lasthash = currenthash;\n  if (!uptodate() && module.hot.status() === \"idle\") {\n    log(\"info\", \"[hmr] checking for updates on the server...\");\n    check();\n  }\n});\n\nvar check = function check() {\n  //  moudle.hot.check 开始热更新\n  module.hot\n    .check(true)\n    .then(function (updatedmodules) {\n      // ...\n    })\n    .catch(function (err) {\n      // ...\n    });\n};\n\n\n\n# 4. 请求 hot-update.json 和 hot-update.js\n\n调用 module.hot.check 的时候，实际上就是执行 hotcheck 函数，通过调用hotdownloadmainfest方法，向server端发送ajax请求，服务端返回一个manifest文件（即hot-update.json），该文件包含所有要更新模块的hash值和chunk名。\n\nfunction hotcheck(apply) {\n\t\t// ...\n\t\treturn hotdownloadmanifest(hotrequesttimeout).then(function(update) {\n      hotensureupdatechunk(chunkid);\n    })\n}\n\n// hot-update.json 文件，h 代表本次新生成的 hash 值，c 表示当前要热更新的文件对应的是哪个模块\n{\n    \"h\": \"0c256052432b51ed32c8\",\n    \"c\": {\n        \"201\": true\n    }\n}\n\n\n然后根据描述文件调用hotdownloadupdatechunk方法通过jsonp请求获取到最新的模块代码\n\nfunction hotensureupdatechunk(chunkid) {\n  if (!hotavailablefilesmap[chunkid]) {\n    hotwaitingfilesmap[chunkid] = true;\n  } else {\n    hotrequestedfilesmap[chunkid] = true;\n    hotwaitingfiles++;\n    hotdownloadupdatechunk(chunkid); // jsonp 方式\n  }\n}\n\n\n * 补丁js取回后调用 jsonpmaintemplate.runtime 的 webpackhotupdate方法，里面会调用hotaddupdatechunk方法，用新的模块替换掉旧的模块。\n * 调用hotmoudlereplacement.runtime.js 的 hotaddupdatechunk方法动态更新模块代码\n * 调用 hotapply 方法热更新\n\n参考文章：\n\n * 聊聊 webpack 热更新以及原理\n * 彻底搞懂并实现webpack热更新原理",charsets:{cjk:!0}},{title:"webpack 常见配置",frontmatter:{},regularPath:"/webpack/config.html",relativePath:"webpack/config.md",key:"v-5f833423",path:"/webpack/config.html",headers:[{level:2,title:"publicPath, contentBase 区别",slug:"publicpath-contentbase-区别",normalizedTitle:"publicpath, contentbase 区别",charIndex:19},{level:2,title:"externals",slug:"externals",normalizedTitle:"externals",charIndex:167}],lastUpdated:"8/4/2025, 3:49:09 PM",lastUpdatedTimestamp:1754293749e3,headersStr:"publicPath, contentBase 区别 externals",content:"# webpack 常见配置\n\n\n# publicPath, contentBase 区别\n\n * webpack配置中的path、publicPath和contentBase\n\n * Webpack中publicPath详解\n\n * output里面的publicPath和devServer中的publicPath的区别\n\n\n# externals\n\nWebpack 中的 externals 配置项主要用于排除某些依赖项不被打包到最终的bundle 文件中，而是在运行时从外部获取这些依赖。简单来说，就是让你的代码可以引用这些外部依赖，但它们不会被打包进你的项目中，而是通过其他方式（比如CDN 引入）提供。这样做的好处是可以减小bundle 的体积，加快页面加载速度，并避免重复打包一些常用的库。\n\n具体来说，externals 的作用包括:\n\n 1. 减少打包体积: 当你的项目依赖于一些大型库（如jQuery、React、Vue 等），并且这些库已经通过CDN 引入到页面中，或者在其他地方已经存在，那么使用 externals 就可以避免将这些库再次打包到你的项目中，从而减小最终的bundle 文件大小。\n 2. 提高加载速度: 由于减小了bundle 的体积，页面加载速度自然会得到提升，特别是对于那些依赖大量外部库的项目来说，效果更加明显。\n 3. 避免重复打包: 当多个项目都依赖同一个库时，使用 externals 可以避免每个项目都打包一份相同的库，节省资源。\n 4. 支持不同的模块化规范: externals 不仅可以用于排除全局变量，还可以支持CommonJS、AMD、UMD 等不同的模块化规范。",normalizedContent:"# webpack 常见配置\n\n\n# publicpath, contentbase 区别\n\n * webpack配置中的path、publicpath和contentbase\n\n * webpack中publicpath详解\n\n * output里面的publicpath和devserver中的publicpath的区别\n\n\n# externals\n\nwebpack 中的 externals 配置项主要用于排除某些依赖项不被打包到最终的bundle 文件中，而是在运行时从外部获取这些依赖。简单来说，就是让你的代码可以引用这些外部依赖，但它们不会被打包进你的项目中，而是通过其他方式（比如cdn 引入）提供。这样做的好处是可以减小bundle 的体积，加快页面加载速度，并避免重复打包一些常用的库。\n\n具体来说，externals 的作用包括:\n\n 1. 减少打包体积: 当你的项目依赖于一些大型库（如jquery、react、vue 等），并且这些库已经通过cdn 引入到页面中，或者在其他地方已经存在，那么使用 externals 就可以避免将这些库再次打包到你的项目中，从而减小最终的bundle 文件大小。\n 2. 提高加载速度: 由于减小了bundle 的体积，页面加载速度自然会得到提升，特别是对于那些依赖大量外部库的项目来说，效果更加明显。\n 3. 避免重复打包: 当多个项目都依赖同一个库时，使用 externals 可以避免每个项目都打包一份相同的库，节省资源。\n 4. 支持不同的模块化规范: externals 不仅可以用于排除全局变量，还可以支持commonjs、amd、umd 等不同的模块化规范。",charsets:{cjk:!0}},{title:"webpack（三）",frontmatter:{title:"webpack（三）",date:"2020-09-07T14:47:00.000Z",categories:"webpack"},regularPath:"/webpack/webpack3.html",relativePath:"webpack/webpack3.md",key:"v-7338b94a",path:"/webpack/webpack3.html",headers:[{level:2,title:"HMR",slug:"hmr",normalizedTitle:"hmr",charIndex:17},{level:2,title:"生产环境优化",slug:"生产环境优化",normalizedTitle:"生产环境优化",charIndex:24},{level:2,title:"DefinePlugin",slug:"defineplugin",normalizedTitle:"defineplugin",charIndex:34},{level:2,title:"Tree-shaking",slug:"tree-shaking",normalizedTitle:"tree-shaking",charIndex:50}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"HMR 生产环境优化 DefinePlugin Tree-shaking",content:"# webpack（三）\n\n * HMR\n * 生产环境优化\n * DefinePlugin\n * Tree-shaking\n * sideEffects\n\n\n# HMR\n\nhttps://jinjingxuan.github.io/2021/08/09/webpack-hmr/\n\n\n# 生产环境优化\n\n> 模式 （mode）：为不同的工作环境创建不同的配置\n> \n>  1. 配置文件根据环境不同导出不同配置\n>  2. 一个环境对应一个配置文件\n\nconst webpack = require('webpack')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = (env, argv) => {\n  const config = {\n\t// 正常配置\n  }\n\n  if (env === 'production') {\n    config.mode = 'production'\n    config.devtool = false\n    config.plugins = [\n      ...config.plugins,\n      new CleanWebpackPlugin(),\n      new CopyWebpackPlugin(['public']) // 生产环境需要 copy 图片等\n    ]\n  }\n\n  return config\n}\n\n// 此时在命令行中运行：webpack --env production\n\n\n若一个环境对应一个配置文件，则项目中需要有三个配置文件\n\n * webpack.common.js：存放一些公共的配置\n * webpack.dev.js\n * webpack.prod.js\n\n此时还需要安装一个插件webpack-merge，实现在原有基础上添加插件\n\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'cheap-eval-module-source-map',\n  devServer: {\n    hot: true,\n    contentBase: 'public'\n  },\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n  ]\n})\n\n\n此时命令行则需要输入webpack --config webpack.prod.js\n\n\n# DefinePlugin\n\n> 为代码注入全局成员\n\n// webpack.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      // 值要求的是一个代码片段\n      API_BASE_URL: JSON.stringify('https://api.example.com')\n    })\n  ]\n}\n\n// main.js\nconsole.log(API_BASE_URL)\n\n// 运行 webpack 打包后查看bundle.js,发现在最后添加了代码\nconsole.log(\"https://api.example.com\")\n\n\n\n# Tree-shaking\n\n摇掉那些未引用的代码，减小代码体积，在生产模式下会自动开启webpack --mode production\n\n不是生产环境需要手动配置，如下：\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  // 优化操作\n  optimization: {\n    // 负责标记枯树叶\n    usedExports: true,\n    // 负责摇掉枯树叶\n    minimize: true,\n    // 尽可能合并每一个模块到一个函数中,可以看到 bundle.js 模块数量减少了\n    // concatenateModules: true,\n  }\n}\n\n\n举个例子\n\n// components.js\nexport const Button = () => {\n  return document.createElement('button')\n\n  console.log('dead-code')\n}\n\nexport const Link = () => {\n  return document.createElement('a')\n}\n\nexport const Heading = level => {\n  return document.createElement('h' + level)\n}\n\n// index.js,只有Button被使用\nimport { Button } from './components'\n\ndocument.body.appendChild(Button())\n\n// 正常用 webpack 命令打包时，在 bundle.js 中搜不到 Link, Heading，console.log\n\n\n# 问题：使用babel-loader后，Tree-shaking会失效？\n\n * 由webpack打包的代码必须使用ES Modules，先交给loader处理，然后再打包\n * 而babel转换时，可能会将 ES Module 转换成 CommonJS ,就会失效，但是最新版的babel没问题\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              // 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效\n              // ['@babel/preset-env', { modules: 'commonjs' }]\n                \n              // 设置为false就不会开启转换\n              // ['@babel/preset-env', { modules: false }]\n                \n              // 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换\n              ['@babel/preset-env', { modules: 'auto' }]\n            ]\n          }\n        }\n      }\n    ]\n  },\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true,\n    // 尽可能合并每一个模块到一个函数中\n    // concatenateModules: true,\n    // 压缩输出结果\n    // minimize: true\n  }\n}\n\n",normalizedContent:"# webpack（三）\n\n * hmr\n * 生产环境优化\n * defineplugin\n * tree-shaking\n * sideeffects\n\n\n# hmr\n\nhttps://jinjingxuan.github.io/2021/08/09/webpack-hmr/\n\n\n# 生产环境优化\n\n> 模式 （mode）：为不同的工作环境创建不同的配置\n> \n>  1. 配置文件根据环境不同导出不同配置\n>  2. 一个环境对应一个配置文件\n\nconst webpack = require('webpack')\nconst { cleanwebpackplugin } = require('clean-webpack-plugin')\nconst copywebpackplugin = require('copy-webpack-plugin')\n\nmodule.exports = (env, argv) => {\n  const config = {\n\t// 正常配置\n  }\n\n  if (env === 'production') {\n    config.mode = 'production'\n    config.devtool = false\n    config.plugins = [\n      ...config.plugins,\n      new cleanwebpackplugin(),\n      new copywebpackplugin(['public']) // 生产环境需要 copy 图片等\n    ]\n  }\n\n  return config\n}\n\n// 此时在命令行中运行：webpack --env production\n\n\n若一个环境对应一个配置文件，则项目中需要有三个配置文件\n\n * webpack.common.js：存放一些公共的配置\n * webpack.dev.js\n * webpack.prod.js\n\n此时还需要安装一个插件webpack-merge，实现在原有基础上添加插件\n\nconst webpack = require('webpack')\nconst merge = require('webpack-merge')\nconst common = require('./webpack.common')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'cheap-eval-module-source-map',\n  devserver: {\n    hot: true,\n    contentbase: 'public'\n  },\n  plugins: [\n    new webpack.hotmodulereplacementplugin()\n  ]\n})\n\n\n此时命令行则需要输入webpack --config webpack.prod.js\n\n\n# defineplugin\n\n> 为代码注入全局成员\n\n// webpack.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  plugins: [\n    new webpack.defineplugin({\n      // 值要求的是一个代码片段\n      api_base_url: json.stringify('https://api.example.com')\n    })\n  ]\n}\n\n// main.js\nconsole.log(api_base_url)\n\n// 运行 webpack 打包后查看bundle.js,发现在最后添加了代码\nconsole.log(\"https://api.example.com\")\n\n\n\n# tree-shaking\n\n摇掉那些未引用的代码，减小代码体积，在生产模式下会自动开启webpack --mode production\n\n不是生产环境需要手动配置，如下：\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  // 优化操作\n  optimization: {\n    // 负责标记枯树叶\n    usedexports: true,\n    // 负责摇掉枯树叶\n    minimize: true,\n    // 尽可能合并每一个模块到一个函数中,可以看到 bundle.js 模块数量减少了\n    // concatenatemodules: true,\n  }\n}\n\n\n举个例子\n\n// components.js\nexport const button = () => {\n  return document.createelement('button')\n\n  console.log('dead-code')\n}\n\nexport const link = () => {\n  return document.createelement('a')\n}\n\nexport const heading = level => {\n  return document.createelement('h' + level)\n}\n\n// index.js,只有button被使用\nimport { button } from './components'\n\ndocument.body.appendchild(button())\n\n// 正常用 webpack 命令打包时，在 bundle.js 中搜不到 link, heading，console.log\n\n\n# 问题：使用babel-loader后，tree-shaking会失效？\n\n * 由webpack打包的代码必须使用es modules，先交给loader处理，然后再打包\n * 而babel转换时，可能会将 es module 转换成 commonjs ,就会失效，但是最新版的babel没问题\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              // 如果 babel 加载模块时已经转换了 esm，则会导致 tree shaking 失效\n              // ['@babel/preset-env', { modules: 'commonjs' }]\n                \n              // 设置为false就不会开启转换\n              // ['@babel/preset-env', { modules: false }]\n                \n              // 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 esm 转换\n              ['@babel/preset-env', { modules: 'auto' }]\n            ]\n          }\n        }\n      }\n    ]\n  },\n  optimization: {\n    // 模块只导出被使用的成员\n    usedexports: true,\n    // 尽可能合并每一个模块到一个函数中\n    // concatenatemodules: true,\n    // 压缩输出结果\n    // minimize: true\n  }\n}\n\n",charsets:{cjk:!0}},{title:"webpack（二）",frontmatter:{title:"webpack（二）",date:"2020-09-06T14:47:00.000Z",categories:"webpack"},regularPath:"/webpack/webpack2.html",relativePath:"webpack/webpack2.md",key:"v-7a5510c6",path:"/webpack/webpack2.html",headers:[{level:2,title:"webpack插件机制",slug:"webpack插件机制",normalizedTitle:"webpack插件机制",charIndex:17},{level:3,title:"clean-webpack-plugin",slug:"clean-webpack-plugin",normalizedTitle:"clean-webpack-plugin",charIndex:211},{level:3,title:"html-webpack-plugin",slug:"html-webpack-plugin",normalizedTitle:"html-webpack-plugin",charIndex:455},{level:3,title:"copy-webpack-plugin",slug:"copy-webpack-plugin",normalizedTitle:"copy-webpack-plugin",charIndex:1142},{level:3,title:"插件原理",slug:"插件原理",normalizedTitle:"插件原理",charIndex:1255},{level:3,title:"理解Compiler（负责编译）",slug:"理解compiler-负责编译",normalizedTitle:"理解compiler（负责编译）",charIndex:1318},{level:3,title:"理解Compilation",slug:"理解compilation",normalizedTitle:"理解compilation",charIndex:1498},{level:2,title:"webpack-dev-server",slug:"webpack-dev-server",normalizedTitle:"webpack-dev-server",charIndex:2778},{level:3,title:"proxy代理",slug:"proxy代理",normalizedTitle:"proxy代理",charIndex:3598},{level:2,title:"Sourcemap",slug:"sourcemap",normalizedTitle:"sourcemap",charIndex:54}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"webpack插件机制 clean-webpack-plugin html-webpack-plugin copy-webpack-plugin 插件原理 理解Compiler（负责编译） 理解Compilation webpack-dev-server proxy代理 Sourcemap",content:"# webpack（二）\n\n * webpack插件机制\n * webpack dev server\n * Sourcemap\n * splitChunks\n\n\n# webpack插件机制\n\n * Loader专注实现资源模块加载\n * Plugin解决其他自动化工作\n   * 清除dist目录\n   * 拷贝静态文件至输出目录\n   * 压缩输出代码\n\nwebpack + plugin 基本实现了前端工程化\n\n\n# clean-webpack-plugin\n\n> 作用： 清除dist目录插件\n\ncnpmm install -D clean-webpack-plugin\n\n// webpack.config.js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  // 新增\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}\n\n\n\n# html-webpack-plugin\n\n> 作用：自动生成引用bundle.js的html文件\n\ncnpm install -D html-webpack-plugin\n\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    // publicPath: 'dist/'\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    // 用于生成 index.html\n    new HtmlWebpackPlugin({\n      title: 'Webpack Plugin Sample',\n      meta: {\n        viewport: 'width=device-width'\n      },\n      template: './src/index.html' // 模板\n    }),\n    // 用于生成 about.html\n    new HtmlWebpackPlugin({\n      filename: 'about.html'\n    })\n  ]\n}\n\n\n\n# copy-webpack-plugin\n\n plugins: [\n    new CopyWebpackPlugin([\n      // 'public/**'\n      'public'\n    ])\n  ]\n\n\n\n# 插件原理\n\n> webpack过程中存在钩子函数，插件挂载在其上面\n> \n> 例：实现移除bundle.js中的注释\n\n\n# 理解Compiler（负责编译）\n\n开发插件首先要知道compiler和 compilation 对象是做什么的\n\nCompiler 对象包含了当前运行Webpack的配置，包括entry、output、loaders等配置，这个对象在启动Webpack时被实例化，而且是全局唯一的。Plugin可以通过该对象获取到Webpack的配置信息进行处理。\n\n\n# 理解Compilation\n\nCompilation对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 Compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。Compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。\n\napply方法中插入钩子的一般形式如下：\n\n// compiler提供了compiler.hooks，可以根据这些不同的时刻去让插件做不同的事情。\n\ncompiler.hooks.阶段.tap函数('插件名称', (阶段回调参数) => {\n\n});\n\ncompiler.run(callback)\n\n\n// webpack.config.js\nclass MyPlugin {\n  apply (compiler) { // compiler对象为webpack一核心对象，通过他来找钩子函数\n    console.log('MyPlugin 启动')\n\t\n    // Webpack 会调用 Plugin 实例的 apply 方法给插件实例传入 compiler 对象\n    compiler.hooks.emit.tap('MyPlugin', compilation => { // 挂载在emit方法上\n      // compilation => 可以理解为此次打包的上下文\n      for (const name in compilation.assets) {\n        // console.log(name)                              // 输出文件名\n        // console.log(compilation.assets[name].source()) // 输出文件内容 \n        if (name.endsWith('.js')) {\n          const contents = compilation.assets[name].source() // 获取内容\n          const withoutComments = contents.replace(/\\/\\*\\*+\\*\\//g, '') // 删除注释\n          compilation.assets[name] = {\n            source: () => withoutComments, // 替换内容\n            size: () => withoutComments.length // 必要注释：长度\n          }\n        }\n      }\n    })\n  }\n}\n\nplugins: [\n    new MyPlugin()\n  ]\n\n\n\n# webpack-dev-server\n\n如何自动编译：修改源文件后自动打包\n\n只需要在启动webpack命令时，添加webpack --watch即可\n\n如何自动刷新浏览器\n\n使用browser-sync：browser-sync dist --files \"**/*\"\n\n> 组合这两种方式可以实现，修改源文件时自动刷新浏览器。\n> \n> 缺点：1. 操作复杂：需要同时运行两个终端命令。2. 消耗大：先打包写入磁盘，再读出磁盘刷新浏览器\n\nwebpack-dev-server\n\nwebpack dev server：将自动编译和自动刷新集成在一起\n\n安装：cnpm install -D webpack-dev-server\n\n> 优点：不会生成dist目录造成磁盘读写操作，均存储在内存中\n> \n> webpack-dev-server --open 命令可自动打开浏览器\n\n静态资源文件的处理\n\n> 在开发阶段，因为要频繁的打包和编译，尽量不将图片等静态资源文件一起打包到dist目录中\n\n// webpack.config.js\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist')\n  },\n  devServer: {\n    contentBase: './public', // 使用contentBase来设置\n  },\n  module: {\n   // ...\n  },\n  plugins: [\n    // ...\n      \n    // // 开发阶段最好不要使用这个插件\n    // new CopyWebpackPlugin(['public'])\n  ]\n}\n\n\n\n# proxy代理\n\n> 由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n> \n> 那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。\n> \n> 可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。\n> \n> 那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。\n> \n> webpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。\n> \n> 比如我们假定 GitHub 的 API 就是我们应用的后端服务，那我们的目标就是将 GitHub API 代理到本地开发服务器中，我们可以先在浏览器中尝试访问其中的一个接口： https://api.github.com/users\n\ndevServer: {\n    contentBase: './public',\n    proxy: {\n      '/api': {\n        // http://localhost:8080/api/users -> https://api.github.com/api/users\n        target: 'https://api.github.com',\n        // http://localhost:8080/api/users -> https://api.github.com/users\n        pathRewrite: {\n          '^/api': ''\n        },\n        // 不能使用 localhost:8080 作为请求 GitHub 的主机名\n        changeOrigin: true\n      }\n    }\n  },\n\n\n\n\n那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/users\n\n// 此时再写跨域请求，就可正常访问\n// 虽然 GitHub 支持 CORS，但是不是每个服务端都应该支持。\n// fetch('https://api.github.com/users')\nfetch('/api/users') // 实际请求到http://localhost:8080/api/users\n  .then(res => res.json())\n  .then(data => {\n    data.forEach(item => {\n      const li = document.createElement('li')\n      li.textContent = item.login\n      ul.append(li)\n    })\n  })\n\n\n\n# Sourcemap\n\n> SourceMap是一种映射关系。当项目运行后，如果出现错误，错误信息只能定位到打包后文件中错误的位置。如果想查看在源文件中错误的位置，则需要使用映射关系，找到对应的位置。\n\n那么如何在webpack中配置Sourcemap呢？\n\n// webpack.config.js\n\nmodule.exports = {\n  devtool: 'source-map' \n}\n\n// 此时在代码中写一个错误，就可以在控制台看到源文件的错误\n\n\n该配置可选且具有多个配置项 ，具体包含以下：\n\nDEVTOOL                          构建速度   重新构建速度   生产环境   品质(QUALITY)\n(none)                           +++    +++      yes    打包后的代码\neval                             +++    +++      no     生成后的代码\ncheap-eval-source-map            +      ++       no     转换过的代码（仅限行）\ncheap-module-eval-source-map     o      ++       no     原始源代码（仅限行）\neval-source-map                  --     +        no     原始源代码\ncheap-source-map                 +      o        yes    转换过的代码（仅限行）\ncheap-module-source-map          o      -        yes    原始源代码（仅限行）\ninline-cheap-source-map          +      o        no     转换过的代码（仅限行）\ninline-cheap-module-source-map   o      -        no     原始源代码（仅限行）\nsource-map                       --     --       yes    原始源代码\ninline-source-map                --     --       no     原始源代码\nhidden-source-map                --     --       yes    原始源代码\nnosources-source-map             --     --       yes    无源代码内容\n\n> +++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, -- 慢\n\n * eval：打包后的模块都使用 eval() 执行，不产生独立的 map 文件\n * cheap：Source map是否包含行信息\n * module：是否能够得到 Loader 处理之前的源代码，即手写的es6没有编译的源代码\n * inline：使用 dataURL 把 SourceMap 嵌入 （不常用）\n * hidden：控制台看不到SourceMap\n * nosources：看不见源代码，生产环境保护源代码\n\n----------------------------------------\n\n * eval-source-map：相比 eval 生成了 SourceMap\n * cheap-eval-source-map：简单版的eval-source-map，只有行没有列\n * cheap-module-eval-source-map：没有经过 loader 加工，真正的源代码（vue中常用）\n\n----------------------------------------\n\n开发模式：cheap-module-eval-source-map\n\n生产模式：none",normalizedContent:"# webpack（二）\n\n * webpack插件机制\n * webpack dev server\n * sourcemap\n * splitchunks\n\n\n# webpack插件机制\n\n * loader专注实现资源模块加载\n * plugin解决其他自动化工作\n   * 清除dist目录\n   * 拷贝静态文件至输出目录\n   * 压缩输出代码\n\nwebpack + plugin 基本实现了前端工程化\n\n\n# clean-webpack-plugin\n\n> 作用： 清除dist目录插件\n\ncnpmm install -d clean-webpack-plugin\n\n// webpack.config.js\nconst { cleanwebpackplugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  // 新增\n  plugins: [\n    new cleanwebpackplugin()\n  ]\n}\n\n\n\n# html-webpack-plugin\n\n> 作用：自动生成引用bundle.js的html文件\n\ncnpm install -d html-webpack-plugin\n\nconst path = require('path')\nconst htmlwebpackplugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist'),\n    // publicpath: 'dist/'\n  },\n  plugins: [\n    new cleanwebpackplugin(),\n    // 用于生成 index.html\n    new htmlwebpackplugin({\n      title: 'webpack plugin sample',\n      meta: {\n        viewport: 'width=device-width'\n      },\n      template: './src/index.html' // 模板\n    }),\n    // 用于生成 about.html\n    new htmlwebpackplugin({\n      filename: 'about.html'\n    })\n  ]\n}\n\n\n\n# copy-webpack-plugin\n\n plugins: [\n    new copywebpackplugin([\n      // 'public/**'\n      'public'\n    ])\n  ]\n\n\n\n# 插件原理\n\n> webpack过程中存在钩子函数，插件挂载在其上面\n> \n> 例：实现移除bundle.js中的注释\n\n\n# 理解compiler（负责编译）\n\n开发插件首先要知道compiler和 compilation 对象是做什么的\n\ncompiler 对象包含了当前运行webpack的配置，包括entry、output、loaders等配置，这个对象在启动webpack时被实例化，而且是全局唯一的。plugin可以通过该对象获取到webpack的配置信息进行处理。\n\n\n# 理解compilation\n\ncompilation对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。\n\napply方法中插入钩子的一般形式如下：\n\n// compiler提供了compiler.hooks，可以根据这些不同的时刻去让插件做不同的事情。\n\ncompiler.hooks.阶段.tap函数('插件名称', (阶段回调参数) => {\n\n});\n\ncompiler.run(callback)\n\n\n// webpack.config.js\nclass myplugin {\n  apply (compiler) { // compiler对象为webpack一核心对象，通过他来找钩子函数\n    console.log('myplugin 启动')\n\t\n    // webpack 会调用 plugin 实例的 apply 方法给插件实例传入 compiler 对象\n    compiler.hooks.emit.tap('myplugin', compilation => { // 挂载在emit方法上\n      // compilation => 可以理解为此次打包的上下文\n      for (const name in compilation.assets) {\n        // console.log(name)                              // 输出文件名\n        // console.log(compilation.assets[name].source()) // 输出文件内容 \n        if (name.endswith('.js')) {\n          const contents = compilation.assets[name].source() // 获取内容\n          const withoutcomments = contents.replace(/\\/\\*\\*+\\*\\//g, '') // 删除注释\n          compilation.assets[name] = {\n            source: () => withoutcomments, // 替换内容\n            size: () => withoutcomments.length // 必要注释：长度\n          }\n        }\n      }\n    })\n  }\n}\n\nplugins: [\n    new myplugin()\n  ]\n\n\n\n# webpack-dev-server\n\n如何自动编译：修改源文件后自动打包\n\n只需要在启动webpack命令时，添加webpack --watch即可\n\n如何自动刷新浏览器\n\n使用browser-sync：browser-sync dist --files \"**/*\"\n\n> 组合这两种方式可以实现，修改源文件时自动刷新浏览器。\n> \n> 缺点：1. 操作复杂：需要同时运行两个终端命令。2. 消耗大：先打包写入磁盘，再读出磁盘刷新浏览器\n\nwebpack-dev-server\n\nwebpack dev server：将自动编译和自动刷新集成在一起\n\n安装：cnpm install -d webpack-dev-server\n\n> 优点：不会生成dist目录造成磁盘读写操作，均存储在内存中\n> \n> webpack-dev-server --open 命令可自动打开浏览器\n\n静态资源文件的处理\n\n> 在开发阶段，因为要频繁的打包和编译，尽量不将图片等静态资源文件一起打包到dist目录中\n\n// webpack.config.js\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.join(__dirname, 'dist')\n  },\n  devserver: {\n    contentbase: './public', // 使用contentbase来设置\n  },\n  module: {\n   // ...\n  },\n  plugins: [\n    // ...\n      \n    // // 开发阶段最好不要使用这个插件\n    // new copywebpackplugin(['public'])\n  ]\n}\n\n\n\n# proxy代理\n\n> 由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n> \n> 那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 api，回到我们的开发环境后，再次访问这些 api 就会产生跨域请求问题。\n> \n> 可能有人会说，我们可以用跨域资源共享（cors）解决这个问题。确实如此，如果我们请求的后端 api 支持 cors，那这个问题就不成立了。但是并不是每种情况下服务端的 api 都支持 cors。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 cors，所以跨域请求的问题仍然是不可避免的。\n> \n> 那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 api 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。\n> \n> webpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。\n> \n> 比如我们假定 github 的 api 就是我们应用的后端服务，那我们的目标就是将 github api 代理到本地开发服务器中，我们可以先在浏览器中尝试访问其中的一个接口： https://api.github.com/users\n\ndevserver: {\n    contentbase: './public',\n    proxy: {\n      '/api': {\n        // http://localhost:8080/api/users -> https://api.github.com/api/users\n        target: 'https://api.github.com',\n        // http://localhost:8080/api/users -> https://api.github.com/users\n        pathrewrite: {\n          '^/api': ''\n        },\n        // 不能使用 localhost:8080 作为请求 github 的主机名\n        changeorigin: true\n      }\n    }\n  },\n\n\n\n\n那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/users\n\n// 此时再写跨域请求，就可正常访问\n// 虽然 github 支持 cors，但是不是每个服务端都应该支持。\n// fetch('https://api.github.com/users')\nfetch('/api/users') // 实际请求到http://localhost:8080/api/users\n  .then(res => res.json())\n  .then(data => {\n    data.foreach(item => {\n      const li = document.createelement('li')\n      li.textcontent = item.login\n      ul.append(li)\n    })\n  })\n\n\n\n# sourcemap\n\n> sourcemap是一种映射关系。当项目运行后，如果出现错误，错误信息只能定位到打包后文件中错误的位置。如果想查看在源文件中错误的位置，则需要使用映射关系，找到对应的位置。\n\n那么如何在webpack中配置sourcemap呢？\n\n// webpack.config.js\n\nmodule.exports = {\n  devtool: 'source-map' \n}\n\n// 此时在代码中写一个错误，就可以在控制台看到源文件的错误\n\n\n该配置可选且具有多个配置项 ，具体包含以下：\n\ndevtool                          构建速度   重新构建速度   生产环境   品质(quality)\n(none)                           +++    +++      yes    打包后的代码\neval                             +++    +++      no     生成后的代码\ncheap-eval-source-map            +      ++       no     转换过的代码（仅限行）\ncheap-module-eval-source-map     o      ++       no     原始源代码（仅限行）\neval-source-map                  --     +        no     原始源代码\ncheap-source-map                 +      o        yes    转换过的代码（仅限行）\ncheap-module-source-map          o      -        yes    原始源代码（仅限行）\ninline-cheap-source-map          +      o        no     转换过的代码（仅限行）\ninline-cheap-module-source-map   o      -        no     原始源代码（仅限行）\nsource-map                       --     --       yes    原始源代码\ninline-source-map                --     --       no     原始源代码\nhidden-source-map                --     --       yes    原始源代码\nnosources-source-map             --     --       yes    无源代码内容\n\n> +++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, -- 慢\n\n * eval：打包后的模块都使用 eval() 执行，不产生独立的 map 文件\n * cheap：source map是否包含行信息\n * module：是否能够得到 loader 处理之前的源代码，即手写的es6没有编译的源代码\n * inline：使用 dataurl 把 sourcemap 嵌入 （不常用）\n * hidden：控制台看不到sourcemap\n * nosources：看不见源代码，生产环境保护源代码\n\n----------------------------------------\n\n * eval-source-map：相比 eval 生成了 sourcemap\n * cheap-eval-source-map：简单版的eval-source-map，只有行没有列\n * cheap-module-eval-source-map：没有经过 loader 加工，真正的源代码（vue中常用）\n\n----------------------------------------\n\n开发模式：cheap-module-eval-source-map\n\n生产模式：none",charsets:{cjk:!0}},{title:"webpack（四）",frontmatter:{title:"webpack（四）",date:"2020-09-08T14:47:00.000Z",categories:"webpack"},regularPath:"/webpack/webpack4.html",relativePath:"webpack/webpack4.md",key:"v-6c1c61ce",path:"/webpack/webpack4.html",headers:[{level:2,title:"Webpack sideEffects",slug:"webpack-sideeffects",normalizedTitle:"webpack sideeffects",charIndex:17},{level:2,title:"代码分割",slug:"代码分割",normalizedTitle:"代码分割",charIndex:1348},{level:3,title:"多入口打包配置",slug:"多入口打包配置",normalizedTitle:"多入口打包配置",charIndex:1547},{level:3,title:"动态导入",slug:"动态导入",normalizedTitle:"动态导入",charIndex:1520},{level:2,title:"mini-css-extract-plugin",slug:"mini-css-extract-plugin",normalizedTitle:"mini-css-extract-plugin",charIndex:58},{level:2,title:"文件名 Hash",slug:"文件名-hash",normalizedTitle:"文件名 hash",charIndex:85}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"Webpack sideEffects 代码分割 多入口打包配置 动态导入 mini-css-extract-plugin 文件名 Hash",content:"# webpack（四）\n\n * Webpack sideEffects\n * Code Splitting\n * mini-css-extract-plugin\n * 文件名 Hash\n\n\n# Webpack sideEffects\n\n> 副作用：模块执行时除了导出成员之外所做的事情\n> \n> 比如一个 css 文件没有导出，可认为有副作用\n\n|--components\n\t\t--button.js\n\t\t--heading.js\n\t\t--link.js\n\t\t--index.js\n|--index.js\n\n\n// components/index.js\n\nexport { default as Button } from './button'\nexport { default as Link } from './link'\nexport { default as Heading } from './heading'\n\n// 入口文件 index.js\nimport { Button } from './components'\n// 只想载入 Button 却载入了所有模块\n\n\n// webpack.config.js\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  optimization: {\n    sideEffects: true, // 标识为true就会去package.json中去检查有无副作用\n  }\n}\n\n// package.json\n{\n  \"name\": \"31-side-effects\",\n  \"version\": \"0.1.0\",\n  \"main\": \"index.js\",\n  \"author\": \"zce <w@zce.me> (https://zce.me)\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build\": \"webpack\"\n  },\n  \"devDependencies\": {\n    \"css-loader\": \"^3.2.0\",\n    \"style-loader\": \"^1.0.0\",\n    \"webpack\": \"^4.41.2\",\n    \"webpack-cli\": \"^3.3.9\"\n  },\n  // \"sideEffects\": false  //设置为false说明没有副作用，则多余的模块不会被打包\n  \"sideEffects\": [\n    \"./src/extend.js\", // 标识一下有副作用而不想被删除的模块，防止不会被打包\n    \"*.css\"\n  ]\n}\n\n\n\n\n# 代码分割\n\n> webpack将所有模块都打包到一起，但是并不是每个模块在启动时都是必要的。\n> \n> 更好的方案是把打包结果按一定的规则分离，按照应用的运行结果按需加载。\n> \n> webpack 的理念就是把各个模块打包到一起，现在又要分离开来，是否矛盾？不矛盾，物极必反而已。\n\n * 多入口打包：一个页面一个入口，公共部分提取。\n * 动态导入：需要某个模块时，再去加载这个模块。\n\n\n# 多入口打包配置\n\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    index: './src/index.js',  // 多入口\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // 生成对应的文件名\n  },\n  optimization: {\n    splitChunks: {\n      // 自动提取所有公共模块到单独 bundle 一个文件\n      // 打包后: index.bundle.js, album.bundle.js, index~album.bundle.js（公共部分）\n      chunks: 'all'\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/index.html',\n      filename: 'index.html',\n      chunks: ['index']  // index.html 只会引入打包后的 index.js\n    }),\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/album.html',\n      filename: 'album.html',\n      chunks: ['album'] // album.html 只会引入打包后的 album.js\n    })\n  ]\n}\n\n\n\n# 动态导入\n\n> 需要某个模块时再去加载，动态导入的模块会被自动分包，例如常见的数字开头的 js 文件: 0.js 就是这类模块分包出来的文件。\n\n// import posts from './posts/posts'\n// import album from './album/album'\n// 删除固定导入\n\nconst render = () => {\n  const hash = window.location.hash || '#posts'\n\n  const mainElement = document.querySelector('.main')\n\n  mainElement.innerHTML = ''\n  // 根据 hash 值动态导入\n  if (hash === '#posts') {\n    // 魔法注释可以设置打包后文件名\n    import(/* webpackChunkName: 'components' */'./posts/posts').then(({ default: posts }) => {\t\n      mainElement.appendChild(posts())\n    })\n  } else if (hash === '#album') {\n    // 魔法注释可以设置打包后文件名\n    import(/* webpackChunkName: 'components' */'./album/album').then(({ default: album }) => {\n      mainElement.appendChild(album())\n    })\n  }\n}\n\nrender()\n\nwindow.addEventListener('hashchange', render)\n\n\nwebpack SplitChunksPlugin实用指南\n\nWebpack之SplitChunks插件用法详解\n\n> 在研究splitChunks之前，我们必须先弄明白这三个名词是什么意思，主要是chunk的含义，要不然你就不知道splitChunks是在什么的基础上进行拆分。\n> \n>  * module：就是js的模块化webpack支持commonJS、ES6等模块化规范，简单来说就是你通过import语句引入的代码。\n>  * chunk: chunk是webpack根据功能拆分出来的，包含三种情况：\n> \n> 1、你的项目入口（entry）\n> \n> 2、通过import()动态引入的代码（默认分包）\n> \n> 3、通过splitChunks拆分出来的代码\n> \n> chunk包含着module，可能是一对多也可能是一对一。\n> \n>  * bundle：bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，bundle就是对chunk进行编译压缩打包等处理之后的产出。\n\nconst resolve = require('path').resolve\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n    mode: 'none',\n    entry: {\n        entry1: './src/entry1.js',\n        entry2: './src/entry2.js'\n    },\n    plugins: [\n        new CleanWebpackPlugin()\n    ],\n    output: {\n        filename: '[name].bundle.js',\n        path: resolve(__dirname, 'dist')\n    },\n    optimization: {\n        // splitChunks作用: 把 entry1.js 和 entry2.js 都共同引入的模块分包出来。\n        // 假如 entry1.js 和 entry2.js 都引入了 element，那么 entry1.bundle.js 和 entry2.bundle.js\n        // 不分包的话都会将 element 打包进去，两个文件就都会很大，所以需要分包处理\n        splitChunks: {\n            // 默认值就是async，分包的对象共同引入的异步模块。\n            // initial: 分包的对象是共同引入的初始静态导入模块。all: 分包所有的共同引入的模块。\n            chunks: 'all',\n            // name代表打包出来的 chunk 的名称，有三种值：\n            // 1.boolean = false (webpack5中不支持true)\n            // 2.function (module, chunks, cacheGroupKey) => string \n            // 3.string\n            // 一般都是使用 false，就是以 cacheGroups 中的 name 命名，如果没有 name，默认为 2.js, 3.js 这种数字类型的\n            name: false,\n            // 表示要被提取的模块最小被引用次数，引用次数超过或等于minChunks值，才能被提取\n            // 这个例子里 subtract 被引用了 2 次，如果设置成 3 则不能被分包\n            minChunks: 2,\n            // 表示只有超过了多少字节才会被提取, 默认值是 20000，这里设置成 1 是为了这个例子里能分包 modules 中模块\n            minSize: 1,\n            // 模块打包生成的文件大小不能超过的值，如果超了要对其进行分割并打包生成新的文件。\n            // webpack4中默认为0表示大小不限制, webpack5中取消了默认值设置为0时表示大于0的就会分割\n            maxSize: 9999999999,\n            // 动态引入的模块，并行请求的最大数量\n            maxAsyncRequests: 5,\n            // 打包后的入口文件加载时，能同时初始加载js文件的数量\n            // 优先级: maxInitialRequest/maxAsyncRequests < maxSize < minSize\n            maxInitialRequests: 3,\n            // 命名连接符\n            automaticNameDelimiter: '~',\n            cacheGroups: {\n                vendors: {\n                    name: 'vendors',\n                    test: /[\\\\/]node_modules[\\\\/]/,\n                    priority: 10\n                },\n                modules: {\n                    name: 'modules',\n                    test: resolve('src/modules'),\n                    priority: 10,\n                    reuseExistingChunk: true\n                }\n            }\n        }\n    }\n}\n\n\n * demo\n * 官方文档\n\n\n# mini-css-extract-plugin\n\n> mini-css-extract-plugin将css单独提取出来，如果 css 超过 150KB 时需要单独提取\n> \n> 提取出来后还需要用OptimizeCssAssetsWebpackPlugin进行压缩\n> \n> 因为 webpack 内置的压缩插件只打包 js 文件\n\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  optimization: {\n    minimizer: [\n      new TerserWebpackPlugin(),\n      new OptimizeCssAssetsWebpackPlugin() \n    ]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 'style-loader', // 将样式通过 style 标签注入\n          MiniCssExtractPlugin.loader, // 直接通过 link 方式引入\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin()\n  ]\n}\n\n\n> 为什么ptimizeCssAssetsWebpackPlugin插件放在这不放在 plugins 数组中呢 ?\n> \n> 因为放在 plugins 说明在任何时候都会加载这个插件，而我们放到 minimizer 中，只会在生产环境开启 minimizer 时工作\n> \n> 但是这时会发现 js 没有压缩，因为我们设置了minimizer，webpack会认为我们自定义了压缩插件，所以我们还要添加回去压缩 js 的插件TerserWebpackPlugin。\n\n\n# 文件名 Hash\n\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'Dynamic import',\n      template: './src/index.html',\n      filename: 'index.html'\n    }),\n    new MiniCssExtractPlugin({\n      filename: '[name]-[contenthash:8].bundle.css' // 文件级别的hash\n      // filename: '[name]-[chunkhash].bundle.css'  // chunk级别\n      // filename: '[name]-[hash].bundle.css'       // 项目级别，一个文件改变，所有hash全部改变\n    })\n  ]\n}\n",normalizedContent:"# webpack（四）\n\n * webpack sideeffects\n * code splitting\n * mini-css-extract-plugin\n * 文件名 hash\n\n\n# webpack sideeffects\n\n> 副作用：模块执行时除了导出成员之外所做的事情\n> \n> 比如一个 css 文件没有导出，可认为有副作用\n\n|--components\n\t\t--button.js\n\t\t--heading.js\n\t\t--link.js\n\t\t--index.js\n|--index.js\n\n\n// components/index.js\n\nexport { default as button } from './button'\nexport { default as link } from './link'\nexport { default as heading } from './heading'\n\n// 入口文件 index.js\nimport { button } from './components'\n// 只想载入 button 却载入了所有模块\n\n\n// webpack.config.js\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  optimization: {\n    sideeffects: true, // 标识为true就会去package.json中去检查有无副作用\n  }\n}\n\n// package.json\n{\n  \"name\": \"31-side-effects\",\n  \"version\": \"0.1.0\",\n  \"main\": \"index.js\",\n  \"author\": \"zce <w@zce.me> (https://zce.me)\",\n  \"license\": \"mit\",\n  \"scripts\": {\n    \"build\": \"webpack\"\n  },\n  \"devdependencies\": {\n    \"css-loader\": \"^3.2.0\",\n    \"style-loader\": \"^1.0.0\",\n    \"webpack\": \"^4.41.2\",\n    \"webpack-cli\": \"^3.3.9\"\n  },\n  // \"sideeffects\": false  //设置为false说明没有副作用，则多余的模块不会被打包\n  \"sideeffects\": [\n    \"./src/extend.js\", // 标识一下有副作用而不想被删除的模块，防止不会被打包\n    \"*.css\"\n  ]\n}\n\n\n\n\n# 代码分割\n\n> webpack将所有模块都打包到一起，但是并不是每个模块在启动时都是必要的。\n> \n> 更好的方案是把打包结果按一定的规则分离，按照应用的运行结果按需加载。\n> \n> webpack 的理念就是把各个模块打包到一起，现在又要分离开来，是否矛盾？不矛盾，物极必反而已。\n\n * 多入口打包：一个页面一个入口，公共部分提取。\n * 动态导入：需要某个模块时，再去加载这个模块。\n\n\n# 多入口打包配置\n\nconst { cleanwebpackplugin } = require('clean-webpack-plugin')\nconst htmlwebpackplugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    index: './src/index.js',  // 多入口\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // 生成对应的文件名\n  },\n  optimization: {\n    splitchunks: {\n      // 自动提取所有公共模块到单独 bundle 一个文件\n      // 打包后: index.bundle.js, album.bundle.js, index~album.bundle.js（公共部分）\n      chunks: 'all'\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new cleanwebpackplugin(),\n    new htmlwebpackplugin({\n      title: 'multi entry',\n      template: './src/index.html',\n      filename: 'index.html',\n      chunks: ['index']  // index.html 只会引入打包后的 index.js\n    }),\n    new htmlwebpackplugin({\n      title: 'multi entry',\n      template: './src/album.html',\n      filename: 'album.html',\n      chunks: ['album'] // album.html 只会引入打包后的 album.js\n    })\n  ]\n}\n\n\n\n# 动态导入\n\n> 需要某个模块时再去加载，动态导入的模块会被自动分包，例如常见的数字开头的 js 文件: 0.js 就是这类模块分包出来的文件。\n\n// import posts from './posts/posts'\n// import album from './album/album'\n// 删除固定导入\n\nconst render = () => {\n  const hash = window.location.hash || '#posts'\n\n  const mainelement = document.queryselector('.main')\n\n  mainelement.innerhtml = ''\n  // 根据 hash 值动态导入\n  if (hash === '#posts') {\n    // 魔法注释可以设置打包后文件名\n    import(/* webpackchunkname: 'components' */'./posts/posts').then(({ default: posts }) => {\t\n      mainelement.appendchild(posts())\n    })\n  } else if (hash === '#album') {\n    // 魔法注释可以设置打包后文件名\n    import(/* webpackchunkname: 'components' */'./album/album').then(({ default: album }) => {\n      mainelement.appendchild(album())\n    })\n  }\n}\n\nrender()\n\nwindow.addeventlistener('hashchange', render)\n\n\nwebpack splitchunksplugin实用指南\n\nwebpack之splitchunks插件用法详解\n\n> 在研究splitchunks之前，我们必须先弄明白这三个名词是什么意思，主要是chunk的含义，要不然你就不知道splitchunks是在什么的基础上进行拆分。\n> \n>  * module：就是js的模块化webpack支持commonjs、es6等模块化规范，简单来说就是你通过import语句引入的代码。\n>  * chunk: chunk是webpack根据功能拆分出来的，包含三种情况：\n> \n> 1、你的项目入口（entry）\n> \n> 2、通过import()动态引入的代码（默认分包）\n> \n> 3、通过splitchunks拆分出来的代码\n> \n> chunk包含着module，可能是一对多也可能是一对一。\n> \n>  * bundle：bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，bundle就是对chunk进行编译压缩打包等处理之后的产出。\n\nconst resolve = require('path').resolve\nconst { cleanwebpackplugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n    mode: 'none',\n    entry: {\n        entry1: './src/entry1.js',\n        entry2: './src/entry2.js'\n    },\n    plugins: [\n        new cleanwebpackplugin()\n    ],\n    output: {\n        filename: '[name].bundle.js',\n        path: resolve(__dirname, 'dist')\n    },\n    optimization: {\n        // splitchunks作用: 把 entry1.js 和 entry2.js 都共同引入的模块分包出来。\n        // 假如 entry1.js 和 entry2.js 都引入了 element，那么 entry1.bundle.js 和 entry2.bundle.js\n        // 不分包的话都会将 element 打包进去，两个文件就都会很大，所以需要分包处理\n        splitchunks: {\n            // 默认值就是async，分包的对象共同引入的异步模块。\n            // initial: 分包的对象是共同引入的初始静态导入模块。all: 分包所有的共同引入的模块。\n            chunks: 'all',\n            // name代表打包出来的 chunk 的名称，有三种值：\n            // 1.boolean = false (webpack5中不支持true)\n            // 2.function (module, chunks, cachegroupkey) => string \n            // 3.string\n            // 一般都是使用 false，就是以 cachegroups 中的 name 命名，如果没有 name，默认为 2.js, 3.js 这种数字类型的\n            name: false,\n            // 表示要被提取的模块最小被引用次数，引用次数超过或等于minchunks值，才能被提取\n            // 这个例子里 subtract 被引用了 2 次，如果设置成 3 则不能被分包\n            minchunks: 2,\n            // 表示只有超过了多少字节才会被提取, 默认值是 20000，这里设置成 1 是为了这个例子里能分包 modules 中模块\n            minsize: 1,\n            // 模块打包生成的文件大小不能超过的值，如果超了要对其进行分割并打包生成新的文件。\n            // webpack4中默认为0表示大小不限制, webpack5中取消了默认值设置为0时表示大于0的就会分割\n            maxsize: 9999999999,\n            // 动态引入的模块，并行请求的最大数量\n            maxasyncrequests: 5,\n            // 打包后的入口文件加载时，能同时初始加载js文件的数量\n            // 优先级: maxinitialrequest/maxasyncrequests < maxsize < minsize\n            maxinitialrequests: 3,\n            // 命名连接符\n            automaticnamedelimiter: '~',\n            cachegroups: {\n                vendors: {\n                    name: 'vendors',\n                    test: /[\\\\/]node_modules[\\\\/]/,\n                    priority: 10\n                },\n                modules: {\n                    name: 'modules',\n                    test: resolve('src/modules'),\n                    priority: 10,\n                    reuseexistingchunk: true\n                }\n            }\n        }\n    }\n}\n\n\n * demo\n * 官方文档\n\n\n# mini-css-extract-plugin\n\n> mini-css-extract-plugin将css单独提取出来，如果 css 超过 150kb 时需要单独提取\n> \n> 提取出来后还需要用optimizecssassetswebpackplugin进行压缩\n> \n> 因为 webpack 内置的压缩插件只打包 js 文件\n\nconst minicssextractplugin = require('mini-css-extract-plugin')\nconst optimizecssassetswebpackplugin = require('optimize-css-assets-webpack-plugin')\nconst terserwebpackplugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    main: './src/index.js'\n  },\n  optimization: {\n    minimizer: [\n      new terserwebpackplugin(),\n      new optimizecssassetswebpackplugin() \n    ]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 'style-loader', // 将样式通过 style 标签注入\n          minicssextractplugin.loader, // 直接通过 link 方式引入\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new minicssextractplugin()\n  ]\n}\n\n\n> 为什么ptimizecssassetswebpackplugin插件放在这不放在 plugins 数组中呢 ?\n> \n> 因为放在 plugins 说明在任何时候都会加载这个插件，而我们放到 minimizer 中，只会在生产环境开启 minimizer 时工作\n> \n> 但是这时会发现 js 没有压缩，因为我们设置了minimizer，webpack会认为我们自定义了压缩插件，所以我们还要添加回去压缩 js 的插件terserwebpackplugin。\n\n\n# 文件名 hash\n\n  plugins: [\n    new cleanwebpackplugin(),\n    new htmlwebpackplugin({\n      title: 'dynamic import',\n      template: './src/index.html',\n      filename: 'index.html'\n    }),\n    new minicssextractplugin({\n      filename: '[name]-[contenthash:8].bundle.css' // 文件级别的hash\n      // filename: '[name]-[chunkhash].bundle.css'  // chunk级别\n      // filename: '[name]-[hash].bundle.css'       // 项目级别，一个文件改变，所有hash全部改变\n    })\n  ]\n}\n",charsets:{cjk:!0}},{title:"webpack（五）",frontmatter:{title:"webpack（五）",date:"2020-09-08T14:48:00.000Z",categories:"webpack"},regularPath:"/webpack/webpack5.html",relativePath:"webpack/webpack5.md",key:"v-65000a52",path:"/webpack/webpack5.html",headers:[{level:2,title:"使用 webpack 打包一个 vue 项目",slug:"使用-webpack-打包一个-vue-项目",normalizedTitle:"使用 webpack 打包一个 vue 项目",charIndex:126},{level:2,title:"配置 webpack.dev.js",slug:"配置-webpack-dev-js",normalizedTitle:"配置 webpack.dev.js",charIndex:61},{level:2,title:"配置 webpack.prod.js 和 webpack.common.js",slug:"配置-webpack-prod-js-和-webpack-common-js",normalizedTitle:"配置 webpack.prod.js 和 webpack.common.js",charIndex:4785},{level:2,title:"配置eslint",slug:"配置eslint",normalizedTitle:"配置eslint",charIndex:113}],lastUpdated:"9/3/2021, 7:07:07 PM",lastUpdatedTimestamp:1630667227e3,headersStr:"使用 webpack 打包一个 vue 项目 配置 webpack.dev.js 配置 webpack.prod.js 和 webpack.common.js 配置eslint",content:"# webpack（五）\n\n * 使用webpack打包一个vue项目\n * 安装 loader 和 plugin\n * 配置 webpack.dev.js\n * 配置 webpack.prod.js\n * merge\n * 配置eslint\n\n\n# 使用 webpack 打包一个 vue 项目\n\n> 首先安装一些必要的 loader 和 plugin\n\n * webpack，webpack-cli：webpack工具\n\n * vue，vue-loader，vue-template-compiler：处理 .vue 文件\n\n * less，less-loader，css-loader，style-loader：处理样式\n\n * url-loader，file-loader：处理图片等文件\n\n * eslint-loader：代码标准化\n\n * babel-loader @babel/core @babel/preset-env：babel处理 es6\n\n * clean-webpack-plugin：删除 dist 目录\n\n * html-webpack-plugin：生成自动引用打包后的 js 的 html 文件\n\n * copy-webpack-plugin：可以用来拷贝 public 目录\n\n * webpack-dev-server：浏览器自动编译刷新\n\n * webpack-merge：合并配置文件\n\n * sourcemap：映射源文件\n\n\n# 配置 webpack.dev.js\n\n首先写一下入口，出口，处理 vue 和 样式的配置\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      { \n        test: /\\.vue$/, \n        use: 'vue-loader' \n      },\n      {\n        test: /.css$/,   // 处理css\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.less$/, // 处理sass\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader'\n        ]\n      },\n      {\n        test: /.png$/, // 处理图片\n        use: {\n          loader: 'url-loader', \n          options: {\n            limit: 10 * 1024 // 10 KB\n          }\n        }\n      }\n    ]\n  }\n}\n\n\n然后在package.json中配置一下scripts\n\n> \"serve\": \"webpack --config webpack.dev.js\"\n\n运行npm run server后报错：\n\n> vue-loader was used without the corresponding plugin\n> \n> 原来是Vue-loader在15.*之后的版本都是需要伴随 VueLoaderPlugin的,\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      // ...\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n}\n\n\n> 再次运行 npm run server 打包成功，在 dist 目录下生成了 bundle.js\n> \n> 此时只有一个 js 文件，那么怎么能运行呢，这时就需要 html-webpack-plugin 和 webpack-dev-server 了\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      // ...\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin(),\n    new CleanWebpackPlugin(),  // 清除 dist\n    new HtmlWebpackPlugin({    // 生成引入 bundle.js 的 index.html\n      filename: 'index.html'\n    }),\n    new CopyWebpackPlugin({    // 拷贝 public 目录\n      patterns: [\n        { from: path.join(__dirname,'public'),\n          to: 'public' \n        }\n      ],\n    }),\n  ],\n}\n\n\n> // 然后修改脚本\n> \n> \"scripts\": {\n> \n> \"serve\": \"webpack-dev-server --config webpack.dev.js --open --hot\",\n> \n> },\n> \n> 再次运行 npm run serve，成功打开页面，但是里面什么也没有，按 F12检查发现报错\n> \n> Vue warn: Cannot find element: #app\n\n发现在生成的 index.html 文件中没有 div id=\"app\" 的元素，原来是在使用 html-webpack-plugin 的时候没有使用template，检查目录发现在public目录下有写好的 index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\n其中 BASE_URL 需要使用 DefinePlugin 注入全局成员，title 就在 htmlWebpackPlugin 配置\n\n  plugins: [\n    new VueLoaderPlugin(),\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'this is a title',\n      template : './public/index.html',\n      filename: 'index.html'\n    }),\n    new webpack.DefinePlugin({\n      BASE_URL: JSON.stringify('./public/')\n    })\n  ]\n\n\n> 然后页面就正常打开了，但是有一张图片没有显示，显示：\n> \n> img src=\"[object Module]\"\n> \n> 原因是在url-loader内部封装了file-loader 而file-loader在新版本中esModule属性默认为true 即默认使用ES模块语法，导致了造成了引用图片文件的方式和以前的版本不一样 引入路径改变了 自然找不到图片\n\n\t{\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10KB的还会使用file-loader\n          options: {\n            limit: 10 * 1024, // 10 KB\n            esModule: false // 取消使用 esModules\n          }\n        }\n      }\n\n\n再次运行页面就能正常打开了，并且试了热更新功能没问题，但是在开发环境下没必要拷贝 public 目录，设置一下 contentBase 即可\n\ndevServer: {\n    contentBase: './public',\n    hot: true  // 热更新也可以在这配置\n},\n\n\n\n# 配置 webpack.prod.js 和 webpack.common.js\n\n在生产环境下，就需要拷贝 public 目录了，并且设置 mode: 'production'，通过 webpack-merge 合并\n\n// webpack.dev.js\nconst path = require('path')\nconst common = require('./webpack.common.js')\nconst webpackMerge = require('webpack-merge')\n\nmodule.exports = webpackMerge.merge(common, {\n  mode: 'none',\n  devServer: {\n    contentBase: './public',\n    hot: true\n  }\n})\n\n// webpack.prod.js\nconst path = require('path')\nconst common = require('./webpack.common.js')\nconst webpackMerge = require('webpack-merge')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = webpackMerge.merge(common, {\n  mode: 'production',\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        { \n          from: path.join(__dirname,'public'),\n          to: 'public' \n        }\n      ],\n    })\n  ]\n})\n\n\n// webpack.common.js\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      { \n        test: /\\.vue$/, \n        use: 'vue-loader' \n      },\n      {\n        test: /.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader'\n        ]\n      },\n      {\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10KB的还会使用file-loader\n          options: {\n            limit: 10 * 1024, // 10 KB\n            esModule: false\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin(),\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      title: 'this is a title',\n      template : './public/index.html',\n      filename: 'index.html'\n    }),\n    new webpack.DefinePlugin({\n      BASE_URL: JSON.stringify('./public/')\n    })\n  ]\n}\n\n\n\n# 配置eslint\n\neslint --init时模块下载失败，这里我就手动安装一下：\n\ncnpm i -D eslint-plugin-vue eslint-config-standard eslint eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard\n\n\n然后在webpack.common.js中配置一下就可以\n\n\t  {\n        test: /\\.vue$/,\n        use: [\n          'vue-loader',\n          'eslint-loader'\n        ]\n      },\n\n\n然后再package.json中再配置一下\n\n\"scripts\": {\n\t\"lint\": \"eslint src/**/*.vue\"\n}\n",normalizedContent:"# webpack（五）\n\n * 使用webpack打包一个vue项目\n * 安装 loader 和 plugin\n * 配置 webpack.dev.js\n * 配置 webpack.prod.js\n * merge\n * 配置eslint\n\n\n# 使用 webpack 打包一个 vue 项目\n\n> 首先安装一些必要的 loader 和 plugin\n\n * webpack，webpack-cli：webpack工具\n\n * vue，vue-loader，vue-template-compiler：处理 .vue 文件\n\n * less，less-loader，css-loader，style-loader：处理样式\n\n * url-loader，file-loader：处理图片等文件\n\n * eslint-loader：代码标准化\n\n * babel-loader @babel/core @babel/preset-env：babel处理 es6\n\n * clean-webpack-plugin：删除 dist 目录\n\n * html-webpack-plugin：生成自动引用打包后的 js 的 html 文件\n\n * copy-webpack-plugin：可以用来拷贝 public 目录\n\n * webpack-dev-server：浏览器自动编译刷新\n\n * webpack-merge：合并配置文件\n\n * sourcemap：映射源文件\n\n\n# 配置 webpack.dev.js\n\n首先写一下入口，出口，处理 vue 和 样式的配置\n\nconst path = require('path')\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      { \n        test: /\\.vue$/, \n        use: 'vue-loader' \n      },\n      {\n        test: /.css$/,   // 处理css\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.less$/, // 处理sass\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader'\n        ]\n      },\n      {\n        test: /.png$/, // 处理图片\n        use: {\n          loader: 'url-loader', \n          options: {\n            limit: 10 * 1024 // 10 kb\n          }\n        }\n      }\n    ]\n  }\n}\n\n\n然后在package.json中配置一下scripts\n\n> \"serve\": \"webpack --config webpack.dev.js\"\n\n运行npm run server后报错：\n\n> vue-loader was used without the corresponding plugin\n> \n> 原来是vue-loader在15.*之后的版本都是需要伴随 vueloaderplugin的,\n\nconst path = require('path')\nconst vueloaderplugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      // ...\n    ]\n  },\n  plugins: [\n    new vueloaderplugin()\n  ],\n}\n\n\n> 再次运行 npm run server 打包成功，在 dist 目录下生成了 bundle.js\n> \n> 此时只有一个 js 文件，那么怎么能运行呢，这时就需要 html-webpack-plugin 和 webpack-dev-server 了\n\nconst path = require('path')\nconst vueloaderplugin = require('vue-loader/lib/plugin')\nconst { cleanwebpackplugin } = require('clean-webpack-plugin')\nconst htmlwebpackplugin = require('html-webpack-plugin')\nconst copywebpackplugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      // ...\n    ]\n  },\n  plugins: [\n    new vueloaderplugin(),\n    new cleanwebpackplugin(),  // 清除 dist\n    new htmlwebpackplugin({    // 生成引入 bundle.js 的 index.html\n      filename: 'index.html'\n    }),\n    new copywebpackplugin({    // 拷贝 public 目录\n      patterns: [\n        { from: path.join(__dirname,'public'),\n          to: 'public' \n        }\n      ],\n    }),\n  ],\n}\n\n\n> // 然后修改脚本\n> \n> \"scripts\": {\n> \n> \"serve\": \"webpack-dev-server --config webpack.dev.js --open --hot\",\n> \n> },\n> \n> 再次运行 npm run serve，成功打开页面，但是里面什么也没有，按 f12检查发现报错\n> \n> vue warn: cannot find element: #app\n\n发现在生成的 index.html 文件中没有 div id=\"app\" 的元素，原来是在使用 html-webpack-plugin 的时候没有使用template，检查目录发现在public目录下有写好的 index.html\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"<%= base_url %>favicon.ico\">\n    <title><%= htmlwebpackplugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>we're sorry but <%= htmlwebpackplugin.options.title %> doesn't work properly without javascript enabled. please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\n其中 base_url 需要使用 defineplugin 注入全局成员，title 就在 htmlwebpackplugin 配置\n\n  plugins: [\n    new vueloaderplugin(),\n    new cleanwebpackplugin(),\n    new htmlwebpackplugin({\n      title: 'this is a title',\n      template : './public/index.html',\n      filename: 'index.html'\n    }),\n    new webpack.defineplugin({\n      base_url: json.stringify('./public/')\n    })\n  ]\n\n\n> 然后页面就正常打开了，但是有一张图片没有显示，显示：\n> \n> img src=\"[object module]\"\n> \n> 原因是在url-loader内部封装了file-loader 而file-loader在新版本中esmodule属性默认为true 即默认使用es模块语法，导致了造成了引用图片文件的方式和以前的版本不一样 引入路径改变了 自然找不到图片\n\n\t{\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10kb的还会使用file-loader\n          options: {\n            limit: 10 * 1024, // 10 kb\n            esmodule: false // 取消使用 esmodules\n          }\n        }\n      }\n\n\n再次运行页面就能正常打开了，并且试了热更新功能没问题，但是在开发环境下没必要拷贝 public 目录，设置一下 contentbase 即可\n\ndevserver: {\n    contentbase: './public',\n    hot: true  // 热更新也可以在这配置\n},\n\n\n\n# 配置 webpack.prod.js 和 webpack.common.js\n\n在生产环境下，就需要拷贝 public 目录了，并且设置 mode: 'production'，通过 webpack-merge 合并\n\n// webpack.dev.js\nconst path = require('path')\nconst common = require('./webpack.common.js')\nconst webpackmerge = require('webpack-merge')\n\nmodule.exports = webpackmerge.merge(common, {\n  mode: 'none',\n  devserver: {\n    contentbase: './public',\n    hot: true\n  }\n})\n\n// webpack.prod.js\nconst path = require('path')\nconst common = require('./webpack.common.js')\nconst webpackmerge = require('webpack-merge')\nconst copywebpackplugin = require('copy-webpack-plugin')\n\nmodule.exports = webpackmerge.merge(common, {\n  mode: 'production',\n  plugins: [\n    new copywebpackplugin({\n      patterns: [\n        { \n          from: path.join(__dirname,'public'),\n          to: 'public' \n        }\n      ],\n    })\n  ]\n})\n\n\n// webpack.common.js\nconst path = require('path')\nconst vueloaderplugin = require('vue-loader/lib/plugin')\nconst { cleanwebpackplugin } = require('clean-webpack-plugin')\nconst htmlwebpackplugin = require('html-webpack-plugin')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  entry: './src/main.js', // 入口\n  output: { \n    filename: 'bundle.js', \n    path: path.join(__dirname, 'dist')\n  },\n  module:{\n    rules:[\n      { \n        test: /\\.vue$/, \n        use: 'vue-loader' \n      },\n      {\n        test: /.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader'\n        ]\n      },\n      {\n        test: /.png$/,\n        use: {\n          loader: 'url-loader', // 大于10kb的还会使用file-loader\n          options: {\n            limit: 10 * 1024, // 10 kb\n            esmodule: false\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new vueloaderplugin(),\n    new cleanwebpackplugin(),\n    new htmlwebpackplugin({\n      title: 'this is a title',\n      template : './public/index.html',\n      filename: 'index.html'\n    }),\n    new webpack.defineplugin({\n      base_url: json.stringify('./public/')\n    })\n  ]\n}\n\n\n\n# 配置eslint\n\neslint --init时模块下载失败，这里我就手动安装一下：\n\ncnpm i -d eslint-plugin-vue eslint-config-standard eslint eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard\n\n\n然后在webpack.common.js中配置一下就可以\n\n\t  {\n        test: /\\.vue$/,\n        use: [\n          'vue-loader',\n          'eslint-loader'\n        ]\n      },\n\n\n然后再package.json中再配置一下\n\n\"scripts\": {\n\t\"lint\": \"eslint src/**/*.vue\"\n}\n",charsets:{cjk:!0}}],themeConfig:{logo:"",repo:"jinjingxuan",docsDir:"docs",editLinks:!1,editLinkText:"在 Github 上帮助我们编辑此页",nav:[{text:"首页",link:"/"},{text:"产品与数据",items:[{text:"AB test",link:"/product/abtest"}]},{text:"区块链",items:[{text:"北大公开课学习",link:"/blockchain/learn1"},{text:"常见概念",link:"/blockchain/base"},{text:"web3.js和Ethers.js",link:"/blockchain/js"},{text:"Ethers.js",link:"/blockchain/ethersjs"}]},{text:"node",items:[{text:"Node基础",link:"/node/node-1"},{text:"《深入浅出NodeJs》",link:"/node/book"},{text:"express",link:"/node/express"}]},{text:"算法",items:[{text:"数组",link:"/algorithm/array"},{text:"dfs/bfs",link:"/algorithm/dfs-bfs"},{text:"动态规划",link:"/algorithm/dynamic"},{text:"贪心算法",link:"/algorithm/greedy"},{text:"链表",link:"/algorithm/list"},{text:"排序",link:"/algorithm/sort"},{text:"栈",link:"/algorithm/stack"},{text:"字符串",link:"/algorithm/string"},{text:"回溯",link:"/algorithm/trace"},{text:"树",link:"/algorithm/tree"},{text:"双指针",link:"/algorithm/two-pointer"},{text:"场景题",link:"/algorithm/scene"}]},{text:"css",items:[{text:"BFC",link:"/css/bfc"},{text:"盒子模型",link:"/css/box"},{text:"flex",link:"/css/flex"},{text:"problem",link:"/css/problem"}]},{text:"JavaScript",items:[{text:"JavaScript",items:[{text:"浅/深拷贝",link:"/javascript/clone"},{text:"闭包",link:"/javascript/closure"},{text:"数据类型",link:"/javascript/datatype"},{text:"ES6",link:"/javascript/ES6"},{text:"原型与原型链",link:"/javascript/prototype"},{text:"作用域",link:"/javascript/scope"},{text:"this",link:"/javascript/this"},{text:"函数式编程",link:"/javascript/function"}]},{text:"TypeScript",items:[{text:"基础",link:"/ts/ts-base"},{text:"进阶",link:"/ts/ts-advance"},{text:"《深入理解TypeScript》",link:"/ts/book"},{text:"TypeScript中的装饰器",link:"/ts/decorator"}]},{text:"Threejs",items:[{text:"three基础",link:"/three/three1"},{text:"乒乓球游戏",link:"/three/three2"},{text:"react three",link:"/three/three3"},{text:"一些实践",link:"/three/three4"}]}]},{text:"前端框架",items:[{text:"Vue",items:[{text:"源码解析",link:"/vue/code-1"},{text:"响应式原理",link:"/vue/responsive"},{text:"vue3",link:"/vue/vue3.0-1"},{text:"vuex",link:"/vue/vuex"}]},{text:"React",items:[{text:"react基础",link:"/react/react-1"},{text:"react hooks",link:"/react/react-hooks"},{text:"redux",link:"/react/redux"},{text:"React Fiber",link:"/react/fiber"},{text:"React 版本",link:"/react/time"},{text:"React Diff",link:"/react/diff"}]},{text:"San",items:[{text:"eslint-plugin-san",link:"/san/eslint-plugin-san"},{text:"san-loader",link:"/san/san-loader"}]},{text:"微前端",items:[{text:"微前端",link:"/micro/micro"}]}]},{text:"Webpack",items:[{text:"webpack基础",link:"/webpack/webpack1"},{text:"hmr原理",link:"/webpack/hmr"},{text:"webpack模块化",link:"/module/webpack"}]},{text:"前端工程化",items:[{text:"yeoman",link:"/engineering/engineering"},{text:"eslint",link:"/engineering/eslint"},{text:"grunt",link:"/engineering/grunt"},{text:"gulp",link:"/engineering/gulp"},{text:"rollup",link:"/engineering/rollup"},{text:"cli工具",items:[{text:"环境变量",link:"/engineering/env"},{text:"命令行交互工具",link:"/engineering/commander"}]},{text:"单元测试",link:"/engineering/test"}]},{text:"面试题",items:[{text:"面试题整理",link:"/interview/interview"},{text:"算法",link:"/interview/algorithm"},{text:"手写代码",link:"/interview/code-1"},{text:"面试题精选",link:"/interview/interview-1"},{text:"智力题",link:"/interview/iq"}]},{text:"后端系列",items:[{text:"开发机相关",link:"/re/development"},{text:"mongodb",link:"/re/mongodb"},{text:"devops",link:"/re/devops"},{text:"nginx",link:"/re/nginx"},{text:"shell",link:"/re/shell"},{text:"docker",link:"/re/docker"}]},{text:"前端系列",items:[{text:"git",link:"/git/git"},{text:"ssr",link:"/ssr/ssr"},{text:"计算机基础",link:"/computer/computer"},{text:"正则表达式",link:"/regular/regular"},{text:"前端路由",link:"/route/route"},{text:"前端安全",link:"/safe/safe"},{text:"模块化",link:"/module/module"},{text:"代码规范",link:"/code-style/code-style"},{text:"常用工具",link:"/tool/tool"},{text:"浏览器",items:[{text:"GC算法",link:"/chrome/gc"},{text:"浏览器渲染",link:"/chrome/render"},{text:"跨域",link:"/chrome/cross"},{text:"Chrome性能分析",link:"/chrome/performance"}]},{text:"移动端",items:[{text:"跨端技术",link:"/mobile/cross"},{text:"移动端适配",link:"/mobile/adaptation"},{text:"移动端h5开发",link:"/mobile/h5"},{text:"长列表优化",link:"/mobile/long-list"},{text:"galacean",link:"/mobile/galacean"},{text:"galacean 3d",link:"/mobile/gc-3d"}]},{text:"设计模式",items:[{text:"设计模式简介",link:"/design-pattern/design-pattern"},{text:"面向对象编程",link:"/design-pattern/object"}]},{text:"虚拟DOM",items:[{text:"Virtual DOM",link:"/virtual-dom/virtualdom"},{text:"实例",link:"/virtual-dom/example"}]},{text:"渲染相关",items:[{text:"canvas 和 svg",link:"/webgl/canvas"}]}]},{text:"工具系列",items:[{text:"常用工具和插件",link:"/tool/tool"},{text:"依赖管理工具",link:"/tool/npm"},{text:"相机基础",link:"/tool/camera"},{text:"performance",link:"/tool/performance"},{text:"第三方包",items:[{text:"postcss",link:"/tool/postcss"},{text:"babel",link:"/tool/babel"},{text:"htmlparser2",link:"/tool/htmlparser2"},{text:"yaml",link:"/tool/yaml"}]}]}],lastUpdated:"最后更新时间",sidebarDepth:3,sidebar:{"/css/":["/css/bfc","/css/box","/css/flex","/css/layout","/css/problem"],"/javascript":["/javascript/asynchronous","/javascript/clone","/javascript/closure","/javascript/datatype","/javascript/date","/javascript/ES6","/javascript/number","/javascript/parse-order","/javascript/prototype","/javascript/scope","/javascript/stringify","/javascript/this","/javascript/function","/javascript/log","/javascript/ES2017-2022"],"/vue":[{title:"Vue源码解析",children:["/vue/code-1","/vue/code-2","/vue/code-3"]},{title:"Vue3",children:["/vue/vue3.0-1","/vue/vue3.0-2","/vue/vue3.0-3"]},"/vue/vuex","/vue/communication","/vue/responsive","/vue/template"],"/san":["/san/san","/san/eslint-plugin-san","/san/composition","/san/san-loader"],"/react":["/react/react-1","/react/react-hooks","/react/redux","/react/fiber","/react/time","/react/diff"],"/micro":["/micro/micro"],"/virtual-dom":["/virtual-dom/virtualdom","/virtual-dom/example"],"/webgl":["/webgl/canvas"],"/webpack":[{title:"webpack基础",collapsable:!0,children:["/webpack/webpack1","/webpack/webpack2","/webpack/webpack3","/webpack/webpack4","/webpack/webpack5"]},"/webpack/config","/webpack/hmr"],"/ts":["/ts/ts-base","/ts/ts-advance","/ts/ts-type","/ts/book","/ts/decorator"],"/three":["/three/three1","/three/three2","/three/three3","/three/three4"],"/ssr":["/ssr/ssr"],"/node":[{title:"Node基础",collapsable:!0,children:["/node/node-1","/node/node-2","/node/node-3","/node/node-4","/node/node-5","/node/node-6"]},"/node/book","/node/express"],"/regular":["/regular/regular"],"/mobile":["/mobile/cross","/mobile/adaptation","/mobile/h5","/mobile/long-list","/mobile/galacean","/mobile/gc-3d"],"/algorithm/":["/algorithm/array","/algorithm/dfs-bfs","/algorithm/dynamic","/algorithm/greedy","/algorithm/list","/algorithm/scene","/algorithm/sort","/algorithm/stack","/algorithm/string","/algorithm/trace","/algorithm/tree","/algorithm/two-pointer"],"/design-pattern":["/design-pattern/design-pattern","/design-pattern/object"],"/route":["/route/route"],"/engineering":["/engineering/engineering","/engineering/eslint","/engineering/grunt","/engineering/gulp","/engineering/rollup","/engineering/env","/engineering/commander","/engineering/test"],"/safe":["/safe/safe"],"/module":["/module/module","/module/webpack"],"/interview":[{title:"面试题整理",collapsable:!0,children:["/interview/interview"]},{title:"手写代码",collapsable:!0,children:["/interview/code-1","/interview/code-2"]},{title:"面试题集合",collapsable:!0,children:["/interview/interview-1","/interview/interview-2","/interview/interview-3","/interview/interview-4","/interview/interview-5","/interview/interview-6","/interview/interview-7","/interview/interview-8","/interview/interview-9","/interview/interview-10","/interview/interview-11"]},{title:"外企",collapsable:!0,children:["/interview/foreign-company","/interview/english"]},"/interview/algorithm","/interview/iq"],"/chrome":["/chrome/gc","/chrome/render","/chrome/cross","/chrome/performance"],"/computer":["/computer/computer"],"/git":["/git/git"],"/code-style":["/code-style/code-style"],"/tool":["/tool/tool","/tool/npm","/tool/camera","/tool/performance",{title:"第三方npm包",collapsable:!0,children:["/tool/babel","/tool/postcss","/tool/htmlparser2","/tool/yaml"]}],"/read":["/read/read"],"/blockchain":["/blockchain/info","/blockchain/learn1","/blockchain/learn2","/blockchain/learn3","/blockchain/learn4","/blockchain/learn5","/blockchain/learn6","/blockchain/learn7","/blockchain/learn8","/blockchain/base","/blockchain/js","/blockchain/ethersjs"],"/re":["/re/development","/re/mongodb","/re/devops","/re/nginx","/re/shell","/re/docker"],"/product":["/product/abtest"],"/":["/time/code"]},nextLinks:!0,prevLinks:!0}};t(234);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,540))),Gt.component("CodeBlock",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,536))),Gt.component("CodeGroup",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,537)));t(235);var Ai=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{}],Mi=[];class Oi extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Oi.prototype,{getPageAsyncComponent:ii,getLayoutAsyncComponent:li,getAsyncComponent:ci,getVueComponent:ui});var Ri={install(n){const e=new Oi;n.$vuepress=e,n.prototype.$vuepress=e}};function Di(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var qi={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return pi("pageKey",e),Gt.component(e)||Gt.component(e,ii(e)),Gt.component(e)?n(e):n("")}},Li={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ni={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Bi=(t(236),t(237),Object(Pi.a)(Ni,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),$i={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use(Hs),Gt.use(Ri),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Ei)),Gt.component("Content",qi),Gt.component("ContentSlotsDistributor",Li),Gt.component("OutboundLink",Bi),Gt.component("ClientOnly",$i),Gt.component("Layout",li("Layout")),Gt.component("NotFound",li("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"f8fd897"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Ei.routerBase||Ei.base,t=new Hs({base:e,mode:"history",fallback:!1,routes:Ci,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Di(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Di(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";Di(n,o)?r(o):Di(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Ai.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:r,router:t,siteData:Ei,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Mi.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);
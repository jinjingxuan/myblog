(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{645:function(s,a,t){"use strict";t.r(a);var n=t(14),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"sh-脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sh-脚本"}},[s._v("#")]),s._v(" sh 脚本")]),s._v(" "),a("p",[s._v("sh 脚本即 shell 脚本，就是由 Shell 命令组成的执行文件。我们可以通过shell命令来操作和控制操作系统，比如Linux中的 Shell 命令就包括ls、cd、pwd等等。shell 脚本和 linux 命令的区别是 shell 是一个用 C 语言编写的程序，既是一种命令语言，又是一种程序设计语言，"),a("strong",[s._v("相当于有了一定的逻辑和过程")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"shell-变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shell-变量"}},[s._v("#")]),s._v(" Shell 变量")]),s._v(" "),a("p",[s._v("Shell 变量分为"),a("strong",[s._v("系统变量")]),s._v("和"),a("strong",[s._v("自定义变量")]),s._v("。系统变量有$HOME、$PWD、$USER等。"),a("strong",[s._v("自定义变量")]),s._v("又分为"),a("strong",[s._v("局部变量")]),s._v("和"),a("strong",[s._v("环境变量（全局变量）")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("显示所有变量")]),s._v("："),a("code",[s._v("set")])]),s._v(" "),a("li",[a("strong",[s._v("删除变量：")]),a("code",[s._v("unset 变量名")])]),s._v(" "),a("li",[a("strong",[s._v("使用变量：")]),a("code",[s._v("$变量名")]),s._v("、"),a("code",[s._v("${变量名}")])]),s._v(" "),a("li",[a("strong",[s._v("打印变量")]),s._v("："),a("code",[s._v("echo ${变量名}")])])]),s._v(" "),a("h3",{attrs:{id:"局部变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#局部变量"}},[s._v("#")]),s._v(" 局部变量")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("定义变量：")]),a("code",[s._v("变量名=变量值")]),s._v("，等号两侧不能有空格，变量名一般习惯用大写。")]),s._v(" "),a("li",[a("strong",[s._v("声明静态变量：")]),a("code",[s._v("readonly 变量名=变量值")]),s._v("，静态变量不能 unset。")])]),s._v(" "),a("h3",{attrs:{id:"环境变量-全局变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#环境变量-全局变量"}},[s._v("#")]),s._v(" 环境变量(全局变量)")]),s._v(" "),a("blockquote",[a("p",[s._v("与局部变量的区别是子 shell 继承可以当前父 shell 的环境变量，并能一直传承下去")])]),s._v(" "),a("ol",[a("li",[a("code",[s._v("export 变量名=变量值")]),s._v("，将 Shell 变量输出为环境变量。")]),s._v(" "),a("li",[a("code",[s._v("source 配置文件路径")]),s._v("，让修改后的配置信息立即生效。")]),s._v(" "),a("li",[a("code",[s._v("echo $变量名")]),s._v("，检查环境变量是否生效")])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("var")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 注意等号两边不能有空格")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${var}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("bash")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 开启子 shell")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${var}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 1")]),s._v("\n")])])]),a("h3",{attrs:{id:"path-环境变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#path-环境变量"}},[s._v("#")]),s._v(" path 环境变量")]),s._v(" "),a("p",[s._v("首先介绍一下 which 命令，它用于查找某个命令所在的绝对路径。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("which")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("node")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#/usr/local/bin/node")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("which")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#/usr/local/bin/npm")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("which")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("rm")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#/bin/rm")]),s._v("\n")])])]),a("p",[s._v("为什么前面在使用 rm、node、npm 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置，这是 PATH 环境变量在起作用。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("$PATH")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin")]),s._v("\n")])])]),a("p",[s._v("PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("export")]),s._v(" APATH "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" /user/a/bin\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("PATH")])]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$APATH")]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("$PATH")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 在原有的 path 基础上添加新的目录")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。")]),s._v("\n")])])]),a("h3",{attrs:{id:"位置参数变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位置参数变量"}},[s._v("#")]),s._v(" 位置参数变量")]),s._v(" "),a("ul",[a("li",[s._v("$n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。")]),s._v(" "),a("li",[s._v("$* ：传递给脚本或者函数的所有参数，且把所有参数看成一个整体输出。")]),s._v(" "),a("li",[s._v("$@ ：传递给脚本或者函数的所有参数，且把每个参数区分对待输出。")]),s._v(" "),a("li",[s._v("$# ：所有参数个数。")])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# test.sh 输出各个参数 ")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$0")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$2")]),s._v(" \n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$*")]),s._v(" test.sh\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$@")]),s._v(" \n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" 参数个数"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$#")]),s._v("\n")])])]),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("chmod")]),s._v(" +x test.sh "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 赋予文件的执行权限")]),s._v("\n./test.sh "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# ./test.sh 1 2")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 1 2 3 4 test.sh")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 1 2 3 4")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 参数个数=4")]),s._v("\n")])])]),a("p",[s._v("将命令行参数传递到脚本，再传递到函数内：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# test.sh")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function-name function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$@")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 接收函数传入参数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\nmain "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$@")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 接收命令行传入参数")]),s._v("\n")])])]),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("./test.sh "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v("\n")])])]),a("h3",{attrs:{id:"预定义变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预定义变量"}},[s._v("#")]),s._v(" 预定义变量")]),s._v(" "),a("ul",[a("li",[s._v("$$ ：当前进程的 PID 进程号。")]),s._v(" "),a("li",[s._v("$! ：后台运行的最后一个进程的 PID 进程号。")]),s._v(" "),a("li",[s._v("$? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。")])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 假如执行了安装依赖的命令并报错")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$?")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 则会打印非0，代表执行失败")]),s._v("\n")])])]),a("h2",{attrs:{id:"括号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#括号"}},[s._v("#")]),s._v(" 括号")]),s._v(" "),a("h3",{attrs:{id:"双中括号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双中括号"}},[s._v("#")]),s._v(" 双中括号")]),s._v(" "),a("ul",[a("li",[s._v("[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在 [[ 和 ]] 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。")]),s._v(" "),a("li",[s._v("支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。")]),s._v(" "),a("li",[s._v("使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]]。")]),s._v(" "),a("li",[s._v("bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。")])]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 判断上一条命令返回状态是否为 0（正确），为 0 则输出")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$?")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$?")]),s._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);
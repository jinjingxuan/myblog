(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{594:function(e,v,_){"use strict";_.r(v);var t=_(14),o=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"面试题-十一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试题-十一"}},[e._v("#")]),e._v(" 面试题（十一）")]),e._v(" "),v("ul",[v("li",[e._v("MVVM")]),e._v(" "),v("li",[e._v("Vue渲染流程")]),e._v(" "),v("li",[e._v("Vue生命周期")]),e._v(" "),v("li",[e._v("父子组件声明周期")]),e._v(" "),v("li",[e._v("vue和react的异同")])]),e._v(" "),v("h2",{attrs:{id:"mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),v("p",[e._v("MVVM 对应 3个组成部分，Model（模型）、View（视图） 和 ViewModel（视图模型）。")]),e._v(" "),v("ul",[v("li",[e._v("View 是用户在屏幕上看到的结构、布局和外观，也称UI。")]),e._v(" "),v("li",[e._v("ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。")]),e._v(" "),v("li",[e._v("Model 是数据和逻辑。")])]),e._v(" "),v("p",[e._v("View 不能和 Model 直接通信，它们只能通过 ViewModel 通信。Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。")]),e._v(" "),v("p",[v("strong",[e._v("严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 "),v("code",[e._v("$refs")]),e._v(" 这个属性，让 Model 可以直接操作 View，违反了这一规定。")])]),e._v(" "),v("h2",{attrs:{id:"vue渲染流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue渲染流程"}},[e._v("#")]),e._v(" Vue渲染流程")]),e._v(" "),v("p",[e._v("流程主要分为三个部分：")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("模板编译")]),e._v("，"),v("code",[e._v("parse")]),e._v(" 解析模板生成抽象语法树（AST）；"),v("code",[e._v("optimize")]),e._v(" 标记静态节点，在后续页面更新时会跳过静态节点；"),v("code",[e._v("generate")]),e._v(" 将AST转成 "),v("code",[e._v("render")]),e._v(" 函数，"),v("code",[e._v("render")]),e._v(" 函数用于构建 "),v("code",[e._v("VNode")]),e._v("。")]),e._v(" "),v("li",[v("strong",[e._v("构建VNode（虚拟dom）")]),e._v("，构建过程使用 "),v("code",[e._v("createElement")]),e._v(" 构建 "),v("code",[e._v("VNode")]),e._v("，"),v("code",[e._v("createElement")]),e._v(" 也是自定义 "),v("code",[e._v("render")]),e._v(" 函数时接受到的第一个参数。")]),e._v(" "),v("li",[v("strong",[e._v("VNode转真实dom")]),e._v("，"),v("code",[e._v("patch")]),e._v(" 函数负责将 "),v("code",[e._v("VNode")]),e._v(" 转换成真实dom，核心方法是"),v("code",[e._v("createElm")]),e._v("，递归创建真实dom树，最终渲染到页面上。")])]),e._v(" "),v("h2",{attrs:{id:"vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("beforeCreate:")]),e._v(" 在实例创建之前调用，由于实例还未创建，所以无法访问实例上的 "),v("code",[e._v("data")]),e._v("、"),v("code",[e._v("computed")]),e._v("、"),v("code",[e._v("method")]),e._v("等。")]),e._v(" "),v("li",[v("strong",[e._v("created:")]),e._v(" 在实例创建完成后调用，这时已完成数据的观测，可以获取数据和更改数据，但还无法与dom进行交互，如果想要访问dom，可以使用 "),v("code",[e._v("vm.$nextTick")]),e._v("。此时可以对数据进行更改，不会触发 "),v("code",[e._v("updated")]),e._v("。")]),e._v(" "),v("li",[v("strong",[e._v("beforeMount:")]),e._v(" 在挂载之前调用，这时的模板已编译完成并生成"),v("code",[e._v("render")]),e._v("函数，准备开始渲染。在此时也可以对数据进行更改，不会触发 "),v("code",[e._v("updated")]),e._v("。")]),e._v(" "),v("li",[v("strong",[e._v("mounted:")]),e._v(" 在挂载完成后调用，真实的dom挂载完毕，可以访问到dom节点，使用 "),v("code",[e._v("$refs")]),e._v(" 属性对dom进行操作。")]),e._v(" "),v("li",[v("strong",[e._v("beforeUpdate:")]),e._v(" 在更新之前调用，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，在当前阶段进行更改数据，不会造成重渲染。")]),e._v(" "),v("li",[v("strong",[e._v("updated：")]),e._v(" 在更新完成之后调用，组件dom已完成更新。要注意的是避免在此期间更改数据，这可能会导致死循环。")]),e._v(" "),v("li",[v("strong",[e._v("beforeDestroy：")]),e._v(" 在实例销毁之前调用，这时实例还可以被使用，一般这个周期内可以做清除计时器和取消事件监听的工作。")]),e._v(" "),v("li",[v("strong",[e._v("destroyed：")]),e._v(" 在实例销毁之后调用，这时已无法访问实例。当前实例从父实例中被移除，观测被卸载，所有事件监听器呗移除，子实例也统统被销毁。")])]),e._v(" "),v("blockquote",[v("p",[e._v("created时已经可以访问到data和methods了，可以在此时进行调用接口。")]),e._v(" "),v("p",[e._v("mounted是可以访问到DOM了，需要用到DOM的操作可以在此进行。")])]),e._v(" "),v("h2",{attrs:{id:"父子组件生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子组件生命周期"}},[e._v("#")]),e._v(" 父子组件生命周期")]),e._v(" "),v("p",[e._v("加载渲染过程：")]),e._v(" "),v("blockquote",[v("p",[e._v("父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted")])]),e._v(" "),v("p",[e._v("子组件更新过程：")]),e._v(" "),v("blockquote",[v("p",[e._v("父beforeUpdate->子beforeUpdate->子updated->父updated")])]),e._v(" "),v("p",[e._v("父组件更新过程：")]),e._v(" "),v("blockquote",[v("p",[e._v("父beforeUpdate->父updated")])]),e._v(" "),v("p",[e._v("销毁过程：")]),e._v(" "),v("blockquote",[v("p",[e._v("父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")])]),e._v(" "),v("h2",{attrs:{id:"vue和react的异同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue和react的异同"}},[e._v("#")]),e._v(" vue和react的异同")]),e._v(" "),v("h3",{attrs:{id:"_1-核心思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心思想"}},[e._v("#")]),e._v(" 1.核心思想")]),e._v(" "),v("p",[e._v("vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。")]),e._v(" "),v("h3",{attrs:{id:"vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" vue")]),e._v(" "),v("p",[e._v("vue的整体思想仍然是拥抱经典的html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等等)，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。另一方面，在针对组件数据上，vue2.0通过"),v("code",[e._v("Object.defineProperty")]),e._v("对数据做到了更细致的监听，精准实现组件级别的更新。")]),e._v(" "),v("h3",{attrs:{id:"react"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" react")]),e._v(" "),v("p",[e._v("react整体上是函数式的思想，组件使用jsx语法，all in js，将html与css全都融入javaScript，jsx语法相对来说更加灵活，我一开始刚转过来也不是很适应，感觉写react应用感觉就像是在写javaScript。当组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过"),v("code",[e._v("shouldComponentUpdate")]),e._v("或者"),v("code",[e._v("PureComponent")]),e._v("可以避免不必要的重新渲染（个人感觉这一点上不如vue做的好）。")])])}),[],!1,null,null,null);v.default=o.exports}}]);
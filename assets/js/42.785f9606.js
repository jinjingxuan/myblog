(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{371:function(t,r,s){t.exports=s.p+"assets/img/render.b5ae6965.png"},372:function(t,r,s){t.exports=s.p+"assets/img/parse.7893d607.png"},373:function(t,r,s){t.exports=s.p+"assets/img/script.93c2bdc0.png"},570:function(t,r,s){"use strict";s.r(r);var a=s(14),e=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"浏览器渲染相关"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染相关"}},[t._v("#")]),t._v(" 浏览器渲染相关")]),t._v(" "),r("h2",{attrs:{id:"浏览器多进程架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器多进程架构"}},[t._v("#")]),t._v(" 浏览器多进程架构")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/102149546",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文看懂Chrome浏览器运行机制"),r("OutboundLink")],1),t._v("，如何查看进程：浏览器中右上角更多工具 => 任务管理器")]),t._v(" "),r("ul",[r("li",[t._v("Browers主进程：负责界面显示，用户交互，子进程管理，同时提供存储等功能")]),t._v(" "),r("li",[t._v("渲染进程：一个tab窗口对应一个(不一定，网站隔离)，核心任务是将 html 转换为用户可以与之交互的网页")]),t._v(" "),r("li",[t._v("GPU进程：只有一个，实现网页，UI界面的硬件绘制")]),t._v(" "),r("li",[t._v("插件进程：主要负责插件的运行，每一个插件对应一个进程")]),t._v(" "),r("li",[t._v("网络进程：主要负责页面的网络资源加载")])]),t._v(" "),r("blockquote",[r("p",[t._v("浏览器主进程有很多负责不同工作的线程（worker thread）其中包括绘制浏览器顶部按钮和导航栏输入框等组件的UI线程（UI thread）、管理网络请求的网络线程（network thread）、以及控制文件读写的存储线程（storage thread）等。当你在导航栏里面输入一个URL的时候，其实就是UI线程在处理你的输入。")])]),t._v(" "),r("h3",{attrs:{id:"单进程缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单进程缺点"}},[t._v("#")]),t._v(" 单进程缺点")]),t._v(" "),r("ul",[r("li",[t._v("不稳定：同一进程中，任何线程或模块的崩溃将导致整个进程的崩溃")]),t._v(" "),r("li",[t._v("不流畅：任务排斥，内存泄露")]),t._v(" "),r("li",[t._v("不安全：用C或C++写的插件可以获取操作系统资源")])]),t._v(" "),r("h3",{attrs:{id:"多进程特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多进程特点"}},[t._v("#")]),t._v(" 多进程特点")]),t._v(" "),r("ul",[r("li",[t._v("解决了稳定性，流畅性，安全性的问题")]),t._v(" "),r("li",[t._v("带来了更多的资源占用")]),t._v(" "),r("li",[t._v("带来了更复杂的体系架构（模块直接耦合度高，可扩展性降低）")])]),t._v(" "),r("h2",{attrs:{id:"浏览器渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),r("h3",{attrs:{id:"导航流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#导航流程"}},[t._v("#")]),t._v(" 导航流程")]),t._v(" "),r("p",[r("img",{attrs:{src:s(371),alt:"渲染"}})]),t._v(" "),r("h3",{attrs:{id:"解析流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解析流程"}},[t._v("#")]),t._v(" 解析流程")]),t._v(" "),r("p",[r("img",{attrs:{src:s(372),alt:"解析"}})]),t._v(" "),r("blockquote",[r("p",[t._v("解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树")])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("DOM Tree：浏览器将HTML解析成树形的数据结构。")])]),t._v(" "),r("li",[r("p",[t._v("CSS Rule Tree：浏览器将CSS解析成树形的数据结构。")])]),t._v(" "),r("li",[r("p",[t._v("Render Tree: DOM和CSS合并后生成Render Tree。")])]),t._v(" "),r("li",[r("p",[t._v("layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置")])]),t._v(" "),r("li",[r("p",[t._v("painting: 主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。类似于canvas。")])]),t._v(" "),r("li",[r("p",[t._v("合成与光栅化：一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后将图块发送给一系列光栅线程（raster threads）。光栅线程会栅格化每个图块并且把它们存储在GPU的内存中。")]),t._v(" "),r("p",[t._v("当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做"),r("strong",[t._v("绘画四边形")]),t._v("（draw quads）的信息来构建一个"),r("strong",[t._v("合成帧")]),t._v("（compositor frame）。")]),t._v(" "),r("p",[t._v("合成帧构建完成之后，合成线程就会通过IPC向浏览器进程提交（commit）一个渲染帧，合成帧会被发送给GPU从而展示在屏幕上。")]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("将绘制信息转化为显示器的像素的过程叫做光栅化（rasterizing）")]),t._v("。")]),t._v(" "),r("p",[t._v("可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。Chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。")]),t._v(" "),r("p",[t._v("合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。")])])])]),t._v(" "),r("p",[t._v("综上所述，渲染进程共有三个线程参与工作，解析 html 到 painting 以上过程都是在主线程执行的，而合成和光栅化分别有合成线程和光栅化线程处理。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://oscimg.oschina.net/oscnet/418cfcf9122d7eb129c92bda22a008d26c8.png",alt:"渲染线程"}})]),t._v(" "),r("ul",[r("li",[r("p",[t._v("Compositor Thread")]),t._v(" "),r("p",[t._v("首先将页面分成若干层，然后切分为一块又一块的小图块，然后将图块发送给光栅线程。当图层上面的图块都被栅格化后，合成线程会收集"),r("strong",[t._v("绘画四边形")]),t._v("的信息来构建一个"),r("strong",[t._v("合成帧")]),t._v("。合成帧构建完成之后，合成线程就会向浏览器进程提交一个渲染帧，合成帧会被发送给GPU从而展示在屏幕上。")])]),t._v(" "),r("li",[r("p",[t._v("Main Thread")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://oscimg.oschina.net/oscnet/38642585793dd3eeb282143e587ec9e8b37.png",alt:"img"}})]),t._v(" "),r("p",[t._v("这里大家就很熟悉了，chrome devtools的Timeline里Main那一栏显示的内容就是Main Thread完成的相关任务：某段JS的执行、Recalculate Style、Update Layer Tree、Paint、Composite Layers等等。")])]),t._v(" "),r("li",[r("p",[t._v("Compositor Tile Worker(s)\n可能有一个或多个线程，比如PC端的chrome是2个或4个，安卓和safari为1个或2个不等。是由Compositor Thread创建的，专门用来处理tile（小图块） 的Rasterization（前文说过的光栅化）。")])])]),t._v(" "),r("p",[t._v("可以看到Compositor Thread是一个很核心的东西，后面的俩线程都是由他主要进行控制的。\n同时，用户输入是直接进入Compositor Thread的，一方面在那些不需要执行JS或者没有CSS动画、不重绘等的场景时，可以直接对用户输入进行处理和响应，而Main Thread是有很复杂的任务流程的。这使得浏览器可以快速响应用户的滚动、打字等等输入，完全不用进主线程。"),r("strong",[t._v("就比如说js动画要走主线程，css动画有的不会走主线程，直接在 Compositor Thread 中完成")])]),t._v(" "),r("blockquote",[r("p",[t._v("所以说 css 动画会不会被 js 阻塞呢，答案是有时会有时不会，比如 transform，opacity，filter。"),r("code",[t._v("transform")]),t._v("在"),r("code",[t._v("GPU")]),t._v("直接创建一个新的层")])]),t._v(" "),r("h2",{attrs:{id:"回流与重绘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回流与重绘"}},[t._v("#")]),t._v(" 回流与重绘")]),t._v(" "),r("h3",{attrs:{id:"reflow-回流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reflow-回流"}},[t._v("#")]),t._v(" reflow（回流）")]),t._v(" "),r("p",[t._v("当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。")]),t._v(" "),r("h3",{attrs:{id:"repaint-重绘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#repaint-重绘"}},[t._v("#")]),t._v(" repaint（重绘）")]),t._v(" "),r("p",[t._v("改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/qq_36337754/article/details/103773474",target:"_blank",rel:"noopener noreferrer"}},[t._v("哪些属性会触发回流与重绘"),r("OutboundLink")],1)]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("display"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("none 的节点不会被加入Render Tree，而visibility"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" hidden 则会，所以，如果某个节点最开始是不显示的，设为display"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("none是更优的。")]),t._v("\n\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("display"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("none 会触发 reflow，而 visibility"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("hidden 只会触发 "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("repaint，因为没有发现位置变化。")]),t._v("\n\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，浏览器会维护"),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。\n")])])]),r("h2",{attrs:{id:"css-硬件加速"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-硬件加速"}},[t._v("#")]),t._v(" CSS 硬件加速")]),t._v(" "),r("p",[r("code",[t._v("CSS3 硬件加速又叫做 GPU 加速")]),t._v("，是"),r("code",[t._v("利用 GPU 进行渲染，减少 CPU 操作的一种优化方案")]),t._v("。由于 GPU 中的 transform3d 等 CSS 属性不会触发 "),r("code",[t._v("repaint")]),t._v("，所以能大大提高网页的性能。")]),t._v(" "),r("p",[r("strong",[t._v("在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层")]),t._v(" ，一旦独立出来，就不会影响其它 DOM 的布局（主线程），所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了。")]),t._v(" "),r("p",[t._v("如下几个css属性可以触发硬件加速：")]),t._v(" "),r("ul",[r("li",[t._v("transform（ translate3d、translateZ(0)等）")]),t._v(" "),r("li",[t._v("opacity")]),t._v(" "),r("li",[t._v("filter（滤镜：drop-shadow()、opacity()，函数与已有的"),r("code",[t._v("box-shadow、opacity")]),t._v("属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速）")]),t._v(" "),r("li",[t._v("will-change：哪一个属性即将发生变化，进而进行优化。")])]),t._v(" "),r("h2",{attrs:{id:"js-会阻塞-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js-会阻塞-dom"}},[t._v("#")]),t._v(" js 会阻塞 dom")]),t._v(" "),r("ul",[r("li",[t._v("现代浏览器会并行加载js文件，但是按照书写顺序执行代码")]),t._v(" "),r("li",[t._v("加载或者执行js时会阻塞对标签的解析，也就是阻塞了dom树的形成，只有等到js执行完毕，浏览器才会继续解析标签。没有dom树，浏览器就无法渲染，所以当加载很大的js文件时，可以看到页面很长时间是一片空白")]),t._v(" "),r("li",[t._v("之所以会阻塞对标签的解析是因为加载的js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，然后生成dom树，性能比较差")])]),t._v(" "),r("h2",{attrs:{id:"css-不会阻塞-dom-解析但会阻塞渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-不会阻塞-dom-解析但会阻塞渲染"}},[t._v("#")]),t._v(" css 不会阻塞 dom 解析但会阻塞渲染")]),t._v(" "),r("ul",[r("li",[t._v("因为需要具有 DOM 以及 CSSOM 才会构建渲染树，加载 css 的时候肯定无法继续渲染")])]),t._v(" "),r("blockquote",[r("p",[t._v("为什么把 js 放在底部，css 放在顶部")])]),t._v(" "),r("p",[t._v("Js 放在顶部会阻塞 dom 的渲染，浏览器可能一直转圈圈，而 css 不会阻塞 dom 解析。")]),t._v(" "),r("p",[t._v("我们会将 js 放在后面，以减少First Paint的时间")]),t._v(" "),r("h2",{attrs:{id:"script标签中的async-defer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#script标签中的async-defer"}},[t._v("#")]),t._v(" script标签中的async，defer")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6844904197423382535",target:"_blank",rel:"noopener noreferrer"}},[t._v("script标签中的async，defer"),r("OutboundLink")],1)])]),t._v(" "),r("p",[r("img",{attrs:{src:s(373),alt:"script"}})])])}),[],!1,null,null,null);r.default=e.exports}}]);